syntax = "proto3";
package tokenization.v22;

import "gogoproto/gogo.proto";
import "tokenization/v22/challenges.proto";
import "tokenization/v22/predetermined_balances.proto";
import "tokenization/v22/approval_tracking.proto";
import "tokenization/v22/approval_conditions.proto";

option go_package = "github.com/bitbadges/bitbadgeschain/x/tokenization/types/v22";

// ApprovalCriteria defines the criteria for approving transfers.
// All criteria must be satisfied for the approval to be considered valid.
message ApprovalCriteria {
  // Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs
  // that satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.
  repeated MerkleChallenge merkleChallenges = 1;
  // Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs
  // that can be transferred when using this approval.
  PredeterminedBalances predeterminedBalances = 2;
  // Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts
  // transferred and enforces maximum limits per approval.
  ApprovalAmounts approvalAmounts = 3;
  // Maximum number of transfers that can be processed using this approval. Tracks the count of transfers
  // and enforces the limit to prevent exceeding the allowed number of uses.
  MaxNumTransfers maxNumTransfers = 4;
  // The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,
  // royalties) that must be executed alongside the token transfer for the approval to be valid.
  repeated CoinTransfer coinTransfers = 5;

  // Require the "to" address to be equal to the "initiated by" address for approval.
  // If true, only transfers where the recipient matches the initiator are allowed.
  bool requireToEqualsInitiatedBy = 6;
  // Require the "from" address to be equal to the "initiated by" address for approval.
  // If true, only transfers where the sender matches the initiator are allowed.
  bool requireFromEqualsInitiatedBy = 7;
  // Require the "to" address to not be equal to the "initiated by" address for approval.
  // If true, transfers where the recipient equals the initiator are forbidden.
  bool requireToDoesNotEqualInitiatedBy = 8;
  // Require the "from" address to not be equal to the "initiated by" address for approval.
  // If true, transfers where the sender equals the initiator are forbidden.
  bool requireFromDoesNotEqualInitiatedBy = 9;

  // Overrides the user's outgoing approvals for approval. If true, this collection-level approval
  // takes precedence over any outgoing approvals defined by the sender, allowing the collection to
  // control outgoing transfer behavior.
  bool overridesFromOutgoingApprovals = 10;
  // Overrides the user's incoming approvals for approval. If true, this collection-level approval
  // takes precedence over any incoming approvals defined by the recipient, allowing the collection to
  // control incoming transfer behavior.
  bool overridesToIncomingApprovals = 11;

  // Auto-deletion options for this approval. Defines conditions under which this approval should be
  // automatically deleted (e.g., after a certain number of uses or time period).
  AutoDeletionOptions autoDeletionOptions = 12;

  // User level royalties to apply to the transfer. Defines the percentage and payout address for
  // royalties that should be collected when this approval is used for a transfer.
  UserRoyalties userRoyalties = 13;

  // Must own tokens for approval. Defines token ownership requirements that must be satisfied for
  // the approval to be valid. The initiator must own the specified tokens at the specified ownership times.
  repeated MustOwnTokens mustOwnTokens = 14;
  // Dynamic store challenges that the initiator must pass for approval. The initiator must provide
  // valid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).
  repeated DynamicStoreChallenge dynamicStoreChallenges = 15;
  // ETH signature challenges that the initiator must pass for approval. The initiator must provide
  // valid Ethereum signatures for all specified challenges. Each signature can only be used once.
  repeated ETHSignatureChallenge ethSignatureChallenges = 16;
  // Address checks for the sender of the transfer. Validates that the sender address meets the
  // specified criteria (e.g., whitelist, blacklist, protocol address requirements).
  AddressChecks senderChecks = 17;
  // Address checks for the recipient of the transfer. Validates that the recipient address meets the
  // specified criteria (e.g., whitelist, blacklist, protocol address requirements).
  AddressChecks recipientChecks = 18;
  // Address checks for the initiator of the transfer. Validates that the initiator address meets the
  // specified criteria (e.g., whitelist, blacklist, protocol address requirements).
  AddressChecks initiatorChecks = 19;
  // Alternative time-based checks for approval denial (offline hours/days). Defines time periods
  // during which this approval should be denied, such as specific hours of the day or days of the week.
  AltTimeChecks altTimeChecks = 20;
  // If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
  // This allows fine-grained control over which approvals are applied when multiple approvals could match.
  bool mustPrioritize = 21;
  // Voting challenges that must be satisfied for approval. The initiator must provide
  // valid votes that meet the quorum threshold for all specified challenges.
  repeated VotingChallenge votingChallenges = 22;
}

// OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.
// This is used for user-level outgoing approvals and only includes fields relevant to outgoing transfers.
// All criteria must be satisfied for the approval to be considered valid.
message OutgoingApprovalCriteria {
  // Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs
  // that satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.
  repeated MerkleChallenge merkleChallenges = 1;
  // Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs
  // that can be transferred when using this approval.
  PredeterminedBalances predeterminedBalances = 2;
  // Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts
  // transferred and enforces maximum limits per approval.
  ApprovalAmounts approvalAmounts = 3;
  // Maximum number of transfers that can be processed using this approval. Tracks the count of transfers
  // and enforces the limit to prevent exceeding the allowed number of uses.
  MaxNumTransfers maxNumTransfers = 4;
  // The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,
  // royalties) that must be executed alongside the token transfer for the approval to be valid.
  repeated CoinTransfer coinTransfers = 5;

  // Require the "to" address to be equal to the "initiated by" address for approval.
  // If true, only transfers where the recipient matches the initiator are allowed.
  bool requireToEqualsInitiatedBy = 6;
  // Require the "to" address to not be equal to the "initiated by" address for approval.
  // If true, transfers where the recipient equals the initiator are forbidden.
  bool requireToDoesNotEqualInitiatedBy = 7;

  // Auto-deletion options for this approval. Defines conditions under which this approval should be
  // automatically deleted (e.g., after a certain number of uses or time period).
  AutoDeletionOptions autoDeletionOptions = 8;

  // Must own tokens for approval. Defines token ownership requirements that must be satisfied for
  // the approval to be valid. The initiator must own the specified tokens at the specified ownership times.
  repeated MustOwnTokens mustOwnTokens = 9;
  // Dynamic store challenges that the initiator must pass for approval. The initiator must provide
  // valid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).
  repeated DynamicStoreChallenge dynamicStoreChallenges = 10;
  // ETH signature challenges that the initiator must pass for approval. The initiator must provide
  // valid Ethereum signatures for all specified challenges. Each signature can only be used once.
  repeated ETHSignatureChallenge ethSignatureChallenges = 11;
  // Address checks for the recipient of the transfer. Validates that the recipient address meets the
  // specified criteria (e.g., whitelist, blacklist, protocol address requirements).
  // Note: No sender checks are included for outgoing approvals since the sender is the user themselves.
  AddressChecks recipientChecks = 12;
  // Address checks for the initiator of the transfer. Validates that the initiator address meets the
  // specified criteria (e.g., whitelist, blacklist, protocol address requirements).
  AddressChecks initiatorChecks = 13;
  // Alternative time-based checks for approval denial (offline hours/days). Defines time periods
  // during which this approval should be denied, such as specific hours of the day or days of the week.
  AltTimeChecks altTimeChecks = 14;
  // If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
  // This allows fine-grained control over which approvals are applied when multiple approvals could match.
  bool mustPrioritize = 15;
  // Voting challenges that must be satisfied for approval. The initiator must provide
  // valid votes that meet the quorum threshold for all specified challenges.
  repeated VotingChallenge votingChallenges = 16;
}

// IncomingApprovalCriteria defines the criteria for approving incoming transfers.
// This is used for user-level incoming approvals and only includes fields relevant to incoming transfers.
// All criteria must be satisfied for the approval to be considered valid.
message IncomingApprovalCriteria {
  // Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs
  // that satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.
  repeated MerkleChallenge merkleChallenges = 1;
  // Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs
  // that can be transferred when using this approval.
  PredeterminedBalances predeterminedBalances = 2;
  // Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts
  // transferred and enforces maximum limits per approval.
  ApprovalAmounts approvalAmounts = 3;
  // Maximum number of transfers that can be processed using this approval. Tracks the count of transfers
  // and enforces the limit to prevent exceeding the allowed number of uses.
  MaxNumTransfers maxNumTransfers = 4;
  // The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,
  // royalties) that must be executed alongside the token transfer for the approval to be valid.
  repeated CoinTransfer coinTransfers = 5;

  // Require the "from" address to be equal to the "initiated by" address for approval.
  // If true, only transfers where the sender matches the initiator are allowed.
  bool requireFromEqualsInitiatedBy = 6;
  // Require the "from" address to not be equal to the "initiated by" address for approval.
  // If true, transfers where the sender equals the initiator are forbidden.
  bool requireFromDoesNotEqualInitiatedBy = 7;

  // Auto-deletion options for this approval. Defines conditions under which this approval should be
  // automatically deleted (e.g., after a certain number of uses or time period).
  AutoDeletionOptions autoDeletionOptions = 8;

  // Must own tokens for approval. Defines token ownership requirements that must be satisfied for
  // the approval to be valid. The initiator must own the specified tokens at the specified ownership times.
  repeated MustOwnTokens mustOwnTokens = 9;
  // Dynamic store challenges that the initiator must pass for approval. The initiator must provide
  // valid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).
  repeated DynamicStoreChallenge dynamicStoreChallenges = 10;
  // ETH signature challenges that the initiator must pass for approval. The initiator must provide
  // valid Ethereum signatures for all specified challenges. Each signature can only be used once.
  repeated ETHSignatureChallenge ethSignatureChallenges = 11;
  // Address checks for the sender of the transfer. Validates that the sender address meets the
  // specified criteria (e.g., whitelist, blacklist, protocol address requirements).
  // Note: No recipient checks are included for incoming approvals since the recipient is the user themselves.
  AddressChecks senderChecks = 12;
  // Address checks for the initiator of the transfer. Validates that the initiator address meets the
  // specified criteria (e.g., whitelist, blacklist, protocol address requirements).
  AddressChecks initiatorChecks = 13;
  // Alternative time-based checks for approval denial (offline hours/days). Defines time periods
  // during which this approval should be denied, such as specific hours of the day or days of the week.
  AltTimeChecks altTimeChecks = 14;
  // If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
  // This allows fine-grained control over which approvals are applied when multiple approvals could match.
  bool mustPrioritize = 15;
  // Voting challenges that must be satisfied for approval. The initiator must provide
  // valid votes that meet the quorum threshold for all specified challenges.
  repeated VotingChallenge votingChallenges = 16;
}

