syntax = "proto3";
package tokenization;

import "gogoproto/gogo.proto";

option go_package = "github.com/bitbadges/bitbadgeschain/x/tokenization/types";

/*
  Challenges define a rule for the approval in the form of a Merkle challenge.

  A Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,
  then the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.

  IMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.

  IMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.
  If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
  We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
*/
message MerkleChallenge {
  // The root hash of the Merkle tree to which the Merkle path must lead for verification.
  string root = 1;

  // The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.
  string expectedProofLength = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.
  bool useCreatorAddressAsLeaf = 3;

  // The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.
  string maxUsesPerLeaf = 4 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // The URI associated with this Merkle challenge, optionally providing metadata about the challenge.
  string uri = 5;

  // Arbitrary custom data associated with this Merkle challenge.
  string customData = 6;

  // The ID of this Merkle challenge for tracking the number of uses per leaf.
  string challengeTrackerId = 7;

  // Ethereum address that must sign the leaf. Used to protect against man-in-the-middle attacks.
  // Signature scheme: sign(leaf + "-" + creatorAddress), verified using elliptic curve signature verification.
  string leafSigner = 8;
}

/*
  ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.

  An ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.
  The signature scheme is ETHSign(nonce + "-" + initiatorAddress + "-" + collectionId + "-" + approverAddress + "-" + approvalLevel + "-" + approvalId + "-" + challengeId) and each signature can only be used once.
  All challenges must be met with valid solutions for the transfer to be approved.

  IMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.
  If you update the challenge ID, then the used signatures tracker will reset and start a new tally.
  We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
*/
message ETHSignatureChallenge {
  // The Ethereum address that must sign the nonce for verification.
  string signer = 1;

  // The ID of this ETH signature challenge for tracking the number of uses per signature.
  string challengeTrackerId = 2;

  // The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.
  string uri = 3;

  // Arbitrary custom data associated with this ETH signature challenge.
  string customData = 4;
}

// MerklePathItem represents an item in a Merkle path.
message MerklePathItem {
  // The hash of the sibling node (aunt) in the Merkle path.
  string aunt = 1;
  // Indicates whether the aunt node is on the right side of the path.
  bool onRight = 2;
}

// MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.
message MerkleProof {
  // The hash of the leaf node for which the proof is generated.
  string leaf = 1;
  // List of Merkle path items (aunts) that make up the proof.
  repeated MerklePathItem aunts = 2;
  // The signature of the leaf node tying the address to the leaf node.
  string leafSignature = 3;
}

// ETHSignatureProof represents an Ethereum signature proof for a challenge.
message ETHSignatureProof {
  // The nonce that was signed. The signature scheme is ETHSign(nonce + "-" + initiatorAddress + "-" + collectionId + "-" + approverAddress + "-" + approvalLevel + "-" + approvalId + "-" + challengeId).
  string nonce = 1;
  // The Ethereum signature of the nonce.
  string signature = 2;
}

/*
  VotingChallenge defines a rule for approval in the form of a voting/multi-sig challenge.
  Requires a weighted quorum threshold to be met through votes from specified voters.
  All challenges must be met with valid solutions for the transfer to be approved.

  IMPORTANT: Votes are stored separately and can be updated. The threshold is calculated as a percentage
  of total possible weight (all voters), not just voted weight. If you update the proposal ID, then the
  vote tracker will reset and start a new tally. We recommend using a unique proposal ID for each challenge
  to prevent overlap and unexpected behavior.
*/
message VotingChallenge {
  // The ID of this voting challenge for tracking votes (scoped like challengeTrackerId).
  // Format: collectionId-approverAddress-approvalLevel-approvalId-challengeId
  string proposalId = 1;
  
  // The quorum threshold as a percentage (0-100) of total possible weight that must vote "yes".
  // Example: 50 means 50% of total voter weight must vote yes for approval.
  string quorumThreshold = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  
  // List of voters with their weights. Each voter can cast a weighted vote.
  repeated Voter voters = 3;
  
  // The URI associated with this voting challenge.
  string uri = 4;
  
  // Arbitrary custom data associated with this voting challenge.
  string customData = 5;
}

// Voter defines a voter with their address and weight.
message Voter {
  // The address of the voter.
  string address = 1;
  
  // The weight of this voter's vote.
  string weight = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}

// VoteProof represents a vote cast for a voting challenge.
message VoteProof {
  // The proposal ID this vote is for.
  string proposalId = 1;
  
  // The address of the voter casting the vote.
  string voter = 2;
  
  // The percentage weight (0-100) allocated to "yes" vote.
  // The remaining percentage (100 - yesWeight) is allocated to "no" vote.
  // Example: yesWeight=70 means 70% yes, 30% no.
  string yesWeight = 3 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}

