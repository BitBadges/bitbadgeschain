syntax = "proto3";
package bitbadges.bitbadgeschain.badges;

import "google/protobuf/any.proto";
import "badges/balances.proto";
import "badges/address_mappings.proto";
import "gogoproto/gogo.proto";

option go_package = "github.com/bitbadges/bitbadgeschain/x/badges/types";

// CollectionPermissions defines the permissions for the collection (i.e. what the manager can and cannot do).
//
// There are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BalancesActionPermission, and CollectionApprovedTransferPermission.
//
// The permission type allows fine-grained access control for each action.
// ActionPermission: defines when the manager can perform an action.
// TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.
// TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.
// BalancesActionPermission: defines when the manager can perform an action for specific badges and specific badge ownership times.
// CollectionApprovedTransferPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs locked
//
// Note there are a few different times here which could get confusing:
// - timelineTimes: the times when a timeline-based field is a specific value
// - permitted/forbiddenTimes - the times that a permission can be performed
// - transferTimes - the times that a transfer occurs
// - ownershipTimes - the times when a badge is owned by a user
//
// The permitted/forbiddenTimes are used to determine when a permission can be executed.
// Once a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.
// If a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.
//
// Each permission type has a defaultValues field and a combinations field.
// The defaultValues field defines the default values for the permission which can be manipulated by the combinations field (to avoid unnecessary repetition).
// Ex: We can have default value badgeIds = [1,2] and combinations = [{invertDefault: true, isApproved: false}, {isApproved: true}].
// This would mean that badgeIds [1,2] are allowed but everything else is not allowed.
//
// IMPORTANT: For all permissions, we ONLY take the first combination that matches. Any subsequent combinations are ignored. 
// Ex: If we have defaultValues = {badgeIds: [1,2]} and combinations = [{isApproved: true}, {isApproved: false}].
// This would mean that badgeIds [1,2] are allowed and the second combination is ignored.
message CollectionPermissions {
  repeated ActionPermission canDeleteCollection = 1;
  repeated TimedUpdatePermission canArchiveCollection = 2;
  repeated TimedUpdatePermission canUpdateContractAddress = 3;
  repeated TimedUpdatePermission canUpdateOffChainBalancesMetadata = 4;
  repeated TimedUpdatePermission canUpdateStandards = 5;
  
  repeated TimedUpdatePermission canUpdateCustomData = 6;
  repeated TimedUpdatePermission canUpdateManager = 7;
  repeated TimedUpdatePermission canUpdateCollectionMetadata = 8;

  repeated BalancesActionPermission canCreateMoreBadges = 9;

  repeated TimedUpdateWithBadgeIdsPermission canUpdateBadgeMetadata = 10;
  repeated TimedUpdateWithBadgeIdsPermission canUpdateInheritedBalances = 11;

  repeated CollectionApprovedTransferPermission canUpdateCollectionApprovedTransfers = 12;
}

// UserPermissions defines the permissions for the user (i.e. what the user can and cannot do).
//
// See CollectionPermissions for more details on the different types of permissions.
// The UserApprovedOutgoing and UserApprovedIncoming permissions are the same as the CollectionApprovedTransferPermission,
// but certain fields are removed because they are not relevant to the user.
message UserPermissions {
  repeated UserApprovedOutgoingTransferPermission canUpdateApprovedOutgoingTransfers = 1;
  repeated UserApprovedIncomingTransferPermission canUpdateApprovedIncomingTransfers = 2;
}

// ValueOptions defines how we manipulate the default values.
message ValueOptions {
  bool invertDefault = 1;
  bool allValues = 2; //Override default values with all possible values
  bool noValues = 3; //Override default values with no values
}

message CollectionApprovedTransferCombination {
  ValueOptions timelineTimesOptions = 1;

  ValueOptions fromMappingOptions = 2;
  ValueOptions toMappingOptions = 3;
  ValueOptions initiatedByMappingOptions = 4;
  ValueOptions transferTimesOptions = 5;
  ValueOptions badgeIdsOptions = 6;
  ValueOptions ownershipTimesOptions = 9;

  ValueOptions permittedTimesOptions = 7;
  ValueOptions forbiddenTimesOptions = 8;
}

message CollectionApprovedTransferDefaultValues {
  repeated UintRange timelineTimes = 1;

  string fromMappingId = 2;
  string toMappingId = 3;
  string initiatedByMappingId = 4;
  repeated UintRange transferTimes = 5;
  repeated UintRange badgeIds = 6;
  repeated UintRange ownershipTimes = 9;

  repeated UintRange permittedTimes = 7;
  repeated UintRange forbiddenTimes = 8;
}

// CollectionApprovedTransferPermission defines what collection approved transfers can be updated vs are locked.
//
// Each transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.
// For a transfer to match, we need to match ALL of the fields in the combination. 
// These are detemined by the fromMappingId, toMappingId, initiatedByMappingId, transferTimes, badgeIds fields.
// AddressMappings are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressMappings). 
// 
// TimelineTimes: which timeline times of the collection's approvedTransfersTimeline field can be updated or not?
// permitted/forbidden TimelineTimes: when can the manager execute this permission?
//
// Ex: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", 10, 1000).
// We would check to find the FIRST CollectionApprovedTransferPermission that matches this combination.
// If we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).
//
// Ex: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set
// the combination ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", "All Transfer Times", 1) to always be forbidden at all timelineTimes.
message CollectionApprovedTransferPermission {
  CollectionApprovedTransferDefaultValues defaultValues = 1;
  repeated CollectionApprovedTransferCombination combinations = 7;
}

message UserApprovedOutgoingTransferCombination {
  ValueOptions timelineTimesOptions = 1;

  ValueOptions toMappingOptions = 2;
  ValueOptions initiatedByMappingOptions = 3;
  ValueOptions transferTimesOptions = 4;
  ValueOptions badgeIdsOptions = 5;
  ValueOptions ownershipTimesOptions = 6;

  ValueOptions permittedTimesOptions = 7;
  ValueOptions forbiddenTimesOptions = 8;
}

message UserApprovedOutgoingTransferDefaultValues {
  repeated UintRange timelineTimes = 1;

  string toMappingId = 2;
  string initiatedByMappingId = 3;
  repeated UintRange transferTimes = 4;
  repeated UintRange badgeIds = 5;
  repeated UintRange ownershipTimes = 6;

  repeated UintRange permittedTimes = 7;
  repeated UintRange forbiddenTimes = 8;
}

// UserApprovedOutgoingTransferPermission defines the permissions for updating the user's approved outgoing transfers.
// See CollectionApprovedTransferPermission for more details. This is equivalent without the fromMappingId field because that is always the user.
message UserApprovedOutgoingTransferPermission {
  UserApprovedOutgoingTransferDefaultValues defaultValues = 1;
  repeated UserApprovedOutgoingTransferCombination combinations = 2;
}

message UserApprovedIncomingTransferCombination {
  ValueOptions timelineTimesOptions = 1;

  ValueOptions fromMappingOptions = 2;
  ValueOptions initiatedByMappingOptions = 3;
  ValueOptions transferTimesOptions = 4;
  ValueOptions badgeIdsOptions = 5;
  ValueOptions ownershipTimesOptions = 6;


  ValueOptions permittedTimesOptions = 7;
  ValueOptions forbiddenTimesOptions = 8;
}

message UserApprovedIncomingTransferDefaultValues {
  repeated UintRange timelineTimes = 1;

  string fromMappingId = 2;
  string initiatedByMappingId = 3;
  repeated UintRange transferTimes = 4;
  repeated UintRange badgeIds = 5;
  repeated UintRange ownershipTimes = 6;

  repeated UintRange permittedTimes = 7;
  repeated UintRange forbiddenTimes = 8;
}

// UserApprovedIncomingTransferPermission defines the permissions for updating the user's approved incoming transfers.
// See CollectionApprovedTransferPermission for more details. This is equivalent without the toMappingId field because that is always the user.
message UserApprovedIncomingTransferPermission {
  UserApprovedIncomingTransferDefaultValues defaultValues = 1;
  repeated UserApprovedIncomingTransferCombination combinations = 2;
}

message BalancesActionCombination {
  ValueOptions badgeIdsOptions = 1;
  ValueOptions ownershipTimesOptions = 2;

  ValueOptions permittedTimesOptions = 3;
  ValueOptions forbiddenTimesOptions = 4;
}

message BalancesActionDefaultValues {
  repeated UintRange badgeIds = 1;
  repeated UintRange ownershipTimes = 2;

  repeated UintRange permittedTimes = 3;
  repeated UintRange forbiddenTimes = 4;
}

// BalancesActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.
// Currently, this is only used for creating new badges.
//
// Ex: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, 
// you could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
message BalancesActionPermission {
  BalancesActionDefaultValues defaultValues = 1;
  repeated BalancesActionCombination combinations = 2;
}

message ActionDefaultValues {
  repeated UintRange permittedTimes = 1;
  repeated UintRange forbiddenTimes = 2;
}

message ActionCombination {
  ValueOptions permittedTimesOptions = 1;
  ValueOptions forbiddenTimesOptions = 2;
}

// ActionPermission defines the permissions for performing an action.
// 
// This is simple and straightforward as the only thing we need to check is the permitted/forbidden times.
message ActionPermission {
  ActionDefaultValues defaultValues = 1;
  repeated ActionCombination combinations = 2;
}

message TimedUpdateCombination {
  ValueOptions timelineTimesOptions = 1;

  ValueOptions permittedTimesOptions = 2;
  ValueOptions forbiddenTimesOptions = 3;
}

message TimedUpdateDefaultValues {
  repeated UintRange timelineTimes = 1;

  repeated UintRange permittedTimes = 2;
  repeated UintRange forbiddenTimes = 3;
}

// TimedUpdatePermission defines the permissions for updating a timeline-based field.
//
// Ex: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,
// you could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
message TimedUpdatePermission {
  TimedUpdateDefaultValues defaultValues = 1;

  repeated TimedUpdateCombination combinations = 2;
}

message TimedUpdateWithBadgeIdsCombination {
  ValueOptions timelineTimesOptions = 1;

  ValueOptions badgeIdsOptions = 2;

  ValueOptions permittedTimesOptions = 3;
  ValueOptions forbiddenTimesOptions = 4;
}

message TimedUpdateWithBadgeIdsDefaultValues {
  repeated UintRange badgeIds = 1;
  repeated UintRange timelineTimes = 2;

  repeated UintRange permittedTimes = 3;
  repeated UintRange forbiddenTimes = 4;
}

// TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.
// 
// Ex: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,
// you could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
message TimedUpdateWithBadgeIdsPermission {
  TimedUpdateWithBadgeIdsDefaultValues defaultValues = 1;
  repeated TimedUpdateWithBadgeIdsCombination combinations = 2;
}