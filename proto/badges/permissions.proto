syntax = "proto3";
package bitbadges.bitbadgeschain.badges;

import "google/protobuf/any.proto";
import "badges/balances.proto";
import "badges/address_mappings.proto";
import "gogoproto/gogo.proto";

option go_package = "github.com/bitbadges/bitbadgeschain/x/badges/types";

// CollectionPermissions defines the permissions for the collection (i.e. what the manager can and cannot do).
//
// There are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BalancesActionPermission, and CollectionApprovalPermission.
//
// The permission type allows fine-grained access control for each action.
// ActionPermission: defines when the manager can perform an action.
// TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.
// TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.
// BalancesActionPermission: defines when the manager can perform an action for specific badges and specific badge ownership times.
// CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs locked
//
// Note there are a few different times here which could get confusing:
// - timelineTimes: the times when a timeline-based field is a specific value
// - permitted/forbiddenTimes - the times that a permission can be performed
// - transferTimes - the times that a transfer occurs
// - ownershipTimes - the times when a badge is owned by a user
//
// The permitted/forbiddenTimes are used to determine when a permission can be executed.
// Once a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.
// If a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.
//
// Each permission type has a defaultValues field and a combinations field.
// The defaultValues field defines the default values for the permission which can be manipulated by the combinations field (to avoid unnecessary repetition).
// Ex: We can have default value badgeIds = [1,2] and combinations = [{invertDefault: true, isApproved: false}, {isApproved: true}].
// This would mean that badgeIds [1,2] are allowed but everything else is not allowed.
//
// IMPORTANT: For all permissions, we ONLY take the first combination that matches. Any subsequent combinations are ignored. 
// Ex: If we have defaultValues = {badgeIds: [1,2]} and combinations = [{isApproved: true}, {isApproved: false}].
// This would mean that badgeIds [1,2] are allowed and the second combination is ignored.
message CollectionPermissions {
  repeated ActionPermission canDeleteCollection = 1;
  repeated TimedUpdatePermission canArchiveCollection = 2;
  repeated TimedUpdatePermission canUpdateOffChainBalancesMetadata = 3;
  repeated TimedUpdatePermission canUpdateStandards = 4;
  
  repeated TimedUpdatePermission canUpdateCustomData = 5;
  repeated TimedUpdatePermission canUpdateManager = 6;
  repeated TimedUpdatePermission canUpdateCollectionMetadata = 7;

  repeated BalancesActionPermission canCreateMoreBadges = 8;

  repeated TimedUpdateWithBadgeIdsPermission canUpdateBadgeMetadata = 9;

  repeated CollectionApprovalPermission canUpdateCollectionApprovals = 10;
}

// UserPermissions defines the permissions for the user (i.e. what the user can and cannot do).
//
// See CollectionPermissions for more details on the different types of permissions.
// The UserApprovedOutgoing and UserApprovedIncoming permissions are the same as the CollectionApprovalPermission,
// but certain fields are removed because they are not relevant to the user.
message UserPermissions {
  repeated UserOutgoingApprovalPermission canUpdateOutgoingApprovals = 1;
  repeated UserIncomingApprovalPermission canUpdateIncomingApprovals = 2;
  repeated ActionPermission canUpdateAutoApproveSelfInitiatedOutgoingTransfers = 3;
  repeated ActionPermission canUpdateAutoApproveSelfInitiatedIncomingTransfers = 4;
}

// CollectionApprovalPermission defines what collection approved transfers can be updated vs are locked.
//
// Each transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.
// For a transfer to match, we need to match ALL of the fields in the combination. 
// These are detemined by the fromMappingId, toMappingId, initiatedByMappingId, transferTimes, badgeIds fields.
// AddressMappings are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressMappings). 
// 
// TimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?
// permitted/forbidden TimelineTimes: when can the manager execute this permission?
//
// Ex: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", 10, 1000).
// We would check to find the FIRST CollectionApprovalPermission that matches this combination.
// If we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).
//
// Ex: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set
// the combination ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", "All Transfer Times", 1) to always be forbidden at all timelineTimes.
message CollectionApprovalPermission {
  string fromMappingId = 1;
  string toMappingId = 2;
  string initiatedByMappingId = 3;
  repeated UintRange transferTimes = 4;
  repeated UintRange badgeIds = 5;
  repeated UintRange ownershipTimes = 6;

  string amountTrackerId = 7;
  string challengeTrackerId = 8;

  repeated UintRange permittedTimes = 9;
  repeated UintRange forbiddenTimes = 10;
}

// UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.
// See CollectionApprovalPermission for more details. This is equivalent without the fromMappingId field because that is always the user.
message UserOutgoingApprovalPermission {
  string toMappingId = 1;
  string initiatedByMappingId = 2;
  repeated UintRange transferTimes = 3;
  repeated UintRange badgeIds = 4;
  repeated UintRange ownershipTimes = 5;

  string amountTrackerId = 6;
  string challengeTrackerId = 7;

  repeated UintRange permittedTimes = 8;
  repeated UintRange forbiddenTimes = 9;
}

// UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.
// See CollectionApprovalPermission for more details. This is equivalent without the toMappingId field because that is always the user.
message UserIncomingApprovalPermission {
  string fromMappingId = 1;
  string initiatedByMappingId = 2;
  repeated UintRange transferTimes = 3;
  repeated UintRange badgeIds = 4;
  repeated UintRange ownershipTimes = 5;

  string amountTrackerId = 6;
  string challengeTrackerId = 7;

  repeated UintRange permittedTimes = 8;
  repeated UintRange forbiddenTimes = 9;
}


// BalancesActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.
// Currently, this is only used for creating new badges.
//
// Ex: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, 
// you could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
message BalancesActionPermission {
  repeated UintRange badgeIds = 1;
  repeated UintRange ownershipTimes = 2;

  repeated UintRange permittedTimes = 3;
  repeated UintRange forbiddenTimes = 4;
}


// ActionPermission defines the permissions for performing an action.
// 
// This is simple and straightforward as the only thing we need to check is the permitted/forbidden times.
message ActionPermission {
  repeated UintRange permittedTimes = 1;
  repeated UintRange forbiddenTimes = 2;
}

// TimedUpdatePermission defines the permissions for updating a timeline-based field.
//
// Ex: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,
// you could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
message TimedUpdatePermission {
  repeated UintRange timelineTimes = 1;

  repeated UintRange permittedTimes = 2;
  repeated UintRange forbiddenTimes = 3;
}

// TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.
// 
// Ex: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,
// you could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
message TimedUpdateWithBadgeIdsPermission {
  repeated UintRange badgeIds = 1;
  repeated UintRange timelineTimes = 2;
  repeated UintRange permittedTimes = 3;
  repeated UintRange forbiddenTimes = 4;
}