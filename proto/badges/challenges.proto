syntax = "proto3";
package badges;

import "gogoproto/gogo.proto";

option go_package = "github.com/bitbadges/bitbadgeschain/x/badges/types";

/*
  Challenges define a rule for the approval in the form of a Merkle challenge.

  A Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,
  then the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.

  IMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.

  IMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.
  If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
  We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
*/
message MerkleChallenge {
  // The root hash of the Merkle tree to which the Merkle path must lead for verification.
  string root = 1;

  // The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.
  string expectedProofLength = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.
  bool useCreatorAddressAsLeaf = 3;

  // The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.
  string maxUsesPerLeaf = 4 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // The URI associated with this Merkle challenge, optionally providing metadata about the challenge.
  string uri = 5;

  // Arbitrary custom data associated with this Merkle challenge.
  string customData = 6;

  // The ID of this Merkle challenge for tracking the number of uses per leaf.
  string challengeTrackerId = 7;

  // Ethereum address that must sign the leaf. Used to protect against man-in-the-middle attacks.
  // Signature scheme: sign(leaf + "-" + creatorAddress), verified using elliptic curve signature verification.
  string leafSigner = 8;
}

/*
  ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.

  An ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.
  The signature scheme is ETHSign(nonce + "-" + creatorAddress) and each signature can only be used once.
  All challenges must be met with valid solutions for the transfer to be approved.

  IMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.
  If you update the challenge ID, then the used signatures tracker will reset and start a new tally.
  We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
*/
message ETHSignatureChallenge {
  // The Ethereum address that must sign the nonce for verification.
  string signer = 1;

  // The ID of this ETH signature challenge for tracking the number of uses per signature.
  string challengeTrackerId = 2;

  // The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.
  string uri = 3;

  // Arbitrary custom data associated with this ETH signature challenge.
  string customData = 4;
}

// MerklePathItem represents an item in a Merkle path.
message MerklePathItem {
  // The hash of the sibling node (aunt) in the Merkle path.
  string aunt = 1;
  // Indicates whether the aunt node is on the right side of the path.
  bool onRight = 2;
}

// MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.
message MerkleProof {
  // The hash of the leaf node for which the proof is generated.
  string leaf = 1;
  // List of Merkle path items (aunts) that make up the proof.
  repeated MerklePathItem aunts = 2;
  // The signature of the leaf node tying the address to the leaf node.
  string leafSignature = 3;
}

// ETHSignatureProof represents an Ethereum signature proof for a challenge.
message ETHSignatureProof {
  // The nonce that was signed. The signature scheme is ETHSign(nonce + "-" + creatorAddress).
  string nonce = 1;
  // The Ethereum signature of the nonce.
  string signature = 2;
}

