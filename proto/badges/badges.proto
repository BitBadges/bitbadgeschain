syntax = "proto3";
package bitbadges.bitbadgeschain.badges;

import "google/protobuf/any.proto";
import "badges/ranges.proto";
import "badges/balances.proto";
import "badges/claims.proto";

option go_package = "github.com/bitbadges/bitbadgeschain/x/badges/types";

//BadgeUri defines a URI where to fetch the badge metadata for the given badge id ranges
//If {id} is included in the URI, it will be replaced by each badge's unique id.
message BadgeUri {
  string uri = 1;
  repeated IdRange badgeIds = 2;
}

// BadgeCollection defines a standard collection of badges.
message BadgeCollection {
    // The collectionId defines the unique identifier of the BadgeCollection classification, similar to the contract address of ERC721.
    // This is assigned by the chain itself. All ids start at 1 and increments by 1 each created collection.
    uint64 collectionId = 1;

    // The URI where to fetch the collection's metadata. Max 100 characters.
    string collectionUri = 2; 

    // An array of BadgeUri objects for where to fetch the badge metadata.
    // Each BadgeUri object has a uri and an array of badgeId ranges (see BadgeUri type).
    // The uri can include {id} in the URI which is a placeholder to be replaced by each badge's unique id.
    // To fetch the metadata for a speciifc badge, the first match is always used.
    repeated BadgeUri badgeUris = 3;

    // The URI where to fetch the collection's balances. Max 100 characters. 
    // Leave blank if balances are to be stored on-chain.
    string balancesUri = 4;

    // These are arbitrary bytes can be used to store anything on-chain about the badge (often used for a permanent hash).
    // This can be updatable or not depending on the permissions set. Max 256 bytes allowed.
    string bytes = 5;
    
    // The manager's address. The manager can be granted special permissions.
    string manager = 6;
    
    //Store permissions packed in a uint where the bits correspond to certain permissions.
    //Leading zeroes are applied. See permissions definition.
    uint64 permissions = 7;

    //This defines the address combinations that can be transferred. 
    //Used to freeze addresses and prevent transfers.
    //If all addresses are disallowed, then the badge is non-transferable.
    //If all are allowed, then the badge is transferable.
    //Ex: If an account is in the "to" mapping and another account is in the "from" mapping,
    //    the "to" account can transfer to the "from" account
    repeated TransferMapping allowedTransfers = 8;

    //This defines the address combinations that the manager is approved to execute (overrides allowedTransfers).
    //Example use case would be to set up the manager being able to forcefully revoke or forcefully burn badges.
    //This can be updated, but addresses can only be removed, never added.
    //Ex: If an account is in the "to" mapping and another account is in the "from" mapping,
    //    the manager can transfer any badge from the "to" account to the "from" account
    repeated TransferMapping managerApprovedTransfers = 9;

    //Badge ids start at 1. Each badge created will increment this by 1. Can't overflow.
    uint64 nextBadgeId = 10;

    //This is a map of the current unminted badge supplys by ID. 
    //Claimable badges are not included in this count (considered "transfered" to the claim's balances).
    repeated Balance unmintedSupplys = 11;

    //This is a map of the maximum badge supplys by ID.
    repeated Balance maxSupplys = 12;

    //Keeps track of the next claim id. Claim ids start at 1. 
    //Each claim created will increment this by 1. Can't overflow.
    //Claims are stored in a separate store because they are frequently written to.
    uint64 nextClaimId = 13;

    //Defines what standard this badge should implement (see standards documentation).
    uint64 standard = 14;
}
