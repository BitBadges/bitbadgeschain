syntax = "proto3";
package trevormil.bitbadgeschain.badges;

import "google/protobuf/any.proto";

option go_package = "github.com/trevormil/bitbadgeschain/x/badges/types";

// BitBadge defines a badge type. Think of this like the smart contract definition
message BitBadge {
    // id defines the unique identifier of the Badge classification, similar to the contract address of ERC721
    // starts at 0 and increments by 1 each badge
    uint64 id = 1;
  
    // uri for the class metadata stored off chain. must match a valid metadata standard (bitbadge, collection, etc)
    string uri = 2;
    
    // manager address of the class; can have special permissions; is used as the reserve address for the assets
    uint64 manager = 4;
    
    /*
        Flag bits are in the following order from left to right; leading zeroes are applied and any future additions will be appended to the right

        can_manager_transfer: can the manager transfer managerial privileges to another address
        can_update_uris: can the manager update the uris of the class and subassets; if false, locked forever
        forceful_transfers: if true, one can send a badge to an account without pending approval; these badges should not by default be displayed on public profiles (can also use collections)
        can_create: when true, manager can create more subassets of the class; once set to false, it is locked
        can_revoke: when true, manager can revoke subassets of the class (including null address); once set to false, it is locked
        can_freeze: when true, manager can freeze addresseses from transferring; once set to false, it is locked
        frozen_by_default: when true, all addresses are considered frozen and must be unfrozen to transfer; when false, all addresses are considered unfrozen and must be frozen to freeze
            manager is not frozen by default

        More permissions to be added
    */
    uint64 permission_flags = 5;
    

    // if frozen_by_default is true, this is a list of unfrozen addresses; and vice versa for false
    //TODO: make this a fixed length set efficient accumulator (no need to store a list of all addresses; just lookup membership)
    //TODO: set max length
    string frozen_or_unfrozen_addresses_digest = 10;

    // uri for the subassets metadata stored off chain; include {id} in the string, it will be replaced with the subasset id
    // if not specified, uses a default Class (ID # 1) like metadata
    string subasset_uri_format = 11;

    // starts at 0; each subasset created will incrementally have an increasing ID #
    uint64 next_subasset_id = 12;

    //only store if not 1 (default); will be sorted in order of subsasset ids; (maybe add defaut option in future)
    repeated Subasset subassets_total_supply = 13;
    
    //TODO: maybe do something to more efficiently query owners of a badge?
}

//Only will be created if supply >= 0
message Subasset {
    uint64 id = 1;
    uint64 supply = 2;
}