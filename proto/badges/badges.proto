syntax = "proto3";
package bitbadges.bitbadgeschain.badges;

import "google/protobuf/any.proto";
import "badges/ranges.proto";
import "badges/balances.proto";
import "badges/claims.proto";

option go_package = "github.com/bitbadges/bitbadgeschain/x/badges/types";

message BadgeUri {
    string uri = 1;
    repeated IdRange badgeIds = 2;
}

// BadgeCollection defines a standard collection of badges.
message BadgeCollection {
    // The collectionId defines the unique identifier of the Badge classification, similar to the contract address of ERC721.
    // This is assigned by the chain itself. All ids starts at 0 and increments by 1 each created badge.
    uint64 collectionId = 1;

    // The URI where to fetch the collection's metadata. Max 100 characters.
    string collectionUri = 2; 

    // The URI where to fetch each badge's metadata. Max 100 characters.
    // Can include {id} in the URI to be replaced by the badge's id.
    repeated BadgeUri badgeUris = 3;

    // These are arbitrary bytes can be used to store anything on-chain about the badge (often used for a permanent hash).
    // This can be updatable or not depending on the permissions set. Max 256 bytes allowed.
    string bytes = 4;
    
    // The manager's account number of the badge. The manager can have special permissions.
    uint64 manager = 5;
    
    //Store permissions packed in a uint where the bits correspond to permissions from left to right.
    //Leading zeroes are applied. See types/permissions.go
    uint64 permissions = 6;

    //This defines the address combinations that cannot be transferred. 
    //Used to freeze addresses and prevent transfers.
    //If all addresses are disallowed, then the badge is non-transferable.
    repeated TransferMapping disallowedTransfers = 7;

    //This defines the address combinations that the manager is approved to execute (overrides disallowedTransfers).
    //Example use case would be to set up the manager being able to forcefully revoke or forcefully burn badges.
    //This can be updated, but addresses can only be removed, never added.
    repeated TransferMapping managerApprovedTransfers = 8;

    //Badge ids start at 0. Each badge created will increment this by 1. Can't overflow.
    uint64 nextBadgeId = 9;

    //This is a map of the current badge supplys. 
    repeated Balance unmintedSupplys = 10;

    //This is a map of the maximum badge supplys. 
    repeated Balance maxSupplys = 11;

    //This is an array of the current badge claims.
    repeated Claim claims = 12;

    //Defines what standard this badge should implement (see /standards).
    uint64 standard = 13;
}
