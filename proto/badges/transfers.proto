syntax = "proto3";
package bitbadges.bitbadgeschain.badges;

import "gogoproto/gogo.proto";
import "badges/permissions.proto";
import "badges/address_mappings.proto";
import "badges/balances.proto";

option go_package = "github.com/bitbadges/bitbadgeschain/x/badges/types";

// UserBalanceStore is the store for the user balances
// It consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,
// and the permissions for updating the approved incoming/outgoing transfers.
//
// The default approved outgoing / incoming transfers are defined by the collection.
//
// The outgoing transfers can be used to allow / disallow transfers which are sent from this user.
// If a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user).
//
// The incoming transfers can be used to allow / disallow transfers which are sent to this user.
// If a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user).
//
// Note that the user approved transfers are only checked if the collection approved transfers do not specify to override
// the user approved transfers.
message UserBalanceStore {
  repeated Balance balances = 1;
  repeated UserOutgoingApproval outgoingApprovals = 2;
  repeated UserIncomingApproval incomingApprovals = 3;
  bool autoApproveSelfInitiatedOutgoingTransfers = 4;
  bool autoApproveSelfInitiatedIncomingTransfers = 5;
  UserPermissions userPermissions = 6;
}


// Challenges define the rules for the approval.
// If all challenge are not met with valid solutions, then the transfer is not approved.
//
// Currently, we only support Merkle tree challenges where the Merkle path must be to the provided root
// and be the expected length.
//
// We also support the following options:
// -useCreatorAddressAsLeaf: If true, then the leaf will be set to the creator address. Used for whitelist trees.
// -maxOneUsePerLeaf: If true, then each leaf can only be used once. If false, then the leaf can be used multiple times.
// This is very important to be set to true if you want to prevent replay attacks.
// -useLeafIndexForDistributionOrder: If true, we will use the leafIndex to determine the order of the distribution of badges.
// leafIndex 0 will be the leftmost leaf of the expectedProofLength layer
//
// IMPORTANT: We track the number of uses per leaf according to a challenge ID.
// Please use unique challenge IDs for different challenges of the same timeline.
// If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
// It is highly recommended to avoid updating a challenge without resetting the tally via a new challenge ID.
message MerkleChallenge {
  string root = 1;
  string expectedProofLength = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  bool useCreatorAddressAsLeaf = 3;
  string maxUsesPerLeaf = 4 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  string uri = 6;
  string customData = 7;
}

// UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.
// See CollectionApproval for more details. This is the same minus a few fields.
message UserOutgoingApproval {
  string toMappingId = 1;
  string initiatedByMappingId = 2;
  repeated UintRange transferTimes = 3;
  repeated UintRange badgeIds = 4;
  repeated UintRange ownershipTimes = 5;
  string amountTrackerId = 6; 
  string challengeTrackerId = 7; 

  //if approved, we use these. if not, these are ignored
  string uri = 8;
  string customData = 9;
  string approvalId = 10; 
  OutgoingApprovalCriteria approvalCriteria = 11;
}

// UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.
// See CollectionApproval for more details. This is the same minus a few fields.
message UserIncomingApproval {
  string fromMappingId = 1;
  string initiatedByMappingId = 2;
  repeated UintRange transferTimes = 3;
  repeated UintRange badgeIds = 4;
  repeated UintRange ownershipTimes = 5;
  string amountTrackerId = 6; // if applicable
  string challengeTrackerId = 7; // if applicable

  string uri = 8;
  string customData = 9;
  string approvalId = 10; // if applicable
  IncomingApprovalCriteria approvalCriteria = 11;
}


// CollectionApproval defines the rules for the approval of a transfer.
// Each transfer can be broken down into a (from, to, initiatedBy, transferTime, badgeId) tuple.
// We check the approvals for first match of this tuple, using the approvals. Subsequent matches are ignored.
//
// If the first match is disallowed, the transfer is disallowed.
// If the first match is allowed, then we check the rest of the restrictions. If any restrictions fail, then the transfer is disallowed. 
// We do not proceed to the next match.
//
// Challenges defines the challenges that must be met with valid solutions for the transfer to be approved.
//
// requireTo/From(DoesNot)EqualsInitiatedBy defines whether the to/from address must equal the initiatedBy address or not. If it doesn't, then the transfer is disallowed.
//  
// overallApprovals defines the overall approvals for the transfer (i.e. the running tally of the number of transfers and amounts transferred by all addresses).
// perAddressApprovals defines the approvals per unique from, to, and/or initiatedBy address.
// If any of these are nil, we assume unlimited approvals.
//
// IMPORTANT: We track the number of transfers and amounts transferred according to a tracker ID. This is a running tally that increments over time.
// Whenever a transfer is processed that maps to a specific tracker ID, we increment the number of transfers and amounts transferred.
// If the number of transfers or amounts transferred exceeds the corresponding overall or per address approvals, then the transfer is disallowed.
// Note we only track if overallApprovals or to/from/intiiatedByApprovals is not nil.
// If you want to reset the tracker tally, update the tracker ID to a new unique tracker ID.
// Tracker IDs are unique to their timelines. A tracker ID "abc" can be used for the collection, outgoing, and incoming timelines without overlap or overwriting one another.
//
// Ex: If overallApprovals maxNumTransfers = 20 and trackerID = "abc", then the first 20 transfers that map to trackerID = "abc" will be approved. The 21st transfer will be disallowed.
//
// IMPORTANT: Be very careful when updating an approved transfer but keeping the same tracker ID. 
// For example, if you change the corresponding badge IDs and the old badge IDs overlap, then the overlapping badge IDs will already have existing tallies.
//    
// Another common area of confusion is what is actually being tallied. The tally is based on the approved transfer rules that are set.
// For example, if you don't have per address rules set and you update the approved transfer rules to include per address rules, 
// then the tally doesn't retroactively apply the per address rules to the previous transfers. It starts at that time.
//
// Lastly, we have overridesFromOutgoingApprovals and overridesToIncomingApprovals.
// If these are set to true, we ignore the from / to user's approved outgoing / incoming transfers, respectively.
// This is useful, for example, for forcefully revoking badges.
// If these are set to false, the transfer must also be approved by the from /to user's approved outgoing / incoming transfers, respectively.

message ManualBalances {
  repeated Balance balances = 1;
}

message IncrementedBalances {
  repeated Balance startBalances = 1;
  string incrementBadgeIdsBy = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string incrementOwnershipTimesBy = 3 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}


message PredeterminedOrderCalculationMethod {
  bool useOverallNumTransfers = 1;
  bool usePerToAddressNumTransfers = 2;
  bool usePerFromAddressNumTransfers = 3;
  bool usePerInitiatedByAddressNumTransfers = 4;
  bool useMerkleChallengeLeafIndex = 5;
}

message PredeterminedBalances {
  repeated ManualBalances manualBalances = 1;
  IncrementedBalances incrementedBalances = 2;

  PredeterminedOrderCalculationMethod orderCalculationMethod = 3;
}

//PerAddressApprovals defines the approvals per unique from, to, and/or initiatedBy address.
message ApprovalAmounts {
  string overallApprovalAmount = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perToAddressApprovalAmount = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perFromAddressApprovalAmount = 3 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perInitiatedByAddressApprovalAmount = 4 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}

message MaxNumTransfers {
  string overallMaxNumTransfers = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perToAddressMaxNumTransfers = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perFromAddressMaxNumTransfers = 3 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perInitiatedByAddressMaxNumTransfers = 4 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}

message ApprovalsTracker {
  string numTransfers = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  repeated Balance amounts = 2;
}

message ApprovalCriteria {
  repeated MustOwnBadges mustOwnBadges = 1;
  MerkleChallenge merkleChallenge = 2;
  PredeterminedBalances predeterminedBalances = 3;
  ApprovalAmounts approvalAmounts = 4;
  MaxNumTransfers maxNumTransfers = 5;

  bool requireToEqualsInitiatedBy = 9;
  bool requireFromEqualsInitiatedBy = 10;
  bool requireToDoesNotEqualInitiatedBy = 11;
  bool requireFromDoesNotEqualInitiatedBy = 12;

  bool overridesFromOutgoingApprovals = 13;
  bool overridesToIncomingApprovals = 14;
}

message OutgoingApprovalCriteria {
  repeated MustOwnBadges mustOwnBadges = 1;
  MerkleChallenge merkleChallenge = 2;
  PredeterminedBalances predeterminedBalances = 3;
  ApprovalAmounts approvalAmounts = 4;
  MaxNumTransfers maxNumTransfers = 5;

  bool requireToEqualsInitiatedBy = 9;
  bool requireToDoesNotEqualInitiatedBy = 11;
}

message IncomingApprovalCriteria {
  repeated MustOwnBadges mustOwnBadges = 1;
  MerkleChallenge merkleChallenge= 2;
  PredeterminedBalances predeterminedBalances = 3;
  ApprovalAmounts approvalAmounts = 4;
  MaxNumTransfers maxNumTransfers = 5;

  bool requireFromEqualsInitiatedBy = 10;
  bool requireFromDoesNotEqualInitiatedBy = 12;
}

message CollectionApproval {
  // Match Criteria 
  string fromMappingId = 1;
  string toMappingId = 2;
  string initiatedByMappingId = 3;
  repeated UintRange transferTimes = 4;
  repeated UintRange badgeIds = 5;
  repeated UintRange ownershipTimes = 6;
  string amountTrackerId = 7; // if applicable
  string challengeTrackerId = 8; // if applicable

  string uri = 9;
  string customData = 10;
  string approvalId = 11; // if applicable
  ApprovalCriteria approvalCriteria = 12;
}


message ApprovalIdentifierDetails {
  string approvalId = 1;
  string approvalLevel = 2; //"collection", "incoming", "outgoing"
  string approverAddress = 3; //Leave blank if approvalLevel == "collection"
}

message Transfer {
  string from = 1;
  repeated string toAddresses = 2;
  repeated Balance balances = 3;
  ApprovalIdentifierDetails precalculateBalancesFromApproval = 4;
  repeated MerkleProof merkleProofs = 5;
  string memo = 6;
  repeated ApprovalIdentifierDetails prioritizedApprovals = 7;
  bool onlyCheckPrioritizedApprovals = 8;
}

message MerklePathItem {
  string aunt = 1;
  bool onRight = 2;
}

//Consistent with tendermint/crypto merkle tree
message MerkleProof {
  string leaf = 1;
  repeated MerklePathItem aunts = 2;
}