syntax = "proto3";
package bitbadges.bitbadgeschain.badges;

import "gogoproto/gogo.proto";
import "badges/permissions.proto";
import "badges/address_mappings.proto";
import "badges/balances.proto";

option go_package = "github.com/bitbadges/bitbadgeschain/x/badges/types";

// UserBalanceStore is the store for the user balances
// It consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,
// and the permissions for updating the approved incoming/outgoing transfers.
//
// The default approved outgoing / incoming transfers are defined by the collection.
//
// The outgoing transfers can be used to allow / disallow transfers which are sent from this user.
// If a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user).
//
// The incoming transfers can be used to allow / disallow transfers which are sent to this user.
// If a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user).
//
// Note that the user approved transfers are only checked if the collection approved transfers do not specify to override
// the user approved transfers.
message UserBalanceStore {
  repeated Balance balances = 1;
  repeated UserApprovedOutgoingTransferTimeline approvedOutgoingTransfersTimeline = 2;
  repeated UserApprovedIncomingTransferTimeline approvedIncomingTransfersTimeline = 3;
  UserPermissions userPermissions = 4;
}

message UserApprovedOutgoingTransferTimeline {
  repeated UserApprovedOutgoingTransfer approvedOutgoingTransfers = 1;
  repeated UintRange timelineTimes = 2;
}

message UserApprovedIncomingTransferTimeline {
  repeated UserApprovedIncomingTransfer approvedIncomingTransfers = 1;
  repeated UintRange timelineTimes = 2;
}

// Challenges define the rules for the approval.
// If all challenge are not met with valid solutions, then the transfer is not approved.
//
// Currently, we only support Merkle tree challenges where the Merkle path must be to the provided root
// and be the expected length.
//
// We also support the following options:
// -useCreatorAddressAsLeaf: If true, then the leaf will be set to the creator address. Used for whitelist trees.
// -maxOneUsePerLeaf: If true, then each leaf can only be used once. If false, then the leaf can be used multiple times.
// This is very important to be set to true if you want to prevent replay attacks.
// -useLeafIndexForDistributionOrder: If true, we will use the leafIndex to determine the order of the distribution of badges.
// leafIndex 0 will be the leftmost leaf of the expectedProofLength layer
//
// IMPORTANT: We track the number of uses per leaf according to a challenge ID.
// Please use unique challenge IDs for different challenges of the same timeline.
// If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
// It is highly recommended to avoid updating a challenge without resetting the tally via a new challenge ID.
message Challenge {
  string root = 1;
  string expectedProofLength = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  bool useCreatorAddressAsLeaf = 3;
  bool maxOneUsePerLeaf = 4;
  bool useLeafIndexForTransferOrder = 5;
}

message IsUserOutgoingTransferAllowed {
  bool invertTo = 2;
  bool invertInitiatedBy = 3;
  bool invertTransferTimes = 4;
  bool invertBadgeIds = 5;
  bool invertOwnedTimes = 6;
  bool isAllowed = 7;
}

message IsUserIncomingTransferAllowed {
  bool invertFrom = 2;
  bool invertInitiatedBy = 3;
  bool invertTransferTimes = 4;
  bool invertBadgeIds = 5;
  bool invertOwnedTimes = 6;
  bool isAllowed = 7;
}

// UserApprovedOutgoingTransfer defines the rules for the approval of an outgoing transfer from a user.
// See CollectionApprovedTransfer for more details. This is the same minus a few fields.
message UserApprovedOutgoingTransfer {
  string toMappingId = 1;
  string initiatedByMappingId = 2;
  repeated UintRange transferTimes = 3;
  repeated UintRange badgeIds = 4;
  repeated UintRange ownedTimes = 16;

  repeated IsUserOutgoingTransferAllowed allowedCombinations = 5;

  string approvalId = 7;

  repeated Challenge challenges = 6;

  PredeterminedBalances predeterminedBalances = 8;
  ApprovalAmounts approvalAmounts = 9;
  MaxNumTransfers maxNumTransfers = 10;
  
  string uri = 12;
  string customData = 13;
  
  bool requireToEqualsInitiatedBy = 14;
  bool requireToDoesNotEqualInitiatedBy = 15;
}

// UserApprovedIncomingTransfer defines the rules for the approval of an incoming transfer to a user.
// See CollectionApprovedTransfer for more details. This is the same minus a few fields.
message UserApprovedIncomingTransfer {
  string fromMappingId = 1;
  string initiatedByMappingId = 2;
  repeated UintRange transferTimes = 3;
  repeated UintRange badgeIds = 4;
  repeated UintRange ownedTimes = 16;
  repeated IsUserIncomingTransferAllowed allowedCombinations = 5;

  repeated Challenge challenges = 6;

  string approvalId = 7;

  PredeterminedBalances predeterminedBalances = 8;
  ApprovalAmounts approvalAmounts = 9;
  MaxNumTransfers maxNumTransfers = 10;

  string uri = 12;
  string customData = 13;

  bool requireFromEqualsInitiatedBy = 14;
  bool requireFromDoesNotEqualInitiatedBy = 15;
}

message IsCollectionTransferAllowed {
  bool invertFrom = 1;
  bool invertTo = 2;
  bool invertInitiatedBy = 3;
  bool invertTransferTimes = 4;
  bool invertBadgeIds = 5;
  bool invertOwnedTimes = 6;
  bool isAllowed = 7;
}

// CollectionApprovedTransfer defines the rules for the approval of a transfer.
// Each transfer can be broken down into a (from, to, initiatedBy, transferTime, badgeId) tuple.
// We check the approvedTransfers for first match of this tuple, using the allowedCombinations. Subsequent matches are ignored.
//
// If the first match is disallowed, the transfer is disallowed.
// If the first match is allowed, then we check the rest of the restrictions. If any restrictions fail, then the transfer is disallowed. 
// We do not proceed to the next match.
//
// Challenges defines the challenges that must be met with valid solutions for the transfer to be approved.
//
// requireTo/From(DoesNot)EqualsInitiatedBy defines whether the to/from address must equal the initiatedBy address or not. If it doesn't, then the transfer is disallowed.
//  
// overallApprovals defines the overall approvals for the transfer (i.e. the running tally of the number of transfers and amounts transferred by all addresses).
// perAddressApprovals defines the approvals per unique from, to, and/or initiatedBy address.
// If any of these are nil, we assume unlimited approvals.
//
// IMPORTANT: We track the number of transfers and amounts transferred according to a tracker ID. This is a running tally that increments over time.
// Whenever a transfer is processed that maps to a specific tracker ID, we increment the number of transfers and amounts transferred.
// If the number of transfers or amounts transferred exceeds the corresponding overall or per address approvals, then the transfer is disallowed.
// Note we only track if overallApprovals or to/from/intiiatedByApprovals is not nil.
// If you want to reset the tracker tally, update the tracker ID to a new unique tracker ID.
// Tracker IDs are unique to their timelines. A tracker ID "abc" can be used for the collection, outgoing, and incoming timelines without overlap or overwriting one another.
//
// Ex: If overallApprovals maxNumTransfers = 20 and trackerID = "abc", then the first 20 transfers that map to trackerID = "abc" will be approved. The 21st transfer will be disallowed.
//
// IMPORTANT: Be very careful when updating an approved transfer but keeping the same tracker ID. 
// For example, if you change the corresponding badge IDs and the old badge IDs overlap, then the overlapping badge IDs will already have existing tallies.
//    
// Another common area of confusion is what is actually being tallied. The tally is based on the approved transfer rules that are set.
// For example, if you don't have per address rules set and you update the approved transfer rules to include per address rules, 
// then the tally doesn't retroactively apply the per address rules to the previous transfers. It starts at that time.
//
// Lastly, we have overridesFromApprovedOutgoingTransfers and overridesToApprovedIncomingTransfers.
// If these are set to true, we ignore the from / to user's approved outgoing / incoming transfers, respectively.
// This is useful, for example, for forcefully revoking badges.
// If these are set to false, the transfer must also be approved by the from /to user's approved outgoing / incoming transfers, respectively.

message ManualBalances {
  repeated Balance balances = 1;
}

message IncrementedBalances {
  repeated Balance startBalances = 1;
  string incrementBadgeIdsBy = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string incrementOwnedTimesBy = 3 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}

message PredeterminedOrderCalculationMethod {
  bool useOverallNumTransfers = 1;
  bool usePerToAddressNumTransfers = 2;
  bool usePerFromAddressNumTransfers = 3;
  bool usePerInitiatedByAddressNumTransfers = 4;

  bool useChallengeLeafIndex = 5;
}

message PredeterminedBalances {
  repeated ManualBalances manualBalances = 1;
  IncrementedBalances incrementedBalances = 2;

  PredeterminedOrderCalculationMethod orderCalculationMethod = 3;
}

//PerAddressApprovals defines the approvals per unique from, to, and/or initiatedBy address.
message ApprovalAmounts {
  string overallApprovalAmount = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perToAddressApprovalAmount = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perFromAddressApprovalAmount = 3 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perInitiatedByAddressApprovalAmount = 4 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}

message MaxNumTransfers {
  string overallMaxNumTransfers = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perToAddressMaxNumTransfers = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perFromAddressMaxNumTransfers = 3 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string perInitiatedByAddressMaxNumTransfers = 4 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}

message ApprovalsTracker {
  string numTransfers = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  repeated Balance amounts = 2;
}

message CollectionApprovedTransfer {
  //Metadata
  string approvalId = 1;
  string uri = 2;
  string customData = 3;

  //Match Criteria 
  string fromMappingId = 4;
  string toMappingId = 5;
  string initiatedByMappingId = 6;
  repeated UintRange transferTimes = 7;
  repeated UintRange badgeIds = 8;
  repeated UintRange ownedTimes = 9;
  
  repeated IsCollectionTransferAllowed allowedCombinations = 10;

  //Restrictions (Challenges, Amounts, MaxNumTransfers)
  repeated Challenge challenges = 11;
  PredeterminedBalances predeterminedBalances = 12;
  ApprovalAmounts approvalAmounts = 13;
  MaxNumTransfers maxNumTransfers = 14;
  
  
  bool requireToEqualsInitiatedBy = 15;
  bool requireFromEqualsInitiatedBy = 16;
  bool requireToDoesNotEqualInitiatedBy = 17;
  bool requireFromDoesNotEqualInitiatedBy = 18;

  //Is this approval forceful, or does it additionally require the to/from user's approval?
  bool overridesFromApprovedOutgoingTransfers = 19;
  bool overridesToApprovedIncomingTransfers = 20;
}

message ApprovalIdDetails {
  string approvalId = 1;
  string approvalLevel = 2; //"collection", "incoming", "outgoing"
  string address = 3; //Leave blank if approvalLevel == "collection"
}

message Transfer {
  string from = 1;
  repeated string toAddresses = 2;
  repeated Balance balances = 3;
  ApprovalIdDetails precalculateFromApproval = 4;
  repeated ChallengeSolution solutions = 5;
}

message ClaimProofItem {
  string aunt = 1;
  bool onRight = 2;
}

//Consistent with tendermint/crypto merkle tree
message ClaimProof {
  string leaf = 1;
  repeated ClaimProofItem aunts = 2;
}

message ChallengeSolution {
  ClaimProof proof = 1;
}