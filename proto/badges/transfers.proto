syntax = "proto3";
package bitbadges.bitbadgeschain.badges;

import "gogoproto/gogo.proto";
import "badges/permissions.proto";
import "badges/address_mappings.proto";
import "badges/balances.proto";

option go_package = "github.com/bitbadges/bitbadgeschain/x/badges/types";


message UserBalanceStore {
  repeated Balance balances = 1;
  repeated UserApprovedOutgoingTransferTimeline approvedOutgoingTransfersTimeline = 2;
  repeated UserApprovedIncomingTransferTimeline approvedIncomingTransfersTimeline = 3;
  UserPermissions permissions = 4;
}

message UserApprovedOutgoingTransferTimeline {
  repeated UserApprovedOutgoingTransfer approvedOutgoingTransfers = 1;
  repeated IdRange times = 2;
}

message UserApprovedIncomingTransferTimeline {
  repeated UserApprovedIncomingTransfer approvedIncomingTransfers = 1;
  repeated IdRange times = 2;
}

message Challenge {
  string root = 1;
  string expectedProofLength = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  bool useCreatorAddressAsLeaf = 3;
  bool maxOneUsePerLeaf = 4;
  bool useLeafIndexForDistributionOrder = 5;
  string challengeId = 6;
}

message PerAddressApprovals {
  ApprovalsTracker approvalsPerFromAddress = 1;
  ApprovalsTracker approvalsPerToAddress = 2;
  ApprovalsTracker approvalsPerInitiatedByAddress = 3;
}

message IsUserOutgoingTransferAllowed {
  bool invertTo = 2;
  bool invertInitiatedBy = 3;
  bool invertTransferTimes = 4;
  bool invertBadgeIds = 5;
  bool isAllowed = 6;
}

message IsUserIncomingTransferAllowed {
  bool invertFrom = 2;
  bool invertInitiatedBy = 3;
  bool invertTransferTimes = 4;
  bool invertBadgeIds = 5;
  bool isAllowed = 6;
}


message UserApprovedOutgoingTransfer {
  string toMappingId = 1;
  string initiatedByMappingId = 2;
  repeated IdRange transferTimes = 3;
  repeated IdRange badgeIds = 4;
  repeated IsUserOutgoingTransferAllowed allowedCombinations = 5;

  repeated Challenge challenges = 6;

  string trackerId = 7;

  string incrementIdsBy = 8 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string incrementTimesBy = 9 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  PerAddressApprovals perAddressApprovals = 10;
  
  string uri = 12;
  string customData = 13;
  
  bool requireToEqualsInitiatedBy = 14;
  bool requireToDoesNotEqualInitiatedBy = 15;
}

message UserApprovedIncomingTransfer {
  string fromMappingId = 1;
  string initiatedByMappingId = 2;
  repeated IdRange transferTimes = 3;
  repeated IdRange badgeIds = 4;
  repeated IsUserIncomingTransferAllowed allowedCombinations = 5;

  repeated Challenge challenges = 6;

  string trackerId = 7;

  string incrementIdsBy = 8 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string incrementTimesBy = 9 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  PerAddressApprovals perAddressApprovals = 11;

  string uri = 12;
  string customData = 13;

  bool requireFromEqualsInitiatedBy = 14;
  bool requireFromDoesNotEqualInitiatedBy = 15;
}

message IsCollectionTransferAllowed {
  bool invertFrom = 1;
  bool invertTo = 2;
  bool invertInitiatedBy = 3;
  bool invertTransferTimes = 4;
  bool invertBadgeIds = 5;
  bool isAllowed = 6;
}

message CollectionApprovedTransfer {
  string fromMappingId = 1;
  string toMappingId = 2;
  string initiatedByMappingId = 3;
  repeated IdRange transferTimes = 4;
  repeated IdRange badgeIds = 5;
  
  repeated IsCollectionTransferAllowed allowedCombinations = 6;

  repeated Challenge challenges = 7;

  string trackerId = 8;

  string incrementIdsBy = 9 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string incrementTimesBy = 10 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  ApprovalsTracker overallApprovals = 11;
  PerAddressApprovals perAddressApprovals = 12;

  bool overridesFromApprovedOutgoingTransfers = 15;
  bool overridesToApprovedIncomingTransfers = 16;

  bool requireToEqualsInitiatedBy = 17;
  bool requireFromEqualsInitiatedBy = 18;
  bool requireToDoesNotEqualInitiatedBy = 19;
  bool requireFromDoesNotEqualInitiatedBy = 20;

  string uri = 21;
  string customData = 22;
}

message ApprovalsTracker {
  string numTransfers = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  repeated Balance amounts = 2;
}

/*
  We always track the primary num transfers and amounts.
  For collection, primary = overall.
  For outgoing, primary = from.
  For incoming, primary = to.

  When you first add an approved transfer with a unique tracker ID, it starts a running tally of the number of transfers and the amounts transferred.
  For example, if you approve x20 of badge ID 1, then when valid transfers are made that match the approved transfer, the tally will increment.
  Once the tally reaches x20 of badge ID 1, the next transfer will be unapproved.
  In each approved transfer, there are more fine-grained rules such as per address approvals. The tracker does not tally if they are not set.
  Tracker IDs are considered different tallies / counts via each level (collection is a diff count than outgoing is a diff count than incoming).

  When updating approved transfers, you can specify a new unique tracker ID. If you do, then the tracker will reset and start a new tally.
  If you do not update the tracker ID, then the tracker will continue to tally the transfers and amounts, according to whatever rules are set.
  You can query the current tracker status anytime with the query endpoints.
  
  There are three cases when updating the approved transfers:
  -1) No update needed. Leave the existing approved transfer as is w/ tracker ID, and it will continue to tally as before.
  -2) Update and reset state. Remove the existing approved transfer and replace it with a new one with a new tracker ID, thus resetting the tally.
      For most use cases, this should be the approach you take. It is the simplest and most straightforward.
  -3) If you need to update and keep the current tally, then you can update the approved transfer rules without updating the tracker ID.
      This is a more advanced use case and can cause confusion. You should BE VERY CAREFUL when using this approach and know what you are changing.
      For example, if you change the corresponding badge IDs and the old badge IDs overlap, then the overlapping badge IDs will already have existing tallies.
      
      Another common area of confusion is what is actually being tallied. The tally is based on the approved transfer rules that are set.
      For example, if you don't have per address rules set and you update the approved transfer rules to include per address rules, 
      then the tally doesn't retroactively apply the per address rules to the previous transfers. It starts at that time.
   
  Note when updating approved transfers, order matters (we take the first match ONLY).
*/

/*
  Challenge IDs are the same way. If maxOneUsePerleaf is turned on, we use the challenge ID to track which leaves have been used for the challenge.
  If you update the challenge ID, then the used leaves traceker will reset and start a new tally.

  -Do not use the same challenge ID for different challenges. This can cause unexpected behavior because both challenges will use the same tally.
  -For the same challenge, use the same challenge ID. You are allowed to use the same challenge across different approvals, but note that if they have
   different challenge IDs, they will have different tallies. This means that any successful solution for one challenge can be replayed for the other challenge.
  -Note that if you update the challenge ID but keep the challenge the same, your challenge is now susceptible to replay attacks using the previous successful solutions.
*/