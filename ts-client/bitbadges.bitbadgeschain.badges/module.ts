// Generated by Ignite ignite.com/cli

import { StdFee } from "@cosmjs/launchpad";
import { SigningStargateClient, DeliverTxResponse } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { MsgTransferBadge } from "./types/badges/tx";
import { MsgUpdateUris } from "./types/badges/tx";
import { MsgRegisterAddresses } from "./types/badges/tx";
import { MsgRequestTransferManager } from "./types/badges/tx";
import { MsgSetApproval } from "./types/badges/tx";
import { MsgUpdateBytes } from "./types/badges/tx";
import { MsgNewBadge } from "./types/badges/tx";
import { MsgNewSubBadge } from "./types/badges/tx";
import { MsgUpdatePermissions } from "./types/badges/tx";
import { MsgFreezeAddress } from "./types/badges/tx";
import { MsgTransferManager } from "./types/badges/tx";
import { MsgRevokeBadge } from "./types/badges/tx";
import { MsgRequestTransferBadge } from "./types/badges/tx";
import { MsgSelfDestructBadge } from "./types/badges/tx";
import { MsgHandlePendingTransfer } from "./types/badges/tx";
import { MsgPruneBalances } from "./types/badges/tx";


export { MsgTransferBadge, MsgUpdateUris, MsgRegisterAddresses, MsgRequestTransferManager, MsgSetApproval, MsgUpdateBytes, MsgNewBadge, MsgNewSubBadge, MsgUpdatePermissions, MsgFreezeAddress, MsgTransferManager, MsgRevokeBadge, MsgRequestTransferBadge, MsgSelfDestructBadge, MsgHandlePendingTransfer, MsgPruneBalances };

type sendMsgTransferBadgeParams = {
  value: MsgTransferBadge,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateUrisParams = {
  value: MsgUpdateUris,
  fee?: StdFee,
  memo?: string
};

type sendMsgRegisterAddressesParams = {
  value: MsgRegisterAddresses,
  fee?: StdFee,
  memo?: string
};

type sendMsgRequestTransferManagerParams = {
  value: MsgRequestTransferManager,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetApprovalParams = {
  value: MsgSetApproval,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateBytesParams = {
  value: MsgUpdateBytes,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewBadgeParams = {
  value: MsgNewBadge,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewSubBadgeParams = {
  value: MsgNewSubBadge,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdatePermissionsParams = {
  value: MsgUpdatePermissions,
  fee?: StdFee,
  memo?: string
};

type sendMsgFreezeAddressParams = {
  value: MsgFreezeAddress,
  fee?: StdFee,
  memo?: string
};

type sendMsgTransferManagerParams = {
  value: MsgTransferManager,
  fee?: StdFee,
  memo?: string
};

type sendMsgRevokeBadgeParams = {
  value: MsgRevokeBadge,
  fee?: StdFee,
  memo?: string
};

type sendMsgRequestTransferBadgeParams = {
  value: MsgRequestTransferBadge,
  fee?: StdFee,
  memo?: string
};

type sendMsgSelfDestructBadgeParams = {
  value: MsgSelfDestructBadge,
  fee?: StdFee,
  memo?: string
};

type sendMsgHandlePendingTransferParams = {
  value: MsgHandlePendingTransfer,
  fee?: StdFee,
  memo?: string
};

type sendMsgPruneBalancesParams = {
  value: MsgPruneBalances,
  fee?: StdFee,
  memo?: string
};


type msgTransferBadgeParams = {
  value: MsgTransferBadge,
};

type msgUpdateUrisParams = {
  value: MsgUpdateUris,
};

type msgRegisterAddressesParams = {
  value: MsgRegisterAddresses,
};

type msgRequestTransferManagerParams = {
  value: MsgRequestTransferManager,
};

type msgSetApprovalParams = {
  value: MsgSetApproval,
};

type msgUpdateBytesParams = {
  value: MsgUpdateBytes,
};

type msgNewBadgeParams = {
  value: MsgNewBadge,
};

type msgNewSubBadgeParams = {
  value: MsgNewSubBadge,
};

type msgUpdatePermissionsParams = {
  value: MsgUpdatePermissions,
};

type msgFreezeAddressParams = {
  value: MsgFreezeAddress,
};

type msgTransferManagerParams = {
  value: MsgTransferManager,
};

type msgRevokeBadgeParams = {
  value: MsgRevokeBadge,
};

type msgRequestTransferBadgeParams = {
  value: MsgRequestTransferBadge,
};

type msgSelfDestructBadgeParams = {
  value: MsgSelfDestructBadge,
};

type msgHandlePendingTransferParams = {
  value: MsgHandlePendingTransfer,
};

type msgPruneBalancesParams = {
  value: MsgPruneBalances,
};


export const registry = new Registry(msgTypes);

const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendMsgTransferBadge({ value, fee, memo }: sendMsgTransferBadgeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgTransferBadge: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgTransferBadge({ value: MsgTransferBadge.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgTransferBadge: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateUris({ value, fee, memo }: sendMsgUpdateUrisParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateUris: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateUris({ value: MsgUpdateUris.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateUris: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRegisterAddresses({ value, fee, memo }: sendMsgRegisterAddressesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRegisterAddresses: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRegisterAddresses({ value: MsgRegisterAddresses.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRegisterAddresses: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRequestTransferManager({ value, fee, memo }: sendMsgRequestTransferManagerParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRequestTransferManager: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRequestTransferManager({ value: MsgRequestTransferManager.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRequestTransferManager: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetApproval({ value, fee, memo }: sendMsgSetApprovalParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetApproval: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgSetApproval({ value: MsgSetApproval.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetApproval: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateBytes({ value, fee, memo }: sendMsgUpdateBytesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateBytes: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdateBytes({ value: MsgUpdateBytes.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateBytes: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewBadge({ value, fee, memo }: sendMsgNewBadgeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewBadge: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgNewBadge({ value: MsgNewBadge.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewBadge: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewSubBadge({ value, fee, memo }: sendMsgNewSubBadgeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewSubBadge: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgNewSubBadge({ value: MsgNewSubBadge.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewSubBadge: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdatePermissions({ value, fee, memo }: sendMsgUpdatePermissionsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdatePermissions: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUpdatePermissions({ value: MsgUpdatePermissions.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdatePermissions: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgFreezeAddress({ value, fee, memo }: sendMsgFreezeAddressParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgFreezeAddress: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgFreezeAddress({ value: MsgFreezeAddress.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgFreezeAddress: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgTransferManager({ value, fee, memo }: sendMsgTransferManagerParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgTransferManager: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgTransferManager({ value: MsgTransferManager.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgTransferManager: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRevokeBadge({ value, fee, memo }: sendMsgRevokeBadgeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRevokeBadge: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRevokeBadge({ value: MsgRevokeBadge.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRevokeBadge: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRequestTransferBadge({ value, fee, memo }: sendMsgRequestTransferBadgeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRequestTransferBadge: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgRequestTransferBadge({ value: MsgRequestTransferBadge.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRequestTransferBadge: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSelfDestructBadge({ value, fee, memo }: sendMsgSelfDestructBadgeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSelfDestructBadge: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgSelfDestructBadge({ value: MsgSelfDestructBadge.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSelfDestructBadge: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgHandlePendingTransfer({ value, fee, memo }: sendMsgHandlePendingTransferParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgHandlePendingTransfer: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgHandlePendingTransfer({ value: MsgHandlePendingTransfer.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgHandlePendingTransfer: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPruneBalances({ value, fee, memo }: sendMsgPruneBalancesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPruneBalances: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgPruneBalances({ value: MsgPruneBalances.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPruneBalances: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		msgTransferBadge({ value }: msgTransferBadgeParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgTransferBadge", value: MsgTransferBadge.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgTransferBadge: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateUris({ value }: msgUpdateUrisParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgUpdateUris", value: MsgUpdateUris.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateUris: Could not create message: ' + e.message)
			}
		},
		
		msgRegisterAddresses({ value }: msgRegisterAddressesParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgRegisterAddresses", value: MsgRegisterAddresses.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRegisterAddresses: Could not create message: ' + e.message)
			}
		},
		
		msgRequestTransferManager({ value }: msgRequestTransferManagerParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgRequestTransferManager", value: MsgRequestTransferManager.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRequestTransferManager: Could not create message: ' + e.message)
			}
		},
		
		msgSetApproval({ value }: msgSetApprovalParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgSetApproval", value: MsgSetApproval.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetApproval: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateBytes({ value }: msgUpdateBytesParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgUpdateBytes", value: MsgUpdateBytes.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateBytes: Could not create message: ' + e.message)
			}
		},
		
		msgNewBadge({ value }: msgNewBadgeParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgNewBadge", value: MsgNewBadge.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewBadge: Could not create message: ' + e.message)
			}
		},
		
		msgNewSubBadge({ value }: msgNewSubBadgeParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgNewSubBadge", value: MsgNewSubBadge.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewSubBadge: Could not create message: ' + e.message)
			}
		},
		
		msgUpdatePermissions({ value }: msgUpdatePermissionsParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgUpdatePermissions", value: MsgUpdatePermissions.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdatePermissions: Could not create message: ' + e.message)
			}
		},
		
		msgFreezeAddress({ value }: msgFreezeAddressParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgFreezeAddress", value: MsgFreezeAddress.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgFreezeAddress: Could not create message: ' + e.message)
			}
		},
		
		msgTransferManager({ value }: msgTransferManagerParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgTransferManager", value: MsgTransferManager.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgTransferManager: Could not create message: ' + e.message)
			}
		},
		
		msgRevokeBadge({ value }: msgRevokeBadgeParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgRevokeBadge", value: MsgRevokeBadge.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRevokeBadge: Could not create message: ' + e.message)
			}
		},
		
		msgRequestTransferBadge({ value }: msgRequestTransferBadgeParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgRequestTransferBadge", value: MsgRequestTransferBadge.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRequestTransferBadge: Could not create message: ' + e.message)
			}
		},
		
		msgSelfDestructBadge({ value }: msgSelfDestructBadgeParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgSelfDestructBadge", value: MsgSelfDestructBadge.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSelfDestructBadge: Could not create message: ' + e.message)
			}
		},
		
		msgHandlePendingTransfer({ value }: msgHandlePendingTransferParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgHandlePendingTransfer", value: MsgHandlePendingTransfer.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgHandlePendingTransfer: Could not create message: ' + e.message)
			}
		},
		
		msgPruneBalances({ value }: msgPruneBalancesParams): EncodeObject {
			try {
				return { typeUrl: "/bitbadges.bitbadgeschain.badges.MsgPruneBalances", value: MsgPruneBalances.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPruneBalances: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const Module = (test: IgniteClient) => {
	return {
		module: {
			BitbadgesBitbadgeschainBadges: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default Module;