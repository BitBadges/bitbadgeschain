{"id":"github.com/bitbadges/bitbadgeschain","consumes":["application/json"],"produces":["application/json"],"swagger":"2.0","info":{"description":"Chain github.com/bitbadges/bitbadgeschain REST API","title":"HTTP API Console","contact":{"name":"github.com/bitbadges/bitbadgeschain"},"version":"version not set"},"paths":{"/anchor.Msg/AddCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_AddCustomData","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/anchor.MsgAddCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.MsgAddCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/anchor.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParams","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/anchor.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressLists","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollection","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/CreateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateDynamicStore","parameters":[{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgCreateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgCreateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DecrementStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DecrementStoreValue","parameters":[{"description":"MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDecrementStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDecrementStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollection","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DeleteDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteDynamicStore","parameters":[{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDeleteDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDeleteDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DeleteIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteIncomingApproval","parameters":[{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDeleteIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDeleteIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DeleteOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteOutgoingApproval","parameters":[{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDeleteOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDeleteOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/IncrementStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_IncrementStoreValue","parameters":[{"description":"MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgIncrementStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgIncrementStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/PurgeApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_PurgeApprovals","parameters":[{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgPurgeApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgPurgeApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetBadgeMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetBadgeMetadata","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetBadgeMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetBadgeMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetCollectionApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionApprovals","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetCollectionApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetCollectionApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetCollectionMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionMetadata","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetCollectionMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetCollectionMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCustomData","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetDynamicStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDynamicStoreValue","parameters":[{"description":"MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetDynamicStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIncomingApproval","parameters":[{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetIsArchived":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIsArchived","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetIsArchived"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetIsArchivedResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetManager":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetManager","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetManager"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetManagerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetOutgoingApproval","parameters":[{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetStandards":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetStandards","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetStandards"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetStandardsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetValidBadgeIds":{"post":{"tags":["Msg"],"summary":"Helper message types for UniversalUpdateCollection subsets","operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValidBadgeIds","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetValidBadgeIds"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetValidBadgeIdsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/TransferBadges":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferBadges","parameters":[{"description":"MsgTransferBadges is used to transfer tokens.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgTransferBadges"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgTransferBadgesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollection","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollection","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateDynamicStore","parameters":[{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin18","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovals","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressListsMixin30","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollectionMixin30","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/CreateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateDynamicStoreMixin30","parameters":[{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgCreateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgCreateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollectionMixin30","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/DeleteDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteDynamicStoreMixin30","parameters":[{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgDeleteDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgDeleteDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/DeleteIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteIncomingApprovalMixin30","parameters":[{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgDeleteIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgDeleteIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/DeleteOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteOutgoingApprovalMixin30","parameters":[{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgDeleteOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgDeleteOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/PurgeApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_PurgeApprovalsMixin30","parameters":[{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgPurgeApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgPurgeApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/SetBadgeMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetBadgeMetadataMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgSetBadgeMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgSetBadgeMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/SetCollectionApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionApprovalsMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgSetCollectionApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgSetCollectionApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/SetCollectionMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionMetadataMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgSetCollectionMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgSetCollectionMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/SetCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCustomDataMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgSetCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgSetCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/SetDynamicStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDynamicStoreValueMixin30","parameters":[{"description":"MsgSetDynamicStoreValue is used to set a 0/1 flag for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgSetDynamicStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgSetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/SetIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIncomingApprovalMixin30","parameters":[{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgSetIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgSetIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/SetIsArchived":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIsArchivedMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgSetIsArchived"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgSetIsArchivedResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/SetManager":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetManagerMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgSetManager"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgSetManagerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/SetOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetOutgoingApprovalMixin30","parameters":[{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgSetOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgSetOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/SetStandards":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetStandardsMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgSetStandards"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgSetStandardsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/SetValidBadgeIds":{"post":{"tags":["Msg"],"summary":"Helper message types for UniversalUpdateCollection subsets","operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValidBadgeIdsMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgSetValidBadgeIds"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgSetValidBadgeIdsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/TransferBadges":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferBadgesMixin30","parameters":[{"description":"MsgTransferBadges is used to transfer badges.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgTransferBadges"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgTransferBadgesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollectionMixin30","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollectionMixin30","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/UpdateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateDynamicStoreMixin30","parameters":[{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgUpdateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgUpdateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin30","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v10.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovalsMixin30","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v10.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v10.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressListsMixin42","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollectionMixin42","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/CreateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateDynamicStoreMixin42","parameters":[{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgCreateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgCreateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollectionMixin42","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/DeleteDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteDynamicStoreMixin42","parameters":[{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgDeleteDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgDeleteDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/DeleteIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteIncomingApprovalMixin42","parameters":[{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgDeleteIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgDeleteIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/DeleteOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteOutgoingApprovalMixin42","parameters":[{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgDeleteOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgDeleteOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/PurgeApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_PurgeApprovalsMixin42","parameters":[{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgPurgeApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgPurgeApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/SetBadgeMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetBadgeMetadataMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgSetBadgeMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgSetBadgeMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/SetCollectionApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionApprovalsMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgSetCollectionApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgSetCollectionApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/SetCollectionMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionMetadataMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgSetCollectionMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgSetCollectionMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/SetCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCustomDataMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgSetCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgSetCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/SetDynamicStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDynamicStoreValueMixin42","parameters":[{"description":"MsgSetDynamicStoreValue is used to set a 0/1 flag for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgSetDynamicStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgSetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/SetIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIncomingApprovalMixin42","parameters":[{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgSetIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgSetIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/SetIsArchived":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIsArchivedMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgSetIsArchived"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgSetIsArchivedResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/SetManager":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetManagerMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgSetManager"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgSetManagerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/SetOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetOutgoingApprovalMixin42","parameters":[{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgSetOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgSetOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/SetStandards":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetStandardsMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgSetStandards"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgSetStandardsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/SetValidBadgeIds":{"post":{"tags":["Msg"],"summary":"Helper message types for UniversalUpdateCollection subsets","operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValidBadgeIdsMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgSetValidBadgeIds"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgSetValidBadgeIdsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/TransferBadges":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferBadgesMixin42","parameters":[{"description":"MsgTransferBadges is used to transfer badges.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgTransferBadges"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgTransferBadgesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollectionMixin42","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollectionMixin42","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/UpdateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateDynamicStoreMixin42","parameters":[{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgUpdateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgUpdateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin42","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v11.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovalsMixin42","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v11.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v11.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressListsMixin54","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollectionMixin54","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/CreateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateDynamicStoreMixin54","parameters":[{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgCreateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgCreateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/DecrementStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DecrementStoreValueMixin54","parameters":[{"description":"MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgDecrementStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgDecrementStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollectionMixin54","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/DeleteDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteDynamicStoreMixin54","parameters":[{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgDeleteDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgDeleteDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/DeleteIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteIncomingApprovalMixin54","parameters":[{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgDeleteIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgDeleteIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/DeleteOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteOutgoingApprovalMixin54","parameters":[{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgDeleteOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgDeleteOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/IncrementStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_IncrementStoreValueMixin54","parameters":[{"description":"MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgIncrementStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgIncrementStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/PurgeApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_PurgeApprovalsMixin54","parameters":[{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgPurgeApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgPurgeApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/SetBadgeMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetBadgeMetadataMixin54","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgSetBadgeMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgSetBadgeMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/SetCollectionApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionApprovalsMixin54","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgSetCollectionApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgSetCollectionApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/SetCollectionMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionMetadataMixin54","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgSetCollectionMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgSetCollectionMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/SetCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCustomDataMixin54","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgSetCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgSetCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/SetDynamicStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDynamicStoreValueMixin54","parameters":[{"description":"MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgSetDynamicStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgSetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/SetIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIncomingApprovalMixin54","parameters":[{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgSetIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgSetIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/SetIsArchived":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIsArchivedMixin54","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgSetIsArchived"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgSetIsArchivedResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/SetManager":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetManagerMixin54","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgSetManager"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgSetManagerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/SetOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetOutgoingApprovalMixin54","parameters":[{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgSetOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgSetOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/SetStandards":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetStandardsMixin54","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgSetStandards"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgSetStandardsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/SetValidBadgeIds":{"post":{"tags":["Msg"],"summary":"Helper message types for UniversalUpdateCollection subsets","operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValidBadgeIdsMixin54","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgSetValidBadgeIds"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgSetValidBadgeIdsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/TransferBadges":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferBadgesMixin54","parameters":[{"description":"MsgTransferBadges is used to transfer badges.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgTransferBadges"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgTransferBadgesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollectionMixin54","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollectionMixin54","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/UpdateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateDynamicStoreMixin54","parameters":[{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgUpdateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgUpdateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin54","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v12.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovalsMixin54","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v12.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v12.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_address_list/{listId}":{"get":{"tags":["Query"],"summary":"Queries an address list by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetAddressList","parameters":[{"type":"string","name":"listId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetAddressListResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_approvals_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{amountTrackerId}/{trackerType}/{approvedAddress}":{"get":{"tags":["Query"],"summary":"Queries an approvals tracker by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetApprovalTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"amountTrackerId","in":"path","required":true},{"type":"string","name":"trackerType","in":"path","required":true},{"type":"string","description":"if trackerType is \"overall\", leave blank","name":"approvedAddress","in":"path","required":true},{"type":"string","name":"approvalId","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetApprovalTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_balance/{collectionId}/{address}":{"get":{"tags":["Query"],"summary":"Queries an addresses balance for a collection, specified by its ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetBalance","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetBalanceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_challenge_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{challengeTrackerId}/{leafIndex}":{"get":{"tags":["Query"],"summary":"Queries the number of times a given leaf has been used for a given merkle challenge.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetChallengeTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"challengeTrackerId","in":"path","required":true},{"type":"string","name":"leafIndex","in":"path","required":true},{"type":"string","name":"approvalId","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetChallengeTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_collection/{collectionId}":{"get":{"tags":["Query"],"summary":"Queries a collection by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetCollection","parameters":[{"type":"string","name":"collectionId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_dynamic_store/{storeId}":{"get":{"tags":["Query"],"summary":"Queries a dynamic store by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetDynamicStore","parameters":[{"type":"string","name":"storeId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_dynamic_store_value/{storeId}/{address}":{"get":{"tags":["Query"],"summary":"Queries a dynamic store value by store ID and address.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetDynamicStoreValue","parameters":[{"type":"string","name":"storeId","in":"path","required":true},{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_eth_signature_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{approvalId}/{challengeTrackerId}/{signature}":{"get":{"tags":["Query"],"summary":"Queries the number of times a given signature has been used for a given ETH signature challenge.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetETHSignatureTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"approvalId","in":"path","required":true},{"type":"string","name":"challengeTrackerId","in":"path","required":true},{"type":"string","name":"signature","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetETHSignatureTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin15","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin64","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/{mapId}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_Map","parameters":[{"type":"string","name":"mapId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryGetMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/{mapId}/{key}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_MapValue","parameters":[{"type":"string","name":"mapId","in":"path","required":true},{"type":"string","name":"key","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryGetMapValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/wasmx/v1/module_state":{"get":{"tags":["Query"],"summary":"Retrieves the entire wasmx module's state","operationId":"GithubCombitbadgesbitbadgeschainQuery_WasmxModuleState","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.QueryModuleStateResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/wasmx/v1/params":{"get":{"tags":["Query"],"summary":"Retrieves wasmx params","operationId":"GithubCombitbadgesbitbadgeschainQuery_WasmxParams","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.QueryWasmxParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/anchor/locations/{locationId}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_GetValueAtLocation","parameters":[{"type":"string","name":"locationId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.QueryGetValueAtLocationResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/anchor/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_Params","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/wasmx/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin71","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/CreateMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgCreateMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgCreateMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/DeleteMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgDeleteMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgDeleteMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/SetValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValue","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgSetValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgSetValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/UpdateMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgUpdateMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgUpdateMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/UpdateParams":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin66","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/wasmx.Msg/ExecuteContractCompat":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_ExecuteContractCompat","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/wasmx.MsgExecuteContractCompat"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.MsgExecuteContractCompatResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/wasmx.Msg/InstantiateContractCompat":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_InstantiateContractCompat","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/wasmx.MsgInstantiateContractCompat"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.MsgInstantiateContractCompatResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/wasmx.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin72","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/wasmx.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}}},"definitions":{"anchor.AnchorData":{"type":"object","properties":{"creator":{"type":"string"},"data":{"type":"string"},"timestamp":{"type":"string"}}},"anchor.MsgAddCustomData":{"type":"object","properties":{"creator":{"type":"string"},"data":{"type":"string"}}},"anchor.MsgAddCustomDataResponse":{"type":"object","properties":{"locationId":{"description":"ID of the anchor location.","type":"string"}}},"anchor.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"NOTE: All parameters must be supplied.","$ref":"#/definitions/anchor.Params"}}},"anchor.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"anchor.Params":{"description":"Params defines the parameters for the module.","type":"object"},"anchor.QueryGetValueAtLocationResponse":{"type":"object","properties":{"anchorData":{"$ref":"#/definitions/anchor.AnchorData"}}},"anchor.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/anchor.Params"}}},"badges.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"badges.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified token IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.ResetTimeIntervals"}}},"badges.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnBadges"}},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"userRoyalties":{"description":"User level royalties to apply to the transfer.","$ref":"#/definitions/badges.UserRoyalties"}}},"badges.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"badges.ApprovalTracker":{"description":"ApprovalTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.","type":"object","properties":{"amounts":{"description":"Cumulative balances associated with the transfers that have been processed.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"lastUpdatedAt":{"description":"Last updated at time.","type":"string"},"numTransfers":{"description":"The number of transfers that have been processed.","type":"string"}}},"badges.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"},"allowCounterpartyPurge":{"type":"boolean","title":"Allow counterparty to purge this approval if they are the only initiator"},"allowPurgeIfExpired":{"type":"boolean","title":"Allow others to call PurgeApprovals on behalf of this approval owner"}}},"badges.BadgeCollection":{"description":"A BadgeCollection is the top-level object for a collection of tokens. \nIt defines everything about the collection, such as the manager, metadata, etc.\n\nAll collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).\n\nAll collections can have a manager who is responsible for managing the collection and can be granted certain admin\npermissions, such as the ability to mint new tokens.\n\nCertain fields are timeline-based, which means they may have different values at different block heights. \nWe fetch the value according to the current time.\nFor example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.\n\nCollections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.\n\nSee documentation for more details.","type":"object","properties":{"badgeMetadataTimeline":{"description":"The metadata for each token in the collection, also subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"balancesType":{"description":"The type of balances this collection uses (\"Standard\", \"Off-Chain - Indexed\", \"Off-Chain - Non-Indexed\", or \"Non-Public\").","type":"string"},"collectionApprovals":{"description":"Transferability of the collection for collections with standard balances, subject to changes over time.\nOverrides user approvals for a transfer if specified.\nTransfer must satisfy both user and collection-level approvals.\nOnly applicable to on-chain balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.","type":"string"},"collectionMetadataTimeline":{"description":"The metadata for the collection itself, which can vary over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Permissions that define what the manager of the collection can do or not do.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPaths":{"description":"The IBC wrapper (sdk.coin) paths for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPath"}},"createdBy":{"description":"The user or entity who created the collection.","type":"string"},"customDataTimeline":{"description":"An arbitrary field that can store any data, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"description":"The default store of a balance for a user, upon genesis.","$ref":"#/definitions/badges.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.CollectionInvariants"},"isArchivedTimeline":{"description":"Whether the collection is archived or not, subject to changes over time.\nWhen archived, it becomes read-only, and no transactions can be processed until it is unarchived.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"The address of the manager of this collection, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowAddress":{"description":"The generated address of the collection. Also used to escrow Mint balances.","type":"string"},"offChainBalancesMetadataTimeline":{"description":"Metadata for fetching balances for collections with off-chain balances, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"Standards that define how to interpret the fields of the collection, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"validBadgeIds":{"description":"The valid token IDs for this collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.BadgeIdsActionPermission":{"description":"BadgeIdsActionPermission defines the permissions for updating a timeline-based field for specific tokens and specific token ownership times.\nCurrently, this is only used for creating new tokens.\n\nEx: If you want to lock the ability to create new tokens for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.BadgeMetadata":{"description":"This message defines the metadata for specific token IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"badgeIds":{"description":"The token IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Custom data or additional information related to the token metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the token metadata.","type":"string"}}},"badges.BadgeMetadataTimeline":{"description":"BadgeMetadataTimeline defines the metadata for tokens at different timeline times.","type":"object","properties":{"badgeMetadata":{"description":"The token metadata for a specific timeline element.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadata"}},"timelineTimes":{"description":"The timeline times when the token metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.Balance":{"description":"Balance represents the balance of a token for a specific user.\nThe user amounts xAmount of a token for the badgeID specified for the time ranges specified.\n\nExample: User A owns x10 of token IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or badgeIDs have len \u003e 1, then the user owns all token IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the token owned by the user.","type":"string"},"badgeIds":{"description":"The token IDs for which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"ownershipTimes":{"description":"The time ranges during which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"badges.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, badgeIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\nTimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that token ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden at all timelineTimes.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CollectionInvariants":{"description":"CollectionInvariants defines the invariants that apply to a collection.","type":"object","properties":{"noCustomOwnershipTimes":{"description":"If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].\nThis prevents time-based restrictions on token ownership.","type":"boolean"}}},"badges.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"badges.CollectionMetadataTimeline":{"description":"CollectionMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"collectionMetadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/badges.CollectionMetadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BadgeIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action.\n- TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.\n- TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific tokens and what times of the timeline can be updated.\n- BadgeIdsActionPermission: defines when the manager can perform an action for specific tokens\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- timelineTimes: the times when a timeline-based field is a specific value\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a token is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateBadgeMetadata":{"description":"Permissions related to updating token metadata for specific tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdateWithBadgeIdsPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateOffChainBalancesMetadata":{"description":"Permissions related to updating off-chain balances metadata.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateValidBadgeIds":{"description":"Permissions related to creating more tokens for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeIdsActionPermission"}}}},"badges.CosmosCoinWrapperPath":{"type":"object","properties":{"address":{"type":"string"},"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.DenomUnit"}},"symbol":{"type":"string"}}},"badges.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.DenomUnit"}},"symbol":{"type":"string"}}},"badges.CustomDataTimeline":{"description":"CustomDataTimeline defines custom data at different timeline times.","type":"object","properties":{"customData":{"description":"The custom data for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the custom data is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.DenomUnit":{"type":"object","properties":{"decimals":{"type":"string"},"isDefaultDisplay":{"type":"boolean"},"symbol":{"type":"string"}}},"badges.DynamicStore":{"description":"A DynamicStore is a flexible storage object that can store arbitrary data.\nIt is identified by a unique ID assigned by the blockchain, which is a uint64 that increments.\nDynamic stores are created by users and can only be updated or deleted by their creator.\nThey provide a way to store custom data on-chain with proper access control.","type":"object","properties":{"createdBy":{"description":"The address of the creator of this dynamic store.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses (number of uses).","type":"string"},"storeId":{"description":"The unique identifier for this dynamic store. This is assigned by the blockchain.","type":"string"}}},"badges.DynamicStoreChallenge":{"description":"DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.","type":"object","properties":{"storeId":{"description":"The ID of the dynamic store to check.","type":"string"}}},"badges.DynamicStoreValue":{"description":"A DynamicStoreValue stores a usage count for a specific address in a dynamic store.\nThis allows the creator to set usage counts per address that can be decremented on use.","type":"object","properties":{"address":{"description":"The address for which this value is stored.","type":"string"},"storeId":{"description":"The unique identifier for this dynamic store.","type":"string"},"value":{"description":"The usage count (number of times this address can use the approval).","type":"string"}}},"badges.ETHSignatureChallenge":{"description":"ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.\n\nAn ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.\nThe signature scheme is ETHSign(nonce + \"-\" + creatorAddress) and each signature can only be used once.\nAll challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.\nIf you update the challenge ID, then the used signatures tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this ETH signature challenge for tracking the number of uses per signature.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this ETH signature challenge.","type":"string"},"signer":{"description":"The Ethereum address that must sign the nonce for verification.","type":"string"},"uri":{"description":"The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.","type":"string"}}},"badges.ETHSignatureProof":{"description":"ETHSignatureProof represents an Ethereum signature proof for a challenge.","type":"object","properties":{"nonce":{"description":"The nonce that was signed. The signature scheme is ETHSign(nonce + \"-\" + creatorAddress).","type":"string"},"signature":{"description":"The Ethereum signature of the nonce.","type":"string"}}},"badges.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidBadge":{"type":"boolean","title":"Allow override of any valid ID"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementBadgeIdsBy":{"description":"The amount by which to increment token IDs.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/badges.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}}}},"badges.IsArchivedTimeline":{"description":"IsArchivedTimeline defines whether a collection is archived at different timeline times.","type":"object","properties":{"isArchived":{"description":"Indicates whether the collection is archived for a specific timeline element.","type":"boolean"},"timelineTimes":{"description":"The timeline times when the archived status is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}}}},"badges.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified token IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.ResetTimeIntervals"}}},"badges.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"type":"string","title":"Leaf must be signed by. Used to protect against man in the middle attacks.`\nScheme we use is sign(leaf + \"-\" +"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"badges.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"badges.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"badges.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.AddressList"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"badges.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"Token metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionMetadataTimeline":{"description":"Collection metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"Custom data timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.","$ref":"#/definitions/badges.CollectionInvariants"},"isArchivedTimeline":{"description":"isArchived timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"Manager timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"Off-chain balances metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"Standards timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgCreateDynamicStore":{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses (number of uses).","type":"string"}}},"badges.MsgCreateDynamicStoreResponse":{"description":"MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.","type":"object","properties":{"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.MsgDecrementStoreValue":{"description":"MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to decrement the value.","type":"string"},"amount":{"description":"The amount to decrement by.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"setToZeroOnUnderflow":{"description":"If true, set to zero on underflow. If false, throw error on underflow.","type":"boolean"},"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.MsgDecrementStoreValueResponse":{"description":"MsgDecrementStoreValueResponse is the response to MsgDecrementStoreValue.","type":"object"},"badges.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"badges.MsgDeleteDynamicStore":{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store to delete.","type":"string"}}},"badges.MsgDeleteDynamicStoreResponse":{"description":"MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.","type":"object"},"badges.MsgDeleteIncomingApproval":{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgDeleteIncomingApprovalResponse":{"description":"MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.","type":"object"},"badges.MsgDeleteOutgoingApproval":{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgDeleteOutgoingApprovalResponse":{"description":"MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.","type":"object"},"badges.MsgIncrementStoreValue":{"description":"MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to increment the value.","type":"string"},"amount":{"description":"The amount to increment by.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.MsgIncrementStoreValueResponse":{"description":"MsgIncrementStoreValueResponse is the response to MsgIncrementStoreValue.","type":"object"},"badges.MsgPurgeApprovals":{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","type":"object","properties":{"approvalsToPurge":{"description":"Specific approvals to purge. If empty, purges all applicable approvals based on other flags.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ApprovalIdentifierDetails"}},"approverAddress":{"description":"Address of the user whose approvals to purge. If empty, defaults to creator.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"purgeCounterpartyApprovals":{"description":"Whether to purge counterparty approvals (approvals where the creator is the only initiator).","type":"boolean"},"purgeExpired":{"description":"Whether to purge expired approvals (approvals with no future valid transfer times).","type":"boolean"}}},"badges.MsgPurgeApprovalsResponse":{"description":"MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.","type":"object","properties":{"numPurged":{"description":"Number of approvals purged.","type":"string"}}},"badges.MsgSetBadgeMetadata":{"type":"object","title":"MsgSetBadgeMetadata sets the token metadata timeline and canUpdateBadgeMetadata permission","properties":{"badgeMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"canUpdateBadgeMetadata":{"type":"array","title":"Permission to update token metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdateWithBadgeIdsPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgSetBadgeMetadataResponse":{"description":"MsgSetBadgeMetadataResponse is the response to MsgSetBadgeMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetCollectionApprovals":{"type":"object","title":"MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission","properties":{"canUpdateCollectionApprovals":{"type":"array","title":"Permission to update collection approvals","items":{"type":"object","$ref":"#/definitions/badges.CollectionApprovalPermission"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgSetCollectionApprovalsResponse":{"description":"MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetCollectionMetadata":{"type":"object","title":"MsgSetCollectionMetadata sets the collection metadata timeline and canUpdateCollectionMetadata permission","properties":{"canUpdateCollectionMetadata":{"type":"array","title":"Permission to update collection metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgSetCollectionMetadataResponse":{"description":"MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetCustomData":{"type":"object","title":"MsgSetCustomData sets the custom data timeline and canUpdateCustomData permission","properties":{"canUpdateCustomData":{"type":"array","title":"Permission to update custom data timeline","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}}}},"badges.MsgSetCustomDataResponse":{"description":"MsgSetCustomDataResponse is the response to MsgSetCustomData.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetDynamicStoreValue":{"description":"MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to set the value.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"},"value":{"description":"The usage count to set (number of times this address can use the approval).","type":"string"}}},"badges.MsgSetDynamicStoreValueResponse":{"description":"MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.","type":"object"},"badges.MsgSetIncomingApproval":{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","type":"object","properties":{"approval":{"description":"The incoming approval to set.","$ref":"#/definitions/badges.UserIncomingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgSetIncomingApprovalResponse":{"description":"MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.","type":"object"},"badges.MsgSetIsArchived":{"type":"object","title":"MsgSetIsArchived sets the isArchived timeline and canArchiveCollection permission","properties":{"canArchiveCollection":{"type":"array","title":"Permission to archive collection","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}}}},"badges.MsgSetIsArchivedResponse":{"description":"MsgSetIsArchivedResponse is the response to MsgSetIsArchived.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetManager":{"type":"object","title":"MsgSetManager sets the manager timeline and canUpdateManager permission","properties":{"canUpdateManager":{"type":"array","title":"Permission to update manager timeline","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}}}},"badges.MsgSetManagerResponse":{"description":"MsgSetManagerResponse is the response to MsgSetManager.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetOutgoingApproval":{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","type":"object","properties":{"approval":{"description":"The outgoing approval to set.","$ref":"#/definitions/badges.UserOutgoingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgSetOutgoingApprovalResponse":{"description":"MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.","type":"object"},"badges.MsgSetStandards":{"type":"object","title":"MsgSetStandards sets the standards timeline and canUpdateStandards permission","properties":{"canUpdateStandards":{"type":"array","title":"Permission to update standards timeline","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}}}},"badges.MsgSetStandardsResponse":{"description":"MsgSetStandardsResponse is the response to MsgSetStandards.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetValidBadgeIds":{"type":"object","title":"MsgSetValidBadgeIds sets the validBadgeIds and canUpdateValidBadgeIds permission","properties":{"canUpdateValidBadgeIds":{"type":"array","title":"Permission to update valid token IDs","items":{"type":"object","$ref":"#/definitions/badges.BadgeIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgSetValidBadgeIdsResponse":{"description":"MsgSetValidBadgeIdsResponse is the response to MsgSetValidBadgeIds.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgTransferBadges":{"description":"MsgTransferBadges is used to transfer tokens.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Transfer"}}}},"badges.MsgTransferBadgesResponse":{"description":"MsgTransferBadgesResponse is the response to MsgTransferBadges.","type":"object"},"badges.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.CollectionInvariants"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.CollectionInvariants"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgUpdateDynamicStore":{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The new default value for uninitialized addresses (optional, only set if updating).","type":"string"},"storeId":{"description":"ID of the dynamic store to update.","type":"string"}}},"badges.MsgUpdateDynamicStoreResponse":{"description":"MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.","type":"object"},"badges.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/badges.Params"}}},"badges.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"badges.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/badges.UserPermissions"}}},"badges.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"badges.MustOwnBadges":{"description":"MustOwnBadges represents a condition where a user must own specific tokens\nto be approved to transfer.\n\n- collectionId: The ID of the collection for the tokens that must be owned\n- amountRange: The range of amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the tokens.\n- badgeIds: The token IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified tokens; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of amounts the user must own (min to max).","$ref":"#/definitions/badges.UintRange"},"badgeIds":{"description":"The token IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"collectionId":{"description":"The ID of the collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipCheckParty":{"description":"The party to check ownership for. Options are \"initiator\", \"sender\", or \"recipient\". Defaults to \"initiator\" if empty.","type":"string"},"ownershipTimes":{"description":"The time ranges during which the user must own the tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.OffChainBalancesMetadata":{"description":"This message defines the metadata for off-chain balances (if using an off-chain balances type).\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the off-chain balances metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the off-chain balances metadata.","type":"string"}}},"badges.OffChainBalancesMetadataTimeline":{"description":"OffChainBalancesMetadataTimeline defines the metadata for off-chain balances at different timeline times.","type":"object","properties":{"offChainBalancesMetadata":{"description":"The off-chain balances metadata for a specific timeline element.","$ref":"#/definitions/badges.OffChainBalancesMetadata"},"timelineTimes":{"description":"The timeline times when the off-chain balances metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"affiliate_percentage":{"type":"string","title":"affiliate_percentage defines the percentage of the transfer amount that goes to the affiliate"},"allowed_denoms":{"type":"array","title":"allowed_denoms defines the list of denoms that are allowed to be used in coin_transfers","items":{"type":"string"}}}},"badges.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"badgeIdsOverride":{"description":"The IDs to override for the transfer. Only applicable if using this option in precalculation.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"}}},"badges.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/badges.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/badges.PredeterminedOrderCalculationMethod"}}},"badges.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"badges.QueryGetAddressListResponse":{"type":"object","properties":{"list":{"$ref":"#/definitions/badges.AddressList"}}},"badges.QueryGetApprovalTrackerResponse":{"type":"object","properties":{"tracker":{"$ref":"#/definitions/badges.ApprovalTracker"}}},"badges.QueryGetBalanceResponse":{"type":"object","properties":{"balance":{"$ref":"#/definitions/badges.UserBalanceStore"}}},"badges.QueryGetChallengeTrackerResponse":{"type":"object","properties":{"numUsed":{"type":"string"}}},"badges.QueryGetCollectionResponse":{"type":"object","properties":{"collection":{"$ref":"#/definitions/badges.BadgeCollection"}}},"badges.QueryGetDynamicStoreResponse":{"type":"object","properties":{"store":{"$ref":"#/definitions/badges.DynamicStore"}}},"badges.QueryGetDynamicStoreValueResponse":{"type":"object","properties":{"value":{"$ref":"#/definitions/badges.DynamicStoreValue"}}},"badges.QueryGetETHSignatureTrackerResponse":{"type":"object","properties":{"numUsed":{"type":"string"}}},"badges.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/badges.Params"}}},"badges.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"badges.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"badges.StandardsTimeline":{"description":"StandardsTimeline defines the standards used for a collection at different timeline times.","type":"object","properties":{"standards":{"description":"The standards applied to the collection for a specific timeline element.","type":"array","items":{"type":"string"}},"timelineTimes":{"description":"The timeline times when the standards are valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.TimedUpdateWithBadgeIdsPermission":{"description":"TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific tokens.\n\nEx: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.Transfer":{"description":"Transfer defines the details of a transfer of tokens.","type":"object","properties":{"affiliateAddress":{"description":"Affiliate address for the transfer.","type":"string"},"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"ethSignatureProofs":{"description":"The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ETHSignatureProof"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleProof"}},"numAttempts":{"description":"The number of times to attempt approval validation. If 0 / not specified, we default to only one.","type":"string"},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/badges.ApprovalIdentifierDetails"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/badges.PrecalculationOptions"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"badges.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from token IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"badges.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/badges.UserPermissions"}}},"badges.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApprovalPermission"}}}},"badges.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"badges.v10.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"badges.v10.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified badge IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v10.ResetTimeIntervals"}}},"badges.v10.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v10.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v10.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.DynamicStoreChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v10.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.MustOwnBadges"}},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v10.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"userRoyalties":{"description":"User level royalties to apply to the transfer.","$ref":"#/definitions/badges.v10.UserRoyalties"}}},"badges.v10.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"badges.v10.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"},"allowCounterpartyPurge":{"type":"boolean","title":"Allow counterparty to purge this approval if they are the only initiator"},"allowPurgeIfExpired":{"type":"boolean","title":"Allow others to call PurgeApprovals on behalf of this approval owner"}}},"badges.v10.BadgeIdsActionPermission":{"description":"BadgeIdsActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.\nCurrently, this is only used for creating new badges.\n\nEx: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.BadgeMetadata":{"description":"This message defines the metadata for specific badge IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"badgeIds":{"description":"The badge IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"customData":{"description":"Custom data or additional information related to the badge metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the badge metadata.","type":"string"}}},"badges.v10.BadgeMetadataTimeline":{"description":"BadgeMetadataTimeline defines the metadata for badges at different timeline times.","type":"object","properties":{"badgeMetadata":{"description":"The badge metadata for a specific timeline element.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.BadgeMetadata"}},"timelineTimes":{"description":"The timeline times when the badge metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.Balance":{"description":"Balance represents the balance of a badge for a specific user.\nThe user amounts xAmount of a badge for the badgeID specified for the time ranges specified.\n\nExample: User A owns x10 of badge IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or badgeIDs have len \u003e 1, then the user owns all badge IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the badge owned by the user.","type":"string"},"badgeIds":{"description":"The badge IDs for which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"ownershipTimes":{"description":"The time ranges during which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"badges.v10.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v10.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v10.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, badgeIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\nTimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden at all timelineTimes.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"badges.v10.CollectionMetadataTimeline":{"description":"CollectionMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"collectionMetadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/badges.v10.CollectionMetadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BadgeIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action.\n- TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.\n- TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.\n- BadgeIdsActionPermission: defines when the manager can perform an action for specific badges\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- timelineTimes: the times when a timeline-based field is a specific value\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a badge is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdatePermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.ActionPermission"}},"canUpdateBadgeMetadata":{"description":"Permissions related to updating badge metadata for specific badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdateWithBadgeIdsPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdatePermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdatePermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdatePermission"}},"canUpdateOffChainBalancesMetadata":{"description":"Permissions related to updating off-chain balances metadata.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdatePermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdatePermission"}},"canUpdateValidBadgeIds":{"description":"Permissions related to creating more badges for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.BadgeIdsActionPermission"}}}},"badges.v10.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.Balance"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.DenomUnit"}},"symbol":{"type":"string"}}},"badges.v10.CustomDataTimeline":{"description":"CustomDataTimeline defines custom data at different timeline times.","type":"object","properties":{"customData":{"description":"The custom data for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the custom data is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.DenomUnit":{"type":"object","properties":{"decimals":{"type":"string"},"isDefaultDisplay":{"type":"boolean"},"symbol":{"type":"string"}}},"badges.v10.DynamicStoreChallenge":{"description":"DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.","type":"object","properties":{"storeId":{"description":"The ID of the dynamic store to check.","type":"string"}}},"badges.v10.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v10.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v10.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.DynamicStoreChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v10.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v10.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v10.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidBadge":{"type":"boolean","title":"Allow override of any valid badge"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementBadgeIdsBy":{"description":"The amount by which to increment badge IDs.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/badges.v10.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.Balance"}}}},"badges.v10.IsArchivedTimeline":{"description":"IsArchivedTimeline defines whether a collection is archived at different timeline times.","type":"object","properties":{"isArchived":{"description":"Indicates whether the collection is archived for a specific timeline element.","type":"boolean"},"timelineTimes":{"description":"The timeline times when the archived status is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.Balance"}}}},"badges.v10.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified badge IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v10.ResetTimeIntervals"}}},"badges.v10.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"type":"string","title":"Leaf must be signed by. Used to protect against man in the middle attacks.`\nScheme we use is sign(leaf + \"-\" +"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"badges.v10.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"badges.v10.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"badges.v10.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.AddressList"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v10.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"badges.v10.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"Badge metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CollectionApproval"}},"collectionMetadataTimeline":{"description":"Collection metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/badges.v10.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"Custom data timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v10.UserBalanceStore"},"isArchivedTimeline":{"description":"isArchived timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.IsArchivedTimeline"}},"managerTimeline":{"description":"Manager timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"Off-chain balances metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"Standards timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.StandardsTimeline"}},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v10.MsgCreateDynamicStore":{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses.","type":"boolean"}}},"badges.v10.MsgCreateDynamicStoreResponse":{"description":"MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.","type":"object","properties":{"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.v10.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v10.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"badges.v10.MsgDeleteDynamicStore":{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store to delete.","type":"string"}}},"badges.v10.MsgDeleteDynamicStoreResponse":{"description":"MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.","type":"object"},"badges.v10.MsgDeleteIncomingApproval":{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v10.MsgDeleteIncomingApprovalResponse":{"description":"MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.","type":"object"},"badges.v10.MsgDeleteOutgoingApproval":{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v10.MsgDeleteOutgoingApprovalResponse":{"description":"MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.","type":"object"},"badges.v10.MsgPurgeApprovals":{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","type":"object","properties":{"approvalsToPurge":{"description":"Specific approvals to purge. If empty, purges all applicable approvals based on other flags.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.ApprovalIdentifierDetails"}},"approverAddress":{"description":"Address of the user whose approvals to purge. If empty, defaults to creator.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"purgeCounterpartyApprovals":{"description":"Whether to purge counterparty approvals (approvals where the creator is the only initiator).","type":"boolean"},"purgeExpired":{"description":"Whether to purge expired approvals (approvals with no future valid transfer times).","type":"boolean"}}},"badges.v10.MsgPurgeApprovalsResponse":{"description":"MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.","type":"object","properties":{"numPurged":{"description":"Number of approvals purged.","type":"string"}}},"badges.v10.MsgSetBadgeMetadata":{"type":"object","title":"MsgSetBadgeMetadata sets the badge metadata timeline and canUpdateBadgeMetadata permission","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.BadgeMetadataTimeline"}},"canUpdateBadgeMetadata":{"type":"array","title":"Permission to update badge metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdateWithBadgeIdsPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v10.MsgSetBadgeMetadataResponse":{"description":"MsgSetBadgeMetadataResponse is the response to MsgSetBadgeMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v10.MsgSetCollectionApprovals":{"type":"object","title":"MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission","properties":{"canUpdateCollectionApprovals":{"type":"array","title":"Permission to update collection approvals","items":{"type":"object","$ref":"#/definitions/badges.v10.CollectionApprovalPermission"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CollectionApproval"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v10.MsgSetCollectionApprovalsResponse":{"description":"MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v10.MsgSetCollectionMetadata":{"type":"object","title":"MsgSetCollectionMetadata sets the collection metadata timeline and canUpdateCollectionMetadata permission","properties":{"canUpdateCollectionMetadata":{"type":"array","title":"Permission to update collection metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CollectionMetadataTimeline"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v10.MsgSetCollectionMetadataResponse":{"description":"MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v10.MsgSetCustomData":{"type":"object","title":"MsgSetCustomData sets the custom data timeline and canUpdateCustomData permission","properties":{"canUpdateCustomData":{"type":"array","title":"Permission to update custom data timeline","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CustomDataTimeline"}}}},"badges.v10.MsgSetCustomDataResponse":{"description":"MsgSetCustomDataResponse is the response to MsgSetCustomData.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v10.MsgSetDynamicStoreValue":{"description":"MsgSetDynamicStoreValue is used to set a 0/1 flag for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to set the value.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"},"value":{"description":"The boolean value to set (true = 1, false = 0).","type":"boolean"}}},"badges.v10.MsgSetDynamicStoreValueResponse":{"description":"MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.","type":"object"},"badges.v10.MsgSetIncomingApproval":{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","type":"object","properties":{"approval":{"description":"The incoming approval to set.","$ref":"#/definitions/badges.v10.UserIncomingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v10.MsgSetIncomingApprovalResponse":{"description":"MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.","type":"object"},"badges.v10.MsgSetIsArchived":{"type":"object","title":"MsgSetIsArchived sets the isArchived timeline and canArchiveCollection permission","properties":{"canArchiveCollection":{"type":"array","title":"Permission to archive collection","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.IsArchivedTimeline"}}}},"badges.v10.MsgSetIsArchivedResponse":{"description":"MsgSetIsArchivedResponse is the response to MsgSetIsArchived.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v10.MsgSetManager":{"type":"object","title":"MsgSetManager sets the manager timeline and canUpdateManager permission","properties":{"canUpdateManager":{"type":"array","title":"Permission to update manager timeline","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.ManagerTimeline"}}}},"badges.v10.MsgSetManagerResponse":{"description":"MsgSetManagerResponse is the response to MsgSetManager.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v10.MsgSetOutgoingApproval":{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","type":"object","properties":{"approval":{"description":"The outgoing approval to set.","$ref":"#/definitions/badges.v10.UserOutgoingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v10.MsgSetOutgoingApprovalResponse":{"description":"MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.","type":"object"},"badges.v10.MsgSetStandards":{"type":"object","title":"MsgSetStandards sets the standards timeline and canUpdateStandards permission","properties":{"canUpdateStandards":{"type":"array","title":"Permission to update standards timeline","items":{"type":"object","$ref":"#/definitions/badges.v10.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.StandardsTimeline"}}}},"badges.v10.MsgSetStandardsResponse":{"description":"MsgSetStandardsResponse is the response to MsgSetStandards.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v10.MsgSetValidBadgeIds":{"type":"object","title":"MsgSetValidBadgeIds sets the validBadgeIds and canUpdateValidBadgeIds permission","properties":{"canUpdateValidBadgeIds":{"type":"array","title":"Permission to update valid badge IDs","items":{"type":"object","$ref":"#/definitions/badges.v10.BadgeIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.MsgSetValidBadgeIdsResponse":{"description":"MsgSetValidBadgeIdsResponse is the response to MsgSetValidBadgeIds.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v10.MsgTransferBadges":{"description":"MsgTransferBadges is used to transfer badges.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.Transfer"}}}},"badges.v10.MsgTransferBadgesResponse":{"description":"MsgTransferBadgesResponse is the response to MsgTransferBadges.","type":"object"},"badges.v10.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v10.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v10.UserBalanceStore"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v10.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v10.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CustomDataTimeline"}},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v10.MsgUpdateDynamicStore":{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The new default value for uninitialized addresses (optional, only set if updating).","type":"boolean"},"storeId":{"description":"ID of the dynamic store to update.","type":"string"}}},"badges.v10.MsgUpdateDynamicStoreResponse":{"description":"MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.","type":"object"},"badges.v10.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/badges.v10.Params"}}},"badges.v10.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"badges.v10.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/badges.v10.UserPermissions"}}},"badges.v10.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"badges.v10.MustOwnBadges":{"description":"MustOwnBadges represents a condition where a user must own specific badges\nto be approved to transfer.\n\n- collectionId: The ID of the badge collection for the badges that must be owned\n- amountRange: The range of badge amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the badges.\n- badgeIds: The badge IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified badges; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of badge amounts the user must own (min to max).","$ref":"#/definitions/badges.v10.UintRange"},"badgeIds":{"description":"The badge IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"collectionId":{"description":"The ID of the badge collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified badges; else, must meet requirements for any single badge.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipTimes":{"description":"The time ranges during which the user must own the badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.OffChainBalancesMetadata":{"description":"This message defines the metadata for off-chain balances (if using an off-chain balances type).\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the off-chain balances metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the off-chain balances metadata.","type":"string"}}},"badges.v10.OffChainBalancesMetadataTimeline":{"description":"OffChainBalancesMetadataTimeline defines the metadata for off-chain balances at different timeline times.","type":"object","properties":{"offChainBalancesMetadata":{"description":"The off-chain balances metadata for a specific timeline element.","$ref":"#/definitions/badges.v10.OffChainBalancesMetadata"},"timelineTimes":{"description":"The timeline times when the off-chain balances metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v10.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v10.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.DynamicStoreChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v10.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v10.PredeterminedBalances"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v10.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"allowed_denoms":{"type":"array","title":"allowed_denoms defines the list of denoms that are allowed to be used in coin_transfers","items":{"type":"string"}}}},"badges.v10.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"badgeIdsOverride":{"description":"The badgeIdsOverride to use for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"}}},"badges.v10.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/badges.v10.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/badges.v10.PredeterminedOrderCalculationMethod"}}},"badges.v10.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"badges.v10.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"badges.v10.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"badges.v10.StandardsTimeline":{"description":"StandardsTimeline defines the standards used for a collection at different timeline times.","type":"object","properties":{"standards":{"description":"The standards applied to the collection for a specific timeline element.","type":"array","items":{"type":"string"}},"timelineTimes":{"description":"The timeline times when the standards are valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.TimedUpdateWithBadgeIdsPermission":{"description":"TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.\n\nEx: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.Transfer":{"description":"Transfer defines the details of a transfer of badges.","type":"object","properties":{"affiliateAddress":{"description":"Affiliate address for the transfer.","type":"string"},"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.Balance"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.MerkleProof"}},"numAttempts":{"description":"The number of times to attempt approval validation. If 0 / not specified, we default to only one.","type":"string"},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/badges.v10.ApprovalIdentifierDetails"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/badges.v10.PrecalculationOptions"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"badges.v10.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from badge IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"badges.v10.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/badges.v10.UserPermissions"}}},"badges.v10.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v10.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v10.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v10.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v10.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UintRange"}}}},"badges.v10.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v10.UserOutgoingApprovalPermission"}}}},"badges.v10.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"badges.v11.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"badges.v11.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified badge IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v11.ResetTimeIntervals"}}},"badges.v11.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v11.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v11.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.DynamicStoreChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v11.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.MustOwnBadges"}},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v11.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"userRoyalties":{"description":"User level royalties to apply to the transfer.","$ref":"#/definitions/badges.v11.UserRoyalties"}}},"badges.v11.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"badges.v11.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"},"allowCounterpartyPurge":{"type":"boolean","title":"Allow counterparty to purge this approval if they are the only initiator"},"allowPurgeIfExpired":{"type":"boolean","title":"Allow others to call PurgeApprovals on behalf of this approval owner"}}},"badges.v11.BadgeIdsActionPermission":{"description":"BadgeIdsActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.\nCurrently, this is only used for creating new badges.\n\nEx: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.BadgeMetadata":{"description":"This message defines the metadata for specific badge IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"badgeIds":{"description":"The badge IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"customData":{"description":"Custom data or additional information related to the badge metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the badge metadata.","type":"string"}}},"badges.v11.BadgeMetadataTimeline":{"description":"BadgeMetadataTimeline defines the metadata for badges at different timeline times.","type":"object","properties":{"badgeMetadata":{"description":"The badge metadata for a specific timeline element.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.BadgeMetadata"}},"timelineTimes":{"description":"The timeline times when the badge metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.Balance":{"description":"Balance represents the balance of a badge for a specific user.\nThe user amounts xAmount of a badge for the badgeID specified for the time ranges specified.\n\nExample: User A owns x10 of badge IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or badgeIDs have len \u003e 1, then the user owns all badge IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the badge owned by the user.","type":"string"},"badgeIds":{"description":"The badge IDs for which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"ownershipTimes":{"description":"The time ranges during which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"badges.v11.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v11.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v11.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, badgeIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\nTimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden at all timelineTimes.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"badges.v11.CollectionMetadataTimeline":{"description":"CollectionMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"collectionMetadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/badges.v11.CollectionMetadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BadgeIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action.\n- TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.\n- TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.\n- BadgeIdsActionPermission: defines when the manager can perform an action for specific badges\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- timelineTimes: the times when a timeline-based field is a specific value\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a badge is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdatePermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.ActionPermission"}},"canUpdateBadgeMetadata":{"description":"Permissions related to updating badge metadata for specific badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdateWithBadgeIdsPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdatePermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdatePermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdatePermission"}},"canUpdateOffChainBalancesMetadata":{"description":"Permissions related to updating off-chain balances metadata.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdatePermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdatePermission"}},"canUpdateValidBadgeIds":{"description":"Permissions related to creating more badges for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.BadgeIdsActionPermission"}}}},"badges.v11.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.Balance"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.DenomUnit"}},"symbol":{"type":"string"}}},"badges.v11.CustomDataTimeline":{"description":"CustomDataTimeline defines custom data at different timeline times.","type":"object","properties":{"customData":{"description":"The custom data for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the custom data is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.DenomUnit":{"type":"object","properties":{"decimals":{"type":"string"},"isDefaultDisplay":{"type":"boolean"},"symbol":{"type":"string"}}},"badges.v11.DynamicStoreChallenge":{"description":"DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.","type":"object","properties":{"storeId":{"description":"The ID of the dynamic store to check.","type":"string"}}},"badges.v11.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v11.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v11.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.DynamicStoreChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v11.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v11.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v11.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidBadge":{"type":"boolean","title":"Allow override of any valid badge"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementBadgeIdsBy":{"description":"The amount by which to increment badge IDs.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/badges.v11.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.Balance"}}}},"badges.v11.IsArchivedTimeline":{"description":"IsArchivedTimeline defines whether a collection is archived at different timeline times.","type":"object","properties":{"isArchived":{"description":"Indicates whether the collection is archived for a specific timeline element.","type":"boolean"},"timelineTimes":{"description":"The timeline times when the archived status is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.Balance"}}}},"badges.v11.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified badge IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v11.ResetTimeIntervals"}}},"badges.v11.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"type":"string","title":"Leaf must be signed by. Used to protect against man in the middle attacks.`\nScheme we use is sign(leaf + \"-\" +"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"badges.v11.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"badges.v11.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"badges.v11.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.AddressList"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v11.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"badges.v11.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"Badge metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CollectionApproval"}},"collectionMetadataTimeline":{"description":"Collection metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/badges.v11.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"Custom data timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v11.UserBalanceStore"},"isArchivedTimeline":{"description":"isArchived timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.IsArchivedTimeline"}},"managerTimeline":{"description":"Manager timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"Off-chain balances metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"Standards timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.StandardsTimeline"}},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v11.MsgCreateDynamicStore":{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses.","type":"boolean"}}},"badges.v11.MsgCreateDynamicStoreResponse":{"description":"MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.","type":"object","properties":{"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.v11.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v11.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"badges.v11.MsgDeleteDynamicStore":{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store to delete.","type":"string"}}},"badges.v11.MsgDeleteDynamicStoreResponse":{"description":"MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.","type":"object"},"badges.v11.MsgDeleteIncomingApproval":{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v11.MsgDeleteIncomingApprovalResponse":{"description":"MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.","type":"object"},"badges.v11.MsgDeleteOutgoingApproval":{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v11.MsgDeleteOutgoingApprovalResponse":{"description":"MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.","type":"object"},"badges.v11.MsgPurgeApprovals":{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","type":"object","properties":{"approvalsToPurge":{"description":"Specific approvals to purge. If empty, purges all applicable approvals based on other flags.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.ApprovalIdentifierDetails"}},"approverAddress":{"description":"Address of the user whose approvals to purge. If empty, defaults to creator.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"purgeCounterpartyApprovals":{"description":"Whether to purge counterparty approvals (approvals where the creator is the only initiator).","type":"boolean"},"purgeExpired":{"description":"Whether to purge expired approvals (approvals with no future valid transfer times).","type":"boolean"}}},"badges.v11.MsgPurgeApprovalsResponse":{"description":"MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.","type":"object","properties":{"numPurged":{"description":"Number of approvals purged.","type":"string"}}},"badges.v11.MsgSetBadgeMetadata":{"type":"object","title":"MsgSetBadgeMetadata sets the badge metadata timeline and canUpdateBadgeMetadata permission","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.BadgeMetadataTimeline"}},"canUpdateBadgeMetadata":{"type":"array","title":"Permission to update badge metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdateWithBadgeIdsPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v11.MsgSetBadgeMetadataResponse":{"description":"MsgSetBadgeMetadataResponse is the response to MsgSetBadgeMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v11.MsgSetCollectionApprovals":{"type":"object","title":"MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission","properties":{"canUpdateCollectionApprovals":{"type":"array","title":"Permission to update collection approvals","items":{"type":"object","$ref":"#/definitions/badges.v11.CollectionApprovalPermission"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CollectionApproval"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v11.MsgSetCollectionApprovalsResponse":{"description":"MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v11.MsgSetCollectionMetadata":{"type":"object","title":"MsgSetCollectionMetadata sets the collection metadata timeline and canUpdateCollectionMetadata permission","properties":{"canUpdateCollectionMetadata":{"type":"array","title":"Permission to update collection metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CollectionMetadataTimeline"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v11.MsgSetCollectionMetadataResponse":{"description":"MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v11.MsgSetCustomData":{"type":"object","title":"MsgSetCustomData sets the custom data timeline and canUpdateCustomData permission","properties":{"canUpdateCustomData":{"type":"array","title":"Permission to update custom data timeline","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CustomDataTimeline"}}}},"badges.v11.MsgSetCustomDataResponse":{"description":"MsgSetCustomDataResponse is the response to MsgSetCustomData.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v11.MsgSetDynamicStoreValue":{"description":"MsgSetDynamicStoreValue is used to set a 0/1 flag for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to set the value.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"},"value":{"description":"The boolean value to set (true = 1, false = 0).","type":"boolean"}}},"badges.v11.MsgSetDynamicStoreValueResponse":{"description":"MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.","type":"object"},"badges.v11.MsgSetIncomingApproval":{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","type":"object","properties":{"approval":{"description":"The incoming approval to set.","$ref":"#/definitions/badges.v11.UserIncomingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v11.MsgSetIncomingApprovalResponse":{"description":"MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.","type":"object"},"badges.v11.MsgSetIsArchived":{"type":"object","title":"MsgSetIsArchived sets the isArchived timeline and canArchiveCollection permission","properties":{"canArchiveCollection":{"type":"array","title":"Permission to archive collection","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.IsArchivedTimeline"}}}},"badges.v11.MsgSetIsArchivedResponse":{"description":"MsgSetIsArchivedResponse is the response to MsgSetIsArchived.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v11.MsgSetManager":{"type":"object","title":"MsgSetManager sets the manager timeline and canUpdateManager permission","properties":{"canUpdateManager":{"type":"array","title":"Permission to update manager timeline","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.ManagerTimeline"}}}},"badges.v11.MsgSetManagerResponse":{"description":"MsgSetManagerResponse is the response to MsgSetManager.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v11.MsgSetOutgoingApproval":{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","type":"object","properties":{"approval":{"description":"The outgoing approval to set.","$ref":"#/definitions/badges.v11.UserOutgoingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v11.MsgSetOutgoingApprovalResponse":{"description":"MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.","type":"object"},"badges.v11.MsgSetStandards":{"type":"object","title":"MsgSetStandards sets the standards timeline and canUpdateStandards permission","properties":{"canUpdateStandards":{"type":"array","title":"Permission to update standards timeline","items":{"type":"object","$ref":"#/definitions/badges.v11.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.StandardsTimeline"}}}},"badges.v11.MsgSetStandardsResponse":{"description":"MsgSetStandardsResponse is the response to MsgSetStandards.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v11.MsgSetValidBadgeIds":{"type":"object","title":"MsgSetValidBadgeIds sets the validBadgeIds and canUpdateValidBadgeIds permission","properties":{"canUpdateValidBadgeIds":{"type":"array","title":"Permission to update valid badge IDs","items":{"type":"object","$ref":"#/definitions/badges.v11.BadgeIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.MsgSetValidBadgeIdsResponse":{"description":"MsgSetValidBadgeIdsResponse is the response to MsgSetValidBadgeIds.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v11.MsgTransferBadges":{"description":"MsgTransferBadges is used to transfer badges.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.Transfer"}}}},"badges.v11.MsgTransferBadgesResponse":{"description":"MsgTransferBadgesResponse is the response to MsgTransferBadges.","type":"object"},"badges.v11.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v11.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v11.UserBalanceStore"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v11.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v11.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CustomDataTimeline"}},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v11.MsgUpdateDynamicStore":{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The new default value for uninitialized addresses (optional, only set if updating).","type":"boolean"},"storeId":{"description":"ID of the dynamic store to update.","type":"string"}}},"badges.v11.MsgUpdateDynamicStoreResponse":{"description":"MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.","type":"object"},"badges.v11.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/badges.v11.Params"}}},"badges.v11.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"badges.v11.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/badges.v11.UserPermissions"}}},"badges.v11.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"badges.v11.MustOwnBadges":{"description":"MustOwnBadges represents a condition where a user must own specific badges\nto be approved to transfer.\n\n- collectionId: The ID of the badge collection for the badges that must be owned\n- amountRange: The range of badge amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the badges.\n- badgeIds: The badge IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified badges; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of badge amounts the user must own (min to max).","$ref":"#/definitions/badges.v11.UintRange"},"badgeIds":{"description":"The badge IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"collectionId":{"description":"The ID of the badge collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified badges; else, must meet requirements for any single badge.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipTimes":{"description":"The time ranges during which the user must own the badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.OffChainBalancesMetadata":{"description":"This message defines the metadata for off-chain balances (if using an off-chain balances type).\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the off-chain balances metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the off-chain balances metadata.","type":"string"}}},"badges.v11.OffChainBalancesMetadataTimeline":{"description":"OffChainBalancesMetadataTimeline defines the metadata for off-chain balances at different timeline times.","type":"object","properties":{"offChainBalancesMetadata":{"description":"The off-chain balances metadata for a specific timeline element.","$ref":"#/definitions/badges.v11.OffChainBalancesMetadata"},"timelineTimes":{"description":"The timeline times when the off-chain balances metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v11.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v11.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.DynamicStoreChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v11.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v11.PredeterminedBalances"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v11.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"allowed_denoms":{"type":"array","title":"allowed_denoms defines the list of denoms that are allowed to be used in coin_transfers","items":{"type":"string"}}}},"badges.v11.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"badgeIdsOverride":{"description":"The badgeIdsOverride to use for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"}}},"badges.v11.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/badges.v11.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/badges.v11.PredeterminedOrderCalculationMethod"}}},"badges.v11.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"badges.v11.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"badges.v11.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"badges.v11.StandardsTimeline":{"description":"StandardsTimeline defines the standards used for a collection at different timeline times.","type":"object","properties":{"standards":{"description":"The standards applied to the collection for a specific timeline element.","type":"array","items":{"type":"string"}},"timelineTimes":{"description":"The timeline times when the standards are valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.TimedUpdateWithBadgeIdsPermission":{"description":"TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.\n\nEx: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.Transfer":{"description":"Transfer defines the details of a transfer of badges.","type":"object","properties":{"affiliateAddress":{"description":"Affiliate address for the transfer.","type":"string"},"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.Balance"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.MerkleProof"}},"numAttempts":{"description":"The number of times to attempt approval validation. If 0 / not specified, we default to only one.","type":"string"},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/badges.v11.ApprovalIdentifierDetails"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/badges.v11.PrecalculationOptions"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"badges.v11.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from badge IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"badges.v11.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/badges.v11.UserPermissions"}}},"badges.v11.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v11.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v11.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v11.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v11.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UintRange"}}}},"badges.v11.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v11.UserOutgoingApprovalPermission"}}}},"badges.v11.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"badges.v12.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"badges.v12.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified badge IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v12.ResetTimeIntervals"}}},"badges.v12.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v12.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v12.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v12.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.MustOwnBadges"}},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v12.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"userRoyalties":{"description":"User level royalties to apply to the transfer.","$ref":"#/definitions/badges.v12.UserRoyalties"}}},"badges.v12.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"badges.v12.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"},"allowCounterpartyPurge":{"type":"boolean","title":"Allow counterparty to purge this approval if they are the only initiator"},"allowPurgeIfExpired":{"type":"boolean","title":"Allow others to call PurgeApprovals on behalf of this approval owner"}}},"badges.v12.BadgeIdsActionPermission":{"description":"BadgeIdsActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.\nCurrently, this is only used for creating new badges.\n\nEx: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.BadgeMetadata":{"description":"This message defines the metadata for specific badge IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"badgeIds":{"description":"The badge IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"customData":{"description":"Custom data or additional information related to the badge metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the badge metadata.","type":"string"}}},"badges.v12.BadgeMetadataTimeline":{"description":"BadgeMetadataTimeline defines the metadata for badges at different timeline times.","type":"object","properties":{"badgeMetadata":{"description":"The badge metadata for a specific timeline element.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.BadgeMetadata"}},"timelineTimes":{"description":"The timeline times when the badge metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.Balance":{"description":"Balance represents the balance of a badge for a specific user.\nThe user amounts xAmount of a badge for the badgeID specified for the time ranges specified.\n\nExample: User A owns x10 of badge IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or badgeIDs have len \u003e 1, then the user owns all badge IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the badge owned by the user.","type":"string"},"badgeIds":{"description":"The badge IDs for which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"ownershipTimes":{"description":"The time ranges during which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"badges.v12.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v12.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v12.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, badgeIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\nTimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden at all timelineTimes.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.CollectionInvariants":{"description":"CollectionInvariants defines the invariants that apply to a collection.","type":"object","properties":{"noCustomOwnershipTimes":{"description":"If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].\nThis prevents time-based restrictions on badge ownership.","type":"boolean"}}},"badges.v12.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"badges.v12.CollectionMetadataTimeline":{"description":"CollectionMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"collectionMetadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/badges.v12.CollectionMetadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BadgeIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action.\n- TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.\n- TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.\n- BadgeIdsActionPermission: defines when the manager can perform an action for specific badges\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- timelineTimes: the times when a timeline-based field is a specific value\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a badge is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdatePermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ActionPermission"}},"canUpdateBadgeMetadata":{"description":"Permissions related to updating badge metadata for specific badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdateWithBadgeIdsPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdatePermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdatePermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdatePermission"}},"canUpdateOffChainBalancesMetadata":{"description":"Permissions related to updating off-chain balances metadata.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdatePermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdatePermission"}},"canUpdateValidBadgeIds":{"description":"Permissions related to creating more badges for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.BadgeIdsActionPermission"}}}},"badges.v12.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.Balance"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.DenomUnit"}},"symbol":{"type":"string"}}},"badges.v12.CustomDataTimeline":{"description":"CustomDataTimeline defines custom data at different timeline times.","type":"object","properties":{"customData":{"description":"The custom data for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the custom data is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.DenomUnit":{"type":"object","properties":{"decimals":{"type":"string"},"isDefaultDisplay":{"type":"boolean"},"symbol":{"type":"string"}}},"badges.v12.DynamicStoreChallenge":{"description":"DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.","type":"object","properties":{"storeId":{"description":"The ID of the dynamic store to check.","type":"string"}}},"badges.v12.ETHSignatureChallenge":{"description":"ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.\n\nAn ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.\nThe signature scheme is ETHSign(nonce + \"-\" + creatorAddress) and each signature can only be used once.\nAll challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.\nIf you update the challenge ID, then the used signatures tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this ETH signature challenge for tracking the number of uses per signature.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this ETH signature challenge.","type":"string"},"signer":{"description":"The Ethereum address that must sign the nonce for verification.","type":"string"},"uri":{"description":"The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.","type":"string"}}},"badges.v12.ETHSignatureProof":{"description":"ETHSignatureProof represents an Ethereum signature proof for a challenge.","type":"object","properties":{"nonce":{"description":"The nonce that was signed. The signature scheme is ETHSign(nonce + \"-\" + creatorAddress).","type":"string"},"signature":{"description":"The Ethereum signature of the nonce.","type":"string"}}},"badges.v12.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v12.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v12.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v12.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v12.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v12.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidBadge":{"type":"boolean","title":"Allow override of any valid badge"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementBadgeIdsBy":{"description":"The amount by which to increment badge IDs.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/badges.v12.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.Balance"}}}},"badges.v12.IsArchivedTimeline":{"description":"IsArchivedTimeline defines whether a collection is archived at different timeline times.","type":"object","properties":{"isArchived":{"description":"Indicates whether the collection is archived for a specific timeline element.","type":"boolean"},"timelineTimes":{"description":"The timeline times when the archived status is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.Balance"}}}},"badges.v12.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified badge IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v12.ResetTimeIntervals"}}},"badges.v12.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"type":"string","title":"Leaf must be signed by. Used to protect against man in the middle attacks.`\nScheme we use is sign(leaf + \"-\" +"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"badges.v12.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"badges.v12.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"badges.v12.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.AddressList"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v12.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"badges.v12.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"Badge metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CollectionApproval"}},"collectionMetadataTimeline":{"description":"Collection metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/badges.v12.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"Custom data timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v12.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.","$ref":"#/definitions/badges.v12.CollectionInvariants"},"isArchivedTimeline":{"description":"isArchived timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.IsArchivedTimeline"}},"managerTimeline":{"description":"Manager timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"Off-chain balances metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"Standards timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.StandardsTimeline"}},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v12.MsgCreateDynamicStore":{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses (number of uses).","type":"string"}}},"badges.v12.MsgCreateDynamicStoreResponse":{"description":"MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.","type":"object","properties":{"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.v12.MsgDecrementStoreValue":{"description":"MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to decrement the value.","type":"string"},"amount":{"description":"The amount to decrement by.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"setToZeroOnUnderflow":{"description":"If true, set to zero on underflow. If false, throw error on underflow.","type":"boolean"},"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.v12.MsgDecrementStoreValueResponse":{"description":"MsgDecrementStoreValueResponse is the response to MsgDecrementStoreValue.","type":"object"},"badges.v12.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v12.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"badges.v12.MsgDeleteDynamicStore":{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store to delete.","type":"string"}}},"badges.v12.MsgDeleteDynamicStoreResponse":{"description":"MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.","type":"object"},"badges.v12.MsgDeleteIncomingApproval":{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v12.MsgDeleteIncomingApprovalResponse":{"description":"MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.","type":"object"},"badges.v12.MsgDeleteOutgoingApproval":{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v12.MsgDeleteOutgoingApprovalResponse":{"description":"MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.","type":"object"},"badges.v12.MsgIncrementStoreValue":{"description":"MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to increment the value.","type":"string"},"amount":{"description":"The amount to increment by.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.v12.MsgIncrementStoreValueResponse":{"description":"MsgIncrementStoreValueResponse is the response to MsgIncrementStoreValue.","type":"object"},"badges.v12.MsgPurgeApprovals":{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","type":"object","properties":{"approvalsToPurge":{"description":"Specific approvals to purge. If empty, purges all applicable approvals based on other flags.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ApprovalIdentifierDetails"}},"approverAddress":{"description":"Address of the user whose approvals to purge. If empty, defaults to creator.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"purgeCounterpartyApprovals":{"description":"Whether to purge counterparty approvals (approvals where the creator is the only initiator).","type":"boolean"},"purgeExpired":{"description":"Whether to purge expired approvals (approvals with no future valid transfer times).","type":"boolean"}}},"badges.v12.MsgPurgeApprovalsResponse":{"description":"MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.","type":"object","properties":{"numPurged":{"description":"Number of approvals purged.","type":"string"}}},"badges.v12.MsgSetBadgeMetadata":{"type":"object","title":"MsgSetBadgeMetadata sets the badge metadata timeline and canUpdateBadgeMetadata permission","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.BadgeMetadataTimeline"}},"canUpdateBadgeMetadata":{"type":"array","title":"Permission to update badge metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdateWithBadgeIdsPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v12.MsgSetBadgeMetadataResponse":{"description":"MsgSetBadgeMetadataResponse is the response to MsgSetBadgeMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v12.MsgSetCollectionApprovals":{"type":"object","title":"MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission","properties":{"canUpdateCollectionApprovals":{"type":"array","title":"Permission to update collection approvals","items":{"type":"object","$ref":"#/definitions/badges.v12.CollectionApprovalPermission"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CollectionApproval"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v12.MsgSetCollectionApprovalsResponse":{"description":"MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v12.MsgSetCollectionMetadata":{"type":"object","title":"MsgSetCollectionMetadata sets the collection metadata timeline and canUpdateCollectionMetadata permission","properties":{"canUpdateCollectionMetadata":{"type":"array","title":"Permission to update collection metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CollectionMetadataTimeline"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v12.MsgSetCollectionMetadataResponse":{"description":"MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v12.MsgSetCustomData":{"type":"object","title":"MsgSetCustomData sets the custom data timeline and canUpdateCustomData permission","properties":{"canUpdateCustomData":{"type":"array","title":"Permission to update custom data timeline","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CustomDataTimeline"}}}},"badges.v12.MsgSetCustomDataResponse":{"description":"MsgSetCustomDataResponse is the response to MsgSetCustomData.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v12.MsgSetDynamicStoreValue":{"description":"MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to set the value.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"},"value":{"description":"The usage count to set (number of times this address can use the approval).","type":"string"}}},"badges.v12.MsgSetDynamicStoreValueResponse":{"description":"MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.","type":"object"},"badges.v12.MsgSetIncomingApproval":{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","type":"object","properties":{"approval":{"description":"The incoming approval to set.","$ref":"#/definitions/badges.v12.UserIncomingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v12.MsgSetIncomingApprovalResponse":{"description":"MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.","type":"object"},"badges.v12.MsgSetIsArchived":{"type":"object","title":"MsgSetIsArchived sets the isArchived timeline and canArchiveCollection permission","properties":{"canArchiveCollection":{"type":"array","title":"Permission to archive collection","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.IsArchivedTimeline"}}}},"badges.v12.MsgSetIsArchivedResponse":{"description":"MsgSetIsArchivedResponse is the response to MsgSetIsArchived.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v12.MsgSetManager":{"type":"object","title":"MsgSetManager sets the manager timeline and canUpdateManager permission","properties":{"canUpdateManager":{"type":"array","title":"Permission to update manager timeline","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ManagerTimeline"}}}},"badges.v12.MsgSetManagerResponse":{"description":"MsgSetManagerResponse is the response to MsgSetManager.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v12.MsgSetOutgoingApproval":{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","type":"object","properties":{"approval":{"description":"The outgoing approval to set.","$ref":"#/definitions/badges.v12.UserOutgoingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v12.MsgSetOutgoingApprovalResponse":{"description":"MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.","type":"object"},"badges.v12.MsgSetStandards":{"type":"object","title":"MsgSetStandards sets the standards timeline and canUpdateStandards permission","properties":{"canUpdateStandards":{"type":"array","title":"Permission to update standards timeline","items":{"type":"object","$ref":"#/definitions/badges.v12.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.StandardsTimeline"}}}},"badges.v12.MsgSetStandardsResponse":{"description":"MsgSetStandardsResponse is the response to MsgSetStandards.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v12.MsgSetValidBadgeIds":{"type":"object","title":"MsgSetValidBadgeIds sets the validBadgeIds and canUpdateValidBadgeIds permission","properties":{"canUpdateValidBadgeIds":{"type":"array","title":"Permission to update valid badge IDs","items":{"type":"object","$ref":"#/definitions/badges.v12.BadgeIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.MsgSetValidBadgeIdsResponse":{"description":"MsgSetValidBadgeIdsResponse is the response to MsgSetValidBadgeIds.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v12.MsgTransferBadges":{"description":"MsgTransferBadges is used to transfer badges.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.Transfer"}}}},"badges.v12.MsgTransferBadgesResponse":{"description":"MsgTransferBadgesResponse is the response to MsgTransferBadges.","type":"object"},"badges.v12.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v12.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v12.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.v12.CollectionInvariants"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v12.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v12.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CustomDataTimeline"}},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.v12.CollectionInvariants"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v12.MsgUpdateDynamicStore":{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The new default value for uninitialized addresses (optional, only set if updating).","type":"string"},"storeId":{"description":"ID of the dynamic store to update.","type":"string"}}},"badges.v12.MsgUpdateDynamicStoreResponse":{"description":"MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.","type":"object"},"badges.v12.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/badges.v12.Params"}}},"badges.v12.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"badges.v12.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/badges.v12.UserPermissions"}}},"badges.v12.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"badges.v12.MustOwnBadges":{"description":"MustOwnBadges represents a condition where a user must own specific badges\nto be approved to transfer.\n\n- collectionId: The ID of the badge collection for the badges that must be owned\n- amountRange: The range of badge amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the badges.\n- badgeIds: The badge IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified badges; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of badge amounts the user must own (min to max).","$ref":"#/definitions/badges.v12.UintRange"},"badgeIds":{"description":"The badge IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"collectionId":{"description":"The ID of the badge collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified badges; else, must meet requirements for any single badge.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipTimes":{"description":"The time ranges during which the user must own the badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.OffChainBalancesMetadata":{"description":"This message defines the metadata for off-chain balances (if using an off-chain balances type).\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the off-chain balances metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the off-chain balances metadata.","type":"string"}}},"badges.v12.OffChainBalancesMetadataTimeline":{"description":"OffChainBalancesMetadataTimeline defines the metadata for off-chain balances at different timeline times.","type":"object","properties":{"offChainBalancesMetadata":{"description":"The off-chain balances metadata for a specific timeline element.","$ref":"#/definitions/badges.v12.OffChainBalancesMetadata"},"timelineTimes":{"description":"The timeline times when the off-chain balances metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v12.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v12.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v12.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v12.PredeterminedBalances"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v12.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"affiliate_percentage":{"type":"string","title":"affiliate_percentage defines the percentage of the transfer amount that goes to the affiliate"},"allowed_denoms":{"type":"array","title":"allowed_denoms defines the list of denoms that are allowed to be used in coin_transfers","items":{"type":"string"}}}},"badges.v12.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"badgeIdsOverride":{"description":"The badgeIdsOverride to use for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"}}},"badges.v12.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/badges.v12.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/badges.v12.PredeterminedOrderCalculationMethod"}}},"badges.v12.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"badges.v12.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"badges.v12.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"badges.v12.StandardsTimeline":{"description":"StandardsTimeline defines the standards used for a collection at different timeline times.","type":"object","properties":{"standards":{"description":"The standards applied to the collection for a specific timeline element.","type":"array","items":{"type":"string"}},"timelineTimes":{"description":"The timeline times when the standards are valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.TimedUpdateWithBadgeIdsPermission":{"description":"TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.\n\nEx: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.Transfer":{"description":"Transfer defines the details of a transfer of badges.","type":"object","properties":{"affiliateAddress":{"description":"Affiliate address for the transfer.","type":"string"},"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.Balance"}},"ethSignatureProofs":{"description":"The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ETHSignatureProof"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.MerkleProof"}},"numAttempts":{"description":"The number of times to attempt approval validation. If 0 / not specified, we default to only one.","type":"string"},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/badges.v12.ApprovalIdentifierDetails"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/badges.v12.PrecalculationOptions"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"badges.v12.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from badge IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"badges.v12.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/badges.v12.UserPermissions"}}},"badges.v12.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v12.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v12.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v12.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v12.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UintRange"}}}},"badges.v12.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v12.UserOutgoingApprovalPermission"}}}},"badges.v12.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"cosmos.base.v1beta1.Coin":{"description":"Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.","type":"object","properties":{"amount":{"type":"string"},"denom":{"type":"string"}}},"google.protobuf.Any":{"type":"object","properties":{"@type":{"type":"string"}},"additionalProperties":{}},"google.rpc.Status":{"type":"object","properties":{"code":{"type":"integer","format":"int32"},"details":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}},"message":{"type":"string"}}},"maps.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.Map":{"type":"object","properties":{"creator":{"type":"string"},"defaultValue":{"type":"string"},"inheritManagerTimelineFrom":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateCriteria":{"title":"config options that will not change at all","$ref":"#/definitions/maps.MapUpdateCriteria"},"valueOptions":{"$ref":"#/definitions/maps.ValueOptions"}}},"maps.MapMetadataTimeline":{"description":"MapMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"metadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/maps.Metadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.MapPermissions":{"type":"object","properties":{"canDeleteMap":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ActionPermission"}},"canUpdateManager":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.TimedUpdatePermission"}},"canUpdateMetadata":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.TimedUpdatePermission"}}}},"maps.MapUpdateCriteria":{"type":"object","properties":{"collectionId":{"type":"string","title":"ID slots are only updatable by token ID owner of this collection (\u003e1 balance at current time)"},"creatorOnly":{"type":"boolean","title":"Keys are address based and can only be updated by that respective address"},"firstComeFirstServe":{"description":"Claim slots. Can unclaim by setting to blank. Uses lastSetBy.","type":"boolean"},"managerOnly":{"type":"boolean","title":"All ID slots are only updatable by manager"}}},"maps.Metadata":{"description":"This message defines the metadata for the map.\nThe interpretation of this metadata should follow the map standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the map metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the map metadata.","type":"string"}}},"maps.MsgCreateMap":{"type":"object","properties":{"creator":{"type":"string"},"defaultValue":{"type":"string"},"inheritManagerTimelineFrom":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateCriteria":{"title":"config options that will not change at all","$ref":"#/definitions/maps.MapUpdateCriteria"},"valueOptions":{"$ref":"#/definitions/maps.ValueOptions"}}},"maps.MsgCreateMapResponse":{"type":"object"},"maps.MsgDeleteMap":{"type":"object","properties":{"creator":{"type":"string"},"mapId":{"type":"string"}}},"maps.MsgDeleteMapResponse":{"type":"object"},"maps.MsgSetValue":{"type":"object","properties":{"creator":{"type":"string"},"key":{"type":"string"},"mapId":{"type":"string"},"options":{"$ref":"#/definitions/maps.SetOptions"},"value":{"type":"string"}}},"maps.MsgSetValueResponse":{"type":"object"},"maps.MsgUpdateMap":{"type":"object","properties":{"creator":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateManagerTimeline":{"type":"boolean"},"updateMetadataTimeline":{"type":"boolean"},"updatePermissions":{"type":"boolean"}}},"maps.MsgUpdateMapResponse":{"type":"object"},"maps.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/maps.Params"}}},"maps.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"maps.Params":{"description":"Params defines the parameters for the module.","type":"object"},"maps.QueryGetMapResponse":{"type":"object","properties":{"map":{"$ref":"#/definitions/maps.Map"}}},"maps.QueryGetMapValueResponse":{"type":"object","properties":{"value":{"$ref":"#/definitions/maps.ValueStore"}}},"maps.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/maps.Params"}}},"maps.SetOptions":{"type":"object","properties":{"useMostRecentCollectionId":{"type":"boolean"}}},"maps.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\n\nuintRanges are one of the core types used in the BitBadgesChain module.\nThey are used for everything from token IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"maps.ValueOptions":{"type":"object","properties":{"expectAddress":{"type":"boolean"},"expectBoolean":{"type":"boolean"},"expectUint":{"type":"boolean"},"expectUri":{"type":"boolean"},"noDuplicates":{"type":"boolean"},"permanentOnceSet":{"type":"boolean"}}},"maps.ValueStore":{"type":"object","properties":{"key":{"type":"string"},"lastSetBy":{"type":"string"},"value":{"type":"string"}}},"wasmx.GenesisState":{"description":"GenesisState defines the wasmx module's genesis state.","type":"object","properties":{"params":{"description":"params defines all the parameters of the module.","$ref":"#/definitions/wasmx.Params"},"port_id":{"type":"string"}}},"wasmx.MsgExecuteContractCompat":{"type":"object","title":"MsgExecuteContractCompat submits the given message data to a smart contract, compatible with EIP712","properties":{"contract":{"type":"string","title":"Contract is the address of the smart contract"},"funds":{"type":"string","title":"Funds coins that are transferred to the contract on execution"},"msg":{"type":"string","title":"Msg json encoded message to be passed to the contract"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"wasmx.MsgExecuteContractCompatResponse":{"description":"MsgExecuteContractCompatResponse returns execution result data.","type":"object","properties":{"data":{"type":"string","format":"byte","title":"Data contains bytes to returned from the contract"}}},"wasmx.MsgInstantiateContractCompat":{"type":"object","properties":{"codeId":{"type":"string","title":"Code ID obtained from store wasm code"},"funds":{"type":"string","title":"Funds coins that are transferred to the contract on instantiation"},"label":{"type":"string","title":"Label is a human-readable string for labelling the contract"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"wasmx.MsgInstantiateContractCompatResponse":{"description":"MsgInstantiateContractCompatResponse returns store result data.","type":"object","properties":{"address":{"type":"string"},"data":{"type":"string","format":"byte"}}},"wasmx.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/wasmx.Params"}}},"wasmx.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"wasmx.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"is_execution_enabled":{"description":"Set the status to active to indicate that contracts can be executed in begin blocker.","type":"boolean"},"max_begin_block_total_gas":{"description":"Maximum aggregate total gas to be used for the contract executions in the BeginBlocker.","type":"string","format":"uint64"},"max_contract_gas_limit":{"description":"the maximum gas limit each individual contract can consume in the BeginBlocker.","type":"string","format":"uint64"},"min_gas_price":{"description":"min_gas_price defines the minimum gas price the contracts must pay to be executed in the BeginBlocker.","type":"string","format":"uint64"}}},"wasmx.QueryModuleStateResponse":{"description":"QueryModuleStateResponse is the response type for the Query/WasmxModuleState RPC method.","type":"object","properties":{"state":{"$ref":"#/definitions/wasmx.GenesisState"}}},"wasmx.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/wasmx.Params"}}},"wasmx.QueryWasmxParamsResponse":{"description":"QueryWasmxParamsRequest is the response type for the Query/WasmxParams RPC method.","type":"object","properties":{"params":{"$ref":"#/definitions/wasmx.Params"}}}},"tags":[{"name":"Query"},{"name":"Msg"}]}