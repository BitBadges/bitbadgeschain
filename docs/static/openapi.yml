{"id":"github.com/bitbadges/bitbadgeschain","consumes":["application/json"],"produces":["application/json"],"swagger":"2.0","info":{"description":"Chain github.com/bitbadges/bitbadgeschain REST API","title":"HTTP API Console","contact":{"name":"github.com/bitbadges/bitbadgeschain"},"version":"version not set"},"paths":{"/anchor.Msg/AddCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_AddCustomData","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/anchor.MsgAddCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.MsgAddCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/anchor.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParams","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/anchor.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressLists","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollection","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollection","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/TransferBadges":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferBadges","parameters":[{"description":"MsgTransferBadges is used to transfer badges.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgTransferBadges"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgTransferBadgesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollection","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollection","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin17","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovals","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v9.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressListsMixin28","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v9.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v9.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v9.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollectionMixin28","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v9.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v9.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v9.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollectionMixin28","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v9.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v9.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v9.Msg/TransferBadges":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferBadgesMixin28","parameters":[{"description":"MsgTransferBadges is used to transfer badges.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v9.MsgTransferBadges"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v9.MsgTransferBadgesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v9.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollectionMixin28","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v9.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v9.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v9.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollectionMixin28","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v9.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v9.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v9.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin28","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v9.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v9.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v9.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovalsMixin28","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v9.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v9.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_address_list/{listId}":{"get":{"tags":["Query"],"summary":"Queries an address list by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetAddressList","parameters":[{"type":"string","name":"listId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetAddressListResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_approvals_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{amountTrackerId}/{trackerType}/{approvedAddress}":{"get":{"tags":["Query"],"summary":"Queries an approvals tracker by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetApprovalTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"amountTrackerId","in":"path","required":true},{"type":"string","name":"trackerType","in":"path","required":true},{"type":"string","description":"if trackerType is \"overall\", leave blank","name":"approvedAddress","in":"path","required":true},{"type":"string","name":"approvalId","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetApprovalTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_balance/{collectionId}/{address}":{"get":{"tags":["Query"],"summary":"Queries an addresses balance for a badge collection, specified by its ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetBalance","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetBalanceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_challenge_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{challengeTrackerId}/{leafIndex}":{"get":{"tags":["Query"],"summary":"Queries the number of times a given leaf has been used for a given merkle challenge.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetChallengeTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"challengeTrackerId","in":"path","required":true},{"type":"string","name":"leafIndex","in":"path","required":true},{"type":"string","name":"approvalId","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetChallengeTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_collection/{collectionId}":{"get":{"tags":["Query"],"summary":"Queries a badge collection by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetCollection","parameters":[{"type":"string","name":"collectionId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin14","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin38","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/{mapId}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_Map","parameters":[{"type":"string","name":"mapId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryGetMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/{mapId}/{key}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_MapValue","parameters":[{"type":"string","name":"mapId","in":"path","required":true},{"type":"string","name":"key","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryGetMapValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/wasmx/v1/module_state":{"get":{"tags":["Query"],"summary":"Retrieves the entire wasmx module's state","operationId":"GithubCombitbadgesbitbadgeschainQuery_WasmxModuleState","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.QueryModuleStateResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/wasmx/v1/params":{"get":{"tags":["Query"],"summary":"Retrieves wasmx params","operationId":"GithubCombitbadgesbitbadgeschainQuery_WasmxParams","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.QueryWasmxParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/anchor/locations/{locationId}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_GetValueAtLocation","parameters":[{"type":"string","name":"locationId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.QueryGetValueAtLocationResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/anchor/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_Params","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/wasmx/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin45","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/AddCodeUploadParamsAddresses":{"post":{"tags":["Msg"],"summary":"AddCodeUploadParamsAddresses defines a governance operation for\nadding addresses to code upload params.\nThe authority is defined in the keeper.","operationId":"WasmMsg_AddCodeUploadParamsAddresses","parameters":[{"description":"MsgAddCodeUploadParamsAddresses is the\nMsgAddCodeUploadParamsAddresses request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddresses"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddressesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/ClearAdmin":{"post":{"tags":["Msg"],"summary":"ClearAdmin removes any admin stored for a smart contract","operationId":"WasmMsg_ClearAdmin","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgClearAdmin"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgClearAdminResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/ExecuteContract":{"post":{"tags":["Msg"],"summary":"Execute submits the given message data to a smart contract","operationId":"WasmMsg_ExecuteContract","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgExecuteContract"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgExecuteContractResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/InstantiateContract":{"post":{"tags":["Msg"],"summary":"InstantiateContract creates a new smart contract instance for the given\n code id.","operationId":"WasmMsg_InstantiateContract","parameters":[{"description":"MsgInstantiateContract create a new smart contract instance for the given\ncode id.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgInstantiateContract"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgInstantiateContractResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/InstantiateContract2":{"post":{"tags":["Msg"],"summary":"InstantiateContract2 creates a new smart contract instance for the given\n code id with a predictable address","operationId":"WasmMsg_InstantiateContract2","parameters":[{"description":"MsgInstantiateContract2 create a new smart contract instance for the given\ncode id with a predicable address.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgInstantiateContract2"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgInstantiateContract2Response"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/MigrateContract":{"post":{"tags":["Msg"],"summary":"Migrate runs a code upgrade/ downgrade for a smart contract","operationId":"WasmMsg_MigrateContract","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgMigrateContract"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgMigrateContractResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/PinCodes":{"post":{"description":"Since: 0.40","tags":["Msg"],"summary":"PinCodes defines a governance operation for pinning a set of\ncode ids in the wasmvm cache. The authority is defined in the keeper.","operationId":"WasmMsg_PinCodes","parameters":[{"description":"MsgPinCodes is the MsgPinCodes request type.\n\nSince: 0.40","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgPinCodes"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgPinCodesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/RemoveCodeUploadParamsAddresses":{"post":{"tags":["Msg"],"summary":"RemoveCodeUploadParamsAddresses defines a governance operation for\nremoving addresses from code upload params.\nThe authority is defined in the keeper.","operationId":"WasmMsg_RemoveCodeUploadParamsAddresses","parameters":[{"description":"MsgRemoveCodeUploadParamsAddresses is the\nMsgRemoveCodeUploadParamsAddresses request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddresses"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddressesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/StoreAndInstantiateContract":{"post":{"description":"Since: 0.40","tags":["Msg"],"summary":"StoreAndInstantiateContract defines a governance operation for storing\nand instantiating the contract. The authority is defined in the keeper.","operationId":"WasmMsg_StoreAndInstantiateContract","parameters":[{"description":"MsgStoreAndInstantiateContract is the MsgStoreAndInstantiateContract\nrequest type.\n\nSince: 0.40","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgStoreAndInstantiateContract"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgStoreAndInstantiateContractResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/StoreAndMigrateContract":{"post":{"description":"Since: 0.42","tags":["Msg"],"summary":"StoreAndMigrateContract defines a governance operation for storing\nand migrating the contract. The authority is defined in the keeper.","operationId":"WasmMsg_StoreAndMigrateContract","parameters":[{"description":"MsgStoreAndMigrateContract is the MsgStoreAndMigrateContract\nrequest type.\n\nSince: 0.42","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgStoreAndMigrateContract"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgStoreAndMigrateContractResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/StoreCode":{"post":{"tags":["Msg"],"summary":"StoreCode to submit Wasm code to the system","operationId":"WasmMsg_StoreCode","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgStoreCode"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgStoreCodeResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/SudoContract":{"post":{"description":"Since: 0.40","tags":["Msg"],"summary":"SudoContract defines a governance operation for calling sudo\non a contract. The authority is defined in the keeper.","operationId":"WasmMsg_SudoContract","parameters":[{"description":"MsgSudoContract is the MsgSudoContract request type.\n\nSince: 0.40","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgSudoContract"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgSudoContractResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/UnpinCodes":{"post":{"description":"Since: 0.40","tags":["Msg"],"summary":"UnpinCodes defines a governance operation for unpinning a set of\ncode ids in the wasmvm cache. The authority is defined in the keeper.","operationId":"WasmMsg_UnpinCodes","parameters":[{"description":"MsgUnpinCodes is the MsgUnpinCodes request type.\n\nSince: 0.40","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgUnpinCodes"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgUnpinCodesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/UpdateAdmin":{"post":{"tags":["Msg"],"summary":"UpdateAdmin sets a new admin for a smart contract","operationId":"WasmMsg_UpdateAdmin","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgUpdateAdmin"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgUpdateAdminResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/UpdateContractLabel":{"post":{"description":"Since: 0.43","tags":["Msg"],"summary":"UpdateContractLabel sets a new label for a smart contract","operationId":"WasmMsg_UpdateContractLabel","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgUpdateContractLabel"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgUpdateContractLabelResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/UpdateInstantiateConfig":{"post":{"tags":["Msg"],"summary":"UpdateInstantiateConfig updates instantiate config for a smart contract","operationId":"WasmMsg_UpdateInstantiateConfig","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgUpdateInstantiateConfig"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgUpdateInstantiateConfigResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm.wasm.v1.Msg/UpdateParams":{"post":{"description":"Since: 0.40","tags":["Msg"],"summary":"UpdateParams defines a governance operation for updating the x/wasm\nmodule parameters. The authority is defined in the keeper.","operationId":"WasmMsg_UpdateParams","parameters":[{"description":"MsgUpdateParams is the MsgUpdateParams request type.\n\nSince: 0.40","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/code":{"get":{"tags":["Query"],"summary":"Codes gets the metadata for all stored wasm codes","operationId":"WasmQuery_Codes","parameters":[{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QueryCodesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/code/{code_id}":{"get":{"tags":["Query"],"summary":"Code gets the binary code and metadata for a singe wasm code","operationId":"WasmQuery_Code","parameters":[{"type":"string","format":"uint64","description":"grpc-gateway_out does not support Go style CodID","name":"code_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QueryCodeResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/code/{code_id}/contracts":{"get":{"tags":["Query"],"summary":"ContractsByCode lists all smart contracts for a code id","operationId":"WasmQuery_ContractsByCode","parameters":[{"type":"string","format":"uint64","description":"grpc-gateway_out does not support Go style CodID","name":"code_id","in":"path","required":true},{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QueryContractsByCodeResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/codes/params":{"get":{"tags":["Query"],"summary":"Params gets the module params","operationId":"WasmQuery_Params","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/codes/pinned":{"get":{"tags":["Query"],"summary":"PinnedCodes gets the pinned code ids","operationId":"WasmQuery_PinnedCodes","parameters":[{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QueryPinnedCodesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/contract/build_address":{"get":{"tags":["Query"],"summary":"BuildAddress builds a contract address","operationId":"WasmQuery_BuildAddress","parameters":[{"type":"string","description":"CodeHash is the hash of the code","name":"code_hash","in":"query"},{"type":"string","description":"CreatorAddress is the address of the contract instantiator","name":"creator_address","in":"query"},{"type":"string","description":"Salt is a hex encoded salt","name":"salt","in":"query"},{"type":"string","format":"byte","description":"InitArgs are optional json encoded init args to be used in contract address\nbuilding if provided","name":"init_args","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QueryBuildAddressResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/contract/{address}":{"get":{"tags":["Query"],"summary":"ContractInfo gets the contract meta data","operationId":"WasmQuery_ContractInfo","parameters":[{"type":"string","description":"address is the address of the contract to query","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QueryContractInfoResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/contract/{address}/history":{"get":{"tags":["Query"],"summary":"ContractHistory gets the contract code history","operationId":"WasmQuery_ContractHistory","parameters":[{"type":"string","description":"address is the address of the contract to query","name":"address","in":"path","required":true},{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QueryContractHistoryResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/contract/{address}/raw/{query_data}":{"get":{"tags":["Query"],"summary":"RawContractState gets single key from the raw store data of a contract","operationId":"WasmQuery_RawContractState","parameters":[{"type":"string","description":"address is the address of the contract","name":"address","in":"path","required":true},{"type":"string","format":"byte","name":"query_data","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QueryRawContractStateResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/contract/{address}/smart/{query_data}":{"get":{"tags":["Query"],"summary":"SmartContractState get smart query result from the contract","operationId":"WasmQuery_SmartContractState","parameters":[{"type":"string","description":"address is the address of the contract","name":"address","in":"path","required":true},{"type":"string","format":"byte","description":"QueryData contains the query data passed to the contract","name":"query_data","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QuerySmartContractStateResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/contract/{address}/state":{"get":{"tags":["Query"],"summary":"AllContractState gets all raw store data for a single contract","operationId":"WasmQuery_AllContractState","parameters":[{"type":"string","description":"address is the address of the contract","name":"address","in":"path","required":true},{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QueryAllContractStateResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmwasm/wasm/v1/contracts/creator/{creator_address}":{"get":{"tags":["Query"],"summary":"ContractsByCreator gets the contracts by creator","operationId":"WasmQuery_ContractsByCreator","parameters":[{"type":"string","description":"CreatorAddress is the address of contract creator","name":"creator_address","in":"path","required":true},{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmwasm.wasm.v1.QueryContractsByCreatorResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/CreateMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgCreateMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgCreateMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/DeleteMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgDeleteMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgDeleteMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/SetValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValue","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgSetValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgSetValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/UpdateMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgUpdateMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgUpdateMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/UpdateParams":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin40","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/wasmx.Msg/ExecuteContractCompat":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_ExecuteContractCompat","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/wasmx.MsgExecuteContractCompat"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.MsgExecuteContractCompatResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/wasmx.Msg/InstantiateContractCompat":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_InstantiateContractCompat","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/wasmx.MsgInstantiateContractCompat"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.MsgInstantiateContractCompatResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/wasmx.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin46","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/wasmx.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}}},"definitions":{"anchor.AnchorData":{"type":"object","properties":{"creator":{"type":"string"},"data":{"type":"string"},"timestamp":{"type":"string"}}},"anchor.MsgAddCustomData":{"type":"object","properties":{"creator":{"type":"string"},"data":{"type":"string"}}},"anchor.MsgAddCustomDataResponse":{"type":"object","properties":{"locationId":{"description":"ID of the anchor location.","type":"string"}}},"anchor.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"NOTE: All parameters must be supplied.","$ref":"#/definitions/anchor.Params"}}},"anchor.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"anchor.Params":{"description":"Params defines the parameters for the module.","type":"object"},"anchor.QueryGetValueAtLocationResponse":{"type":"object","properties":{"anchorData":{"$ref":"#/definitions/anchor.AnchorData"}}},"anchor.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/anchor.Params"}}},"badges.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"badges.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified badge IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.ResetTimeIntervals"}}},"badges.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnBadges"}},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"userRoyalties":{"description":"User level royalties to apply to the transfer.","$ref":"#/definitions/badges.UserRoyalties"}}},"badges.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"badges.ApprovalTracker":{"description":"ApprovalTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.","type":"object","properties":{"amounts":{"description":"Cumulative balances associated with the transfers that have been processed.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"lastUpdatedAt":{"description":"Last updated at time.","type":"string"},"numTransfers":{"description":"The number of transfers that have been processed.","type":"string"}}},"badges.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"}}},"badges.BadgeCollection":{"description":"A BadgeCollection is the top-level object for a collection of badges. \nIt defines everything about the collection, such as the manager, metadata, etc.\n\nAll collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).\n\nAll collections can have a manager who is responsible for managing the collection and can be granted certain admin\npermissions, such as the ability to mint new badges.\n\nCertain fields are timeline-based, which means they may have different values at different block heights. \nWe fetch the value according to the current time.\nFor example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.\n\nCollections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.\n\nSee documentation for more details.","type":"object","properties":{"badgeMetadataTimeline":{"description":"The metadata for each badge in the collection, also subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"balancesType":{"description":"The type of balances this collection uses (\"Standard\", \"Off-Chain - Indexed\", \"Off-Chain - Non-Indexed\", or \"Non-Public\").","type":"string"},"collectionApprovals":{"description":"Transferability of the collection for collections with standard balances, subject to changes over time.\nOverrides user approvals for a transfer if specified.\nTransfer must satisfy both user and collection-level approvals.\nOnly applicable to on-chain balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.","type":"string"},"collectionMetadataTimeline":{"description":"The metadata for the collection itself, which can vary over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Permissions that define what the manager of the collection can do or not do.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPaths":{"description":"The IBC wrapper (sdk.coin) paths for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPath"}},"createdBy":{"description":"The user or entity who created the badge collection.","type":"string"},"customDataTimeline":{"description":"An arbitrary field that can store any data, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"description":"The default store of a balance for a user, upon genesis.","$ref":"#/definitions/badges.UserBalanceStore"},"isArchivedTimeline":{"description":"Whether the collection is archived or not, subject to changes over time.\nWhen archived, it becomes read-only, and no transactions can be processed until it is unarchived.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"The address of the manager of this collection, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowAddress":{"description":"The generated address of the badge collection. Also used to escrow Mint balances.","type":"string"},"offChainBalancesMetadataTimeline":{"description":"Metadata for fetching balances for collections with off-chain balances, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"Standards that define how to interpret the fields of the collection, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"validBadgeIds":{"description":"The valid badge IDs for this collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.BadgeIdsActionPermission":{"description":"BadgeIdsActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.\nCurrently, this is only used for creating new badges.\n\nEx: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.BadgeMetadata":{"description":"This message defines the metadata for specific badge IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"badgeIds":{"description":"The badge IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Custom data or additional information related to the badge metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the badge metadata.","type":"string"}}},"badges.BadgeMetadataTimeline":{"description":"BadgeMetadataTimeline defines the metadata for badges at different timeline times.","type":"object","properties":{"badgeMetadata":{"description":"The badge metadata for a specific timeline element.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadata"}},"timelineTimes":{"description":"The timeline times when the badge metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.Balance":{"description":"Balance represents the balance of a badge for a specific user.\nThe user amounts xAmount of a badge for the badgeID specified for the time ranges specified.\n\nExample: User A owns x10 of badge IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or badgeIDs have len \u003e 1, then the user owns all badge IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the badge owned by the user.","type":"string"},"badgeIds":{"description":"The badge IDs for which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"ownershipTimes":{"description":"The time ranges during which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"badges.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, badgeIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\nTimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden at all timelineTimes.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"badges.CollectionMetadataTimeline":{"description":"CollectionMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"collectionMetadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/badges.CollectionMetadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BadgeIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action.\n- TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.\n- TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.\n- BadgeIdsActionPermission: defines when the manager can perform an action for specific badges\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- timelineTimes: the times when a timeline-based field is a specific value\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a badge is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateBadgeMetadata":{"description":"Permissions related to updating badge metadata for specific badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdateWithBadgeIdsPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateOffChainBalancesMetadata":{"description":"Permissions related to updating off-chain balances metadata.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateValidBadgeIds":{"description":"Permissions related to creating more badges for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeIdsActionPermission"}}}},"badges.CosmosCoinWrapperPath":{"type":"object","properties":{"address":{"type":"string"},"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.DenomUnit"}},"symbol":{"type":"string"}}},"badges.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.DenomUnit"}},"symbol":{"type":"string"}}},"badges.CustomDataTimeline":{"description":"CustomDataTimeline defines custom data at different timeline times.","type":"object","properties":{"customData":{"description":"The custom data for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the custom data is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.DenomUnit":{"type":"object","properties":{"decimals":{"type":"string"},"isDefaultDisplay":{"type":"boolean"},"symbol":{"type":"string"}}},"badges.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidBadge":{"type":"boolean","title":"Allow override of any valid badge"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementBadgeIdsBy":{"description":"The amount by which to increment badge IDs.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/badges.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}}}},"badges.IsArchivedTimeline":{"description":"IsArchivedTimeline defines whether a collection is archived at different timeline times.","type":"object","properties":{"isArchived":{"description":"Indicates whether the collection is archived for a specific timeline element.","type":"boolean"},"timelineTimes":{"description":"The timeline times when the archived status is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}}}},"badges.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified badge IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.ResetTimeIntervals"}}},"badges.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"type":"string","title":"Leaf must be signed by. Used to protect against man in the middle attacks.`\nScheme we use is sign(leaf + \"-\" +"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"badges.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"badges.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"badges.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.AddressList"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"badges.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"Badge metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionMetadataTimeline":{"description":"Collection metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"Custom data timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.UserBalanceStore"},"isArchivedTimeline":{"description":"isArchived timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"Manager timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"Off-chain balances metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"Standards timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"badges.MsgTransferBadges":{"description":"MsgTransferBadges is used to transfer badges.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Transfer"}}}},"badges.MsgTransferBadgesResponse":{"description":"MsgTransferBadgesResponse is the response to MsgTransferBadges.","type":"object"},"badges.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.UserBalanceStore"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/badges.Params"}}},"badges.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"badges.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/badges.UserPermissions"}}},"badges.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"badges.MustOwnBadges":{"description":"MustOwnBadges represents a condition where a user must own specific badges\nto be approved to transfer.\n\n- collectionId: The ID of the badge collection for the badges that must be owned\n- amountRange: The range of badge amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the badges.\n- badgeIds: The badge IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified badges; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of badge amounts the user must own (min to max).","$ref":"#/definitions/badges.UintRange"},"badgeIds":{"description":"The badge IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"collectionId":{"description":"The ID of the badge collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified badges; else, must meet requirements for any single badge.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipTimes":{"description":"The time ranges during which the user must own the badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.OffChainBalancesMetadata":{"description":"This message defines the metadata for off-chain balances (if using an off-chain balances type).\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the off-chain balances metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the off-chain balances metadata.","type":"string"}}},"badges.OffChainBalancesMetadataTimeline":{"description":"OffChainBalancesMetadataTimeline defines the metadata for off-chain balances at different timeline times.","type":"object","properties":{"offChainBalancesMetadata":{"description":"The off-chain balances metadata for a specific timeline element.","$ref":"#/definitions/badges.OffChainBalancesMetadata"},"timelineTimes":{"description":"The timeline times when the off-chain balances metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"allowed_denoms":{"type":"array","title":"allowed_denoms defines the list of denoms that are allowed to be used in coin_transfers","items":{"type":"string"}}}},"badges.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"badgeIdsOverride":{"description":"The badgeIdsOverride to use for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"}}},"badges.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/badges.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/badges.PredeterminedOrderCalculationMethod"}}},"badges.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"badges.QueryGetAddressListResponse":{"type":"object","properties":{"list":{"$ref":"#/definitions/badges.AddressList"}}},"badges.QueryGetApprovalTrackerResponse":{"type":"object","properties":{"tracker":{"$ref":"#/definitions/badges.ApprovalTracker"}}},"badges.QueryGetBalanceResponse":{"type":"object","properties":{"balance":{"$ref":"#/definitions/badges.UserBalanceStore"}}},"badges.QueryGetChallengeTrackerResponse":{"type":"object","properties":{"numUsed":{"type":"string"}}},"badges.QueryGetCollectionResponse":{"type":"object","properties":{"collection":{"$ref":"#/definitions/badges.BadgeCollection"}}},"badges.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/badges.Params"}}},"badges.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"badges.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"badges.StandardsTimeline":{"description":"StandardsTimeline defines the standards used for a collection at different timeline times.","type":"object","properties":{"standards":{"description":"The standards applied to the collection for a specific timeline element.","type":"array","items":{"type":"string"}},"timelineTimes":{"description":"The timeline times when the standards are valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.TimedUpdateWithBadgeIdsPermission":{"description":"TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.\n\nEx: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.Transfer":{"description":"Transfer defines the details of a transfer of badges.","type":"object","properties":{"affiliateAddress":{"description":"Affiliate address for the transfer.","type":"string"},"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleProof"}},"numAttempts":{"description":"The number of times to attempt approval validation. If 0 / not specified, we default to only one.","type":"string"},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/badges.ApprovalIdentifierDetails"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/badges.PrecalculationOptions"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"badges.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from badge IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"badges.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/badges.UserPermissions"}}},"badges.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApprovalPermission"}}}},"badges.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"badges.v9.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"badges.v9.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified badge IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v9.ResetTimeIntervals"}}},"badges.v9.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v9.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v9.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v9.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.MustOwnBadges"}},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v9.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"userRoyalties":{"description":"User level royalties to apply to the transfer.","$ref":"#/definitions/badges.v9.UserRoyalties"}}},"badges.v9.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"badges.v9.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"}}},"badges.v9.BadgeIdsActionPermission":{"description":"BadgeIdsActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.\nCurrently, this is only used for creating new badges.\n\nEx: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.BadgeMetadata":{"description":"This message defines the metadata for specific badge IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"badgeIds":{"description":"The badge IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"customData":{"description":"Custom data or additional information related to the badge metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the badge metadata.","type":"string"}}},"badges.v9.BadgeMetadataTimeline":{"description":"BadgeMetadataTimeline defines the metadata for badges at different timeline times.","type":"object","properties":{"badgeMetadata":{"description":"The badge metadata for a specific timeline element.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.BadgeMetadata"}},"timelineTimes":{"description":"The timeline times when the badge metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.Balance":{"description":"Balance represents the balance of a badge for a specific user.\nThe user amounts xAmount of a badge for the badgeID specified for the time ranges specified.\n\nExample: User A owns x10 of badge IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or badgeIDs have len \u003e 1, then the user owns all badge IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the badge owned by the user.","type":"string"},"badgeIds":{"description":"The badge IDs for which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"ownershipTimes":{"description":"The time ranges during which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"badges.v9.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v9.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v9.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, badgeIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\nTimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden at all timelineTimes.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"badges.v9.CollectionMetadataTimeline":{"description":"CollectionMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"collectionMetadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/badges.v9.CollectionMetadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BadgeIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action.\n- TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.\n- TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.\n- BadgeIdsActionPermission: defines when the manager can perform an action for specific badges\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- timelineTimes: the times when a timeline-based field is a specific value\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a badge is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.TimedUpdatePermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.ActionPermission"}},"canUpdateBadgeMetadata":{"description":"Permissions related to updating badge metadata for specific badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.TimedUpdateWithBadgeIdsPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.TimedUpdatePermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.TimedUpdatePermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.TimedUpdatePermission"}},"canUpdateOffChainBalancesMetadata":{"description":"Permissions related to updating off-chain balances metadata.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.TimedUpdatePermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.TimedUpdatePermission"}},"canUpdateValidBadgeIds":{"description":"Permissions related to creating more badges for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.BadgeIdsActionPermission"}}}},"badges.v9.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"badgeIds":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.DenomUnit"}},"ownershipTimes":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"symbol":{"type":"string"}}},"badges.v9.CustomDataTimeline":{"description":"CustomDataTimeline defines custom data at different timeline times.","type":"object","properties":{"customData":{"description":"The custom data for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the custom data is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.DenomUnit":{"type":"object","properties":{"decimals":{"type":"string"},"isDefaultDisplay":{"type":"boolean"},"symbol":{"type":"string"}}},"badges.v9.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v9.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v9.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v9.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v9.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v9.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidBadge":{"type":"boolean","title":"Allow override of any valid badge"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementBadgeIdsBy":{"description":"The amount by which to increment badge IDs.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/badges.v9.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.Balance"}}}},"badges.v9.IsArchivedTimeline":{"description":"IsArchivedTimeline defines whether a collection is archived at different timeline times.","type":"object","properties":{"isArchived":{"description":"Indicates whether the collection is archived for a specific timeline element.","type":"boolean"},"timelineTimes":{"description":"The timeline times when the archived status is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.Balance"}}}},"badges.v9.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified badge IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v9.ResetTimeIntervals"}}},"badges.v9.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"type":"string","title":"Leaf must be signed by. Used to protect against man in the middle attacks.`\nScheme we use is sign(leaf + \"-\" +"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"badges.v9.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"badges.v9.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"badges.v9.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.AddressList"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v9.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"badges.v9.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"Badge metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CollectionApproval"}},"collectionMetadataTimeline":{"description":"Collection metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/badges.v9.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"Custom data timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v9.UserBalanceStore"},"isArchivedTimeline":{"description":"isArchived timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.IsArchivedTimeline"}},"managerTimeline":{"description":"Manager timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"Off-chain balances metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"Standards timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.StandardsTimeline"}},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v9.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v9.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"badges.v9.MsgTransferBadges":{"description":"MsgTransferBadges is used to transfer badges.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.Transfer"}}}},"badges.v9.MsgTransferBadgesResponse":{"description":"MsgTransferBadgesResponse is the response to MsgTransferBadges.","type":"object"},"badges.v9.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v9.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v9.UserBalanceStore"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v9.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v9.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CustomDataTimeline"}},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v9.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/badges.v9.Params"}}},"badges.v9.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"badges.v9.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/badges.v9.UserPermissions"}}},"badges.v9.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"badges.v9.MustOwnBadges":{"description":"MustOwnBadges represents a condition where a user must own specific badges\nto be approved to transfer.\n\n- collectionId: The ID of the badge collection for the badges that must be owned\n- amountRange: The range of badge amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the badges.\n- badgeIds: The badge IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified badges; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of badge amounts the user must own (min to max).","$ref":"#/definitions/badges.v9.UintRange"},"badgeIds":{"description":"The badge IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"collectionId":{"description":"The ID of the badge collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified badges; else, must meet requirements for any single badge.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipTimes":{"description":"The time ranges during which the user must own the badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.OffChainBalancesMetadata":{"description":"This message defines the metadata for off-chain balances (if using an off-chain balances type).\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the off-chain balances metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the off-chain balances metadata.","type":"string"}}},"badges.v9.OffChainBalancesMetadataTimeline":{"description":"OffChainBalancesMetadataTimeline defines the metadata for off-chain balances at different timeline times.","type":"object","properties":{"offChainBalancesMetadata":{"description":"The off-chain balances metadata for a specific timeline element.","$ref":"#/definitions/badges.v9.OffChainBalancesMetadata"},"timelineTimes":{"description":"The timeline times when the off-chain balances metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v9.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v9.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v9.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v9.PredeterminedBalances"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v9.Params":{"description":"Params defines the parameters for the module.","type":"object"},"badges.v9.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"badgeIdsOverride":{"description":"The badgeIdsOverride to use for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"}}},"badges.v9.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/badges.v9.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/badges.v9.PredeterminedOrderCalculationMethod"}}},"badges.v9.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"badges.v9.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"badges.v9.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"badges.v9.StandardsTimeline":{"description":"StandardsTimeline defines the standards used for a collection at different timeline times.","type":"object","properties":{"standards":{"description":"The standards applied to the collection for a specific timeline element.","type":"array","items":{"type":"string"}},"timelineTimes":{"description":"The timeline times when the standards are valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.TimedUpdateWithBadgeIdsPermission":{"description":"TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.\n\nEx: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.Transfer":{"description":"Transfer defines the details of a transfer of badges.","type":"object","properties":{"affiliateAddress":{"description":"Affiliate address for the transfer.","type":"string"},"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.Balance"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.MerkleProof"}},"numAttempts":{"description":"The number of times to attempt approval validation. If 0 / not specified, we default to only one.","type":"string"},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/badges.v9.ApprovalIdentifierDetails"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/badges.v9.PrecalculationOptions"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"badges.v9.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from badge IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"badges.v9.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/badges.v9.UserPermissions"}}},"badges.v9.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v9.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v9.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v9.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v9.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UintRange"}}}},"badges.v9.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v9.UserOutgoingApprovalPermission"}}}},"badges.v9.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"cosmos.base.query.v1beta1.PageRequest":{"description":"message SomeRequest {\n         Foo some_parameter = 1;\n         PageRequest pagination = 2;\n }","type":"object","title":"PageRequest is to be embedded in gRPC request messages for efficient\npagination. Ex:","properties":{"count_total":{"description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","type":"boolean"},"key":{"description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","type":"string","format":"byte"},"limit":{"description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","type":"string","format":"uint64"},"offset":{"description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","type":"string","format":"uint64"},"reverse":{"description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","type":"boolean"}}},"cosmos.base.query.v1beta1.PageResponse":{"description":"PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }","type":"object","properties":{"next_key":{"description":"next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.","type":"string","format":"byte"},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"}}},"cosmos.base.v1beta1.Coin":{"description":"Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.","type":"object","properties":{"amount":{"type":"string"},"denom":{"type":"string"}}},"cosmwasm.wasm.v1.AbsoluteTxPosition":{"description":"AbsoluteTxPosition is a unique transaction position that allows for global\nordering of transactions.","type":"object","properties":{"block_height":{"type":"string","format":"uint64","title":"BlockHeight is the block the contract was created at"},"tx_index":{"type":"string","format":"uint64","title":"TxIndex is a monotonic counter within the block (actual transaction index,\nor gas consumed)"}}},"cosmwasm.wasm.v1.AccessConfig":{"description":"AccessConfig access control type.","type":"object","properties":{"addresses":{"type":"array","items":{"type":"string"}},"permission":{"$ref":"#/definitions/cosmwasm.wasm.v1.AccessType"}}},"cosmwasm.wasm.v1.AccessType":{"description":"- ACCESS_TYPE_UNSPECIFIED: AccessTypeUnspecified placeholder for empty value\n - ACCESS_TYPE_NOBODY: AccessTypeNobody forbidden\n - ACCESS_TYPE_EVERYBODY: AccessTypeEverybody unrestricted\n - ACCESS_TYPE_ANY_OF_ADDRESSES: AccessTypeAnyOfAddresses allow any of the addresses","type":"string","title":"AccessType permission types","default":"ACCESS_TYPE_UNSPECIFIED","enum":["ACCESS_TYPE_UNSPECIFIED","ACCESS_TYPE_NOBODY","ACCESS_TYPE_EVERYBODY","ACCESS_TYPE_ANY_OF_ADDRESSES"]},"cosmwasm.wasm.v1.CodeInfoResponse":{"type":"object","title":"CodeInfoResponse contains code meta data from CodeInfo","properties":{"code_id":{"type":"string","format":"uint64","title":"id for legacy support"},"creator":{"type":"string"},"data_hash":{"type":"string","format":"byte"},"instantiate_permission":{"$ref":"#/definitions/cosmwasm.wasm.v1.AccessConfig"}}},"cosmwasm.wasm.v1.ContractCodeHistoryEntry":{"description":"ContractCodeHistoryEntry metadata to a contract.","type":"object","properties":{"code_id":{"type":"string","format":"uint64","title":"CodeID is the reference to the stored WASM code"},"msg":{"type":"string","format":"byte"},"operation":{"$ref":"#/definitions/cosmwasm.wasm.v1.ContractCodeHistoryOperationType"},"updated":{"description":"Updated Tx position when the operation was executed.","$ref":"#/definitions/cosmwasm.wasm.v1.AbsoluteTxPosition"}}},"cosmwasm.wasm.v1.ContractCodeHistoryOperationType":{"description":"- CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED: ContractCodeHistoryOperationTypeUnspecified placeholder for empty value\n - CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT: ContractCodeHistoryOperationTypeInit on chain contract instantiation\n - CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE: ContractCodeHistoryOperationTypeMigrate code migration\n - CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS: ContractCodeHistoryOperationTypeGenesis based on genesis data","type":"string","title":"ContractCodeHistoryOperationType actions that caused a code change","default":"CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED","enum":["CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED","CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT","CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE","CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS"]},"cosmwasm.wasm.v1.ContractInfo":{"type":"object","title":"ContractInfo stores a WASM contract instance","properties":{"admin":{"type":"string","title":"Admin is an optional address that can execute migrations"},"code_id":{"type":"string","format":"uint64","title":"CodeID is the reference to the stored Wasm code"},"created":{"description":"Created Tx position when the contract was instantiated.","$ref":"#/definitions/cosmwasm.wasm.v1.AbsoluteTxPosition"},"creator":{"type":"string","title":"Creator address who initially instantiated the contract"},"extension":{"description":"Extension is an extension point to store custom metadata within the\npersistence model.","$ref":"#/definitions/google.protobuf.Any"},"ibc_port_id":{"type":"string"},"label":{"description":"Label is optional metadata to be stored with a contract instance.","type":"string"}}},"cosmwasm.wasm.v1.Model":{"type":"object","title":"Model is a struct that holds a KV pair","properties":{"key":{"type":"string","format":"byte","title":"hex-encode key to read it better (this is often ascii)"},"value":{"type":"string","format":"byte","title":"base64-encode raw value"}}},"cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddresses":{"description":"MsgAddCodeUploadParamsAddresses is the\nMsgAddCodeUploadParamsAddresses request type.","type":"object","properties":{"addresses":{"type":"array","items":{"type":"string"}},"authority":{"description":"Authority is the address of the governance account.","type":"string"}}},"cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddressesResponse":{"description":"MsgAddCodeUploadParamsAddressesResponse defines the response\nstructure for executing a MsgAddCodeUploadParamsAddresses message.","type":"object"},"cosmwasm.wasm.v1.MsgClearAdmin":{"type":"object","title":"MsgClearAdmin removes any admin stored for a smart contract","properties":{"contract":{"type":"string","title":"Contract is the address of the smart contract"},"sender":{"type":"string","title":"Sender is the actor that signed the messages"}}},"cosmwasm.wasm.v1.MsgClearAdminResponse":{"type":"object","title":"MsgClearAdminResponse returns empty data"},"cosmwasm.wasm.v1.MsgExecuteContract":{"type":"object","title":"MsgExecuteContract submits the given message data to a smart contract","properties":{"contract":{"type":"string","title":"Contract is the address of the smart contract"},"funds":{"type":"array","title":"Funds coins that are transferred to the contract on execution","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"msg":{"type":"string","format":"byte","title":"Msg json encoded message to be passed to the contract"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"cosmwasm.wasm.v1.MsgExecuteContractResponse":{"description":"MsgExecuteContractResponse returns execution result data.","type":"object","properties":{"data":{"type":"string","format":"byte","title":"Data contains bytes to returned from the contract"}}},"cosmwasm.wasm.v1.MsgInstantiateContract":{"description":"MsgInstantiateContract create a new smart contract instance for the given\ncode id.","type":"object","properties":{"admin":{"type":"string","title":"Admin is an optional address that can execute migrations"},"code_id":{"type":"string","format":"uint64","title":"CodeID is the reference to the stored WASM code"},"funds":{"type":"array","title":"Funds coins that are transferred to the contract on instantiation","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"label":{"description":"Label is optional metadata to be stored with a contract instance.","type":"string"},"msg":{"type":"string","format":"byte","title":"Msg json encoded message to be passed to the contract on instantiation"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"cosmwasm.wasm.v1.MsgInstantiateContract2":{"description":"MsgInstantiateContract2 create a new smart contract instance for the given\ncode id with a predicable address.","type":"object","properties":{"admin":{"type":"string","title":"Admin is an optional address that can execute migrations"},"code_id":{"type":"string","format":"uint64","title":"CodeID is the reference to the stored WASM code"},"fix_msg":{"type":"boolean","title":"FixMsg include the msg value into the hash for the predictable address.\nDefault is false"},"funds":{"type":"array","title":"Funds coins that are transferred to the contract on instantiation","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"label":{"description":"Label is optional metadata to be stored with a contract instance.","type":"string"},"msg":{"type":"string","format":"byte","title":"Msg json encoded message to be passed to the contract on instantiation"},"salt":{"description":"Salt is an arbitrary value provided by the sender. Size can be 1 to 64.","type":"string","format":"byte"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"cosmwasm.wasm.v1.MsgInstantiateContract2Response":{"type":"object","title":"MsgInstantiateContract2Response return instantiation result data","properties":{"address":{"description":"Address is the bech32 address of the new contract instance.","type":"string"},"data":{"type":"string","format":"byte","title":"Data contains bytes to returned from the contract"}}},"cosmwasm.wasm.v1.MsgInstantiateContractResponse":{"type":"object","title":"MsgInstantiateContractResponse return instantiation result data","properties":{"address":{"description":"Address is the bech32 address of the new contract instance.","type":"string"},"data":{"type":"string","format":"byte","title":"Data contains bytes to returned from the contract"}}},"cosmwasm.wasm.v1.MsgMigrateContract":{"type":"object","title":"MsgMigrateContract runs a code upgrade/ downgrade for a smart contract","properties":{"code_id":{"type":"string","format":"uint64","title":"CodeID references the new WASM code"},"contract":{"type":"string","title":"Contract is the address of the smart contract"},"msg":{"type":"string","format":"byte","title":"Msg json encoded message to be passed to the contract on migration"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"cosmwasm.wasm.v1.MsgMigrateContractResponse":{"description":"MsgMigrateContractResponse returns contract migration result data.","type":"object","properties":{"data":{"type":"string","format":"byte","title":"Data contains same raw bytes returned as data from the wasm contract.\n(May be empty)"}}},"cosmwasm.wasm.v1.MsgPinCodes":{"description":"MsgPinCodes is the MsgPinCodes request type.\n\nSince: 0.40","type":"object","properties":{"authority":{"description":"Authority is the address of the governance account.","type":"string"},"code_ids":{"type":"array","title":"CodeIDs references the new WASM codes","items":{"type":"string","format":"uint64"}}}},"cosmwasm.wasm.v1.MsgPinCodesResponse":{"description":"MsgPinCodesResponse defines the response structure for executing a\nMsgPinCodes message.\n\nSince: 0.40","type":"object"},"cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddresses":{"description":"MsgRemoveCodeUploadParamsAddresses is the\nMsgRemoveCodeUploadParamsAddresses request type.","type":"object","properties":{"addresses":{"type":"array","items":{"type":"string"}},"authority":{"description":"Authority is the address of the governance account.","type":"string"}}},"cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddressesResponse":{"description":"MsgRemoveCodeUploadParamsAddressesResponse defines the response\nstructure for executing a MsgRemoveCodeUploadParamsAddresses message.","type":"object"},"cosmwasm.wasm.v1.MsgStoreAndInstantiateContract":{"description":"MsgStoreAndInstantiateContract is the MsgStoreAndInstantiateContract\nrequest type.\n\nSince: 0.40","type":"object","properties":{"admin":{"type":"string","title":"Admin is an optional address that can execute migrations"},"authority":{"description":"Authority is the address of the governance account.","type":"string"},"builder":{"type":"string","title":"Builder is the docker image used to build the code deterministically, used\nfor smart contract verification"},"code_hash":{"type":"string","format":"byte","title":"CodeHash is the SHA256 sum of the code outputted by builder, used for smart\ncontract verification"},"funds":{"type":"array","title":"Funds coins that are transferred from the authority account to the contract\non instantiation","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"instantiate_permission":{"title":"InstantiatePermission to apply on contract creation, optional","$ref":"#/definitions/cosmwasm.wasm.v1.AccessConfig"},"label":{"description":"Label is optional metadata to be stored with a constract instance.","type":"string"},"msg":{"type":"string","format":"byte","title":"Msg json encoded message to be passed to the contract on instantiation"},"source":{"type":"string","title":"Source is the URL where the code is hosted"},"unpin_code":{"description":"UnpinCode code on upload, optional. As default the uploaded contract is\npinned to cache.","type":"boolean"},"wasm_byte_code":{"type":"string","format":"byte","title":"WASMByteCode can be raw or gzip compressed"}}},"cosmwasm.wasm.v1.MsgStoreAndInstantiateContractResponse":{"description":"MsgStoreAndInstantiateContractResponse defines the response structure\nfor executing a MsgStoreAndInstantiateContract message.\n\nSince: 0.40","type":"object","properties":{"address":{"description":"Address is the bech32 address of the new contract instance.","type":"string"},"data":{"type":"string","format":"byte","title":"Data contains bytes to returned from the contract"}}},"cosmwasm.wasm.v1.MsgStoreAndMigrateContract":{"description":"MsgStoreAndMigrateContract is the MsgStoreAndMigrateContract\nrequest type.\n\nSince: 0.42","type":"object","properties":{"authority":{"description":"Authority is the address of the governance account.","type":"string"},"contract":{"type":"string","title":"Contract is the address of the smart contract"},"instantiate_permission":{"title":"InstantiatePermission to apply on contract creation, optional","$ref":"#/definitions/cosmwasm.wasm.v1.AccessConfig"},"msg":{"type":"string","format":"byte","title":"Msg json encoded message to be passed to the contract on migration"},"wasm_byte_code":{"type":"string","format":"byte","title":"WASMByteCode can be raw or gzip compressed"}}},"cosmwasm.wasm.v1.MsgStoreAndMigrateContractResponse":{"description":"MsgStoreAndMigrateContractResponse defines the response structure\nfor executing a MsgStoreAndMigrateContract message.\n\nSince: 0.42","type":"object","properties":{"checksum":{"type":"string","format":"byte","title":"Checksum is the sha256 hash of the stored code"},"code_id":{"type":"string","format":"uint64","title":"CodeID is the reference to the stored WASM code"},"data":{"type":"string","format":"byte","title":"Data contains bytes to returned from the contract"}}},"cosmwasm.wasm.v1.MsgStoreCode":{"type":"object","title":"MsgStoreCode submit Wasm code to the system","properties":{"instantiate_permission":{"title":"InstantiatePermission access control to apply on contract creation,\noptional","$ref":"#/definitions/cosmwasm.wasm.v1.AccessConfig"},"sender":{"type":"string","title":"Sender is the actor that signed the messages"},"wasm_byte_code":{"type":"string","format":"byte","title":"WASMByteCode can be raw or gzip compressed"}}},"cosmwasm.wasm.v1.MsgStoreCodeResponse":{"description":"MsgStoreCodeResponse returns store result data.","type":"object","properties":{"checksum":{"type":"string","format":"byte","title":"Checksum is the sha256 hash of the stored code"},"code_id":{"type":"string","format":"uint64","title":"CodeID is the reference to the stored WASM code"}}},"cosmwasm.wasm.v1.MsgSudoContract":{"description":"MsgSudoContract is the MsgSudoContract request type.\n\nSince: 0.40","type":"object","properties":{"authority":{"description":"Authority is the address of the governance account.","type":"string"},"contract":{"type":"string","title":"Contract is the address of the smart contract"},"msg":{"type":"string","format":"byte","title":"Msg json encoded message to be passed to the contract as sudo"}}},"cosmwasm.wasm.v1.MsgSudoContractResponse":{"description":"MsgSudoContractResponse defines the response structure for executing a\nMsgSudoContract message.\n\nSince: 0.40","type":"object","properties":{"data":{"type":"string","format":"byte","title":"Data contains bytes to returned from the contract"}}},"cosmwasm.wasm.v1.MsgUnpinCodes":{"description":"MsgUnpinCodes is the MsgUnpinCodes request type.\n\nSince: 0.40","type":"object","properties":{"authority":{"description":"Authority is the address of the governance account.","type":"string"},"code_ids":{"type":"array","title":"CodeIDs references the WASM codes","items":{"type":"string","format":"uint64"}}}},"cosmwasm.wasm.v1.MsgUnpinCodesResponse":{"description":"MsgUnpinCodesResponse defines the response structure for executing a\nMsgUnpinCodes message.\n\nSince: 0.40","type":"object"},"cosmwasm.wasm.v1.MsgUpdateAdmin":{"type":"object","title":"MsgUpdateAdmin sets a new admin for a smart contract","properties":{"contract":{"type":"string","title":"Contract is the address of the smart contract"},"new_admin":{"type":"string","title":"NewAdmin address to be set"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"cosmwasm.wasm.v1.MsgUpdateAdminResponse":{"type":"object","title":"MsgUpdateAdminResponse returns empty data"},"cosmwasm.wasm.v1.MsgUpdateContractLabel":{"type":"object","title":"MsgUpdateContractLabel sets a new label for a smart contract","properties":{"contract":{"type":"string","title":"Contract is the address of the smart contract"},"new_label":{"type":"string","title":"NewLabel string to be set"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"cosmwasm.wasm.v1.MsgUpdateContractLabelResponse":{"type":"object","title":"MsgUpdateContractLabelResponse returns empty data"},"cosmwasm.wasm.v1.MsgUpdateInstantiateConfig":{"type":"object","title":"MsgUpdateInstantiateConfig updates instantiate config for a smart contract","properties":{"code_id":{"type":"string","format":"uint64","title":"CodeID references the stored WASM code"},"new_instantiate_permission":{"title":"NewInstantiatePermission is the new access control","$ref":"#/definitions/cosmwasm.wasm.v1.AccessConfig"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"cosmwasm.wasm.v1.MsgUpdateInstantiateConfigResponse":{"type":"object","title":"MsgUpdateInstantiateConfigResponse returns empty data"},"cosmwasm.wasm.v1.MsgUpdateParams":{"description":"MsgUpdateParams is the MsgUpdateParams request type.\n\nSince: 0.40","type":"object","properties":{"authority":{"description":"Authority is the address of the governance account.","type":"string"},"params":{"description":"params defines the x/wasm parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/cosmwasm.wasm.v1.Params"}}},"cosmwasm.wasm.v1.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.\n\nSince: 0.40","type":"object"},"cosmwasm.wasm.v1.Params":{"description":"Params defines the set of wasm parameters.","type":"object","properties":{"code_upload_access":{"$ref":"#/definitions/cosmwasm.wasm.v1.AccessConfig"},"instantiate_default_permission":{"$ref":"#/definitions/cosmwasm.wasm.v1.AccessType"}}},"cosmwasm.wasm.v1.QueryAllContractStateResponse":{"type":"object","title":"QueryAllContractStateResponse is the response type for the\nQuery/AllContractState RPC method","properties":{"models":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmwasm.wasm.v1.Model"}},"pagination":{"description":"pagination defines the pagination in the response.","$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"}}},"cosmwasm.wasm.v1.QueryBuildAddressResponse":{"description":"QueryBuildAddressResponse is the response type for the Query/BuildAddress RPC\nmethod.","type":"object","properties":{"address":{"type":"string","title":"Address is the contract address"}}},"cosmwasm.wasm.v1.QueryCodeResponse":{"type":"object","title":"QueryCodeResponse is the response type for the Query/Code RPC method","properties":{"code_info":{"$ref":"#/definitions/cosmwasm.wasm.v1.CodeInfoResponse"},"data":{"type":"string","format":"byte"}}},"cosmwasm.wasm.v1.QueryCodesResponse":{"type":"object","title":"QueryCodesResponse is the response type for the Query/Codes RPC method","properties":{"code_infos":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmwasm.wasm.v1.CodeInfoResponse"}},"pagination":{"description":"pagination defines the pagination in the response.","$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"}}},"cosmwasm.wasm.v1.QueryContractHistoryResponse":{"type":"object","title":"QueryContractHistoryResponse is the response type for the\nQuery/ContractHistory RPC method","properties":{"entries":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmwasm.wasm.v1.ContractCodeHistoryEntry"}},"pagination":{"description":"pagination defines the pagination in the response.","$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"}}},"cosmwasm.wasm.v1.QueryContractInfoResponse":{"type":"object","title":"QueryContractInfoResponse is the response type for the Query/ContractInfo RPC\nmethod","properties":{"address":{"type":"string","title":"address is the address of the contract"},"contract_info":{"$ref":"#/definitions/cosmwasm.wasm.v1.ContractInfo"}}},"cosmwasm.wasm.v1.QueryContractsByCodeResponse":{"type":"object","title":"QueryContractsByCodeResponse is the response type for the\nQuery/ContractsByCode RPC method","properties":{"contracts":{"type":"array","title":"contracts are a set of contract addresses","items":{"type":"string"}},"pagination":{"description":"pagination defines the pagination in the response.","$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"}}},"cosmwasm.wasm.v1.QueryContractsByCreatorResponse":{"description":"QueryContractsByCreatorResponse is the response type for the\nQuery/ContractsByCreator RPC method.","type":"object","properties":{"contract_addresses":{"type":"array","title":"ContractAddresses result set","items":{"type":"string"}},"pagination":{"description":"Pagination defines the pagination in the response.","$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"}}},"cosmwasm.wasm.v1.QueryParamsResponse":{"description":"QueryParamsResponse is the response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params defines the parameters of the module.","$ref":"#/definitions/cosmwasm.wasm.v1.Params"}}},"cosmwasm.wasm.v1.QueryPinnedCodesResponse":{"type":"object","title":"QueryPinnedCodesResponse is the response type for the\nQuery/PinnedCodes RPC method","properties":{"code_ids":{"type":"array","items":{"type":"string","format":"uint64"}},"pagination":{"description":"pagination defines the pagination in the response.","$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"}}},"cosmwasm.wasm.v1.QueryRawContractStateResponse":{"type":"object","title":"QueryRawContractStateResponse is the response type for the\nQuery/RawContractState RPC method","properties":{"data":{"type":"string","format":"byte","title":"Data contains the raw store data"}}},"cosmwasm.wasm.v1.QuerySmartContractStateResponse":{"type":"object","title":"QuerySmartContractStateResponse is the response type for the\nQuery/SmartContractState RPC method","properties":{"data":{"type":"string","format":"byte","title":"Data contains the json data returned from the smart contract"}}},"google.protobuf.Any":{"type":"object","properties":{"@type":{"type":"string"}},"additionalProperties":{}},"google.rpc.Status":{"type":"object","properties":{"code":{"type":"integer","format":"int32"},"details":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}},"message":{"type":"string"}}},"maps.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.Map":{"type":"object","properties":{"creator":{"type":"string"},"defaultValue":{"type":"string"},"inheritManagerTimelineFrom":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateCriteria":{"title":"config options that will not change at all","$ref":"#/definitions/maps.MapUpdateCriteria"},"valueOptions":{"$ref":"#/definitions/maps.ValueOptions"}}},"maps.MapMetadataTimeline":{"description":"MapMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"metadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/maps.Metadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.MapPermissions":{"type":"object","properties":{"canDeleteMap":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ActionPermission"}},"canUpdateManager":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.TimedUpdatePermission"}},"canUpdateMetadata":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.TimedUpdatePermission"}}}},"maps.MapUpdateCriteria":{"type":"object","properties":{"collectionId":{"type":"string","title":"ID slots are only updatable by badge ID owner of this collection (\u003e1 balance at current time)"},"creatorOnly":{"type":"boolean","title":"Keys are address based and can only be updated by that respective address"},"firstComeFirstServe":{"description":"Claim slots. Can unclaim by setting to blank. Uses lastSetBy.","type":"boolean"},"managerOnly":{"type":"boolean","title":"All ID slots are only updatable by manager"}}},"maps.Metadata":{"description":"This message defines the metadata for the map.\nThe interpretation of this metadata should follow the map standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the map metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the map metadata.","type":"string"}}},"maps.MsgCreateMap":{"type":"object","properties":{"creator":{"type":"string"},"defaultValue":{"type":"string"},"inheritManagerTimelineFrom":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateCriteria":{"title":"config options that will not change at all","$ref":"#/definitions/maps.MapUpdateCriteria"},"valueOptions":{"$ref":"#/definitions/maps.ValueOptions"}}},"maps.MsgCreateMapResponse":{"type":"object"},"maps.MsgDeleteMap":{"type":"object","properties":{"creator":{"type":"string"},"mapId":{"type":"string"}}},"maps.MsgDeleteMapResponse":{"type":"object"},"maps.MsgSetValue":{"type":"object","properties":{"creator":{"type":"string"},"key":{"type":"string"},"mapId":{"type":"string"},"options":{"$ref":"#/definitions/maps.SetOptions"},"value":{"type":"string"}}},"maps.MsgSetValueResponse":{"type":"object"},"maps.MsgUpdateMap":{"type":"object","properties":{"creator":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateManagerTimeline":{"type":"boolean"},"updateMetadataTimeline":{"type":"boolean"},"updatePermissions":{"type":"boolean"}}},"maps.MsgUpdateMapResponse":{"type":"object"},"maps.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/maps.Params"}}},"maps.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"maps.Params":{"description":"Params defines the parameters for the module.","type":"object"},"maps.QueryGetMapResponse":{"type":"object","properties":{"map":{"$ref":"#/definitions/maps.Map"}}},"maps.QueryGetMapValueResponse":{"type":"object","properties":{"value":{"$ref":"#/definitions/maps.ValueStore"}}},"maps.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/maps.Params"}}},"maps.SetOptions":{"type":"object","properties":{"useMostRecentCollectionId":{"type":"boolean"}}},"maps.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\n\nuintRanges are one of the core types used in the BitBadgesChain module.\nThey are used for everything from badge IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"maps.ValueOptions":{"type":"object","properties":{"expectAddress":{"type":"boolean"},"expectBoolean":{"type":"boolean"},"expectUint":{"type":"boolean"},"expectUri":{"type":"boolean"},"noDuplicates":{"type":"boolean"},"permanentOnceSet":{"type":"boolean"}}},"maps.ValueStore":{"type":"object","properties":{"key":{"type":"string"},"lastSetBy":{"type":"string"},"value":{"type":"string"}}},"wasmx.GenesisState":{"description":"GenesisState defines the wasmx module's genesis state.","type":"object","properties":{"params":{"description":"params defines all the parameters of the module.","$ref":"#/definitions/wasmx.Params"},"port_id":{"type":"string"}}},"wasmx.MsgExecuteContractCompat":{"type":"object","title":"MsgExecuteContractCompat submits the given message data to a smart contract, compatible with EIP712","properties":{"contract":{"type":"string","title":"Contract is the address of the smart contract"},"funds":{"type":"string","title":"Funds coins that are transferred to the contract on execution"},"msg":{"type":"string","title":"Msg json encoded message to be passed to the contract"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"wasmx.MsgExecuteContractCompatResponse":{"description":"MsgExecuteContractCompatResponse returns execution result data.","type":"object","properties":{"data":{"type":"string","format":"byte","title":"Data contains bytes to returned from the contract"}}},"wasmx.MsgInstantiateContractCompat":{"type":"object","properties":{"codeId":{"type":"string","title":"Code ID obtained from store wasm code"},"funds":{"type":"string","title":"Funds coins that are transferred to the contract on instantiation"},"label":{"type":"string","title":"Label is a human-readable string for labelling the contract"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"wasmx.MsgInstantiateContractCompatResponse":{"description":"MsgInstantiateContractCompatResponse returns store result data.","type":"object","properties":{"address":{"type":"string"},"data":{"type":"string","format":"byte"}}},"wasmx.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/wasmx.Params"}}},"wasmx.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"wasmx.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"is_execution_enabled":{"description":"Set the status to active to indicate that contracts can be executed in begin blocker.","type":"boolean"},"max_begin_block_total_gas":{"description":"Maximum aggregate total gas to be used for the contract executions in the BeginBlocker.","type":"string","format":"uint64"},"max_contract_gas_limit":{"description":"the maximum gas limit each individual contract can consume in the BeginBlocker.","type":"string","format":"uint64"},"min_gas_price":{"description":"min_gas_price defines the minimum gas price the contracts must pay to be executed in the BeginBlocker.","type":"string","format":"uint64"}}},"wasmx.QueryModuleStateResponse":{"description":"QueryModuleStateResponse is the response type for the Query/WasmxModuleState RPC method.","type":"object","properties":{"state":{"$ref":"#/definitions/wasmx.GenesisState"}}},"wasmx.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/wasmx.Params"}}},"wasmx.QueryWasmxParamsResponse":{"description":"QueryWasmxParamsRequest is the response type for the Query/WasmxParams RPC method.","type":"object","properties":{"params":{"$ref":"#/definitions/wasmx.Params"}}}},"tags":[{"name":"Query"},{"name":"Msg"}]}