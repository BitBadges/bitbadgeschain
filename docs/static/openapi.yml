{"id":"github.com/bitbadges/bitbadgeschain","consumes":["application/json"],"produces":["application/json"],"swagger":"2.0","info":{"description":"Chain github.com/bitbadges/bitbadgeschain REST API","title":"HTTP API Console","contact":{"name":"github.com/bitbadges/bitbadgeschain"},"version":"version not set"},"paths":{"/anchor.Msg/AddCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_AddCustomData","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/anchor.MsgAddCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.MsgAddCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/anchor.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParams","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/anchor.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressLists","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollection","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollection","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/TransferBadges":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferBadges","parameters":[{"description":"MsgTransferBadges is used to transfer badges.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgTransferBadges"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgTransferBadgesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollection","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollection","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin17","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovals","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v6.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressListsMixin28","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v6.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v6.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v6.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollectionMixin28","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v6.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v6.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v6.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollectionMixin28","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v6.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v6.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v6.Msg/TransferBadges":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferBadgesMixin28","parameters":[{"description":"MsgTransferBadges is used to transfer badges.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v6.MsgTransferBadges"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v6.MsgTransferBadgesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v6.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollectionMixin28","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v6.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v6.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v6.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollectionMixin28","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v6.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v6.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v6.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin28","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v6.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v6.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v6.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovalsMixin28","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v6.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v6.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_address_list/{listId}":{"get":{"tags":["Query"],"summary":"Queries an address list by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetAddressList","parameters":[{"type":"string","name":"listId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetAddressListResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_approvals_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{amountTrackerId}/{trackerType}/{approvedAddress}":{"get":{"tags":["Query"],"summary":"Queries an approvals tracker by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetApprovalTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"amountTrackerId","in":"path","required":true},{"type":"string","name":"trackerType","in":"path","required":true},{"type":"string","description":"if trackerType is \"overall\", leave blank","name":"approvedAddress","in":"path","required":true},{"type":"string","name":"approvalId","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetApprovalTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_balance/{collectionId}/{address}":{"get":{"tags":["Query"],"summary":"Queries an addresses balance for a badge collection, specified by its ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetBalance","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetBalanceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_challenge_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{challengeTrackerId}/{leafIndex}":{"get":{"tags":["Query"],"summary":"Queries the number of times a given leaf has been used for a given merkle challenge.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetChallengeTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"challengeTrackerId","in":"path","required":true},{"type":"string","name":"leafIndex","in":"path","required":true},{"type":"string","name":"approvalId","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetChallengeTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_collection/{collectionId}":{"get":{"tags":["Query"],"summary":"Queries a badge collection by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetCollection","parameters":[{"type":"string","name":"collectionId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin14","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin38","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/{mapId}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_Map","parameters":[{"type":"string","name":"mapId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryGetMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/{mapId}/{key}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_MapValue","parameters":[{"type":"string","name":"mapId","in":"path","required":true},{"type":"string","name":"key","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryGetMapValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/anchor/locations/{locationId}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_GetValueAtLocation","parameters":[{"type":"string","name":"locationId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.QueryGetValueAtLocationResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/anchor/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_Params","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/CreateMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgCreateMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgCreateMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/DeleteMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgDeleteMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgDeleteMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/SetValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValue","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgSetValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgSetValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/UpdateMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgUpdateMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgUpdateMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/UpdateParams":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin40","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}}},"definitions":{"anchor.AnchorData":{"type":"object","properties":{"creator":{"type":"string"},"data":{"type":"string"},"timestamp":{"type":"string"}}},"anchor.MsgAddCustomData":{"type":"object","properties":{"creator":{"type":"string"},"data":{"type":"string"}}},"anchor.MsgAddCustomDataResponse":{"type":"object","properties":{"locationId":{"description":"ID of the anchor location.","type":"string"}}},"anchor.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"NOTE: All parameters must be supplied.","$ref":"#/definitions/anchor.Params"}}},"anchor.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"anchor.Params":{"description":"Params defines the parameters for the module.","type":"object"},"anchor.QueryGetValueAtLocationResponse":{"type":"object","properties":{"anchorData":{"$ref":"#/definitions/anchor.AnchorData"}}},"anchor.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/anchor.Params"}}},"badges.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"badges.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified badge IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.ResetTimeIntervals"}}},"badges.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnBadges"}},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"userRoyalties":{"description":"User level royalties to apply to the transfer.","$ref":"#/definitions/badges.UserRoyalties"}}},"badges.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"badges.ApprovalTracker":{"description":"ApprovalTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.","type":"object","properties":{"amounts":{"description":"Cumulative balances associated with the transfers that have been processed.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"lastUpdatedAt":{"description":"Last updated at time.","type":"string"},"numTransfers":{"description":"The number of transfers that have been processed.","type":"string"}}},"badges.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"}}},"badges.BadgeCollection":{"description":"A BadgeCollection is the top-level object for a collection of badges. \nIt defines everything about the collection, such as the manager, metadata, etc.\n\nAll collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).\n\nAll collections can have a manager who is responsible for managing the collection and can be granted certain admin\npermissions, such as the ability to mint new badges.\n\nCertain fields are timeline-based, which means they may have different values at different block heights. \nWe fetch the value according to the current time.\nFor example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.\n\nCollections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.\n\nSee documentation for more details.","type":"object","properties":{"badgeMetadataTimeline":{"description":"The metadata for each badge in the collection, also subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"balancesType":{"description":"The type of balances this collection uses (\"Standard\", \"Off-Chain - Indexed\", \"Off-Chain - Non-Indexed\", or \"Non-Public\").","type":"string"},"collectionApprovals":{"description":"Transferability of the collection for collections with standard balances, subject to changes over time.\nOverrides user approvals for a transfer if specified.\nTransfer must satisfy both user and collection-level approvals.\nOnly applicable to on-chain balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.","type":"string"},"collectionMetadataTimeline":{"description":"The metadata for the collection itself, which can vary over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Permissions that define what the manager of the collection can do or not do.","$ref":"#/definitions/badges.CollectionPermissions"},"createdBy":{"description":"The user or entity who created the badge collection.","type":"string"},"customDataTimeline":{"description":"An arbitrary field that can store any data, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"description":"The default store of a balance for a user, upon genesis.","$ref":"#/definitions/badges.UserBalanceStore"},"isArchivedTimeline":{"description":"Whether the collection is archived or not, subject to changes over time.\nWhen archived, it becomes read-only, and no transactions can be processed until it is unarchived.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"The address of the manager of this collection, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowAddress":{"description":"The generated address of the badge collection. Also used to escrow Mint balances.","type":"string"},"offChainBalancesMetadataTimeline":{"description":"Metadata for fetching balances for collections with off-chain balances, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"Standards that define how to interpret the fields of the collection, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"validBadgeIds":{"description":"The valid badge IDs for this collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.BadgeIdsActionPermission":{"description":"BadgeIdsActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.\nCurrently, this is only used for creating new badges.\n\nEx: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.BadgeMetadata":{"description":"This message defines the metadata for specific badge IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"badgeIds":{"description":"The badge IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Custom data or additional information related to the badge metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the badge metadata.","type":"string"}}},"badges.BadgeMetadataTimeline":{"description":"BadgeMetadataTimeline defines the metadata for badges at different timeline times.","type":"object","properties":{"badgeMetadata":{"description":"The badge metadata for a specific timeline element.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadata"}},"timelineTimes":{"description":"The timeline times when the badge metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.Balance":{"description":"Balance represents the balance of a badge for a specific user.\nThe user amounts xAmount of a badge for the badgeID specified for the time ranges specified.\n\nExample: User A owns x10 of badge IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or badgeIDs have len \u003e 1, then the user owns all badge IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the badge owned by the user.","type":"string"},"badgeIds":{"description":"The badge IDs for which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"ownershipTimes":{"description":"The time ranges during which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"badges.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, badgeIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\nTimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden at all timelineTimes.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"badges.CollectionMetadataTimeline":{"description":"CollectionMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"collectionMetadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/badges.CollectionMetadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BadgeIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action.\n- TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.\n- TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.\n- BadgeIdsActionPermission: defines when the manager can perform an action for specific badges\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- timelineTimes: the times when a timeline-based field is a specific value\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a badge is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateBadgeMetadata":{"description":"Permissions related to updating badge metadata for specific badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdateWithBadgeIdsPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateOffChainBalancesMetadata":{"description":"Permissions related to updating off-chain balances metadata.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateValidBadgeIds":{"description":"Permissions related to creating more badges for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeIdsActionPermission"}}}},"badges.CustomDataTimeline":{"description":"CustomDataTimeline defines custom data at different timeline times.","type":"object","properties":{"customData":{"description":"The custom data for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the custom data is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidBadge":{"type":"boolean","title":"Allow override of any valid badge"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementBadgeIdsBy":{"description":"The amount by which to increment badge IDs.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/badges.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}}}},"badges.IsArchivedTimeline":{"description":"IsArchivedTimeline defines whether a collection is archived at different timeline times.","type":"object","properties":{"isArchived":{"description":"Indicates whether the collection is archived for a specific timeline element.","type":"boolean"},"timelineTimes":{"description":"The timeline times when the archived status is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}}}},"badges.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified badge IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.ResetTimeIntervals"}}},"badges.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"type":"string","title":"Leaf must be signed by. Used to protect against man in the middle attacks.`\nScheme we use is sign(leaf + \"-\" +"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"badges.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"badges.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"badges.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.AddressList"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"badges.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"Badge metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionMetadataTimeline":{"description":"Collection metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/badges.CollectionPermissions"},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"Custom data timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.UserBalanceStore"},"isArchivedTimeline":{"description":"isArchived timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"Manager timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"Off-chain balances metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"Standards timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"badges.MsgTransferBadges":{"description":"MsgTransferBadges is used to transfer badges.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Transfer"}}}},"badges.MsgTransferBadgesResponse":{"description":"MsgTransferBadgesResponse is the response to MsgTransferBadges.","type":"object"},"badges.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.CollectionPermissions"},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.UserBalanceStore"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.CollectionPermissions"},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/badges.Params"}}},"badges.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"badges.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/badges.UserPermissions"}}},"badges.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"badges.MustOwnBadges":{"description":"MustOwnBadges represents a condition where a user must own specific badges\nto be approved to transfer.\n\n- collectionId: The ID of the badge collection for the badges that must be owned\n- amountRange: The range of badge amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the badges.\n- badgeIds: The badge IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified badges; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of badge amounts the user must own (min to max).","$ref":"#/definitions/badges.UintRange"},"badgeIds":{"description":"The badge IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"collectionId":{"description":"The ID of the badge collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified badges; else, must meet requirements for any single badge.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipTimes":{"description":"The time ranges during which the user must own the badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.OffChainBalancesMetadata":{"description":"This message defines the metadata for off-chain balances (if using an off-chain balances type).\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the off-chain balances metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the off-chain balances metadata.","type":"string"}}},"badges.OffChainBalancesMetadataTimeline":{"description":"OffChainBalancesMetadataTimeline defines the metadata for off-chain balances at different timeline times.","type":"object","properties":{"offChainBalancesMetadata":{"description":"The off-chain balances metadata for a specific timeline element.","$ref":"#/definitions/badges.OffChainBalancesMetadata"},"timelineTimes":{"description":"The timeline times when the off-chain balances metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own badges for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.Params":{"description":"Params defines the parameters for the module.","type":"object"},"badges.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"badgeIdsOverride":{"description":"The badgeIdsOverride to use for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"}}},"badges.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/badges.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/badges.PredeterminedOrderCalculationMethod"}}},"badges.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"badges.QueryGetAddressListResponse":{"type":"object","properties":{"list":{"$ref":"#/definitions/badges.AddressList"}}},"badges.QueryGetApprovalTrackerResponse":{"type":"object","properties":{"tracker":{"$ref":"#/definitions/badges.ApprovalTracker"}}},"badges.QueryGetBalanceResponse":{"type":"object","properties":{"balance":{"$ref":"#/definitions/badges.UserBalanceStore"}}},"badges.QueryGetChallengeTrackerResponse":{"type":"object","properties":{"numUsed":{"type":"string"}}},"badges.QueryGetCollectionResponse":{"type":"object","properties":{"collection":{"$ref":"#/definitions/badges.BadgeCollection"}}},"badges.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/badges.Params"}}},"badges.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"badges.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"badges.StandardsTimeline":{"description":"StandardsTimeline defines the standards used for a collection at different timeline times.","type":"object","properties":{"standards":{"description":"The standards applied to the collection for a specific timeline element.","type":"array","items":{"type":"string"}},"timelineTimes":{"description":"The timeline times when the standards are valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.TimedUpdateWithBadgeIdsPermission":{"description":"TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.\n\nEx: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.Transfer":{"description":"Transfer defines the details of a transfer of badges.","type":"object","properties":{"affiliateAddress":{"description":"Affiliate address for the transfer.","type":"string"},"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleProof"}},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/badges.ApprovalIdentifierDetails"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/badges.PrecalculationOptions"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"badges.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from badge IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"badges.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/badges.UserPermissions"}}},"badges.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApprovalPermission"}}}},"badges.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"badges.v6.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"badges.v6.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified badge IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v6.ResetTimeIntervals"}}},"badges.v6.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v6.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v6.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v6.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.MerkleChallenge"}},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v6.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v6.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"badges.v6.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"}}},"badges.v6.BadgeIdsActionPermission":{"description":"BadgeIdsActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.\nCurrently, this is only used for creating new badges.\n\nEx: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.BadgeMetadata":{"description":"This message defines the metadata for specific badge IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"badgeIds":{"description":"The badge IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"customData":{"description":"Custom data or additional information related to the badge metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the badge metadata.","type":"string"}}},"badges.v6.BadgeMetadataTimeline":{"description":"BadgeMetadataTimeline defines the metadata for badges at different timeline times.","type":"object","properties":{"badgeMetadata":{"description":"The badge metadata for a specific timeline element.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.BadgeMetadata"}},"timelineTimes":{"description":"The timeline times when the badge metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.Balance":{"description":"Balance represents the balance of a badge for a specific user.\nThe user amounts xAmount of a badge for the badgeID specified for the time ranges specified.\n\nExample: User A owns x10 of badge IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or badgeIDs have len \u003e 1, then the user owns all badge IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the badge owned by the user.","type":"string"},"badgeIds":{"description":"The badge IDs for which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"ownershipTimes":{"description":"The time ranges during which the user owns the badge.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"badges.v6.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v6.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v6.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, badgeIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\nTimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden at all timelineTimes.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"badges.v6.CollectionMetadataTimeline":{"description":"CollectionMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"collectionMetadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/badges.v6.CollectionMetadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BadgeIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action.\n- TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.\n- TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.\n- BadgeIdsActionPermission: defines when the manager can perform an action for specific badges\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- timelineTimes: the times when a timeline-based field is a specific value\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a badge is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.TimedUpdatePermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.ActionPermission"}},"canUpdateBadgeMetadata":{"description":"Permissions related to updating badge metadata for specific badges.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.TimedUpdateWithBadgeIdsPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.TimedUpdatePermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.TimedUpdatePermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.TimedUpdatePermission"}},"canUpdateOffChainBalancesMetadata":{"description":"Permissions related to updating off-chain balances metadata.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.TimedUpdatePermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.TimedUpdatePermission"}},"canUpdateValidBadgeIds":{"description":"Permissions related to creating more badges for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.BadgeIdsActionPermission"}}}},"badges.v6.CustomDataTimeline":{"description":"CustomDataTimeline defines custom data at different timeline times.","type":"object","properties":{"customData":{"description":"The custom data for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the custom data is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v6.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v6.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v6.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.MerkleChallenge"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v6.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v6.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidBadge":{"type":"boolean","title":"Allow override of any valid badge"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementBadgeIdsBy":{"description":"The amount by which to increment badge IDs.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/badges.v6.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.Balance"}}}},"badges.v6.IsArchivedTimeline":{"description":"IsArchivedTimeline defines whether a collection is archived at different timeline times.","type":"object","properties":{"isArchived":{"description":"Indicates whether the collection is archived for a specific timeline element.","type":"boolean"},"timelineTimes":{"description":"The timeline times when the archived status is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.Balance"}}}},"badges.v6.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified badge IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v6.ResetTimeIntervals"}}},"badges.v6.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"type":"string","title":"Leaf must be signed by. Used to protect against man in the middle attacks.`\nScheme we use is sign(leaf + \"-\" +"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"badges.v6.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"badges.v6.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"badges.v6.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.AddressList"}},"creator":{"description":"Address of the creator.","type":"string"},"creatorOverride":{"description":"Address of the original creator. Used for CosmWASM purposes. \nIMPORTANT: We will override but we must trust the original creator address.","type":"string"}}},"badges.v6.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"badges.v6.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"Badge metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CollectionApproval"}},"collectionMetadataTimeline":{"description":"Collection metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/badges.v6.CollectionPermissions"},"creator":{"description":"Address of the creator.","type":"string"},"creatorOverride":{"description":"Address of the original creator. Used for CosmWASM purposes. \nIMPORTANT: We will override but we must trust the original creator address.","type":"string"},"customDataTimeline":{"description":"Custom data timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v6.UserBalanceStore"},"isArchivedTimeline":{"description":"isArchived timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.IsArchivedTimeline"}},"managerTimeline":{"description":"Manager timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"Off-chain balances metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"Standards timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.StandardsTimeline"}},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v6.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"creatorOverride":{"description":"Address of the original creator. Used for CosmWASM purposes. \nIMPORTANT: We will override but we must trust the original creator address.","type":"string"}}},"badges.v6.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"badges.v6.MsgTransferBadges":{"description":"MsgTransferBadges is used to transfer badges.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"creatorOverride":{"description":"Address of the original creator. Used for CosmWASM purposes. \nIMPORTANT: We will override but we must trust the original creator address.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.Transfer"}}}},"badges.v6.MsgTransferBadgesResponse":{"description":"MsgTransferBadgesResponse is the response to MsgTransferBadges.","type":"object"},"badges.v6.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.BadgeMetadataTimeline"}},"balancesType":{"description":"Type of balances \"Standard\" or \"Off-Chain - Indexed\" or \"Off-Chain - Non-Indexed\" or \"Non-Public\".","type":"string"},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v6.CollectionPermissions"},"creator":{"description":"Address of the creator.","type":"string"},"creatorOverride":{"description":"Address of the original creator. Used for CosmWASM purposes. \nIMPORTANT: We will override but we must trust the original creator address.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v6.UserBalanceStore"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v6.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New badge metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v6.CollectionPermissions"},"creator":{"description":"Address of the creator.","type":"string"},"creatorOverride":{"description":"Address of the original creator. Used for CosmWASM purposes. \nIMPORTANT: We will override but we must trust the original creator address.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CustomDataTimeline"}},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"offChainBalancesMetadataTimeline":{"description":"New off-chain balances metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.OffChainBalancesMetadataTimeline"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOffChainBalancesMetadataTimeline":{"description":"Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid badge IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New badge IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the badge collection.","type":"string"}}},"badges.v6.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/badges.Params"}}},"badges.v6.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"badges.v6.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"creatorOverride":{"description":"Address of the original creator. Used for CosmWASM purposes. \nIMPORTANT: We will override but we must trust the original creator address.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/badges.v6.UserPermissions"}}},"badges.v6.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"badges.v6.OffChainBalancesMetadata":{"description":"This message defines the metadata for off-chain balances (if using an off-chain balances type).\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the off-chain balances metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the off-chain balances metadata.","type":"string"}}},"badges.v6.OffChainBalancesMetadataTimeline":{"description":"OffChainBalancesMetadataTimeline defines the metadata for off-chain balances at different timeline times.","type":"object","properties":{"offChainBalancesMetadata":{"description":"The off-chain balances metadata for a specific timeline element.","$ref":"#/definitions/badges.v6.OffChainBalancesMetadata"},"timelineTimes":{"description":"The timeline times when the off-chain balances metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v6.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v6.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.CoinTransfer"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v6.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.MerkleChallenge"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v6.PredeterminedBalances"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v6.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"badgeIdsOverride":{"description":"The badgeIdsOverride to use for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"}}},"badges.v6.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/badges.v6.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/badges.v6.PredeterminedOrderCalculationMethod"}}},"badges.v6.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"badges.v6.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"badges.v6.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"badges.v6.StandardsTimeline":{"description":"StandardsTimeline defines the standards used for a collection at different timeline times.","type":"object","properties":{"standards":{"description":"The standards applied to the collection for a specific timeline element.","type":"array","items":{"type":"string"}},"timelineTimes":{"description":"The timeline times when the standards are valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.TimedUpdateWithBadgeIdsPermission":{"description":"TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.\n\nEx: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.Transfer":{"description":"Transfer defines the details of a transfer of badges.","type":"object","properties":{"affiliateAddress":{"description":"Affiliate address for the transfer.","type":"string"},"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.Balance"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.MerkleProof"}},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/badges.v6.ApprovalIdentifierDetails"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/badges.v6.PrecalculationOptions"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"badges.v6.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from badge IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"badges.v6.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/badges.v6.UserPermissions"}}},"badges.v6.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v6.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v6.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v6.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of badge IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v6.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the badge IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the badges in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UintRange"}}}},"badges.v6.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v6.UserOutgoingApprovalPermission"}}}},"cosmos.base.v1beta1.Coin":{"description":"Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.","type":"object","properties":{"amount":{"type":"string"},"denom":{"type":"string"}}},"google.protobuf.Any":{"type":"object","properties":{"@type":{"type":"string"}},"additionalProperties":{}},"google.rpc.Status":{"type":"object","properties":{"code":{"type":"integer","format":"int32"},"details":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}},"message":{"type":"string"}}},"maps.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.Map":{"type":"object","properties":{"creator":{"type":"string"},"defaultValue":{"type":"string"},"inheritManagerTimelineFrom":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateCriteria":{"title":"config options that will not change at all","$ref":"#/definitions/maps.MapUpdateCriteria"},"valueOptions":{"$ref":"#/definitions/maps.ValueOptions"}}},"maps.MapMetadataTimeline":{"description":"MapMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"metadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/maps.Metadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.MapPermissions":{"type":"object","properties":{"canDeleteMap":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ActionPermission"}},"canUpdateManager":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.TimedUpdatePermission"}},"canUpdateMetadata":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.TimedUpdatePermission"}}}},"maps.MapUpdateCriteria":{"type":"object","properties":{"collectionId":{"type":"string","title":"ID slots are only updatable by badge ID owner of this collection (\u003e1 balance at current time)"},"creatorOnly":{"type":"boolean","title":"Keys are address based and can only be updated by that respective address"},"firstComeFirstServe":{"description":"Claim slots. Can unclaim by setting to blank. Uses lastSetBy.","type":"boolean"},"managerOnly":{"type":"boolean","title":"All ID slots are only updatable by manager"}}},"maps.Metadata":{"description":"This message defines the metadata for the map.\nThe interpretation of this metadata should follow the map standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the map metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the map metadata.","type":"string"}}},"maps.MsgCreateMap":{"type":"object","properties":{"creator":{"type":"string"},"defaultValue":{"type":"string"},"inheritManagerTimelineFrom":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateCriteria":{"title":"config options that will not change at all","$ref":"#/definitions/maps.MapUpdateCriteria"},"valueOptions":{"$ref":"#/definitions/maps.ValueOptions"}}},"maps.MsgCreateMapResponse":{"type":"object"},"maps.MsgDeleteMap":{"type":"object","properties":{"creator":{"type":"string"},"mapId":{"type":"string"}}},"maps.MsgDeleteMapResponse":{"type":"object"},"maps.MsgSetValue":{"type":"object","properties":{"creator":{"type":"string"},"key":{"type":"string"},"mapId":{"type":"string"},"options":{"$ref":"#/definitions/maps.SetOptions"},"value":{"type":"string"}}},"maps.MsgSetValueResponse":{"type":"object"},"maps.MsgUpdateMap":{"type":"object","properties":{"creator":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateManagerTimeline":{"type":"boolean"},"updateMetadataTimeline":{"type":"boolean"},"updatePermissions":{"type":"boolean"}}},"maps.MsgUpdateMapResponse":{"type":"object"},"maps.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/maps.Params"}}},"maps.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"maps.Params":{"description":"Params defines the parameters for the module.","type":"object"},"maps.QueryGetMapResponse":{"type":"object","properties":{"map":{"$ref":"#/definitions/maps.Map"}}},"maps.QueryGetMapValueResponse":{"type":"object","properties":{"value":{"$ref":"#/definitions/maps.ValueStore"}}},"maps.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/maps.Params"}}},"maps.SetOptions":{"type":"object","properties":{"useMostRecentCollectionId":{"type":"boolean"}}},"maps.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\n\nuintRanges are one of the core types used in the BitBadgesChain module.\nThey are used for everything from badge IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"maps.ValueOptions":{"type":"object","properties":{"expectAddress":{"type":"boolean"},"expectBoolean":{"type":"boolean"},"expectUint":{"type":"boolean"},"expectUri":{"type":"boolean"},"noDuplicates":{"type":"boolean"},"permanentOnceSet":{"type":"boolean"}}},"maps.ValueStore":{"type":"object","properties":{"key":{"type":"string"},"lastSetBy":{"type":"string"},"value":{"type":"string"}}}},"tags":[{"name":"Query"},{"name":"Msg"}]}