{"id":"github.com/bitbadges/bitbadgeschain","consumes":["application/json"],"produces":["application/json"],"swagger":"2.0","info":{"description":"Chain github.com/bitbadges/bitbadgeschain REST API","title":"HTTP API Console","contact":{"name":"github.com/bitbadges/bitbadgeschain"},"version":"version not set"},"paths":{"/anchor.Msg/AddCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_AddCustomData","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/anchor.MsgAddCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.MsgAddCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/anchor.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParams","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/anchor.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/managersplitter":{"get":{"tags":["Query"],"summary":"AllManagerSplitters queries all manager splitters.","operationId":"GithubCombitbadgesbitbadgeschainQuery_AllManagerSplitters","parameters":[{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/managersplitter.QueryAllManagerSplittersResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/managersplitter/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin23","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/managersplitter.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/managersplitter/{address}":{"get":{"tags":["Query"],"summary":"ManagerSplitter queries a manager splitter by address.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ManagerSplitter","parameters":[{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/managersplitter.QueryGetManagerSplitterResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin31","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/{mapId}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_Map","parameters":[{"type":"string","name":"mapId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryGetMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/{mapId}/{key}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_MapValue","parameters":[{"type":"string","name":"mapId","in":"path","required":true},{"type":"string","name":"key","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryGetMapValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/sendmanager/balance/{address}/{denom}":{"get":{"tags":["Query"],"summary":"Balance queries the balance of a specific denom for an address with alias routing.\nThis allows querying both standard coins and alias denoms (e.g., badgeslp:).","operationId":"GithubCombitbadgesbitbadgeschainQuery_Balance","parameters":[{"type":"string","description":"address is the address to query balances for.","name":"address","in":"path","required":true},{"type":"string","description":"denom is the specific denomination to query the balance for.","name":"denom","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/sendmanager.QueryBalanceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/sendmanager/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin43","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/sendmanager.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_address_list/{listId}":{"get":{"tags":["Query"],"summary":"Queries an address list by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetAddressList","parameters":[{"type":"string","name":"listId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetAddressListResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_all_reserved_protocol_addresses":{"get":{"tags":["Query"],"summary":"Queries all reserved protocol addresses.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetAllReservedProtocolAddresses","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetAllReservedProtocolAddressesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_approvals_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{amountTrackerId}/{trackerType}/{approvedAddress}":{"get":{"tags":["Query"],"summary":"Queries an approvals tracker by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetApprovalTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"amountTrackerId","in":"path","required":true},{"type":"string","name":"trackerType","in":"path","required":true},{"type":"string","description":"if trackerType is \"overall\", leave blank","name":"approvedAddress","in":"path","required":true},{"type":"string","name":"approvalId","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetApprovalTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_balance/{collectionId}/{address}":{"get":{"tags":["Query"],"summary":"Queries an addresses balance for a collection, specified by its ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetBalance","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetBalanceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_challenge_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{challengeTrackerId}/{leafIndex}":{"get":{"tags":["Query"],"summary":"Queries the number of times a given leaf has been used for a given merkle challenge.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetChallengeTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"challengeTrackerId","in":"path","required":true},{"type":"string","name":"leafIndex","in":"path","required":true},{"type":"string","name":"approvalId","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetChallengeTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_collection/{collectionId}":{"get":{"tags":["Query"],"summary":"Queries a collection by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetCollection","parameters":[{"type":"string","name":"collectionId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_collection_stats/{collectionId}":{"get":{"tags":["Query"],"summary":"Queries collection stats (holder count and circulating supply) by collection ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetCollectionStats","parameters":[{"type":"string","name":"collectionId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetCollectionStatsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_dynamic_store/{storeId}":{"get":{"tags":["Query"],"summary":"Queries a dynamic store by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetDynamicStore","parameters":[{"type":"string","name":"storeId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_dynamic_store_value/{storeId}/{address}":{"get":{"tags":["Query"],"summary":"Queries a dynamic store value by store ID and address.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetDynamicStoreValue","parameters":[{"type":"string","name":"storeId","in":"path","required":true},{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_eth_signature_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{approvalId}/{challengeTrackerId}/{signature}":{"get":{"tags":["Query"],"summary":"Queries the number of times a given signature has been used for a given ETH signature challenge.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetETHSignatureTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"approvalId","in":"path","required":true},{"type":"string","name":"challengeTrackerId","in":"path","required":true},{"type":"string","name":"signature","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetETHSignatureTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_vote/{collectionId}/{approvalLevel}/{approverAddress}/{approvalId}/{proposalId}/{voterAddress}":{"get":{"tags":["Query"],"summary":"Queries a vote by collection ID, approval level, approver address, approval ID, proposal ID, and voter address.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetVote","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"approvalId","in":"path","required":true},{"type":"string","name":"proposalId","in":"path","required":true},{"type":"string","name":"voterAddress","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetVoteResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_votes/{collectionId}/{approvalLevel}/{approverAddress}/{approvalId}/{proposalId}":{"get":{"tags":["Query"],"summary":"Queries all votes for a proposal.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetVotes","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"approvalId","in":"path","required":true},{"type":"string","name":"proposalId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetVotesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/get_wrappable_balances/{denom}/{address}":{"get":{"tags":["Query"],"summary":"Queries the maximum wrappable amount for a given denom and user address.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetWrappableBalances","parameters":[{"type":"string","name":"denom","in":"path","required":true},{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryGetWrappableBalancesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/is_address_reserved_protocol/{address}":{"get":{"tags":["Query"],"summary":"Queries if an address is a reserved protocol address.","operationId":"GithubCombitbadgesbitbadgeschainQuery_IsAddressReservedProtocol","parameters":[{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryIsAddressReservedProtocolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/tokenization/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin62","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/anchor/locations/{locationId}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_GetValueAtLocation","parameters":[{"type":"string","name":"locationId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.QueryGetValueAtLocationResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/anchor/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_Params","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmos.evm.vm.v1.Msg/RegisterPreinstalls":{"post":{"tags":["Msg"],"summary":"RegisterPreinstalls defines a governance operation for directly registering\npreinstalled contracts in the EVM. The authority is the same as is used for\nParams updates.","operationId":"Erc20Msg_RegisterPreinstalls","parameters":[{"description":"MsgRegisterPreinstalls defines a Msg for creating preinstalls in evm state.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmos.evm.vm.v1.MsgRegisterPreinstalls"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmos.evm.vm.v1.MsgRegisterPreinstallsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmos.evm.vm.v1.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defined a governance operation for updating the x/vm module\nparameters. The authority is hard-coded to the Cosmos SDK x/gov module\naccount","operationId":"Erc20Msg_UpdateParams","parameters":[{"description":"MsgUpdateParams defines a Msg for updating the x/vm module parameters.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/cosmos.evm.vm.v1.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmos.evm.vm.v1.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/cosmos/evm/vm/v1/ethereum_tx":{"post":{"tags":["Msg"],"summary":"EthereumTx defines a method submitting Ethereum transactions.","operationId":"Erc20Msg_EthereumTx","parameters":[{"type":"string","format":"byte","description":"from is the bytes of ethereum signer address. This address value is checked\nagainst the address derived from the signature (V, R, S) using the\nsecp256k1 elliptic curve","name":"from","in":"query"},{"type":"string","format":"byte","description":"raw is the raw ethereum transaction","name":"raw","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/cosmos.evm.vm.v1.MsgEthereumTxResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.poolmodels.balancer.Msg/CreateBalancerPool":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateBalancerPool","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.poolmodels.balancer.MsgCreateBalancerPool"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.poolmodels.balancer.MsgCreateBalancerPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.poolmodels.stableswap.Msg/CreateStableswapPool":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateStableswapPool","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.poolmodels.stableswap.MsgCreateStableswapPool"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.poolmodels.stableswap.MsgCreateStableswapPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.poolmodels.stableswap.Msg/StableSwapAdjustScalingFactors":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_StableSwapAdjustScalingFactors","parameters":[{"description":"Sender must be the pool's scaling_factor_governor in order for the tx to\nsucceed. Adjusts stableswap scaling factors.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.poolmodels.stableswap.MsgStableSwapAdjustScalingFactors"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.poolmodels.stableswap.MsgStableSwapAdjustScalingFactorsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/ExitPool":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_ExitPool","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitPool"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/ExitSwapExternAmountOut":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_ExitSwapExternAmountOut","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitSwapExternAmountOut"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitSwapExternAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/ExitSwapShareAmountIn":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_ExitSwapShareAmountIn","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitSwapShareAmountIn"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitSwapShareAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/JoinPool":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_JoinPool","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinPool"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/JoinSwapExternAmountIn":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_JoinSwapExternAmountIn","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinSwapExternAmountIn"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinSwapExternAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/JoinSwapShareAmountOut":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_JoinSwapShareAmountOut","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinSwapShareAmountOut"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinSwapShareAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/SwapExactAmountIn":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SwapExactAmountIn","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgSwapExactAmountIn"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/SwapExactAmountInWithIBCTransfer":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SwapExactAmountInWithIBCTransfer","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgSwapExactAmountInWithIBCTransfer"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgSwapExactAmountInWithIBCTransferResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/SwapExactAmountOut":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SwapExactAmountOut","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgSwapExactAmountOut"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Query/CalcJoinPoolNoSwapShares":{"post":{"tags":["Query"],"summary":"Simulates joining pool without a swap. Returns the amount of shares you'd\nget and tokens needed to provide","operationId":"GithubCombitbadgesbitbadgeschainQuery_CalcJoinPoolNoSwapShares","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.QueryCalcJoinPoolNoSwapSharesRequest"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryCalcJoinPoolNoSwapSharesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/ibcratelimit.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin18","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/ibcratelimit.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/ibcratelimit.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/ibcratelimit.Msg/UpdateRateLimit":{"post":{"tags":["Msg"],"summary":"UpdateRateLimit defines a (governance) operation for updating or adding a single rate limit.\nIf a rate limit with the same channel_id and denom exists, it will be updated.\nOtherwise, it will be appended to the list. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateRateLimit","parameters":[{"description":"MsgUpdateRateLimit is the Msg/UpdateRateLimit request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/ibcratelimit.MsgUpdateRateLimit"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/ibcratelimit.MsgUpdateRateLimitResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/managersplitter.Msg/CreateManagerSplitter":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateManagerSplitter","parameters":[{"description":"MsgCreateManagerSplitter creates a new manager splitter entity.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/managersplitter.MsgCreateManagerSplitter"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/managersplitter.MsgCreateManagerSplitterResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/managersplitter.Msg/DeleteManagerSplitter":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteManagerSplitter","parameters":[{"description":"MsgDeleteManagerSplitter deletes a manager splitter entity.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/managersplitter.MsgDeleteManagerSplitter"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/managersplitter.MsgDeleteManagerSplitterResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/managersplitter.Msg/ExecuteUniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_ExecuteUniversalUpdateCollection","parameters":[{"description":"MsgExecuteUniversalUpdateCollection executes a UniversalUpdateCollection message\nthrough the manager splitter, checking permissions before execution.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/managersplitter.MsgExecuteUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/managersplitter.MsgExecuteUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/managersplitter.Msg/UpdateManagerSplitter":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateManagerSplitter","parameters":[{"description":"MsgUpdateManagerSplitter updates an existing manager splitter entity.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/managersplitter.MsgUpdateManagerSplitter"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/managersplitter.MsgUpdateManagerSplitterResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/managersplitter.Msg/UpdateParams":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin24","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/managersplitter.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/managersplitter.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/CreateMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgCreateMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgCreateMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/DeleteMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgDeleteMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgDeleteMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/SetValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValue","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgSetValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgSetValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/UpdateMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgUpdateMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgUpdateMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/UpdateParams":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin32","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/filtered_pools":{"get":{"tags":["Query"],"summary":"PoolsWithFilter allows you to query specific pools with requested\nparameters","operationId":"GithubCombitbadgesbitbadgeschainQuery_PoolsWithFilter","parameters":[{"type":"string","description":"String of the coins in single string separated by comma. Ex)\n10uatom,100uosmo","name":"min_liquidity","in":"query"},{"type":"string","name":"pool_type","in":"query"},{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryPoolsWithFilterResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/num_pools":{"get":{"tags":["Query"],"summary":"Deprecated: please use the alternative in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_NumPools","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryNumPoolsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/params":{"get":{"tags":["Query"],"summary":"Params returns gamm module params.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin12","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.ParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pool_type/{pool_id}":{"get":{"tags":["Query"],"summary":"PoolType returns the type of the pool.\nReturns \"Balancer\" as a string literal when the pool is a balancer pool.\nErrors if the pool is failed to be type caseted.","operationId":"GithubCombitbadgesbitbadgeschainQuery_PoolType","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryPoolTypeResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_Pools","parameters":[{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryPoolsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}":{"get":{"tags":["Query"],"summary":"Deprecated: please use the alternative in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_Pool","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/exit_swap_share_amount_in":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_CalcExitPoolCoinsFromShares","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"share_in_amount","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryCalcExitPoolCoinsFromSharesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/join_swap_exact_in":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_CalcJoinPoolShares","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryCalcJoinPoolSharesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/params":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_PoolParams","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryPoolParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/prices":{"get":{"tags":["Query"],"summary":"SpotPrice defines a gRPC query handler that returns the spot price given\na base denomination and a quote denomination.","operationId":"GithubCombitbadgesbitbadgeschainQuery_SpotPrice","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"base_asset_denom","in":"query"},{"type":"string","name":"quote_asset_denom","in":"query"},{"type":"boolean","description":"DEPRECATED","name":"withSwapFee","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QuerySpotPriceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/total_pool_liquidity":{"get":{"tags":["Query"],"summary":"Deprecated: please use the alternative in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalPoolLiquidity","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryTotalPoolLiquidityResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/total_shares":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalShares","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryTotalSharesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/total_liquidity":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalLiquidity","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryTotalLiquidityResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/{pool_id}/estimate/swap_exact_amount_in":{"get":{"tags":["Query"],"summary":"Deprecated: please use the alternative in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountIn","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"sender","in":"query"},{"type":"string","name":"token_in","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QuerySwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/{pool_id}/estimate/swap_exact_amount_out":{"get":{"tags":["Query"],"summary":"Deprecated: please use the alternative in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountOut","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"sender","in":"query"},{"type":"string","name":"token_out","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QuerySwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v2/pools/{pool_id}/prices":{"get":{"tags":["Query"],"summary":"Deprecated: please use alternate in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_SpotPriceMixin14","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"base_asset_denom","in":"query"},{"type":"string","name":"quote_asset_denom","in":"query"},{"type":"boolean","description":"DEPRECATED","name":"withSwapFee","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v2.QuerySpotPriceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/pools/{pool_id}/prices":{"get":{"tags":["Query"],"summary":"SpotPrice defines a gRPC query handler that returns the spot price given\na base denomination and a quote denomination.","operationId":"GithubCombitbadgesbitbadgeschainQuery_SpotPriceMixin35","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"base_asset_denom","in":"query"},{"type":"string","name":"quote_asset_denom","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.SpotPriceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/Params":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin35","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.ParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/all-pools":{"get":{"tags":["Query"],"summary":"AllPools returns all pools on the Osmosis chain sorted by IDs.","operationId":"GithubCombitbadgesbitbadgeschainQuery_AllPools","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.AllPoolsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/all_registered_alloyed_pools":{"get":{"tags":["Query"],"summary":"AllRegisteredAlloyedPools returns all registered alloyed pools. The\nregistered alloyed pool contains the pool's contract address, along with\nthe current distribution composition of taker fee share denoms within the\nalloyed pool.","operationId":"GithubCombitbadgesbitbadgeschainQuery_AllRegisteredAlloyedPools","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.AllRegisteredAlloyedPoolsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/all_taker_fee_share_accumulators":{"get":{"tags":["Query"],"summary":"AllTakerFeeShareAccumulators returns all taker fee share accumulators. A\ntaker fee share accumulator includes the denom of the denom getting the\ntaker fees, and an accumulated value of coins that the denom has accrued\nsince the last time it was distributed in the epoch prior.","operationId":"GithubCombitbadgesbitbadgeschainQuery_AllTakerFeeShareAccumulators","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.AllTakerFeeShareAccumulatorsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/all_taker_fee_share_agreements":{"get":{"tags":["Query"],"summary":"AllTakerFeeShareAgreements returns all taker fee share agreements.\nA taker fee share agreement includes the denom of the denom getting the\ntaker fees, the percent of the taker fees that the denom gets when it is\nin the route being traded against, and the address that the taker fees are\nsent to at epoch.","operationId":"GithubCombitbadgesbitbadgeschainQuery_AllTakerFeeShareAgreements","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.AllTakerFeeShareAgreementsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/list-pools-by-denom":{"get":{"tags":["Query"],"summary":"ListPoolsByDenom return all pools by denom","operationId":"GithubCombitbadgesbitbadgeschainQuery_ListPoolsByDenom","parameters":[{"type":"string","name":"denom","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.ListPoolsByDenomResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/num_pools":{"get":{"tags":["Query"],"summary":"Returns the total number of pools existing in Osmosis.","operationId":"GithubCombitbadgesbitbadgeschainQuery_NumPoolsMixin35","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.NumPoolsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/pools/{pool_id}":{"get":{"tags":["Query"],"summary":"Pool returns the Pool specified by the pool id","operationId":"GithubCombitbadgesbitbadgeschainQuery_PoolMixin35","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.PoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/pools/{pool_id}/total_pool_liquidity":{"get":{"tags":["Query"],"summary":"TotalPoolLiquidity returns the total liquidity of the specified pool.","operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalPoolLiquidityMixin35","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TotalPoolLiquidityResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/pools/{pool_id}/total_volume":{"get":{"tags":["Query"],"summary":"TotalVolumeForPool returns the total volume of the specified pool.","operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalVolumeForPool","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TotalVolumeForPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/total_liquidity":{"get":{"tags":["Query"],"summary":"TotalLiquidity returns the total liquidity across all pools.","operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalLiquidityMixin35","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TotalLiquidityResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/trading_pair_takerfee":{"get":{"tags":["Query"],"summary":"TradingPairTakerFee returns the taker fee for a given set of denoms","operationId":"GithubCombitbadgesbitbadgeschainQuery_TradingPairTakerFee","parameters":[{"type":"string","name":"denom_0","in":"query"},{"type":"string","name":"denom_1","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TradingPairTakerFeeResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{denom}/registered_alloyed_pool_from_denom":{"get":{"tags":["Query"],"summary":"RegisteredAlloyedPoolFromDenom returns the registered alloyed pool state\nfrom the given denom. The registered alloyed pool contains the pool's\ncontract address, along with the current distribution composition of taker\nfee share denoms within the alloyed pool.","operationId":"GithubCombitbadgesbitbadgeschainQuery_RegisteredAlloyedPoolFromDenom","parameters":[{"type":"string","name":"denom","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.RegisteredAlloyedPoolFromDenomResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{denom}/taker_fee_share_agreement_from_denom":{"get":{"tags":["Query"],"summary":"TakerFeeShareAgreementFromDenom returns the taker fee share agreement for a\ngiven denom. A taker fee share agreement includes the denom of the denom\ngetting the taker fees, the percent of the taker fees that the denom gets\nwhen it is in the route being traded against, and the address that the\ntaker fees are sent to at epoch.","operationId":"GithubCombitbadgesbitbadgeschainQuery_TakerFeeShareAgreementFromDenom","parameters":[{"type":"string","name":"denom","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TakerFeeShareAgreementFromDenomResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate/single_pool_swap_exact_amount_in":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSinglePoolSwapExactAmountIn","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"token_in","in":"query"},{"type":"string","name":"token_out_denom","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate/swap_exact_amount_in":{"get":{"tags":["Query"],"summary":"Estimates swap amount out given in.","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountInMixin35","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","description":"DEPRECATED","name":"sender","in":"query"},{"type":"string","name":"token_in","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate/swap_exact_amount_in_with_primitive_types":{"get":{"tags":["Query"],"summary":"EstimateSwapExactAmountInWithPrimitiveTypes is an alternative query for\nEstimateSwapExactAmountIn. Supports query via GRPC-Gateway by using\nprimitive types instead of repeated structs. Each index in the\nroutes_pool_id field corresponds to the respective routes_token_out_denom\nvalue, thus they are required to have the same length and are grouped\ntogether as pairs.\nexample usage:\nhttp://0.0.0.0:1317/osmosis/poolmanager/v1beta1/1/estimate/\nswap_exact_amount_in_with_primitive_types?token_in=100000stake\u0026routes_token_out_denom=uatom\n\u0026routes_token_out_denom=uion\u0026routes_pool_id=1\u0026routes_pool_id=2","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountInWithPrimitiveTypes","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"token_in","in":"query"},{"type":"array","items":{"type":"string","format":"uint64"},"collectionFormat":"multi","name":"routes_pool_id","in":"query"},{"type":"array","items":{"type":"string"},"collectionFormat":"multi","name":"routes_token_out_denom","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate/swap_exact_amount_out":{"get":{"tags":["Query"],"summary":"Estimates swap amount in given out.","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountOutMixin35","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","description":"DEPRECATED","name":"sender","in":"query"},{"type":"string","name":"token_out","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate/swap_exact_amount_out_with_primitive_types":{"get":{"tags":["Query"],"summary":"Estimates swap amount in given out.","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountOutWithPrimitiveTypes","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"array","items":{"type":"string","format":"uint64"},"collectionFormat":"multi","name":"routes_pool_id","in":"query"},{"type":"array","items":{"type":"string"},"collectionFormat":"multi","name":"routes_token_in_denom","in":"query"},{"type":"string","name":"token_out","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate_out/single_pool_swap_exact_amount_out":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSinglePoolSwapExactAmountOut","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"token_in_denom","in":"query"},{"type":"string","name":"token_out","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate_trade":{"get":{"tags":["Query"],"summary":"EstimateTradeBasedOnPriceImpact returns an estimated trade based on price\nimpact, if a trade cannot be estimated a 0 input and 0 output would be\nreturned.","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateTradeBasedOnPriceImpact","parameters":[{"type":"string","format":"uint64","description":"pool_id is the identifier of the liquidity pool that the trade will occur\non.","name":"pool_id","in":"path","required":true},{"type":"string","name":"from_coin.denom","in":"query"},{"type":"string","name":"from_coin.amount","in":"query"},{"type":"string","description":"to_coin_denom is the denom identifier of the token that the user wants to\nbuy.","name":"to_coin_denom","in":"query"},{"type":"string","description":"max_price_impact is the maximum percentage that the user is willing\nto affect the price of the liquidity pool.","name":"max_price_impact","in":"query"},{"type":"string","description":"external_price is an optional external price that the user can enter.\nIt adjusts the MaxPriceImpact as the SpotPrice of a pool can be changed at\nany time.","name":"external_price","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateTradeBasedOnPriceImpactResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/registered_alloyed_pool_from_pool_id":{"get":{"tags":["Query"],"summary":"RegisteredAlloyedPoolFromPoolId returns the registered alloyed pool state\nfrom the given pool id. The registered alloyed pool contains the pool's\ncontract address, along with the current distribution composition of taker\nfee share denoms within the alloyed pool.","operationId":"GithubCombitbadgesbitbadgeschainQuery_RegisteredAlloyedPoolFromPoolId","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.RegisteredAlloyedPoolFromPoolIdResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{takerFeeDenom}/{denom}/taker_fee_share_denoms_to_accrued_value":{"get":{"tags":["Query"],"summary":"TakerFeeShareDenomsToAccruedValue returns the accrued value (as an Int) of\nthe given taker fee denom (the collected fees) for the given fee share\ndenom (the denom with the taker fee share agreement)","operationId":"GithubCombitbadgesbitbadgeschainQuery_TakerFeeShareDenomsToAccruedValue","parameters":[{"type":"string","name":"takerFeeDenom","in":"path","required":true},{"type":"string","name":"denom","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TakerFeeShareDenomsToAccruedValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v2/pools/{pool_id}/prices":{"get":{"tags":["Query"],"summary":"SpotPriceV2 defines a gRPC query handler that returns the spot price given\na base denomination and a quote denomination.\nThe returned spot price has 36 decimal places. However, some of\nmodules perform sig fig rounding so most of the rightmost decimals can be\nzeroes.","operationId":"GithubCombitbadgesbitbadgeschainQuery_SpotPriceV2","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"base_asset_denom","in":"query"},{"type":"string","name":"quote_asset_denom","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v2.SpotPriceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SetDenomPairTakerFee":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDenomPairTakerFee","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSetDenomPairTakerFee"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSetDenomPairTakerFeeResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SetTakerFeeShareAgreementForDenom":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetTakerFeeShareAgreementForDenom","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenom"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenomResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SplitRouteSwapExactAmountIn":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SplitRouteSwapExactAmountIn","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSplitRouteSwapExactAmountIn"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSplitRouteSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SplitRouteSwapExactAmountOut":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SplitRouteSwapExactAmountOut","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOut"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SwapExactAmountIn":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SwapExactAmountInMixin39","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSwapExactAmountIn"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SwapExactAmountOut":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SwapExactAmountOutMixin39","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSwapExactAmountOut"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/sendmanager.Msg/SendWithAliasRouting":{"post":{"tags":["Msg"],"summary":"SendWithAliasRouting defines a message for sending coins with alias denom routing.\nThis allows sending both standard coins and alias denoms (e.g., badgeslp:) through the sendmanager.","operationId":"GithubCombitbadgesbitbadgeschainMsg_SendWithAliasRouting","parameters":[{"description":"MsgSendWithAliasRouting defines a message for sending coins with alias denom routing.\nThis message mirrors cosmos bank MsgSend but routes through sendmanager to handle\nboth standard coins and alias denoms (e.g., badgeslp:).","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/sendmanager.MsgSendWithAliasRouting"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/sendmanager.MsgSendWithAliasRoutingResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/sendmanager.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin44","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/sendmanager.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/sendmanager.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/CastVote":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CastVote","parameters":[{"description":"MsgCastVote allows a voter to cast or update their vote for a voting challenge.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgCastVote"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgCastVoteResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressLists","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollection","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/CreateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateDynamicStore","parameters":[{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgCreateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgCreateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollection","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/DeleteDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteDynamicStore","parameters":[{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgDeleteDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgDeleteDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/DeleteIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteIncomingApproval","parameters":[{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgDeleteIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgDeleteIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/DeleteOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteOutgoingApproval","parameters":[{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgDeleteOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgDeleteOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/PurgeApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_PurgeApprovals","parameters":[{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgPurgeApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgPurgeApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetCollectionApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionApprovals","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetCollectionApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetCollectionApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetCollectionMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionMetadata","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetCollectionMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetCollectionMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCustomData","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetDynamicStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDynamicStoreValue","parameters":[{"description":"MsgSetDynamicStoreValue is used to set a boolean value for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetDynamicStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIncomingApproval","parameters":[{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetIsArchived":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIsArchived","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetIsArchived"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetIsArchivedResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetManager":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetManager","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetManager"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetManagerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetOutgoingApproval","parameters":[{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetReservedProtocolAddress":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetReservedProtocolAddress","parameters":[{"description":"MsgSetReservedProtocolAddress sets or unsets a reserved protocol address (governance-only).","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetReservedProtocolAddress"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetReservedProtocolAddressResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetStandards":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetStandards","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetStandards"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetStandardsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetTokenMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetTokenMetadata","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetTokenMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetTokenMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/SetValidTokenIds":{"post":{"tags":["Msg"],"summary":"Helper message types for UniversalUpdateCollection subsets","operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValidTokenIds","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgSetValidTokenIds"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgSetValidTokenIdsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/TransferTokens":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferTokens","parameters":[{"description":"MsgTransferTokens is used to transfer tokens.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgTransferTokens"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgTransferTokensResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollection","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the tokens module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollection","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/UpdateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateDynamicStore","parameters":[{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgUpdateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgUpdateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin65","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovals","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/CastVote":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CastVoteMixin84","parameters":[{"description":"MsgCastVote allows a voter to cast or update their vote for a voting challenge.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgCastVote"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgCastVoteResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressListsMixin84","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollectionMixin84","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/CreateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateDynamicStoreMixin84","parameters":[{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgCreateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgCreateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollectionMixin84","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/DeleteDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteDynamicStoreMixin84","parameters":[{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgDeleteDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgDeleteDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/DeleteIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteIncomingApprovalMixin84","parameters":[{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgDeleteIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgDeleteIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/DeleteOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteOutgoingApprovalMixin84","parameters":[{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgDeleteOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgDeleteOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/PurgeApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_PurgeApprovalsMixin84","parameters":[{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgPurgeApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgPurgeApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetCollectionApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionApprovalsMixin84","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetCollectionApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetCollectionApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetCollectionMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionMetadataMixin84","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetCollectionMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetCollectionMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCustomDataMixin84","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetDynamicStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDynamicStoreValueMixin84","parameters":[{"description":"MsgSetDynamicStoreValue is used to set a boolean value for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetDynamicStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIncomingApprovalMixin84","parameters":[{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetIsArchived":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIsArchivedMixin84","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetIsArchived"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetIsArchivedResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetManager":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetManagerMixin84","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetManager"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetManagerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetOutgoingApprovalMixin84","parameters":[{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetReservedProtocolAddress":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetReservedProtocolAddressMixin84","parameters":[{"description":"MsgSetReservedProtocolAddress sets or unsets a reserved protocol address (governance-only).","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetReservedProtocolAddress"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetReservedProtocolAddressResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetStandards":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetStandardsMixin84","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetStandards"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetStandardsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetTokenMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetTokenMetadataMixin84","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetTokenMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetTokenMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/SetValidTokenIds":{"post":{"tags":["Msg"],"summary":"Helper message types for UniversalUpdateCollection subsets","operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValidTokenIdsMixin84","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgSetValidTokenIds"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgSetValidTokenIdsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/TransferTokens":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferTokensMixin84","parameters":[{"description":"MsgTransferTokens is used to transfer tokens.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgTransferTokens"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgTransferTokensResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollectionMixin84","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the tokens module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollectionMixin84","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/UpdateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateDynamicStoreMixin84","parameters":[{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgUpdateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgUpdateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin84","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v23.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovalsMixin84","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v23.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v23.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/CastVote":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CastVoteMixin104","parameters":[{"description":"MsgCastVote allows a voter to cast or update their vote for a voting challenge.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgCastVote"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgCastVoteResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressListsMixin104","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollectionMixin104","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/CreateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateDynamicStoreMixin104","parameters":[{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgCreateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgCreateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollectionMixin104","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/DeleteDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteDynamicStoreMixin104","parameters":[{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgDeleteDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgDeleteDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/DeleteIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteIncomingApprovalMixin104","parameters":[{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgDeleteIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgDeleteIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/DeleteOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteOutgoingApprovalMixin104","parameters":[{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgDeleteOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgDeleteOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/PurgeApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_PurgeApprovalsMixin104","parameters":[{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgPurgeApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgPurgeApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetCollectionApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionApprovalsMixin104","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetCollectionApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetCollectionApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetCollectionMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionMetadataMixin104","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetCollectionMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetCollectionMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCustomDataMixin104","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetDynamicStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDynamicStoreValueMixin104","parameters":[{"description":"MsgSetDynamicStoreValue is used to set a boolean value for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetDynamicStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIncomingApprovalMixin104","parameters":[{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetIsArchived":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIsArchivedMixin104","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetIsArchived"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetIsArchivedResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetManager":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetManagerMixin104","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetManager"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetManagerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetOutgoingApprovalMixin104","parameters":[{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetReservedProtocolAddress":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetReservedProtocolAddressMixin104","parameters":[{"description":"MsgSetReservedProtocolAddress sets or unsets a reserved protocol address (governance-only).","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetReservedProtocolAddress"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetReservedProtocolAddressResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetStandards":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetStandardsMixin104","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetStandards"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetStandardsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetTokenMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetTokenMetadataMixin104","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetTokenMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetTokenMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/SetValidTokenIds":{"post":{"tags":["Msg"],"summary":"Helper message types for UniversalUpdateCollection subsets","operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValidTokenIdsMixin104","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgSetValidTokenIds"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgSetValidTokenIdsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/TransferTokens":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferTokensMixin104","parameters":[{"description":"MsgTransferTokens is used to transfer tokens.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgTransferTokens"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgTransferTokensResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollectionMixin104","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the tokens module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollectionMixin104","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/UpdateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateDynamicStoreMixin104","parameters":[{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgUpdateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgUpdateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin104","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/tokenization.v24.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovalsMixin104","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/tokenization.v24.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/tokenization.v24.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}}},"definitions":{"anchor.AnchorData":{"type":"object","properties":{"creator":{"type":"string"},"data":{"type":"string"},"timestamp":{"type":"string"}}},"anchor.MsgAddCustomData":{"type":"object","properties":{"creator":{"type":"string"},"data":{"type":"string"}}},"anchor.MsgAddCustomDataResponse":{"type":"object","properties":{"locationId":{"description":"ID of the anchor location.","type":"string"}}},"anchor.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"NOTE: All parameters must be supplied.","$ref":"#/definitions/anchor.Params"}}},"anchor.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"anchor.Params":{"description":"Params defines the parameters for the module.","type":"object"},"anchor.QueryGetValueAtLocationResponse":{"type":"object","properties":{"anchorData":{"$ref":"#/definitions/anchor.AnchorData"}}},"anchor.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/anchor.Params"}}},"cosmos.base.query.v1beta1.PageRequest":{"description":"message SomeRequest {\n         Foo some_parameter = 1;\n         PageRequest pagination = 2;\n }","type":"object","title":"PageRequest is to be embedded in gRPC request messages for efficient\npagination. Ex:","properties":{"count_total":{"description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","type":"boolean"},"key":{"description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","type":"string","format":"byte"},"limit":{"description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","type":"string","format":"uint64"},"offset":{"description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","type":"string","format":"uint64"},"reverse":{"description":"reverse is set to true if results are to be returned in the descending order.","type":"boolean"}}},"cosmos.base.query.v1beta1.PageResponse":{"description":"PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }","type":"object","properties":{"next_key":{"description":"next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.","type":"string","format":"byte"},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"}}},"cosmos.base.v1beta1.Coin":{"description":"Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.","type":"object","properties":{"amount":{"type":"string"},"denom":{"type":"string"}}},"cosmos.evm.vm.v1.AccessControl":{"type":"object","title":"AccessControl defines the permission policy of the EVM\nfor creating and calling contracts","properties":{"call":{"title":"call defines the permission policy for calling contracts","$ref":"#/definitions/cosmos.evm.vm.v1.AccessControlType"},"create":{"title":"create defines the permission policy for creating contracts","$ref":"#/definitions/cosmos.evm.vm.v1.AccessControlType"}}},"cosmos.evm.vm.v1.AccessControlType":{"type":"object","title":"AccessControlType defines the permission type for policies","properties":{"access_control_list":{"type":"array","title":"access_control_list defines defines different things depending on the\nAccessType:\n- ACCESS_TYPE_PERMISSIONLESS: list of addresses that are blocked from\nperforming the operation\n- ACCESS_TYPE_RESTRICTED: ignored\n- ACCESS_TYPE_PERMISSIONED: list of addresses that are allowed to perform\nthe operation","items":{"type":"string"}},"access_type":{"title":"access_type defines which type of permission is required for the operation","$ref":"#/definitions/cosmos.evm.vm.v1.AccessType"}}},"cosmos.evm.vm.v1.AccessType":{"description":"- ACCESS_TYPE_PERMISSIONLESS: ACCESS_TYPE_PERMISSIONLESS does not restrict the operation to anyone\n - ACCESS_TYPE_RESTRICTED: ACCESS_TYPE_RESTRICTED restrict the operation to anyone\n - ACCESS_TYPE_PERMISSIONED: ACCESS_TYPE_PERMISSIONED only allows the operation for specific addresses","type":"string","title":"AccessType defines the types of permissions for the operations","default":"ACCESS_TYPE_PERMISSIONLESS","enum":["ACCESS_TYPE_PERMISSIONLESS","ACCESS_TYPE_RESTRICTED","ACCESS_TYPE_PERMISSIONED"]},"cosmos.evm.vm.v1.ExtendedDenomOptions":{"type":"object","properties":{"extended_denom":{"type":"string"}}},"cosmos.evm.vm.v1.Log":{"description":"Log represents an protobuf compatible Ethereum Log that defines a contract\nlog event. These events are generated by the LOG opcode and stored/indexed by\nthe node.\n\nNOTE: address, topics and data are consensus fields. The rest of the fields\nare derived, i.e. filled in by the nodes, but not secured by consensus.","type":"object","properties":{"address":{"type":"string","title":"address of the contract that generated the event"},"block_hash":{"type":"string","title":"block_hash of the block in which the transaction was included"},"block_number":{"type":"string","format":"uint64","title":"block_number of the block in which the transaction was included"},"block_timestamp":{"type":"string","format":"uint64","title":"block_timestamp is the timestamp of the block in which the transaction was"},"data":{"type":"string","format":"byte","title":"data which is supplied by the contract, usually ABI-encoded"},"index":{"type":"string","format":"uint64","title":"index of the log in the block"},"removed":{"description":"removed is true if this log was reverted due to a chain\nreorganisation. You must pay attention to this field if you receive logs\nthrough a filter query.","type":"boolean"},"topics":{"description":"topics is a list of topics provided by the contract.","type":"array","items":{"type":"string"}},"tx_hash":{"type":"string","title":"tx_hash is the transaction hash"},"tx_index":{"type":"string","format":"uint64","title":"tx_index of the transaction in the block"}}},"cosmos.evm.vm.v1.MsgEthereumTxResponse":{"description":"MsgEthereumTxResponse defines the Msg/EthereumTx response type.","type":"object","properties":{"block_hash":{"type":"string","format":"byte","title":"include the block hash for json-rpc to use"},"block_timestamp":{"type":"string","format":"uint64","title":"include the block timestamp for json-rpc to use"},"gas_used":{"type":"string","format":"uint64","title":"gas_used specifies how much gas was consumed by the transaction"},"hash":{"type":"string","title":"hash of the ethereum transaction in hex format. This hash differs from the\nCometBFT sha256 hash of the transaction bytes. See\nhttps://github.com/tendermint/tendermint/issues/6539 for reference"},"logs":{"description":"logs contains the transaction hash and the proto-compatible ethereum\nlogs.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.evm.vm.v1.Log"}},"max_used_gas":{"type":"string","format":"uint64","title":"max_used_gas specifies the gas consumed by the transaction, not including refunds"},"ret":{"type":"string","format":"byte","title":"ret is the returned data from evm function (result or data supplied with\nrevert opcode)"},"vm_error":{"type":"string","title":"vm_error is the error returned by vm execution"}}},"cosmos.evm.vm.v1.MsgRegisterPreinstalls":{"description":"MsgRegisterPreinstalls defines a Msg for creating preinstalls in evm state.","type":"object","properties":{"authority":{"description":"authority is the address of the governance account.","type":"string"},"preinstalls":{"description":"preinstalls defines the preinstalls to create.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.evm.vm.v1.Preinstall"}}}},"cosmos.evm.vm.v1.MsgRegisterPreinstallsResponse":{"description":"MsgRegisterPreinstallsResponse defines the response structure for executing a\nMsgRegisterPreinstalls message.","type":"object"},"cosmos.evm.vm.v1.MsgUpdateParams":{"description":"MsgUpdateParams defines a Msg for updating the x/vm module parameters.","type":"object","properties":{"authority":{"description":"authority is the address of the governance account.","type":"string"},"params":{"description":"params defines the x/vm parameters to update.\nNOTE: All parameters must be supplied.","$ref":"#/definitions/cosmos.evm.vm.v1.Params"}}},"cosmos.evm.vm.v1.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"cosmos.evm.vm.v1.Params":{"type":"object","title":"Params defines the EVM module parameters","properties":{"access_control":{"title":"access_control defines the permission policy of the EVM","$ref":"#/definitions/cosmos.evm.vm.v1.AccessControl"},"active_static_precompiles":{"type":"array","title":"active_static_precompiles defines the slice of hex addresses of the\nprecompiled contracts that are active","items":{"type":"string"}},"evm_channels":{"type":"array","title":"evm_channels is the list of channel identifiers from EVM compatible chains","items":{"type":"string"}},"evm_denom":{"description":"evm_denom represents the token denomination used to run the EVM state\ntransitions.","type":"string"},"extended_denom_options":{"$ref":"#/definitions/cosmos.evm.vm.v1.ExtendedDenomOptions"},"extra_eips":{"type":"array","title":"extra_eips defines the additional EIPs for the vm.Config","items":{"type":"string","format":"int64"}},"history_serve_window":{"type":"string","format":"uint64"}}},"cosmos.evm.vm.v1.Preinstall":{"type":"object","title":"Preinstall defines a contract that is preinstalled on-chain with a specific\ncontract address and bytecode","properties":{"address":{"type":"string","title":"address in hex format of the preinstall contract"},"code":{"type":"string","title":"code in hex format for the preinstall contract"},"name":{"type":"string","title":"name of the preinstall contract"}}},"gamm.poolmodels.balancer.MsgCreateBalancerPool":{"type":"object","title":"===================== MsgCreatePool","properties":{"pool_assets":{"type":"array","items":{"type":"object","$ref":"#/definitions/gamm.poolmodels.balancer.PoolAsset"}},"pool_params":{"$ref":"#/definitions/gamm.poolmodels.balancer.PoolParams"},"sender":{"type":"string"}}},"gamm.poolmodels.balancer.MsgCreateBalancerPoolResponse":{"type":"object","title":"Returns the poolID","properties":{"pool_id":{"type":"string","format":"uint64"}}},"gamm.poolmodels.balancer.PoolAsset":{"description":"Pool asset is an internal struct that combines the amount of the\ntoken in the pool, and its balancer weight.\nThis is an awkward packaging of data,\nand should be revisited in a future state migration.","type":"object","properties":{"token":{"description":"Coins we are talking about,\nthe denomination must be unique amongst all PoolAssets for this pool.","$ref":"#/definitions/cosmos.base.v1beta1.Coin"},"weight":{"type":"string","title":"Weight that is not normalized. This weight must be less than 2^50"}}},"gamm.poolmodels.balancer.PoolParams":{"description":"PoolParams defined the parameters that will be managed by the pool\ngovernance in the future. This params are not managed by the chain\ngovernance. Instead they will be managed by the token holders of the pool.","type":"object","properties":{"exit_fee":{"type":"string","title":"N.B.: exit fee is disabled during pool creation in x/poolmanager. While old\npools can maintain a non-zero fee. No new pool can be created with non-zero\nfee anymore"},"swap_fee":{"type":"string"}}},"gamm.poolmodels.stableswap.MsgCreateStableswapPool":{"type":"object","title":"===================== MsgCreatePool","properties":{"future_pool_governor":{"type":"string"},"initial_pool_liquidity":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"pool_params":{"$ref":"#/definitions/gamm.poolmodels.stableswap.PoolParams"},"scaling_factor_controller":{"type":"string"},"scaling_factors":{"type":"array","items":{"type":"string","format":"uint64"}},"sender":{"type":"string"}}},"gamm.poolmodels.stableswap.MsgCreateStableswapPoolResponse":{"description":"Returns a poolID with custom poolName.","type":"object","properties":{"pool_id":{"type":"string","format":"uint64"}}},"gamm.poolmodels.stableswap.MsgStableSwapAdjustScalingFactors":{"description":"Sender must be the pool's scaling_factor_governor in order for the tx to\nsucceed. Adjusts stableswap scaling factors.","type":"object","properties":{"pool_id":{"type":"string","format":"uint64"},"scaling_factors":{"type":"array","items":{"type":"string","format":"uint64"}},"sender":{"type":"string"}}},"gamm.poolmodels.stableswap.MsgStableSwapAdjustScalingFactorsResponse":{"type":"object"},"gamm.poolmodels.stableswap.PoolParams":{"description":"PoolParams defined the parameters that will be managed by the pool\ngovernance in the future. This params are not managed by the chain\ngovernance. Instead they will be managed by the token holders of the pool.\nThe pool's token holders are specified in future_pool_governor.","type":"object","properties":{"exit_fee":{"type":"string","title":"N.B.: exit fee is disabled during pool creation in x/poolmanager. While old\npools can maintain a non-zero fee. No new pool can be created with non-zero\nfee anymore"},"swap_fee":{"type":"string"}}},"gamm.v1beta1.IBCTransferInfo":{"type":"object","title":"===================== IBC Transfer Info","properties":{"memo":{"type":"string"},"receiver":{"type":"string"},"source_channel":{"type":"string"},"timeout_timestamp":{"type":"string","format":"uint64"}}},"gamm.v1beta1.MsgExitPool":{"type":"object","title":"===================== MsgExitPool","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_in_amount":{"type":"string"},"token_out_mins":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.MsgExitPoolResponse":{"type":"object","properties":{"token_out":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.MsgExitSwapExternAmountOut":{"type":"object","title":"===================== MsgExitSwapExternAmountOut","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_in_max_amount":{"type":"string"},"token_out":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"gamm.v1beta1.MsgExitSwapExternAmountOutResponse":{"type":"object","properties":{"share_in_amount":{"type":"string"}}},"gamm.v1beta1.MsgExitSwapShareAmountIn":{"type":"object","title":"===================== MsgExitSwapShareAmountIn","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_in_amount":{"type":"string"},"token_out_denom":{"type":"string"},"token_out_min_amount":{"type":"string"}}},"gamm.v1beta1.MsgExitSwapShareAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"gamm.v1beta1.MsgJoinPool":{"type":"object","title":"===================== MsgJoinPool\nThis is really MsgJoinPoolNoSwap","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_out_amount":{"type":"string"},"token_in_maxs":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.MsgJoinPoolResponse":{"type":"object","properties":{"share_out_amount":{"type":"string"},"token_in":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.MsgJoinSwapExternAmountIn":{"type":"object","title":"===================== MsgJoinSwapExternAmountIn\nTODO: Rename to MsgJoinSwapExactAmountIn","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_out_min_amount":{"type":"string","title":"repeated cosmos.base.v1beta1.Coin tokensIn = 5 [\n   (gogoproto.moretags) = \"yaml:\\\"tokens_in\\\"\",\n   (gogoproto.nullable) = false\n ];"},"token_in":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"gamm.v1beta1.MsgJoinSwapExternAmountInResponse":{"type":"object","properties":{"share_out_amount":{"type":"string"}}},"gamm.v1beta1.MsgJoinSwapShareAmountOut":{"type":"object","title":"===================== MsgJoinSwapShareAmountOut","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_out_amount":{"type":"string"},"token_in_denom":{"type":"string"},"token_in_max_amount":{"type":"string"}}},"gamm.v1beta1.MsgJoinSwapShareAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"gamm.v1beta1.MsgSwapExactAmountIn":{"type":"object","title":"===================== MsgSwapExactAmountIn","properties":{"affiliates":{"type":"array","title":"affiliates are optional fee recipients that receive fees calculated from token_out_min_amount","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.Affiliate"}},"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountInRoute"}},"sender":{"type":"string"},"token_in":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"},"token_out_min_amount":{"type":"string"}}},"gamm.v1beta1.MsgSwapExactAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"gamm.v1beta1.MsgSwapExactAmountInWithIBCTransfer":{"type":"object","title":"===================== MsgSwapExactAmountInWithIBCTransfer","properties":{"affiliates":{"type":"array","title":"affiliates are optional fee recipients that receive fees calculated from token_out_min_amount","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.Affiliate"}},"ibc_transfer_info":{"$ref":"#/definitions/gamm.v1beta1.IBCTransferInfo"},"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountInRoute"}},"sender":{"type":"string"},"token_in":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"},"token_out_min_amount":{"type":"string"}}},"gamm.v1beta1.MsgSwapExactAmountInWithIBCTransferResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"gamm.v1beta1.MsgSwapExactAmountOut":{"type":"object","properties":{"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountOutRoute"}},"sender":{"type":"string"},"token_in_max_amount":{"type":"string"},"token_out":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"gamm.v1beta1.MsgSwapExactAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"gamm.v1beta1.Params":{"type":"object","title":"Params holds parameters for the incentives module"},"gamm.v1beta1.ParamsResponse":{"type":"object","properties":{"params":{"$ref":"#/definitions/gamm.v1beta1.Params"}}},"gamm.v1beta1.QueryCalcExitPoolCoinsFromSharesResponse":{"type":"object","properties":{"tokens_out":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryCalcJoinPoolNoSwapSharesRequest":{"type":"object","title":"=============================== CalcJoinPoolNoSwapShares","properties":{"pool_id":{"type":"string","format":"uint64"},"tokens_in":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryCalcJoinPoolNoSwapSharesResponse":{"type":"object","properties":{"shares_out":{"type":"string"},"tokens_out":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryCalcJoinPoolSharesResponse":{"type":"object","properties":{"share_out_amount":{"type":"string"},"tokens_out":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryNumPoolsResponse":{"type":"object","properties":{"num_pools":{"type":"string","format":"uint64"}}},"gamm.v1beta1.QueryPoolParamsResponse":{"type":"object","properties":{"params":{"$ref":"#/definitions/google.protobuf.Any"}}},"gamm.v1beta1.QueryPoolResponse":{"type":"object","title":"Deprecated: please use the alternative in x/poolmanager","properties":{"pool":{"$ref":"#/definitions/google.protobuf.Any"}}},"gamm.v1beta1.QueryPoolTypeResponse":{"type":"object","properties":{"pool_type":{"type":"string"}}},"gamm.v1beta1.QueryPoolsResponse":{"type":"object","properties":{"pagination":{"description":"pagination defines the pagination in the response.","$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"},"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}}}},"gamm.v1beta1.QueryPoolsWithFilterResponse":{"type":"object","properties":{"pagination":{"description":"pagination defines the pagination in the response.","$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"},"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}}}},"gamm.v1beta1.QuerySpotPriceResponse":{"description":"QuerySpotPriceResponse defines the gRPC response structure for a SpotPrice\nquery.","type":"object","properties":{"spot_price":{"type":"string","title":"String of the Dec. Ex) 10.203uatom"}}},"gamm.v1beta1.QuerySwapExactAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"gamm.v1beta1.QuerySwapExactAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"gamm.v1beta1.QueryTotalLiquidityResponse":{"type":"object","properties":{"liquidity":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryTotalPoolLiquidityResponse":{"type":"object","title":"Deprecated: please use the alternative in x/poolmanager","properties":{"liquidity":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryTotalSharesResponse":{"type":"object","properties":{"total_shares":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"gamm.v2.QuerySpotPriceResponse":{"type":"object","title":"Deprecated: please use alternate in x/poolmanager","properties":{"spot_price":{"type":"string","title":"String of the Dec. Ex) 10.203uatom"}}},"google.protobuf.Any":{"type":"object","properties":{"@type":{"type":"string"}},"additionalProperties":{}},"google.rpc.Status":{"type":"object","properties":{"code":{"type":"integer","format":"int32"},"details":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}},"message":{"type":"string"}}},"ibcratelimit.AddressLimit":{"type":"object","title":"AddressLimit defines limits per address","properties":{"max_amount":{"type":"string","title":"max_amount is the maximum total amount allowed per address in the timeframe\nValue is represented as an integer (e.g., \"1000000\" = 1,000,000 tokens)\nIf set to 0, amount limit is disabled"},"max_transfers":{"type":"string","format":"int64","title":"max_transfers is the maximum number of transfers allowed per address in the timeframe\nIf set to 0, transfer count limit is disabled"},"timeframe_duration":{"type":"string","format":"int64","title":"timeframe_duration is the duration of the timeframe"},"timeframe_type":{"title":"timeframe_type defines the type of timeframe (block, hour, day)","$ref":"#/definitions/ibcratelimit.TimeframeType"}}},"ibcratelimit.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/ibcratelimit.Params"}}},"ibcratelimit.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"ibcratelimit.MsgUpdateRateLimit":{"description":"MsgUpdateRateLimit is the Msg/UpdateRateLimit request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"rate_limit":{"description":"rate_limit defines the rate limit configuration to update or add.\nIf a rate limit with the same channel_id and denom exists, it will be updated.\nOtherwise, it will be appended to the list.","$ref":"#/definitions/ibcratelimit.RateLimitConfig"}}},"ibcratelimit.MsgUpdateRateLimitResponse":{"description":"MsgUpdateRateLimitResponse defines the response structure for executing a\nMsgUpdateRateLimit message.","type":"object"},"ibcratelimit.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"rate_limits":{"type":"array","title":"rate_limits is an array of rate limit configurations\nEach configuration can specify channel_id, denom, and various limit types (supply_shift_limits, unique_sender_limits, address_limits)\nConfigurations are checked in order, and the first matching config is used\nIf no config matches, the transfer is allowed (no rate limit)","items":{"type":"object","$ref":"#/definitions/ibcratelimit.RateLimitConfig"}}}},"ibcratelimit.RateLimitConfig":{"type":"object","title":"RateLimitConfig defines a rate limit configuration for a specific channel and denom","properties":{"address_limits":{"type":"array","title":"address_limits defines per-address transfer limits\nAll limits are checked, and the transfer is rejected if any limit would be exceeded","items":{"type":"object","$ref":"#/definitions/ibcratelimit.AddressLimit"}},"channel_id":{"type":"string","title":"channel_id is the IBC channel ID this rate limit applies to\nIf empty, applies to all channels"},"denom":{"type":"string","title":"denom is the denomination this rate limit applies to\nMust be specified (empty denoms are not allowed)"},"supply_shift_limits":{"type":"array","title":"supply_shift_limits defines multiple timeframe limits for supply shift\nAll limits are checked, and the transfer is rejected if any limit would be exceeded","items":{"type":"object","$ref":"#/definitions/ibcratelimit.TimeframeLimit"}},"unique_sender_limits":{"type":"array","title":"unique_sender_limits defines limits on unique senders per channel\nAll limits are checked, and the transfer is rejected if any limit would be exceeded","items":{"type":"object","$ref":"#/definitions/ibcratelimit.UniqueSenderLimit"}}}},"ibcratelimit.TimeframeLimit":{"type":"object","title":"TimeframeLimit defines a limit for a specific timeframe","properties":{"max_amount":{"type":"string","title":"max_amount is the maximum absolute amount of supply change allowed in this timeframe\nValue is represented as an integer (e.g., \"1000000\" = 1,000,000 tokens)\nIf set to 0, this limit is disabled"},"timeframe_duration":{"type":"string","format":"int64","title":"timeframe_duration is the duration of the timeframe\nFor BLOCK: number of blocks\nFor HOUR: number of hours (will be converted to blocks using block time)\nFor DAY: number of days (will be converted to blocks using block time)"},"timeframe_type":{"title":"timeframe_type defines the type of timeframe (block, hour, day)","$ref":"#/definitions/ibcratelimit.TimeframeType"}}},"ibcratelimit.TimeframeType":{"description":"- TIMEFRAME_TYPE_BLOCK: Duration in blocks\n - TIMEFRAME_TYPE_HOUR: Duration in hours (converted to blocks using block time)\n - TIMEFRAME_TYPE_DAY: Duration in days (converted to blocks using block time)","type":"string","title":"TimeframeType defines the type of timeframe","default":"TIMEFRAME_TYPE_UNSPECIFIED","enum":["TIMEFRAME_TYPE_UNSPECIFIED","TIMEFRAME_TYPE_BLOCK","TIMEFRAME_TYPE_HOUR","TIMEFRAME_TYPE_DAY"]},"ibcratelimit.UniqueSenderLimit":{"type":"object","title":"UniqueSenderLimit defines limits on unique senders per channel","properties":{"max_unique_senders":{"type":"string","format":"int64","title":"max_unique_senders is the maximum number of unique senders allowed in the timeframe\nIf set to 0, this limit is disabled"},"timeframe_duration":{"type":"string","format":"int64","title":"timeframe_duration is the duration of the timeframe"},"timeframe_type":{"title":"timeframe_type defines the type of timeframe (block, hour, day)","$ref":"#/definitions/ibcratelimit.TimeframeType"}}},"managersplitter.ManagerSplitter":{"description":"ManagerSplitter defines the manager splitter entity.","type":"object","properties":{"address":{"description":"The module address of this manager splitter (derived from module name + ID).","type":"string"},"admin":{"description":"Permanent and static admin address. Has full control and can always execute all permissions.","type":"string"},"permissions":{"description":"Permissions mapping each CollectionPermission field to execution criteria.","$ref":"#/definitions/managersplitter.ManagerSplitterPermissions"}}},"managersplitter.ManagerSplitterPermissions":{"description":"ManagerSplitterPermissions mirrors the CollectionPermissions structure\nbut maps each permission to criteria for execution.","type":"object","properties":{"canAddMoreAliasPaths":{"description":"Permissions related to adding more alias paths to the collection.","$ref":"#/definitions/managersplitter.PermissionCriteria"},"canAddMoreCosmosCoinWrapperPaths":{"description":"Permissions related to adding more cosmos coin wrapper paths to the collection.","$ref":"#/definitions/managersplitter.PermissionCriteria"},"canArchiveCollection":{"description":"Permissions related to archiving the collection.","$ref":"#/definitions/managersplitter.PermissionCriteria"},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","$ref":"#/definitions/managersplitter.PermissionCriteria"},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","$ref":"#/definitions/managersplitter.PermissionCriteria"},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","$ref":"#/definitions/managersplitter.PermissionCriteria"},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","$ref":"#/definitions/managersplitter.PermissionCriteria"},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","$ref":"#/definitions/managersplitter.PermissionCriteria"},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","$ref":"#/definitions/managersplitter.PermissionCriteria"},"canUpdateTokenMetadata":{"description":"Permissions related to updating token metadata for specific tokens.","$ref":"#/definitions/managersplitter.PermissionCriteria"},"canUpdateValidTokenIds":{"description":"Permissions related to creating more tokens for the collection.","$ref":"#/definitions/managersplitter.PermissionCriteria"}}},"managersplitter.MsgCreateManagerSplitter":{"description":"MsgCreateManagerSplitter creates a new manager splitter entity.","type":"object","properties":{"admin":{"description":"Admin address creating the entity.","type":"string"},"permissions":{"description":"Permissions mapping each CollectionPermission field to execution criteria.","$ref":"#/definitions/managersplitter.ManagerSplitterPermissions"}}},"managersplitter.MsgCreateManagerSplitterResponse":{"description":"MsgCreateManagerSplitterResponse is the response to MsgCreateManagerSplitter.","type":"object","properties":{"address":{"description":"The address of the created manager splitter.","type":"string"}}},"managersplitter.MsgDeleteManagerSplitter":{"description":"MsgDeleteManagerSplitter deletes a manager splitter entity.","type":"object","properties":{"address":{"description":"Address of the manager splitter to delete.","type":"string"},"admin":{"description":"Admin address deleting the entity.","type":"string"}}},"managersplitter.MsgDeleteManagerSplitterResponse":{"description":"MsgDeleteManagerSplitterResponse is the response to MsgDeleteManagerSplitter.","type":"object"},"managersplitter.MsgExecuteUniversalUpdateCollection":{"description":"MsgExecuteUniversalUpdateCollection executes a UniversalUpdateCollection message\nthrough the manager splitter, checking permissions before execution.","type":"object","properties":{"executor":{"description":"Address executing the message (must be approved or admin).","type":"string"},"managerSplitterAddress":{"description":"Address of the manager splitter to execute through.","type":"string"},"universalUpdateCollectionMsg":{"description":"The UniversalUpdateCollection message to execute.","$ref":"#/definitions/tokenization.MsgUniversalUpdateCollection"}}},"managersplitter.MsgExecuteUniversalUpdateCollectionResponse":{"description":"MsgExecuteUniversalUpdateCollectionResponse is the response to MsgExecuteUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection that was updated.","type":"string"}}},"managersplitter.MsgUpdateManagerSplitter":{"description":"MsgUpdateManagerSplitter updates an existing manager splitter entity.","type":"object","properties":{"address":{"description":"Address of the manager splitter to update.","type":"string"},"admin":{"description":"Admin address updating the entity.","type":"string"},"permissions":{"description":"New permissions to set.","$ref":"#/definitions/managersplitter.ManagerSplitterPermissions"}}},"managersplitter.MsgUpdateManagerSplitterResponse":{"description":"MsgUpdateManagerSplitterResponse is the response to MsgUpdateManagerSplitter.","type":"object"},"managersplitter.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/managersplitter.Params"}}},"managersplitter.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"managersplitter.Params":{"description":"Params defines the parameters for the module.","type":"object"},"managersplitter.PermissionCriteria":{"description":"PermissionCriteria defines the criteria for executing a permission.\nCurrently supports approved addresses (whitelist).","type":"object","properties":{"approvedAddresses":{"description":"List of approved addresses that can execute this permission.","type":"array","items":{"type":"string"}}}},"managersplitter.QueryAllManagerSplittersResponse":{"description":"QueryAllManagerSplittersResponse is response type for the Query/AllManagerSplitters RPC method.","type":"object","properties":{"managerSplitters":{"type":"array","items":{"type":"object","$ref":"#/definitions/managersplitter.ManagerSplitter"}},"pagination":{"$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"}}},"managersplitter.QueryGetManagerSplitterResponse":{"description":"QueryGetManagerSplitterResponse is response type for the Query/ManagerSplitter RPC method.","type":"object","properties":{"managerSplitter":{"$ref":"#/definitions/managersplitter.ManagerSplitter"}}},"managersplitter.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/managersplitter.Params"}}},"maps.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.Map":{"type":"object","properties":{"creator":{"type":"string"},"defaultValue":{"type":"string"},"inheritManagerFrom":{"type":"string"},"manager":{"type":"string"},"mapId":{"type":"string"},"metadata":{"$ref":"#/definitions/maps.Metadata"},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateCriteria":{"title":"config options that will not change at all","$ref":"#/definitions/maps.MapUpdateCriteria"},"valueOptions":{"$ref":"#/definitions/maps.ValueOptions"}}},"maps.MapPermissions":{"type":"object","properties":{"canDeleteMap":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ActionPermission"}},"canUpdateManager":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ActionPermission"}},"canUpdateMetadata":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ActionPermission"}}}},"maps.MapUpdateCriteria":{"type":"object","properties":{"collectionId":{"type":"string","title":"ID slots are only updatable by token ID owner of this collection (\u003e1 balance at current time)"},"creatorOnly":{"type":"boolean","title":"Keys are address based and can only be updated by that respective address"},"firstComeFirstServe":{"description":"Claim slots. Can unclaim by setting to blank. Uses lastSetBy.","type":"boolean"},"managerOnly":{"type":"boolean","title":"All ID slots are only updatable by manager"}}},"maps.Metadata":{"description":"This message defines the metadata for the map.\nThe interpretation of this metadata should follow the map standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the map metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the map metadata.","type":"string"}}},"maps.MsgCreateMap":{"type":"object","properties":{"creator":{"type":"string"},"defaultValue":{"type":"string"},"inheritManagerFrom":{"type":"string"},"manager":{"type":"string"},"mapId":{"type":"string"},"metadata":{"$ref":"#/definitions/maps.Metadata"},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateCriteria":{"title":"config options that will not change at all","$ref":"#/definitions/maps.MapUpdateCriteria"},"valueOptions":{"$ref":"#/definitions/maps.ValueOptions"}}},"maps.MsgCreateMapResponse":{"type":"object"},"maps.MsgDeleteMap":{"type":"object","properties":{"creator":{"type":"string"},"mapId":{"type":"string"}}},"maps.MsgDeleteMapResponse":{"type":"object"},"maps.MsgSetValue":{"type":"object","properties":{"creator":{"type":"string"},"key":{"type":"string"},"mapId":{"type":"string"},"options":{"$ref":"#/definitions/maps.SetOptions"},"value":{"type":"string"}}},"maps.MsgSetValueResponse":{"type":"object"},"maps.MsgUpdateMap":{"type":"object","properties":{"creator":{"type":"string"},"manager":{"type":"string"},"mapId":{"type":"string"},"metadata":{"$ref":"#/definitions/maps.Metadata"},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateManager":{"type":"boolean"},"updateMetadata":{"type":"boolean"},"updatePermissions":{"type":"boolean"}}},"maps.MsgUpdateMapResponse":{"type":"object"},"maps.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/maps.Params"}}},"maps.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"maps.Params":{"description":"Params defines the parameters for the module.","type":"object"},"maps.QueryGetMapResponse":{"type":"object","properties":{"map":{"$ref":"#/definitions/maps.Map"}}},"maps.QueryGetMapValueResponse":{"type":"object","properties":{"value":{"$ref":"#/definitions/maps.ValueStore"}}},"maps.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/maps.Params"}}},"maps.SetOptions":{"type":"object","properties":{"useMostRecentCollectionId":{"type":"boolean"}}},"maps.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\n\nuintRanges are one of the core types used in the BitBadgesChain module.\nThey are used for everything from token IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"maps.ValueOptions":{"type":"object","properties":{"expectAddress":{"type":"boolean"},"expectBoolean":{"type":"boolean"},"expectUint":{"type":"boolean"},"expectUri":{"type":"boolean"},"noDuplicates":{"type":"boolean"},"permanentOnceSet":{"type":"boolean"}}},"maps.ValueStore":{"type":"object","properties":{"key":{"type":"string"},"lastSetBy":{"type":"string"},"value":{"type":"string"}}},"poolmanager.v1beta1.Affiliate":{"type":"object","title":"===================== Affiliate\nAffiliate represents an affiliate fee recipient","properties":{"address":{"type":"string","title":"address is the affiliate recipient address"},"basis_points_fee":{"type":"string","title":"basis_points_fee is the fee in basis points (1/10000, e.g., 100 = 1%)"}}},"poolmanager.v1beta1.AllPoolsResponse":{"type":"object","properties":{"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}}}},"poolmanager.v1beta1.AllRegisteredAlloyedPoolsResponse":{"type":"object","properties":{"contract_states":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.AlloyContractTakerFeeShareState"}}}},"poolmanager.v1beta1.AllTakerFeeShareAccumulatorsResponse":{"type":"object","properties":{"taker_fee_skim_accumulators":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeSkimAccumulator"}}}},"poolmanager.v1beta1.AllTakerFeeShareAgreementsResponse":{"type":"object","properties":{"taker_fee_share_agreements":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeShareAgreement"}}}},"poolmanager.v1beta1.AlloyContractTakerFeeShareState":{"description":"AlloyContractTakerFeeShareState contains the contract address of the alloyed\nasset pool, along with the adjusted taker fee share agreements for any asset\nwithin the alloyed asset pool that has a taker fee share agreement. If for\ninstance there are two denoms, and denomA makes up 50 percent and denomB\nmakes up 50 percent, and denom A has a taker fee share agreement with a skim\npercent of 10%, then the adjusted taker fee share agreement for denomA will\nbe 5%.","type":"object","properties":{"contract_address":{"description":"contract_address is the address of the alloyed asset pool contract.","type":"string"},"taker_fee_share_agreements":{"description":"taker_fee_share_agreements is the adjusted taker fee share agreements for\nany asset within the alloyed asset pool that has a taker fee share\nagreement.","type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeShareAgreement"}}}},"poolmanager.v1beta1.DenomPairTakerFee":{"type":"object","properties":{"denom0":{"description":"DEPRECATED: Now that we are using uni-directional trading pairs, we are\nusing tokenInDenom and tokenOutDenom instead of denom0 and denom1 to\nprevent confusion.","type":"string"},"denom1":{"type":"string"},"taker_fee":{"type":"string"},"tokenInDenom":{"type":"string"},"tokenOutDenom":{"type":"string"}}},"poolmanager.v1beta1.EstimateSwapExactAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"poolmanager.v1beta1.EstimateSwapExactAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"poolmanager.v1beta1.EstimateTradeBasedOnPriceImpactResponse":{"description":"EstimateTradeBasedOnPriceImpactResponse represents the response data\nfor an estimated trade based on price impact. If a trade fails to be\nestimated the response would be 0,0 for input_coin and output_coin and will\nnot error.","type":"object","properties":{"input_coin":{"description":"input_coin is the actual input amount that would be tradeable\nunder the specified price impact.","$ref":"#/definitions/cosmos.base.v1beta1.Coin"},"output_coin":{"description":"output_coin is the amount of tokens of the ToCoinDenom type\nthat will be received for the actual InputCoin trade.","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"poolmanager.v1beta1.ListPoolsByDenomResponse":{"type":"object","properties":{"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}}}},"poolmanager.v1beta1.MsgSetDenomPairTakerFee":{"type":"object","title":"===================== MsgSetDenomPairTakerFee","properties":{"denom_pair_taker_fee":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.DenomPairTakerFee"}},"sender":{"type":"string"}}},"poolmanager.v1beta1.MsgSetDenomPairTakerFeeResponse":{"type":"object","properties":{"success":{"type":"boolean"}}},"poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenom":{"type":"object","title":"===================== MsgSetTakerFeeShareAgreementForDenom","properties":{"denom":{"description":"denom is the denom that the taker fee share agreement is being set for.\nEx. If this is set to \"nBTC\", then any trade route that includes \"nBTC\"\nwill have the skim_percent skimmed from the taker fees and sent to the\nskim_address.","type":"string"},"sender":{"type":"string"},"skim_address":{"description":"skim_address is the address belonging to the respective bridge provider\nthat the skimmed taker fees will be sent to at the end of each epoch.","type":"string"},"skim_percent":{"description":"skim_percent is the percentage of taker fees that will be skimmed for the\nbridge provider, in the event that the bridge provider's denom is included\nin the swap route.","type":"string"}}},"poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenomResponse":{"type":"object"},"poolmanager.v1beta1.MsgSplitRouteSwapExactAmountIn":{"type":"object","title":"===================== MsgSplitRouteSwapExactAmountIn","properties":{"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountInSplitRoute"}},"sender":{"type":"string"},"token_in_denom":{"type":"string"},"token_out_min_amount":{"type":"string"}}},"poolmanager.v1beta1.MsgSplitRouteSwapExactAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOut":{"type":"object","title":"===================== MsgSplitRouteSwapExactAmountOut","properties":{"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountOutSplitRoute"}},"sender":{"type":"string"},"token_in_max_amount":{"type":"string"},"token_out_denom":{"type":"string"}}},"poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"poolmanager.v1beta1.MsgSwapExactAmountIn":{"type":"object","title":"===================== MsgSwapExactAmountIn","properties":{"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountInRoute"}},"sender":{"type":"string"},"token_in":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"},"token_out_min_amount":{"type":"string"}}},"poolmanager.v1beta1.MsgSwapExactAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"poolmanager.v1beta1.MsgSwapExactAmountOut":{"type":"object","title":"===================== MsgSwapExactAmountOut","properties":{"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountOutRoute"}},"sender":{"type":"string"},"token_in_max_amount":{"type":"string"},"token_out":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"poolmanager.v1beta1.MsgSwapExactAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"poolmanager.v1beta1.NumPoolsResponse":{"type":"object","properties":{"num_pools":{"type":"string","format":"uint64"}}},"poolmanager.v1beta1.Params":{"type":"object","title":"Params holds parameters for the poolmanager module","properties":{"taker_fee_params":{"description":"taker_fee_params is the container of taker fee parameters.","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeParams"}}},"poolmanager.v1beta1.ParamsResponse":{"type":"object","properties":{"params":{"$ref":"#/definitions/poolmanager.v1beta1.Params"}}},"poolmanager.v1beta1.PoolResponse":{"type":"object","properties":{"pool":{"$ref":"#/definitions/google.protobuf.Any"}}},"poolmanager.v1beta1.RegisteredAlloyedPoolFromDenomResponse":{"type":"object","properties":{"contract_state":{"$ref":"#/definitions/poolmanager.v1beta1.AlloyContractTakerFeeShareState"}}},"poolmanager.v1beta1.RegisteredAlloyedPoolFromPoolIdResponse":{"type":"object","properties":{"contract_state":{"$ref":"#/definitions/poolmanager.v1beta1.AlloyContractTakerFeeShareState"}}},"poolmanager.v1beta1.SpotPriceResponse":{"description":"SpotPriceResponse defines the gRPC response structure for a SpotPrice\nquery.","type":"object","properties":{"spot_price":{"type":"string","title":"String of the Dec. Ex) 10.203uatom"}}},"poolmanager.v1beta1.SwapAmountInRoute":{"type":"object","properties":{"pool_id":{"type":"string","format":"uint64"},"token_out_denom":{"type":"string"}}},"poolmanager.v1beta1.SwapAmountInSplitRoute":{"type":"object","properties":{"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountInRoute"}},"token_in_amount":{"type":"string"}}},"poolmanager.v1beta1.SwapAmountOutRoute":{"type":"object","properties":{"pool_id":{"type":"string","format":"uint64"},"token_in_denom":{"type":"string"}}},"poolmanager.v1beta1.SwapAmountOutSplitRoute":{"type":"object","properties":{"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountOutRoute"}},"token_out_amount":{"type":"string"}}},"poolmanager.v1beta1.TakerFeeDistributionPercentage":{"description":"TakerFeeDistributionPercentage defines what percent of the taker fee category\ngets distributed to the available categories.","type":"object","properties":{"community_pool":{"type":"string"},"staking_rewards":{"type":"string"}}},"poolmanager.v1beta1.TakerFeeParams":{"description":"TakerFeeParams consolidates the taker fee parameters for the poolmanager.","type":"object","properties":{"admin_addresses":{"description":"admin_addresses is a list of addresses that are allowed to set and remove\ncustom taker fees for denom pairs. Governance also has the ability to set\nand remove custom taker fees for denom pairs, but with the normal\ngovernance delay.","type":"array","items":{"type":"string"}},"community_pool_denom_to_swap_non_whitelisted_assets_to":{"description":"community_pool_denom_to_swap_non_whitelisted_assets_to is the denom that\nnon-whitelisted taker fees will be swapped to before being sent to\nthe community pool.","type":"string"},"community_pool_denom_whitelist":{"description":"community_pool_denom_whitelist is a list of denoms that should be sent\ndirectly to the community pool instead of being swapped to the\n`community_pool_denom_to_swap_non_whitelisted_assets_to`.","type":"array","items":{"type":"string"}},"default_taker_fee":{"description":"default_taker_fee is the fee used when creating a new pool that doesn't\nfall under a custom pool taker fee or stableswap taker fee category.","type":"string"},"non_osmo_taker_fee_distribution":{"description":"non_osmo_taker_fee_distribution defines the distribution of taker fees\ngenerated in non-OSMO. As of this writing, it has two categories:\n- staking_rewards: the percent of the taker fee that gets swapped to OSMO\n  and then distributed to stakers.\n- community_pool: the percent of the taker fee that gets sent to the\n  community pool. Note: If the non-OSMO asset is an authorized_quote_denom,\n  that denom is sent directly to the community pool. Otherwise, it is\n  swapped to the community_pool_denom_to_swap_non_whitelisted_assets_to and\n  then sent to the community pool as that denom.","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeDistributionPercentage"},"osmo_taker_fee_distribution":{"description":"osmo_taker_fee_distribution defines the distribution of taker fees\ngenerated in OSMO. As of this writing, it has two categories:\n- staking_rewards: the percent of the taker fee that gets distributed to\n  stakers.\n- community_pool: the percent of the taker fee that gets sent to the\n  community pool.","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeDistributionPercentage"},"reduced_fee_whitelist":{"description":"reduced_fee_whitelist is a list of addresses that are\nallowed to pay a reduce taker fee when performing a swap\n(i.e. swap without paying the taker fee).\nIt is intended to be used for integrators who meet qualifying factors\nthat are approved by governance.\nInitially, the taker fee is allowed to be bypassed completely. However\nIn the future, we will charge a reduced taker fee instead of no fee at all.","type":"array","items":{"type":"string"}}}},"poolmanager.v1beta1.TakerFeeShareAgreement":{"description":"TakerFeeShareAgreement represents the agreement between the Osmosis protocol\nand a specific denom to share a certain percent of taker fees generated in\nany route that contains said denom. For example, if the agreement specifies a\n10% skim_percent, this means 10% of the taker fees generated in a swap route\ncontaining the specified denom will be sent to the address specified\nin the skim_address field at the end of each epoch. These skim_percents are\nadditive, so if three taker fee agreements have skim percents of 10%, 20%,\nand 30%, the total skim percent for the route will be 60%.","type":"object","properties":{"denom":{"description":"denom is the denom that has the taker fee share agreement.","type":"string"},"skim_address":{"description":"skim_address is the address belonging to the respective denom\nthat the skimmed taker fees will be sent to at the end of each epoch.","type":"string"},"skim_percent":{"description":"skim_percent is the percentage of taker fees that will be skimmed for the\ndenom, in the event that the denom is included in the swap route.","type":"string"}}},"poolmanager.v1beta1.TakerFeeShareAgreementFromDenomResponse":{"type":"object","properties":{"taker_fee_share_agreement":{"$ref":"#/definitions/poolmanager.v1beta1.TakerFeeShareAgreement"}}},"poolmanager.v1beta1.TakerFeeShareDenomsToAccruedValueResponse":{"type":"object","properties":{"amount":{"type":"string"}}},"poolmanager.v1beta1.TakerFeeSkimAccumulator":{"description":"TakerFeeSkimAccumulator accumulates the total skimmed taker fees for each\ndenom that has a taker fee share agreement.","type":"object","properties":{"denom":{"description":"denom is the denom that has the taker fee share agreement.","type":"string"},"skimmed_taker_fees":{"description":"skimmed_taker_fees is the total skimmed taker fees for the denom.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"poolmanager.v1beta1.TotalLiquidityResponse":{"type":"object","properties":{"liquidity":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"poolmanager.v1beta1.TotalPoolLiquidityResponse":{"type":"object","properties":{"liquidity":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"poolmanager.v1beta1.TotalVolumeForPoolResponse":{"type":"object","properties":{"volume":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"poolmanager.v1beta1.TradingPairTakerFeeResponse":{"type":"object","properties":{"taker_fee":{"type":"string"}}},"poolmanager.v2.SpotPriceResponse":{"description":"SpotPriceResponse defines the gRPC response structure for a SpotPrice\nquery.","type":"object","properties":{"spot_price":{"type":"string","title":"String of the BigDec. Ex) 10.203uatom"}}},"sendmanager.MsgSendWithAliasRouting":{"description":"MsgSendWithAliasRouting defines a message for sending coins with alias denom routing.\nThis message mirrors cosmos bank MsgSend but routes through sendmanager to handle\nboth standard coins and alias denoms (e.g., badgeslp:).","type":"object","properties":{"amount":{"description":"amount is the list of coins to send.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"from_address":{"description":"from_address is the address of the account sending the coins.","type":"string"},"to_address":{"description":"to_address is the address of the account receiving the coins.","type":"string"}}},"sendmanager.MsgSendWithAliasRoutingResponse":{"description":"MsgSendWithAliasRoutingResponse defines the response structure for executing a\nMsgSendWithAliasRouting message.","type":"object"},"sendmanager.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/sendmanager.Params"}}},"sendmanager.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"sendmanager.Params":{"description":"Params defines the parameters for the module.","type":"object"},"sendmanager.QueryBalanceResponse":{"description":"QueryBalanceResponse is response type for the Query/Balance RPC method.","type":"object","properties":{"balance":{"description":"balance is the balance of the specified denom for the address.","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"sendmanager.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/sendmanager.Params"}}},"tokenization.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.AddressChecks":{"type":"object","title":"AddressChecks defines checks for address types (EVM contract, liquidity pool, etc.)","properties":{"mustBeEvmContract":{"description":"Require the address to be an EVM contract (has code).","type":"boolean"},"mustBeLiquidityPool":{"description":"Require the address to be a liquidity pool.","type":"boolean"},"mustNotBeEvmContract":{"description":"Require the address to not be an EVM contract (no code).","type":"boolean"},"mustNotBeLiquidityPool":{"description":"Require the address to not be a liquidity pool.","type":"boolean"}}},"tokenization.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"tokenization.AddressListInput":{"description":"AddressListInput is used for creating address lists via MsgCreateAddressLists.\nIt contains all fields from AddressList except createdBy, which is automatically set from the message creator.","type":"object","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"tokenization.AliasPath":{"type":"object","properties":{"conversion":{"description":"The conversion between cosmos coin and token balances.","$ref":"#/definitions/tokenization.ConversionWithoutDenom"},"denom":{"description":"The denomination (denom) to be used for the alias.","type":"string"},"denomUnits":{"description":"Denomination units for the alias. Defines how the coin can be displayed with different decimal places and symbols.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.DenomUnit"}},"metadata":{"description":"The metadata for this alias path.","$ref":"#/definitions/tokenization.PathMetadata"},"symbol":{"description":"The symbol for the alias (e.g., \"BADGE\", \"NFT\"). Used for display purposes. Note that this may not be the default.","type":"string"}}},"tokenization.AliasPathAddObject":{"type":"object","properties":{"conversion":{"$ref":"#/definitions/tokenization.ConversionWithoutDenom"},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.DenomUnit"}},"metadata":{"description":"The metadata for this alias path.","$ref":"#/definitions/tokenization.PathMetadata"},"symbol":{"type":"string"}}},"tokenization.AltTimeChecks":{"type":"object","title":"AltTimeChecks defines alternative time-based checks for approval denial.\nIf the transfer time falls within any of the specified offline hours or days, the approval is denied.\nUses UTC timezone for neutral timezone approach.\nofflineHours: ranges of hours (0-23) when transfers should be denied\nofflineDays: ranges of days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied","properties":{"offlineDays":{"description":"Days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied. Uses UTC timezone.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"offlineHours":{"description":"Hours (0-23) when transfers should be denied. Uses UTC timezone.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified token IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/tokenization.ResetTimeIntervals"}}},"tokenization.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.\nAll criteria must be satisfied for the approval to be considered valid.","type":"object","properties":{"allowBackedMinting":{"description":"If true, this collection approval allows backed minting operations (CosmosCoinBackedPath).\nWhen false, this approval cannot be used for transfers involving backed minting addresses.\nThis prevents accidental allowances when toListIds is \"All\".","type":"boolean"},"allowSpecialWrapping":{"description":"If true, this collection approval allows special wrapping operations (CosmosCoinWrapperPath).\nWhen false, this approval cannot be used for transfers involving wrapping addresses.\nThis prevents accidental allowances when toListIds is \"All\".","type":"boolean"},"altTimeChecks":{"description":"Alternative time-based checks for approval denial (offline hours/days). Defines time periods\nduring which this approval should be denied, such as specific hours of the day or days of the week.","$ref":"#/definitions/tokenization.AltTimeChecks"},"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts\ntransferred and enforces maximum limits per approval.","$ref":"#/definitions/tokenization.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options for this approval. Defines conditions under which this approval should be\nautomatically deleted (e.g., after a certain number of uses or time period).","$ref":"#/definitions/tokenization.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,\nroyalties) that must be executed alongside the token transfer for the approval to be valid.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval. The initiator must provide\nvalid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval. The initiator must provide\nvalid Ethereum signatures for all specified challenges. Each signature can only be used once.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ETHSignatureChallenge"}},"evmQueryChallenges":{"description":"EVM query challenges that must pass for approval. Read-only contract queries\nthat verify external EVM state (e.g., token ownership in another contract).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.EVMQueryChallenge"}},"initiatorChecks":{"description":"Address checks for the initiator of the transfer. Validates that the initiator address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.AddressChecks"},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval. Tracks the count of transfers\nand enforces the limit to prevent exceeding the allowed number of uses.","$ref":"#/definitions/tokenization.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs\nthat satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval. Defines token ownership requirements that must be satisfied for\nthe approval to be valid. The initiator must own the specified tokens at the specified ownership times.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.MustOwnTokens"}},"mustPrioritize":{"description":"If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.\nThis allows fine-grained control over which approvals are applied when multiple approvals could match.","type":"boolean"},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval. If true, this collection-level approval\ntakes precedence over any outgoing approvals defined by the sender, allowing the collection to\ncontrol outgoing transfer behavior.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval. If true, this collection-level approval\ntakes precedence over any incoming approvals defined by the recipient, allowing the collection to\ncontrol incoming transfer behavior.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs\nthat can be transferred when using this approval.","$ref":"#/definitions/tokenization.PredeterminedBalances"},"recipientChecks":{"description":"Address checks for the recipient of the transfer. Validates that the recipient address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.AddressChecks"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the sender equals the initiator are forbidden.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the sender matches the initiator are allowed.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the recipient equals the initiator are forbidden.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the recipient matches the initiator are allowed.","type":"boolean"},"senderChecks":{"description":"Address checks for the sender of the transfer. Validates that the sender address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.AddressChecks"},"userRoyalties":{"description":"User level royalties to apply to the transfer. Defines the percentage and payout address for\nroyalties that should be collected when this approval is used for a transfer.","$ref":"#/definitions/tokenization.UserRoyalties"},"votingChallenges":{"description":"Voting challenges that must be satisfied for approval. The initiator must provide\nvalid votes that meet the quorum threshold for all specified challenges.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.VotingChallenge"}}}},"tokenization.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"tokenization.ApprovalTracker":{"description":"ApprovalTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.","type":"object","properties":{"amounts":{"description":"Cumulative balances associated with the transfers that have been processed.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.Balance"}},"lastUpdatedAt":{"description":"Last updated at time.","type":"string"},"numTransfers":{"description":"The number of transfers that have been processed.","type":"string"}}},"tokenization.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"},"allowCounterpartyPurge":{"type":"boolean","title":"Allow counterparty to purge this approval if they are the only initiator"},"allowPurgeIfExpired":{"type":"boolean","title":"Allow others to call PurgeApprovals on behalf of this approval owner"}}},"tokenization.Balance":{"description":"Balance represents the balance of a token for a specific user.\nThe user amounts xAmount of a token specified for the time ranges specified.\n\nExample: User A owns x10 of token IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or tokenIDs have len \u003e 1, then the user owns all token IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the token owned by the user.","type":"string"},"ownershipTimes":{"description":"The time ranges during which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"tokenIds":{"description":"The token IDs for which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"tokenization.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/tokenization.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"tokenization.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, tokenId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, tokenIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that token ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.CollectionInvariants":{"description":"CollectionInvariants defines the invariants that apply to a collection.","type":"object","properties":{"cosmosCoinBackedPath":{"description":"The IBC backed (sdk.coin) path for the collection. Only one path is allowed.","$ref":"#/definitions/tokenization.CosmosCoinBackedPath"},"disablePoolCreation":{"description":"If true, disallows pool creation with this collection's assets.\nWhen true, any attempt to create a pool with tokenization assets from this collection will fail.","type":"boolean"},"evmQueryChallenges":{"type":"array","title":"EVM query invariants that must pass after all transfers complete.\nThese are checked once per message after all balance updates, with access to ALL recipient addresses.\nPlaceholders: $sender, $recipients (comma-separated), $initiator, $collectionId, $recipient","items":{"type":"object","$ref":"#/definitions/tokenization.EVMQueryChallenge"}},"maxSupplyPerId":{"description":"Maximum supply per token ID. Checked against Total address balances after transfers complete.\nA value of 0 means no limit (unlimited).","type":"string"},"noCustomOwnershipTimes":{"description":"If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].\nThis prevents time-based restrictions on token ownership.","type":"boolean"},"noForcefulPostMintTransfers":{"description":"If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.\nThis prevents forceful transfers that bypass user-level approvals.\nThis only applies to transfers where the from address does not equal \"Mint\".","type":"boolean"}}},"tokenization.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"tokenization.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are three types of permissions for a collection: ActionPermission, TokenIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action or update a field.\n- TokenIdsActionPermission: defines when the manager can perform an action for specific tokens\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a token is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canAddMoreAliasPaths":{"description":"Permissions related to adding more alias paths to the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"canAddMoreCosmosCoinWrapperPaths":{"description":"Permissions related to adding more cosmos coin wrapper paths to the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"canUpdateTokenMetadata":{"description":"Permissions related to updating token metadata for specific tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.TokenIdsActionPermission"}},"canUpdateValidTokenIds":{"description":"Permissions related to creating more tokens for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.TokenIdsActionPermission"}}}},"tokenization.CollectionStats":{"description":"CollectionStats tracks aggregated statistics for a collection.","type":"object","properties":{"balances":{"type":"array","title":"Tracks circulating supply as Balance[] for proper range handling","items":{"type":"object","$ref":"#/definitions/tokenization.Balance"}},"holderCount":{"type":"string"}}},"tokenization.Conversion":{"description":"Conversion defines a bidirectional conversion between a cosmos coin (with denom) and token balances.","type":"object","properties":{"sideA":{"description":"Side A: The cosmos coin side of the conversion (amount + denom).","$ref":"#/definitions/tokenization.ConversionSideAWithDenom"},"sideB":{"description":"Side B: The token balances side of the conversion.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.Balance"}}}},"tokenization.ConversionSideA":{"description":"ConversionSideA represents the cosmos coin amount side of a conversion without denomination.","type":"object","properties":{"amount":{"description":"The amount of the cosmos coin (0 decimals).","type":"string"}}},"tokenization.ConversionSideAWithDenom":{"description":"ConversionSideAWithDenom represents the cosmos coin side of a conversion with denomination.","type":"object","properties":{"amount":{"description":"The amount of the cosmos coin (0 decimals).","type":"string"},"denom":{"description":"The denomination of the cosmos coin.","type":"string"}}},"tokenization.ConversionWithoutDenom":{"description":"ConversionWithoutDenom defines a bidirectional conversion between a cosmos coin amount (without denom) and token balances.\nThe denom is stored at the base level (e.g., in AliasPath or CosmosCoinWrapperPath).","type":"object","properties":{"sideA":{"description":"Side A: The cosmos coin amount side of the conversion (amount only, denom stored separately).","$ref":"#/definitions/tokenization.ConversionSideA"},"sideB":{"description":"Side B: The token balances side of the conversion.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.Balance"}}}},"tokenization.CosmosCoinBackedPath":{"type":"object","properties":{"address":{"description":"The address associated with this backed path. Used for routing and escrowing IBC tokens.","type":"string"},"conversion":{"description":"The conversion between IBC cosmos coin and token balances.","$ref":"#/definitions/tokenization.Conversion"}}},"tokenization.CosmosCoinBackedPathAddObject":{"type":"object","properties":{"conversion":{"$ref":"#/definitions/tokenization.Conversion"}}},"tokenization.CosmosCoinWrapperPath":{"type":"object","properties":{"address":{"description":"The BitBadges address associated with this wrapper path. Used for routing and identifying the wrapper.","type":"string"},"allowOverrideWithAnyValidToken":{"description":"If true, allows this wrapper path to be used with any valid token ID in the collection via an {id} placeholder.","type":"boolean"},"conversion":{"description":"The conversion between cosmos coin and token balances.","$ref":"#/definitions/tokenization.ConversionWithoutDenom"},"denom":{"description":"The denomination (denom) to be used for the wrapped coin or the alias denom.","type":"string"},"denomUnits":{"description":"Denomination units for the wrapped coin. Defines how the coin can be displayed with different\ndecimal places and symbols (e.g., base unit, display unit). You can specify which is the default display unit (base level or one of these).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.DenomUnit"}},"metadata":{"description":"The metadata for this wrapper path.","$ref":"#/definitions/tokenization.PathMetadata"},"symbol":{"description":"The symbol for the wrapped coin (e.g., \"BADGE\", \"NFT\"). Used for display purposes. Note that this may not be the default.","type":"string"}}},"tokenization.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"allowOverrideWithAnyValidToken":{"type":"boolean"},"conversion":{"$ref":"#/definitions/tokenization.ConversionWithoutDenom"},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.DenomUnit"}},"metadata":{"description":"The metadata for this wrapper path.","$ref":"#/definitions/tokenization.PathMetadata"},"symbol":{"type":"string"}}},"tokenization.DenomUnit":{"type":"object","properties":{"decimals":{"description":"The number of decimal places for this unit. Defines the precision of the unit.","type":"string"},"isDefaultDisplay":{"description":"If true, this is the default display unit. Only one unit should be marked as the default display unit.\nThis unit will be used by default when displaying the coin amount. If none are marked default, we use the base level.","type":"boolean"},"metadata":{"description":"The metadata for this denomination unit.","$ref":"#/definitions/tokenization.PathMetadata"},"symbol":{"description":"The symbol for this unit (e.g., \"BADGE\", \"nBADGE\"). Used for display purposes.","type":"string"}}},"tokenization.DynamicStore":{"description":"A DynamicStore is a flexible storage object that can store arbitrary data.\nIt is identified by a unique ID assigned by the blockchain, which is a uint64 that increments.\nDynamic stores are created by users and can only be updated or deleted by their creator.\nThey provide a way to store custom data on-chain with proper access control.","type":"object","properties":{"createdBy":{"description":"The address of the creator of this dynamic store.","type":"string"},"customData":{"description":"Custom data field for storing arbitrary data associated with this dynamic store.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses (true/false).","type":"boolean"},"globalEnabled":{"description":"Global kill switch state (defaults to true on creation, can be toggled via UpdateDynamicStore).\nWhen false, all approvals using this store via DynamicStoreChallenge will fail immediately.","type":"boolean"},"storeId":{"description":"The unique identifier for this dynamic store. This is assigned by the blockchain.","type":"string"},"uri":{"description":"URI for additional metadata or resources associated with this dynamic store.","type":"string"}}},"tokenization.DynamicStoreChallenge":{"description":"DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.","type":"object","properties":{"ownershipCheckParty":{"description":"The party to check ownership for. Options are \"initiator\", \"sender\", \"recipient\", or any valid bb1 address.\nIf a valid bb1 address is provided, ownership will be checked for that specific address.\nThis enables use cases like halt tokens where ownership is checked for an arbitrary address (e.g., halt token owner).\nDefaults to \"initiator\" if empty or if the value is not a recognized option or valid bb1 address.","type":"string"},"storeId":{"description":"The ID of the dynamic store to check.","type":"string"}}},"tokenization.DynamicStoreValue":{"description":"A DynamicStoreValue stores a boolean value for a specific address in a dynamic store.\nThis allows the creator to set true/false values per address that can be checked during approval.","type":"object","properties":{"address":{"description":"The address for which this value is stored.","type":"string"},"storeId":{"description":"The unique identifier for this dynamic store.","type":"string"},"value":{"description":"The boolean value (true/false).","type":"boolean"}}},"tokenization.ETHSignatureChallenge":{"description":"ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.\n\nAn ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.\nThe signature scheme is ETHSign(nonce + \"-\" + initiatorAddress + \"-\" + collectionId + \"-\" + approverAddress + \"-\" + approvalLevel + \"-\" + approvalId + \"-\" + challengeId) and each signature can only be used once.\nAll challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.\nIf you update the challenge ID, then the used signatures tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this ETH signature challenge for tracking the number of uses per signature.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this ETH signature challenge.","type":"string"},"signer":{"description":"The Ethereum address that must sign the nonce for verification.","type":"string"},"uri":{"description":"The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.","type":"string"}}},"tokenization.ETHSignatureProof":{"description":"ETHSignatureProof represents an Ethereum signature proof for a challenge.","type":"object","properties":{"nonce":{"description":"The nonce that was signed. The signature scheme is ETHSign(nonce + \"-\" + initiatorAddress + \"-\" + collectionId + \"-\" + approverAddress + \"-\" + approvalLevel + \"-\" + approvalId + \"-\" + challengeId).","type":"string"},"signature":{"description":"The Ethereum signature of the nonce.","type":"string"}}},"tokenization.EVMQueryChallenge":{"description":"EVMQueryChallenge defines a rule for approval via read-only EVM contract query.\n\nThe challenge executes a staticcall to the specified contract with the given calldata.\nThe result is compared against the expected result (if provided) or checked for non-zero return.\n\nIMPORTANT: This is read-only and cannot modify state. The query is executed with a gas limit\nto prevent DoS attacks. All results are deterministic since EVM state is consistent within a block.","type":"object","properties":{"calldata":{"type":"string","title":"ABI-encoded function selector + arguments (hex string without 0x prefix)\nExample: \"70a08231000000000000000000000000{address}\" for balanceOf(address)\nCan use placeholders: $initiator, $sender, $recipient (replaced at runtime)"},"comparisonOperator":{"description":"Comparison operator: \"eq\" (equals), \"ne\" (not equals), \"gt\" (greater than), \"gte\", \"lt\", \"lte\"\nOnly \"eq\" and \"ne\" work for non-numeric types. Default is \"eq\".","type":"string"},"contractAddress":{"type":"string","title":"The EVM contract address to query (0x format or bb1 format)"},"customData":{"type":"string","title":"Arbitrary custom data"},"expectedResult":{"description":"Expected return value (hex string without 0x prefix). If empty, any non-error result passes.\nFor boolean checks, use \"0000...0001\" for true.","type":"string"},"gasLimit":{"type":"string","title":"Gas limit for the query (default 100000, max 500000)"},"uri":{"type":"string","title":"The URI associated with this challenge (metadata)"}}},"tokenization.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.\nThis is used for user-level incoming approvals and only includes fields relevant to incoming transfers.\nAll criteria must be satisfied for the approval to be considered valid.","type":"object","properties":{"altTimeChecks":{"description":"Alternative time-based checks for approval denial (offline hours/days). Defines time periods\nduring which this approval should be denied, such as specific hours of the day or days of the week.","$ref":"#/definitions/tokenization.AltTimeChecks"},"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts\ntransferred and enforces maximum limits per approval.","$ref":"#/definitions/tokenization.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options for this approval. Defines conditions under which this approval should be\nautomatically deleted (e.g., after a certain number of uses or time period).","$ref":"#/definitions/tokenization.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,\nroyalties) that must be executed alongside the token transfer for the approval to be valid.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval. The initiator must provide\nvalid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval. The initiator must provide\nvalid Ethereum signatures for all specified challenges. Each signature can only be used once.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ETHSignatureChallenge"}},"evmQueryChallenges":{"description":"EVM query challenges that must pass for approval. Read-only contract queries\nthat verify external EVM state (e.g., token ownership in another contract).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.EVMQueryChallenge"}},"initiatorChecks":{"description":"Address checks for the initiator of the transfer. Validates that the initiator address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.AddressChecks"},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval. Tracks the count of transfers\nand enforces the limit to prevent exceeding the allowed number of uses.","$ref":"#/definitions/tokenization.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs\nthat satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval. Defines token ownership requirements that must be satisfied for\nthe approval to be valid. The initiator must own the specified tokens at the specified ownership times.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.MustOwnTokens"}},"mustPrioritize":{"description":"If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.\nThis allows fine-grained control over which approvals are applied when multiple approvals could match.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs\nthat can be transferred when using this approval.","$ref":"#/definitions/tokenization.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the sender equals the initiator are forbidden.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the sender matches the initiator are allowed.","type":"boolean"},"senderChecks":{"description":"Address checks for the sender of the transfer. Validates that the sender address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).\nNote: No recipient checks are included for incoming approvals since the recipient is the user themselves.","$ref":"#/definitions/tokenization.AddressChecks"},"votingChallenges":{"description":"Voting challenges that must be satisfied for approval. The initiator must provide\nvalid votes that meet the quorum threshold for all specified challenges.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.VotingChallenge"}}}},"tokenization.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidToken":{"type":"boolean","title":"Allow override of any valid ID"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"incrementTokenIdsBy":{"description":"The amount by which to increment token IDs.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/tokenization.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.Balance"}}}},"tokenization.InvariantsAddObject":{"description":"InvariantsAddObject is used for adding invariants without specifying addresses.\nAddresses are generated by the keeper and stored in the collection.","type":"object","properties":{"cosmosCoinBackedPath":{"description":"The IBC backed (sdk.coin) path for the collection. Only one path is allowed.\nAddress will be generated by the keeper.","$ref":"#/definitions/tokenization.CosmosCoinBackedPathAddObject"},"disablePoolCreation":{"description":"If true, disallows pool creation with this collection's assets.\nWhen true, any attempt to create a pool with tokenization assets from this collection will fail.","type":"boolean"},"evmQueryChallenges":{"type":"array","title":"EVM query invariants that must pass after all transfers complete.\nThese are checked once per message after all balance updates, with access to ALL recipient addresses.\nPlaceholders: $sender, $recipients (comma-separated), $initiator, $collectionId, $recipient","items":{"type":"object","$ref":"#/definitions/tokenization.EVMQueryChallenge"}},"maxSupplyPerId":{"description":"Maximum supply per token ID. Checked against Total address balances after transfers complete.\nA value of 0 means no limit (unlimited).","type":"string"},"noCustomOwnershipTimes":{"description":"If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].\nThis prevents time-based restrictions on token ownership.","type":"boolean"},"noForcefulPostMintTransfers":{"description":"If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.\nThis prevents forceful transfers that bypass user-level approvals.\nThis only applies to transfers where the from address does not equal \"Mint\".","type":"boolean"}}},"tokenization.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.Balance"}}}},"tokenization.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified token IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/tokenization.ResetTimeIntervals"}}},"tokenization.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"description":"Ethereum address that must sign the leaf. Used to protect against man-in-the-middle attacks.\nSignature scheme: sign(leaf + \"-\" + creatorAddress), verified using elliptic curve signature verification.","type":"string"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"tokenization.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"tokenization.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"tokenization.MsgCastVote":{"description":"MsgCastVote allows a voter to cast or update their vote for a voting challenge.","type":"object","properties":{"approvalId":{"description":"The approval ID.","type":"string"},"approvalLevel":{"description":"The approval level (\"collection\", \"incoming\", or \"outgoing\").","type":"string"},"approverAddress":{"description":"The approver address (empty string for collection-level approvals).","type":"string"},"collectionId":{"description":"The collection ID for the voting challenge.","type":"string"},"creator":{"description":"The address of the voter casting the vote.","type":"string"},"proposalId":{"description":"The proposal ID (challenge ID) from the VotingChallenge.","type":"string"},"yesWeight":{"description":"The percentage weight (0-100) allocated to \"yes\" vote.\nThe remaining percentage (100 - yesWeight) is allocated to \"no\" vote.\nExample: yesWeight=70 means 70% yes, 30% no.","type":"string"}}},"tokenization.MsgCastVoteResponse":{"type":"object"},"tokenization.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create. The createdBy field will be automatically set to the creator address.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.AddressListInput"}},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"tokenization.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"aliasPathsToAdd":{"description":"Alias (non-wrapping) paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.AliasPathAddObject"}},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CollectionApproval"}},"collectionMetadata":{"description":"Collection metadata.","$ref":"#/definitions/tokenization.CollectionMetadata"},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/tokenization.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"Custom data.","type":"string"},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/tokenization.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nAddresses are generated by the keeper and stored in the collection.","$ref":"#/definitions/tokenization.InvariantsAddObject"},"isArchived":{"description":"isArchived flag.","type":"boolean"},"manager":{"description":"Manager address.","type":"string"},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standards":{"description":"Standards entries.","type":"array","items":{"type":"string"}},"tokenMetadata":{"description":"Token metadata entries.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.TokenMetadata"}},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.MsgCreateDynamicStore":{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"Custom data field for storing arbitrary data associated with this dynamic store.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses (true/false).","type":"boolean"},"uri":{"description":"URI for additional metadata or resources associated with this dynamic store.","type":"string"}}},"tokenization.MsgCreateDynamicStoreResponse":{"description":"MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.","type":"object","properties":{"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"tokenization.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"tokenization.MsgDeleteDynamicStore":{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store to delete.","type":"string"}}},"tokenization.MsgDeleteDynamicStoreResponse":{"description":"MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.","type":"object"},"tokenization.MsgDeleteIncomingApproval":{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.MsgDeleteIncomingApprovalResponse":{"description":"MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.","type":"object"},"tokenization.MsgDeleteOutgoingApproval":{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.MsgDeleteOutgoingApprovalResponse":{"description":"MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.","type":"object"},"tokenization.MsgPurgeApprovals":{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","type":"object","properties":{"approvalsToPurge":{"description":"Specific approvals to purge. If empty, purges all applicable approvals based on other flags.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ApprovalIdentifierDetails"}},"approverAddress":{"description":"Address of the user whose approvals to purge. If empty, defaults to creator.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"purgeCounterpartyApprovals":{"description":"Whether to purge counterparty approvals (approvals where the creator is the only initiator).","type":"boolean"},"purgeExpired":{"description":"Whether to purge expired approvals (approvals with no future valid transfer times).","type":"boolean"}}},"tokenization.MsgPurgeApprovalsResponse":{"description":"MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.","type":"object","properties":{"numPurged":{"description":"Number of approvals purged.","type":"string"}}},"tokenization.MsgSetCollectionApprovals":{"type":"object","title":"MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission","properties":{"canUpdateCollectionApprovals":{"type":"array","title":"Permission to update collection approvals","items":{"type":"object","$ref":"#/definitions/tokenization.CollectionApprovalPermission"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CollectionApproval"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.MsgSetCollectionApprovalsResponse":{"description":"MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.MsgSetCollectionMetadata":{"type":"object","title":"MsgSetCollectionMetadata sets the collection metadata and canUpdateCollectionMetadata permission","properties":{"canUpdateCollectionMetadata":{"type":"array","title":"Permission to update collection metadata","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"collectionMetadata":{"description":"New collection metadata to set.","$ref":"#/definitions/tokenization.CollectionMetadata"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.MsgSetCollectionMetadataResponse":{"description":"MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.MsgSetCustomData":{"type":"object","title":"MsgSetCustomData sets the custom data and canUpdateCustomData permission","properties":{"canUpdateCustomData":{"type":"array","title":"Permission to update custom data","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"New custom data to set.","type":"string"}}},"tokenization.MsgSetCustomDataResponse":{"description":"MsgSetCustomDataResponse is the response to MsgSetCustomData.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.MsgSetDynamicStoreValue":{"description":"MsgSetDynamicStoreValue is used to set a boolean value for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to set the value.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"},"value":{"description":"The boolean value to set (true/false).","type":"boolean"}}},"tokenization.MsgSetDynamicStoreValueResponse":{"description":"MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.","type":"object"},"tokenization.MsgSetIncomingApproval":{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","type":"object","properties":{"approval":{"description":"The incoming approval to set.","$ref":"#/definitions/tokenization.UserIncomingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.MsgSetIncomingApprovalResponse":{"description":"MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.","type":"object"},"tokenization.MsgSetIsArchived":{"type":"object","title":"MsgSetIsArchived sets the isArchived and canArchiveCollection permission","properties":{"canArchiveCollection":{"type":"array","title":"Permission to archive collection","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"isArchived":{"description":"New isArchived to set.","type":"boolean"}}},"tokenization.MsgSetIsArchivedResponse":{"description":"MsgSetIsArchivedResponse is the response to MsgSetIsArchived.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.MsgSetManager":{"type":"object","title":"MsgSetManager sets the manager and canUpdateManager permission","properties":{"canUpdateManager":{"type":"array","title":"Permission to update manager","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"manager":{"description":"New manager to set.","type":"string"}}},"tokenization.MsgSetManagerResponse":{"description":"MsgSetManagerResponse is the response to MsgSetManager.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.MsgSetOutgoingApproval":{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","type":"object","properties":{"approval":{"description":"The outgoing approval to set.","$ref":"#/definitions/tokenization.UserOutgoingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.MsgSetOutgoingApprovalResponse":{"description":"MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.","type":"object"},"tokenization.MsgSetReservedProtocolAddress":{"description":"MsgSetReservedProtocolAddress sets or unsets a reserved protocol address (governance-only).","type":"object","properties":{"address":{"description":"Address to set or unset as reserved protocol address.","type":"string"},"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"isReservedProtocol":{"description":"Whether the address should be a reserved protocol address (true) or not (false).","type":"boolean"}}},"tokenization.MsgSetReservedProtocolAddressResponse":{"description":"MsgSetReservedProtocolAddressResponse is the response to MsgSetReservedProtocolAddress.","type":"object"},"tokenization.MsgSetStandards":{"type":"object","title":"MsgSetStandards sets the standards and canUpdateStandards permission","properties":{"canUpdateStandards":{"type":"array","title":"Permission to update standards","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"standards":{"description":"New standards to set.","type":"array","items":{"type":"string"}}}},"tokenization.MsgSetStandardsResponse":{"description":"MsgSetStandardsResponse is the response to MsgSetStandards.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.MsgSetTokenMetadata":{"type":"object","title":"MsgSetTokenMetadata sets the token metadata and canUpdateTokenMetadata permission","properties":{"canUpdateTokenMetadata":{"type":"array","title":"Permission to update token metadata","items":{"type":"object","$ref":"#/definitions/tokenization.TokenIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"tokenMetadata":{"description":"New token metadata to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.TokenMetadata"}}}},"tokenization.MsgSetTokenMetadataResponse":{"description":"MsgSetTokenMetadataResponse is the response to MsgSetTokenMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.MsgSetValidTokenIds":{"type":"object","title":"MsgSetValidTokenIds sets the validTokenIds and canUpdateValidTokenIds permission","properties":{"canUpdateValidTokenIds":{"type":"array","title":"Permission to update valid token IDs","items":{"type":"object","$ref":"#/definitions/tokenization.TokenIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.MsgSetValidTokenIdsResponse":{"description":"MsgSetValidTokenIdsResponse is the response to MsgSetValidTokenIds.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.MsgTransferTokens":{"description":"MsgTransferTokens is used to transfer tokens.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.Transfer"}}}},"tokenization.MsgTransferTokensResponse":{"description":"MsgTransferTokensResponse is the response to MsgTransferTokens.","type":"object"},"tokenization.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the tokens module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"aliasPathsToAdd":{"description":"Alias (non-wrapping) paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.AliasPathAddObject"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadata":{"description":"New collection metadata to set.","$ref":"#/definitions/tokenization.CollectionMetadata"},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/tokenization.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"New custom data to set.","type":"string"},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/tokenization.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.\nAddresses are generated by the keeper and stored in the collection.","$ref":"#/definitions/tokenization.InvariantsAddObject"},"isArchived":{"description":"New isArchived to set.","type":"boolean"},"manager":{"description":"New manager to set.","type":"string"},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standards":{"description":"New standards to set.","type":"array","items":{"type":"string"}},"tokenMetadata":{"description":"New token metadata to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.TokenMetadata"}},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadata":{"description":"Indicates if the collection metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomData":{"description":"Indicates if the custom data should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchived":{"description":"Indicates if the isArchived should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManager":{"description":"Indicates if the manager should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandards":{"description":"Indicates if the standards should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateTokenMetadata":{"description":"Indicates if the token metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidTokenIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"aliasPathsToAdd":{"description":"Alias (non-wrapping) paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.AliasPathAddObject"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadata":{"description":"New collection metadata to set.","$ref":"#/definitions/tokenization.CollectionMetadata"},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/tokenization.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"New custom data to set.","type":"string"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.\nAddresses are generated by the keeper and stored in the collection.","$ref":"#/definitions/tokenization.InvariantsAddObject"},"isArchived":{"description":"New isArchived to set.","type":"boolean"},"manager":{"description":"New manager to set.","type":"string"},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standards":{"description":"New standards to set.","type":"array","items":{"type":"string"}},"tokenMetadata":{"description":"New token metadata to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.TokenMetadata"}},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadata":{"description":"Indicates if the collection metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomData":{"description":"Indicates if the custom data should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchived":{"description":"Indicates if the isArchived should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManager":{"description":"Indicates if the manager should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandards":{"description":"Indicates if the standards should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateTokenMetadata":{"description":"Indicates if the token metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidTokenIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.MsgUpdateDynamicStore":{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"Custom data field for storing arbitrary data associated with this dynamic store.","type":"string"},"defaultValue":{"description":"The new default value for uninitialized addresses (true/false).","type":"boolean"},"globalEnabled":{"description":"The global kill switch state (true = enabled, false = disabled/halted).\nCallers should query the current value first if they want to keep it unchanged.","type":"boolean"},"storeId":{"description":"ID of the dynamic store to update.","type":"string"},"uri":{"description":"URI for additional metadata or resources associated with this dynamic store.","type":"string"}}},"tokenization.MsgUpdateDynamicStoreResponse":{"description":"MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.","type":"object"},"tokenization.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/tokenization.Params"}}},"tokenization.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"tokenization.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/tokenization.UserPermissions"}}},"tokenization.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"tokenization.MustOwnTokens":{"description":"MustOwnTokens represents a condition where a user must own specific tokens\nto be approved to transfer.\n\n- collectionId: The ID of the collection for the tokens that must be owned\n- amountRange: The range of amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the tokens.\n- tokenIds: The token IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified tokens; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of amounts the user must own (min to max).","$ref":"#/definitions/tokenization.UintRange"},"collectionId":{"description":"The ID of the collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipCheckParty":{"description":"The party to check ownership for. Options are \"initiator\", \"sender\", \"recipient\", or any valid bb1 address.\nIf a valid bb1 address is provided, ownership will be checked for that specific address.\nThis enables use cases like halt tokens where ownership is checked for an arbitrary address (e.g., halt token owner).\nDefaults to \"initiator\" if empty or if the value is not a recognized option or valid bb1 address.","type":"string"},"ownershipTimes":{"description":"The time ranges during which the user must own the tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"tokenIds":{"description":"The token IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.\nThis is used for user-level outgoing approvals and only includes fields relevant to outgoing transfers.\nAll criteria must be satisfied for the approval to be considered valid.","type":"object","properties":{"altTimeChecks":{"description":"Alternative time-based checks for approval denial (offline hours/days). Defines time periods\nduring which this approval should be denied, such as specific hours of the day or days of the week.","$ref":"#/definitions/tokenization.AltTimeChecks"},"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts\ntransferred and enforces maximum limits per approval.","$ref":"#/definitions/tokenization.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options for this approval. Defines conditions under which this approval should be\nautomatically deleted (e.g., after a certain number of uses or time period).","$ref":"#/definitions/tokenization.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,\nroyalties) that must be executed alongside the token transfer for the approval to be valid.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval. The initiator must provide\nvalid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval. The initiator must provide\nvalid Ethereum signatures for all specified challenges. Each signature can only be used once.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ETHSignatureChallenge"}},"evmQueryChallenges":{"description":"EVM query challenges that must pass for approval. Read-only contract queries\nthat verify external EVM state (e.g., token ownership in another contract).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.EVMQueryChallenge"}},"initiatorChecks":{"description":"Address checks for the initiator of the transfer. Validates that the initiator address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.AddressChecks"},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval. Tracks the count of transfers\nand enforces the limit to prevent exceeding the allowed number of uses.","$ref":"#/definitions/tokenization.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs\nthat satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval. Defines token ownership requirements that must be satisfied for\nthe approval to be valid. The initiator must own the specified tokens at the specified ownership times.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.MustOwnTokens"}},"mustPrioritize":{"description":"If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.\nThis allows fine-grained control over which approvals are applied when multiple approvals could match.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs\nthat can be transferred when using this approval.","$ref":"#/definitions/tokenization.PredeterminedBalances"},"recipientChecks":{"description":"Address checks for the recipient of the transfer. Validates that the recipient address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).\nNote: No sender checks are included for outgoing approvals since the sender is the user themselves.","$ref":"#/definitions/tokenization.AddressChecks"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the recipient equals the initiator are forbidden.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the recipient matches the initiator are allowed.","type":"boolean"},"votingChallenges":{"description":"Voting challenges that must be satisfied for approval. The initiator must provide\nvalid votes that meet the quorum threshold for all specified challenges.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.VotingChallenge"}}}},"tokenization.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"affiliate_percentage":{"type":"string","title":"affiliate_percentage defines the percentage of the transfer amount that goes to the affiliate"},"allowed_denoms":{"type":"array","title":"allowed_denoms defines the list of denoms that are allowed to be used in coin_transfers","items":{"type":"string"}}}},"tokenization.PathMetadata":{"description":"This message defines the metadata for paths (alias paths and cosmos coin wrapper paths).\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the path metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the path metadata.","type":"string"}}},"tokenization.PrecalculateBalancesFromApprovalDetails":{"description":"PrecalculateBalancesFromApprovalDetails defines the details for precalculating balances from an approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/tokenization.PrecalculationOptions"},"version":{"description":"The version of the approval.","type":"string"}}},"tokenization.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"},"tokenIdsOverride":{"description":"The IDs to override for the transfer. Only applicable if using this option in precalculation.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/tokenization.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/tokenization.PredeterminedOrderCalculationMethod"}}},"tokenization.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"tokenization.QueryGetAddressListResponse":{"type":"object","properties":{"list":{"$ref":"#/definitions/tokenization.AddressList"}}},"tokenization.QueryGetAllReservedProtocolAddressesResponse":{"type":"object","properties":{"addresses":{"type":"array","items":{"type":"string"}}}},"tokenization.QueryGetApprovalTrackerResponse":{"type":"object","properties":{"tracker":{"$ref":"#/definitions/tokenization.ApprovalTracker"}}},"tokenization.QueryGetBalanceResponse":{"type":"object","properties":{"balance":{"$ref":"#/definitions/tokenization.UserBalanceStore"}}},"tokenization.QueryGetChallengeTrackerResponse":{"type":"object","properties":{"numUsed":{"type":"string"}}},"tokenization.QueryGetCollectionResponse":{"type":"object","properties":{"collection":{"$ref":"#/definitions/tokenization.TokenCollection"}}},"tokenization.QueryGetCollectionStatsResponse":{"type":"object","properties":{"stats":{"$ref":"#/definitions/tokenization.CollectionStats"}}},"tokenization.QueryGetDynamicStoreResponse":{"type":"object","properties":{"store":{"$ref":"#/definitions/tokenization.DynamicStore"}}},"tokenization.QueryGetDynamicStoreValueResponse":{"type":"object","properties":{"value":{"$ref":"#/definitions/tokenization.DynamicStoreValue"}}},"tokenization.QueryGetETHSignatureTrackerResponse":{"type":"object","properties":{"numUsed":{"type":"string"}}},"tokenization.QueryGetVoteResponse":{"type":"object","properties":{"vote":{"$ref":"#/definitions/tokenization.VoteProof"}}},"tokenization.QueryGetVotesResponse":{"type":"object","properties":{"votes":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.VoteProof"}}}},"tokenization.QueryGetWrappableBalancesResponse":{"type":"object","properties":{"amount":{"type":"string"}}},"tokenization.QueryIsAddressReservedProtocolResponse":{"type":"object","properties":{"isReservedProtocol":{"type":"boolean"}}},"tokenization.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/tokenization.Params"}}},"tokenization.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"tokenization.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"tokenization.TokenCollection":{"description":"A TokenCollection is the top-level object for a collection of tokens. \nIt defines everything about the collection, such as the manager, metadata, etc.\n\nAll collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).\n\nAll collections can have a manager who is responsible for managing the collection and can be granted certain admin\npermissions, such as the ability to mint new tokens.\n\nCollections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.\n\nSee documentation for more details.","type":"object","properties":{"aliasPaths":{"description":"The alias (non-wrapping) paths for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.AliasPath"}},"collectionApprovals":{"description":"Transferability of the collection for collections with standard balances, subject to changes over time.\nOverrides user approvals for a transfer if specified.\nTransfer must satisfy both user and collection-level approvals.\nOnly applicable to on-chain balances.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CollectionApproval"}},"collectionId":{"description":"The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.","type":"string"},"collectionMetadata":{"description":"The metadata for the collection itself.","$ref":"#/definitions/tokenization.CollectionMetadata"},"collectionPermissions":{"description":"Permissions that define what the manager of the collection can do or not do.","$ref":"#/definitions/tokenization.CollectionPermissions"},"cosmosCoinWrapperPaths":{"description":"The IBC wrapper (sdk.coin) paths for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.CosmosCoinWrapperPath"}},"createdBy":{"description":"The user or entity who created the collection.","type":"string"},"customData":{"description":"An arbitrary field that can store any data.","type":"string"},"defaultBalances":{"description":"The default store of a balance / approvals for a user, upon genesis.","$ref":"#/definitions/tokenization.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/tokenization.CollectionInvariants"},"isArchived":{"description":"Whether the collection is archived or not.\nWhen archived, it becomes read-only, and no transactions can be processed until it is unarchived.","type":"boolean"},"manager":{"description":"The address of the manager of this collection.","type":"string"},"mintEscrowAddress":{"description":"The generated address of the collection. Also used to escrow Mint balances.","type":"string"},"standards":{"description":"Standards that define how to interpret the fields of the collection.","type":"array","items":{"type":"string"}},"tokenMetadata":{"description":"The metadata for each token in the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.TokenMetadata"}},"validTokenIds":{"description":"The valid token IDs for this collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.TokenIdsActionPermission":{"description":"TokenIdsActionPermission defines the permissions for performing an action for specific tokens.\nCurrently, this is only used for creating new tokens.\n\nEx: If you want to lock the ability to create new tokens for tokenIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (tokenIds: [1,2], ownershipTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.TokenMetadata":{"description":"This message defines the metadata for specific token IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the token metadata.","type":"string"},"tokenIds":{"description":"The token IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the token metadata.","type":"string"}}},"tokenization.Transfer":{"description":"Transfer defines the details of a transfer of tokens.","type":"object","properties":{"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.Balance"}},"ethSignatureProofs":{"description":"The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ETHSignatureProof"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.MerkleProof"}},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/tokenization.PrecalculateBalancesFromApprovalDetails"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"tokenization.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from token IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"tokenization.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/tokenization.UserPermissions"}}},"tokenization.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/tokenization.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"tokenization.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/tokenization.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"tokenization.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UintRange"}}}},"tokenization.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.UserOutgoingApprovalPermission"}}}},"tokenization.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"tokenization.VoteProof":{"description":"VoteProof represents a vote cast for a voting challenge.","type":"object","properties":{"proposalId":{"description":"The proposal ID this vote is for.","type":"string"},"voter":{"description":"The address of the voter casting the vote.","type":"string"},"yesWeight":{"description":"The percentage weight (0-100) allocated to \"yes\" vote.\nThe remaining percentage (100 - yesWeight) is allocated to \"no\" vote.\nExample: yesWeight=70 means 70% yes, 30% no.","type":"string"}}},"tokenization.Voter":{"description":"Voter defines a voter with their address and weight.","type":"object","properties":{"address":{"description":"The address of the voter.","type":"string"},"weight":{"description":"The weight of this voter's vote.","type":"string"}}},"tokenization.VotingChallenge":{"description":"VotingChallenge defines a rule for approval in the form of a voting/multi-sig challenge.\nRequires a weighted quorum threshold to be met through votes from specified voters.\nAll challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Votes are stored separately and can be updated. The threshold is calculated as a percentage\nof total possible weight (all voters), not just voted weight. If you update the proposal ID, then the\nvote tracker will reset and start a new tally. We recommend using a unique proposal ID for each challenge\nto prevent overlap and unexpected behavior.","type":"object","properties":{"customData":{"description":"Arbitrary custom data associated with this voting challenge.","type":"string"},"proposalId":{"type":"string","title":"The ID of this voting challenge for tracking votes (scoped like challengeTrackerId).\nFormat: collectionId-approverAddress-approvalLevel-approvalId-challengeId"},"quorumThreshold":{"description":"The quorum threshold as a percentage (0-100) of total possible weight that must vote \"yes\".\nExample: 50 means 50% of total voter weight must vote yes for approval.","type":"string"},"uri":{"description":"The URI associated with this voting challenge.","type":"string"},"voters":{"description":"List of voters with their weights. Each voter can cast a weighted vote.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.Voter"}}}},"tokenization.v23.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.AddressChecks":{"type":"object","title":"AddressChecks defines checks for address types (WASM contract, liquidity pool, etc.)","properties":{"mustBeLiquidityPool":{"description":"Require the address to be a liquidity pool.","type":"boolean"},"mustBeWasmContract":{"description":"Require the address to be a WASM contract.","type":"boolean"},"mustNotBeLiquidityPool":{"description":"Require the address to not be a liquidity pool.","type":"boolean"},"mustNotBeWasmContract":{"description":"Require the address to not be a WASM contract.","type":"boolean"}}},"tokenization.v23.AddressListInput":{"description":"AddressListInput is used for creating address lists via MsgCreateAddressLists.\nIt contains all fields from AddressList except createdBy, which is automatically set from the message creator.","type":"object","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"tokenization.v23.AliasPathAddObject":{"type":"object","properties":{"conversion":{"$ref":"#/definitions/tokenization.v23.ConversionWithoutDenom"},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.DenomUnit"}},"metadata":{"description":"The metadata for this alias path.","$ref":"#/definitions/tokenization.v23.PathMetadata"},"symbol":{"type":"string"}}},"tokenization.v23.AltTimeChecks":{"type":"object","title":"AltTimeChecks defines alternative time-based checks for approval denial.\nIf the transfer time falls within any of the specified offline hours or days, the approval is denied.\nUses UTC timezone for neutral timezone approach.\nofflineHours: ranges of hours (0-23) when transfers should be denied\nofflineDays: ranges of days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied","properties":{"offlineDays":{"description":"Days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied. Uses UTC timezone.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"offlineHours":{"description":"Hours (0-23) when transfers should be denied. Uses UTC timezone.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified token IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/tokenization.v23.ResetTimeIntervals"}}},"tokenization.v23.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.\nAll criteria must be satisfied for the approval to be considered valid.","type":"object","properties":{"allowBackedMinting":{"description":"If true, this collection approval allows backed minting operations (CosmosCoinBackedPath).\nWhen false, this approval cannot be used for transfers involving backed minting addresses.\nThis prevents accidental allowances when toListIds is \"All\".","type":"boolean"},"allowSpecialWrapping":{"description":"If true, this collection approval allows special wrapping operations (CosmosCoinWrapperPath).\nWhen false, this approval cannot be used for transfers involving wrapping addresses.\nThis prevents accidental allowances when toListIds is \"All\".","type":"boolean"},"altTimeChecks":{"description":"Alternative time-based checks for approval denial (offline hours/days). Defines time periods\nduring which this approval should be denied, such as specific hours of the day or days of the week.","$ref":"#/definitions/tokenization.v23.AltTimeChecks"},"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts\ntransferred and enforces maximum limits per approval.","$ref":"#/definitions/tokenization.v23.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options for this approval. Defines conditions under which this approval should be\nautomatically deleted (e.g., after a certain number of uses or time period).","$ref":"#/definitions/tokenization.v23.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,\nroyalties) that must be executed alongside the badge transfer for the approval to be valid.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval. The initiator must provide\nvalid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval. The initiator must provide\nvalid Ethereum signatures for all specified challenges. Each signature can only be used once.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ETHSignatureChallenge"}},"initiatorChecks":{"description":"Address checks for the initiator of the transfer. Validates that the initiator address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.v23.AddressChecks"},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval. Tracks the count of transfers\nand enforces the limit to prevent exceeding the allowed number of uses.","$ref":"#/definitions/tokenization.v23.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs\nthat satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval. Defines token ownership requirements that must be satisfied for\nthe approval to be valid. The initiator must own the specified tokens at the specified ownership times.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.MustOwnTokens"}},"mustPrioritize":{"description":"If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.\nThis allows fine-grained control over which approvals are applied when multiple approvals could match.","type":"boolean"},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval. If true, this collection-level approval\ntakes precedence over any outgoing approvals defined by the sender, allowing the collection to\ncontrol outgoing transfer behavior.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval. If true, this collection-level approval\ntakes precedence over any incoming approvals defined by the recipient, allowing the collection to\ncontrol incoming transfer behavior.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs\nthat can be transferred when using this approval.","$ref":"#/definitions/tokenization.v23.PredeterminedBalances"},"recipientChecks":{"description":"Address checks for the recipient of the transfer. Validates that the recipient address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.v23.AddressChecks"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the sender equals the initiator are forbidden.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the sender matches the initiator are allowed.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the recipient equals the initiator are forbidden.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the recipient matches the initiator are allowed.","type":"boolean"},"senderChecks":{"description":"Address checks for the sender of the transfer. Validates that the sender address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.v23.AddressChecks"},"userRoyalties":{"description":"User level royalties to apply to the transfer. Defines the percentage and payout address for\nroyalties that should be collected when this approval is used for a transfer.","$ref":"#/definitions/tokenization.v23.UserRoyalties"},"votingChallenges":{"description":"Voting challenges that must be satisfied for approval. The initiator must provide\nvalid votes that meet the quorum threshold for all specified challenges.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.VotingChallenge"}}}},"tokenization.v23.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"tokenization.v23.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"},"allowCounterpartyPurge":{"type":"boolean","title":"Allow counterparty to purge this approval if they are the only initiator"},"allowPurgeIfExpired":{"type":"boolean","title":"Allow others to call PurgeApprovals on behalf of this approval owner"}}},"tokenization.v23.Balance":{"description":"Balance represents the balance of a token for a specific user.\nThe user amounts xAmount of a token specified for the time ranges specified.\n\nExample: User A owns x10 of token IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or tokenIDs have len \u003e 1, then the user owns all token IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the token owned by the user.","type":"string"},"ownershipTimes":{"description":"The time ranges during which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"tokenIds":{"description":"The token IDs for which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"tokenization.v23.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/tokenization.v23.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"tokenization.v23.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, tokenId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, tokenIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that token ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"tokenization.v23.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are three types of permissions for a collection: ActionPermission, TokenIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action or update a field.\n- TokenIdsActionPermission: defines when the manager can perform an action for specific tokens\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a token is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canAddMoreAliasPaths":{"description":"Permissions related to adding more alias paths to the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"canAddMoreCosmosCoinWrapperPaths":{"description":"Permissions related to adding more cosmos coin wrapper paths to the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"canUpdateTokenMetadata":{"description":"Permissions related to updating token metadata for specific tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.TokenIdsActionPermission"}},"canUpdateValidTokenIds":{"description":"Permissions related to creating more tokens for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.TokenIdsActionPermission"}}}},"tokenization.v23.Conversion":{"description":"Conversion defines a bidirectional conversion between a cosmos coin (with denom) and badge balances.","type":"object","properties":{"sideA":{"description":"Side A: The cosmos coin side of the conversion (amount + denom).","$ref":"#/definitions/tokenization.v23.ConversionSideAWithDenom"},"sideB":{"description":"Side B: The badge balances side of the conversion.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.Balance"}}}},"tokenization.v23.ConversionSideA":{"description":"ConversionSideA represents the cosmos coin amount side of a conversion without denomination.","type":"object","properties":{"amount":{"description":"The amount of the cosmos coin (0 decimals).","type":"string"}}},"tokenization.v23.ConversionSideAWithDenom":{"description":"ConversionSideAWithDenom represents the cosmos coin side of a conversion with denomination.","type":"object","properties":{"amount":{"description":"The amount of the cosmos coin (0 decimals).","type":"string"},"denom":{"description":"The denomination of the cosmos coin.","type":"string"}}},"tokenization.v23.ConversionWithoutDenom":{"description":"ConversionWithoutDenom defines a bidirectional conversion between a cosmos coin amount (without denom) and badge balances.\nThe denom is stored at the base level (e.g., in AliasPath or CosmosCoinWrapperPath).","type":"object","properties":{"sideA":{"description":"Side A: The cosmos coin amount side of the conversion (amount only, denom stored separately).","$ref":"#/definitions/tokenization.v23.ConversionSideA"},"sideB":{"description":"Side B: The badge balances side of the conversion.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.Balance"}}}},"tokenization.v23.CosmosCoinBackedPathAddObject":{"type":"object","properties":{"conversion":{"$ref":"#/definitions/tokenization.v23.Conversion"}}},"tokenization.v23.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"allowOverrideWithAnyValidToken":{"type":"boolean"},"conversion":{"$ref":"#/definitions/tokenization.v23.ConversionWithoutDenom"},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.DenomUnit"}},"metadata":{"description":"The metadata for this wrapper path.","$ref":"#/definitions/tokenization.v23.PathMetadata"},"symbol":{"type":"string"}}},"tokenization.v23.DenomUnit":{"type":"object","properties":{"decimals":{"description":"The number of decimal places for this unit. Defines the precision of the unit.","type":"string"},"isDefaultDisplay":{"description":"If true, this is the default display unit. Only one unit should be marked as the default display unit.\nThis unit will be used by default when displaying the coin amount. If none are marked default, we use the base level.","type":"boolean"},"metadata":{"description":"The metadata for this denomination unit.","$ref":"#/definitions/tokenization.v23.PathMetadata"},"symbol":{"description":"The symbol for this unit (e.g., \"BADGE\", \"nBADGE\"). Used for display purposes.","type":"string"}}},"tokenization.v23.DynamicStoreChallenge":{"description":"DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.","type":"object","properties":{"ownershipCheckParty":{"description":"The party to check ownership for. Options are \"initiator\", \"sender\", \"recipient\", or any valid bb1 address.\nIf a valid bb1 address is provided, ownership will be checked for that specific address.\nThis enables use cases like halt tokens where ownership is checked for an arbitrary address (e.g., halt token owner).\nDefaults to \"initiator\" if empty or if the value is not a recognized option or valid bb1 address.","type":"string"},"storeId":{"description":"The ID of the dynamic store to check.","type":"string"}}},"tokenization.v23.ETHSignatureChallenge":{"description":"ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.\n\nAn ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.\nThe signature scheme is ETHSign(nonce + \"-\" + initiatorAddress + \"-\" + collectionId + \"-\" + approverAddress + \"-\" + approvalLevel + \"-\" + approvalId + \"-\" + challengeId) and each signature can only be used once.\nAll challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.\nIf you update the challenge ID, then the used signatures tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this ETH signature challenge for tracking the number of uses per signature.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this ETH signature challenge.","type":"string"},"signer":{"description":"The Ethereum address that must sign the nonce for verification.","type":"string"},"uri":{"description":"The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.","type":"string"}}},"tokenization.v23.ETHSignatureProof":{"description":"ETHSignatureProof represents an Ethereum signature proof for a challenge.","type":"object","properties":{"nonce":{"description":"The nonce that was signed. The signature scheme is ETHSign(nonce + \"-\" + initiatorAddress + \"-\" + collectionId + \"-\" + approverAddress + \"-\" + approvalLevel + \"-\" + approvalId + \"-\" + challengeId).","type":"string"},"signature":{"description":"The Ethereum signature of the nonce.","type":"string"}}},"tokenization.v23.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.\nThis is used for user-level incoming approvals and only includes fields relevant to incoming transfers.\nAll criteria must be satisfied for the approval to be considered valid.","type":"object","properties":{"altTimeChecks":{"description":"Alternative time-based checks for approval denial (offline hours/days). Defines time periods\nduring which this approval should be denied, such as specific hours of the day or days of the week.","$ref":"#/definitions/tokenization.v23.AltTimeChecks"},"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts\ntransferred and enforces maximum limits per approval.","$ref":"#/definitions/tokenization.v23.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options for this approval. Defines conditions under which this approval should be\nautomatically deleted (e.g., after a certain number of uses or time period).","$ref":"#/definitions/tokenization.v23.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,\nroyalties) that must be executed alongside the badge transfer for the approval to be valid.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval. The initiator must provide\nvalid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval. The initiator must provide\nvalid Ethereum signatures for all specified challenges. Each signature can only be used once.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ETHSignatureChallenge"}},"initiatorChecks":{"description":"Address checks for the initiator of the transfer. Validates that the initiator address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.v23.AddressChecks"},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval. Tracks the count of transfers\nand enforces the limit to prevent exceeding the allowed number of uses.","$ref":"#/definitions/tokenization.v23.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs\nthat satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval. Defines token ownership requirements that must be satisfied for\nthe approval to be valid. The initiator must own the specified tokens at the specified ownership times.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.MustOwnTokens"}},"mustPrioritize":{"description":"If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.\nThis allows fine-grained control over which approvals are applied when multiple approvals could match.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs\nthat can be transferred when using this approval.","$ref":"#/definitions/tokenization.v23.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the sender equals the initiator are forbidden.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the sender matches the initiator are allowed.","type":"boolean"},"senderChecks":{"description":"Address checks for the sender of the transfer. Validates that the sender address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).\nNote: No recipient checks are included for incoming approvals since the recipient is the user themselves.","$ref":"#/definitions/tokenization.v23.AddressChecks"},"votingChallenges":{"description":"Voting challenges that must be satisfied for approval. The initiator must provide\nvalid votes that meet the quorum threshold for all specified challenges.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.VotingChallenge"}}}},"tokenization.v23.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidToken":{"type":"boolean","title":"Allow override of any valid ID"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"incrementTokenIdsBy":{"description":"The amount by which to increment token IDs.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/tokenization.v23.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.Balance"}}}},"tokenization.v23.InvariantsAddObject":{"description":"InvariantsAddObject is used for adding invariants without specifying addresses.\nAddresses are generated by the keeper and stored in the collection.","type":"object","properties":{"cosmosCoinBackedPath":{"description":"The IBC backed (sdk.coin) path for the collection. Only one path is allowed.\nAddress will be generated by the keeper.","$ref":"#/definitions/tokenization.v23.CosmosCoinBackedPathAddObject"},"disablePoolCreation":{"description":"If true, disallows pool creation with this collection's assets.\nWhen true, any attempt to create a pool with badges assets from this collection will fail.","type":"boolean"},"maxSupplyPerId":{"description":"Maximum supply per token ID. If set, no balance can exceed this amount.\nThis prevents any single token ID from having more than the specified supply.","type":"string"},"noCustomOwnershipTimes":{"description":"If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].\nThis prevents time-based restrictions on token ownership.","type":"boolean"},"noForcefulPostMintTransfers":{"description":"If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.\nThis prevents forceful transfers that bypass user-level approvals.\nThis only applies to transfers where the from address does not equal \"Mint\".","type":"boolean"}}},"tokenization.v23.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.Balance"}}}},"tokenization.v23.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified token IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/tokenization.v23.ResetTimeIntervals"}}},"tokenization.v23.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"description":"Ethereum address that must sign the leaf. Used to protect against man-in-the-middle attacks.\nSignature scheme: sign(leaf + \"-\" + creatorAddress), verified using elliptic curve signature verification.","type":"string"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"tokenization.v23.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"tokenization.v23.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"tokenization.v23.MsgCastVote":{"description":"MsgCastVote allows a voter to cast or update their vote for a voting challenge.","type":"object","properties":{"approvalId":{"description":"The approval ID.","type":"string"},"approvalLevel":{"description":"The approval level (\"collection\", \"incoming\", or \"outgoing\").","type":"string"},"approverAddress":{"description":"The approver address (empty string for collection-level approvals).","type":"string"},"collectionId":{"description":"The collection ID for the voting challenge.","type":"string"},"creator":{"description":"The address of the voter casting the vote.","type":"string"},"proposalId":{"description":"The proposal ID (challenge ID) from the VotingChallenge.","type":"string"},"yesWeight":{"description":"The percentage weight (0-100) allocated to \"yes\" vote.\nThe remaining percentage (100 - yesWeight) is allocated to \"no\" vote.\nExample: yesWeight=70 means 70% yes, 30% no.","type":"string"}}},"tokenization.v23.MsgCastVoteResponse":{"type":"object"},"tokenization.v23.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create. The createdBy field will be automatically set to the creator address.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.AddressListInput"}},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v23.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"tokenization.v23.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"aliasPathsToAdd":{"description":"Alias (non-wrapping) paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.AliasPathAddObject"}},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CollectionApproval"}},"collectionMetadata":{"description":"Collection metadata.","$ref":"#/definitions/tokenization.v23.CollectionMetadata"},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/tokenization.v23.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"Custom data.","type":"string"},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/tokenization.v23.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nAddresses are generated by the keeper and stored in the collection.","$ref":"#/definitions/tokenization.v23.InvariantsAddObject"},"isArchived":{"description":"isArchived flag.","type":"boolean"},"manager":{"description":"Manager address.","type":"string"},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standards":{"description":"Standards entries.","type":"array","items":{"type":"string"}},"tokenMetadata":{"description":"Token metadata entries.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.TokenMetadata"}},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v23.MsgCreateDynamicStore":{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"Custom data field for storing arbitrary data associated with this dynamic store.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses (true/false).","type":"boolean"},"uri":{"description":"URI for additional metadata or resources associated with this dynamic store.","type":"string"}}},"tokenization.v23.MsgCreateDynamicStoreResponse":{"description":"MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.","type":"object","properties":{"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"tokenization.v23.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v23.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"tokenization.v23.MsgDeleteDynamicStore":{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store to delete.","type":"string"}}},"tokenization.v23.MsgDeleteDynamicStoreResponse":{"description":"MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.","type":"object"},"tokenization.v23.MsgDeleteIncomingApproval":{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v23.MsgDeleteIncomingApprovalResponse":{"description":"MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.","type":"object"},"tokenization.v23.MsgDeleteOutgoingApproval":{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v23.MsgDeleteOutgoingApprovalResponse":{"description":"MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.","type":"object"},"tokenization.v23.MsgPurgeApprovals":{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","type":"object","properties":{"approvalsToPurge":{"description":"Specific approvals to purge. If empty, purges all applicable approvals based on other flags.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ApprovalIdentifierDetails"}},"approverAddress":{"description":"Address of the user whose approvals to purge. If empty, defaults to creator.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"purgeCounterpartyApprovals":{"description":"Whether to purge counterparty approvals (approvals where the creator is the only initiator).","type":"boolean"},"purgeExpired":{"description":"Whether to purge expired approvals (approvals with no future valid transfer times).","type":"boolean"}}},"tokenization.v23.MsgPurgeApprovalsResponse":{"description":"MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.","type":"object","properties":{"numPurged":{"description":"Number of approvals purged.","type":"string"}}},"tokenization.v23.MsgSetCollectionApprovals":{"type":"object","title":"MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission","properties":{"canUpdateCollectionApprovals":{"type":"array","title":"Permission to update collection approvals","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CollectionApprovalPermission"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CollectionApproval"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v23.MsgSetCollectionApprovalsResponse":{"description":"MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v23.MsgSetCollectionMetadata":{"type":"object","title":"MsgSetCollectionMetadata sets the collection metadata and canUpdateCollectionMetadata permission","properties":{"canUpdateCollectionMetadata":{"type":"array","title":"Permission to update collection metadata","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"collectionMetadata":{"description":"New collection metadata to set.","$ref":"#/definitions/tokenization.v23.CollectionMetadata"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v23.MsgSetCollectionMetadataResponse":{"description":"MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v23.MsgSetCustomData":{"type":"object","title":"MsgSetCustomData sets the custom data and canUpdateCustomData permission","properties":{"canUpdateCustomData":{"type":"array","title":"Permission to update custom data","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"New custom data to set.","type":"string"}}},"tokenization.v23.MsgSetCustomDataResponse":{"description":"MsgSetCustomDataResponse is the response to MsgSetCustomData.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v23.MsgSetDynamicStoreValue":{"description":"MsgSetDynamicStoreValue is used to set a boolean value for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to set the value.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"},"value":{"description":"The boolean value to set (true/false).","type":"boolean"}}},"tokenization.v23.MsgSetDynamicStoreValueResponse":{"description":"MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.","type":"object"},"tokenization.v23.MsgSetIncomingApproval":{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","type":"object","properties":{"approval":{"description":"The incoming approval to set.","$ref":"#/definitions/tokenization.v23.UserIncomingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v23.MsgSetIncomingApprovalResponse":{"description":"MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.","type":"object"},"tokenization.v23.MsgSetIsArchived":{"type":"object","title":"MsgSetIsArchived sets the isArchived and canArchiveCollection permission","properties":{"canArchiveCollection":{"type":"array","title":"Permission to archive collection","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"isArchived":{"description":"New isArchived to set.","type":"boolean"}}},"tokenization.v23.MsgSetIsArchivedResponse":{"description":"MsgSetIsArchivedResponse is the response to MsgSetIsArchived.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v23.MsgSetManager":{"type":"object","title":"MsgSetManager sets the manager and canUpdateManager permission","properties":{"canUpdateManager":{"type":"array","title":"Permission to update manager","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"manager":{"description":"New manager to set.","type":"string"}}},"tokenization.v23.MsgSetManagerResponse":{"description":"MsgSetManagerResponse is the response to MsgSetManager.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v23.MsgSetOutgoingApproval":{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","type":"object","properties":{"approval":{"description":"The outgoing approval to set.","$ref":"#/definitions/tokenization.v23.UserOutgoingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v23.MsgSetOutgoingApprovalResponse":{"description":"MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.","type":"object"},"tokenization.v23.MsgSetReservedProtocolAddress":{"description":"MsgSetReservedProtocolAddress sets or unsets a reserved protocol address (governance-only).","type":"object","properties":{"address":{"description":"Address to set or unset as reserved protocol address.","type":"string"},"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"isReservedProtocol":{"description":"Whether the address should be a reserved protocol address (true) or not (false).","type":"boolean"}}},"tokenization.v23.MsgSetReservedProtocolAddressResponse":{"description":"MsgSetReservedProtocolAddressResponse is the response to MsgSetReservedProtocolAddress.","type":"object"},"tokenization.v23.MsgSetStandards":{"type":"object","title":"MsgSetStandards sets the standards and canUpdateStandards permission","properties":{"canUpdateStandards":{"type":"array","title":"Permission to update standards","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"standards":{"description":"New standards to set.","type":"array","items":{"type":"string"}}}},"tokenization.v23.MsgSetStandardsResponse":{"description":"MsgSetStandardsResponse is the response to MsgSetStandards.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v23.MsgSetTokenMetadata":{"type":"object","title":"MsgSetTokenMetadata sets the token metadata and canUpdateTokenMetadata permission","properties":{"canUpdateTokenMetadata":{"type":"array","title":"Permission to update token metadata","items":{"type":"object","$ref":"#/definitions/tokenization.v23.TokenIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"tokenMetadata":{"description":"New token metadata to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.TokenMetadata"}}}},"tokenization.v23.MsgSetTokenMetadataResponse":{"description":"MsgSetTokenMetadataResponse is the response to MsgSetTokenMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v23.MsgSetValidTokenIds":{"type":"object","title":"MsgSetValidTokenIds sets the validTokenIds and canUpdateValidTokenIds permission","properties":{"canUpdateValidTokenIds":{"type":"array","title":"Permission to update valid token IDs","items":{"type":"object","$ref":"#/definitions/tokenization.v23.TokenIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.MsgSetValidTokenIdsResponse":{"description":"MsgSetValidTokenIdsResponse is the response to MsgSetValidTokenIds.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v23.MsgTransferTokens":{"description":"MsgTransferTokens is used to transfer tokens.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.Transfer"}}}},"tokenization.v23.MsgTransferTokensResponse":{"description":"MsgTransferTokensResponse is the response to MsgTransferTokens.","type":"object"},"tokenization.v23.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the tokens module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"aliasPathsToAdd":{"description":"Alias (non-wrapping) paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.AliasPathAddObject"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadata":{"description":"New collection metadata to set.","$ref":"#/definitions/tokenization.v23.CollectionMetadata"},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/tokenization.v23.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"New custom data to set.","type":"string"},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/tokenization.v23.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.\nAddresses are generated by the keeper and stored in the collection.","$ref":"#/definitions/tokenization.v23.InvariantsAddObject"},"isArchived":{"description":"New isArchived to set.","type":"boolean"},"manager":{"description":"New manager to set.","type":"string"},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standards":{"description":"New standards to set.","type":"array","items":{"type":"string"}},"tokenMetadata":{"description":"New token metadata to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.TokenMetadata"}},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadata":{"description":"Indicates if the collection metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomData":{"description":"Indicates if the custom data should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchived":{"description":"Indicates if the isArchived should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManager":{"description":"Indicates if the manager should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandards":{"description":"Indicates if the standards should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateTokenMetadata":{"description":"Indicates if the token metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidTokenIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v23.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"aliasPathsToAdd":{"description":"Alias (non-wrapping) paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.AliasPathAddObject"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadata":{"description":"New collection metadata to set.","$ref":"#/definitions/tokenization.v23.CollectionMetadata"},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/tokenization.v23.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"New custom data to set.","type":"string"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.\nAddresses are generated by the keeper and stored in the collection.","$ref":"#/definitions/tokenization.v23.InvariantsAddObject"},"isArchived":{"description":"New isArchived to set.","type":"boolean"},"manager":{"description":"New manager to set.","type":"string"},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standards":{"description":"New standards to set.","type":"array","items":{"type":"string"}},"tokenMetadata":{"description":"New token metadata to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.TokenMetadata"}},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadata":{"description":"Indicates if the collection metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomData":{"description":"Indicates if the custom data should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchived":{"description":"Indicates if the isArchived should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManager":{"description":"Indicates if the manager should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandards":{"description":"Indicates if the standards should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateTokenMetadata":{"description":"Indicates if the token metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidTokenIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v23.MsgUpdateDynamicStore":{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"Custom data field for storing arbitrary data associated with this dynamic store.","type":"string"},"defaultValue":{"description":"The new default value for uninitialized addresses (true/false).","type":"boolean"},"globalEnabled":{"description":"The global kill switch state (true = enabled, false = disabled/halted).\nCallers should query the current value first if they want to keep it unchanged.","type":"boolean"},"storeId":{"description":"ID of the dynamic store to update.","type":"string"},"uri":{"description":"URI for additional metadata or resources associated with this dynamic store.","type":"string"}}},"tokenization.v23.MsgUpdateDynamicStoreResponse":{"description":"MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.","type":"object"},"tokenization.v23.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/tokenization.v23.Params"}}},"tokenization.v23.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"tokenization.v23.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/tokenization.v23.UserPermissions"}}},"tokenization.v23.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"tokenization.v23.MustOwnTokens":{"description":"MustOwnTokens represents a condition where a user must own specific tokens\nto be approved to transfer.\n\n- collectionId: The ID of the collection for the tokens that must be owned\n- amountRange: The range of amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the tokens.\n- tokenIds: The token IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified tokens; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of amounts the user must own (min to max).","$ref":"#/definitions/tokenization.v23.UintRange"},"collectionId":{"description":"The ID of the collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipCheckParty":{"description":"The party to check ownership for. Options are \"initiator\", \"sender\", \"recipient\", or any valid bb1 address.\nIf a valid bb1 address is provided, ownership will be checked for that specific address.\nThis enables use cases like halt tokens where ownership is checked for an arbitrary address (e.g., halt token owner).\nDefaults to \"initiator\" if empty or if the value is not a recognized option or valid bb1 address.","type":"string"},"ownershipTimes":{"description":"The time ranges during which the user must own the tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"tokenIds":{"description":"The token IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.\nThis is used for user-level outgoing approvals and only includes fields relevant to outgoing transfers.\nAll criteria must be satisfied for the approval to be considered valid.","type":"object","properties":{"altTimeChecks":{"description":"Alternative time-based checks for approval denial (offline hours/days). Defines time periods\nduring which this approval should be denied, such as specific hours of the day or days of the week.","$ref":"#/definitions/tokenization.v23.AltTimeChecks"},"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts\ntransferred and enforces maximum limits per approval.","$ref":"#/definitions/tokenization.v23.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options for this approval. Defines conditions under which this approval should be\nautomatically deleted (e.g., after a certain number of uses or time period).","$ref":"#/definitions/tokenization.v23.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,\nroyalties) that must be executed alongside the badge transfer for the approval to be valid.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval. The initiator must provide\nvalid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval. The initiator must provide\nvalid Ethereum signatures for all specified challenges. Each signature can only be used once.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ETHSignatureChallenge"}},"initiatorChecks":{"description":"Address checks for the initiator of the transfer. Validates that the initiator address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.v23.AddressChecks"},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval. Tracks the count of transfers\nand enforces the limit to prevent exceeding the allowed number of uses.","$ref":"#/definitions/tokenization.v23.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs\nthat satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval. Defines token ownership requirements that must be satisfied for\nthe approval to be valid. The initiator must own the specified tokens at the specified ownership times.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.MustOwnTokens"}},"mustPrioritize":{"description":"If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.\nThis allows fine-grained control over which approvals are applied when multiple approvals could match.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs\nthat can be transferred when using this approval.","$ref":"#/definitions/tokenization.v23.PredeterminedBalances"},"recipientChecks":{"description":"Address checks for the recipient of the transfer. Validates that the recipient address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).\nNote: No sender checks are included for outgoing approvals since the sender is the user themselves.","$ref":"#/definitions/tokenization.v23.AddressChecks"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the recipient equals the initiator are forbidden.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the recipient matches the initiator are allowed.","type":"boolean"},"votingChallenges":{"description":"Voting challenges that must be satisfied for approval. The initiator must provide\nvalid votes that meet the quorum threshold for all specified challenges.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.VotingChallenge"}}}},"tokenization.v23.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"affiliate_percentage":{"type":"string","title":"affiliate_percentage defines the percentage of the transfer amount that goes to the affiliate"},"allowed_denoms":{"type":"array","title":"allowed_denoms defines the list of denoms that are allowed to be used in coin_transfers","items":{"type":"string"}}}},"tokenization.v23.PathMetadata":{"description":"This message defines the metadata for paths (alias paths and cosmos coin wrapper paths).\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the path metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the path metadata.","type":"string"}}},"tokenization.v23.PrecalculateBalancesFromApprovalDetails":{"description":"PrecalculateBalancesFromApprovalDetails defines the details for precalculating balances from an approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/tokenization.v23.PrecalculationOptions"},"version":{"description":"The version of the approval.","type":"string"}}},"tokenization.v23.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"},"tokenIdsOverride":{"description":"The IDs to override for the transfer. Only applicable if using this option in precalculation.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/tokenization.v23.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/tokenization.v23.PredeterminedOrderCalculationMethod"}}},"tokenization.v23.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"tokenization.v23.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"tokenization.v23.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"tokenization.v23.TokenIdsActionPermission":{"description":"TokenIdsActionPermission defines the permissions for performing an action for specific tokens.\nCurrently, this is only used for creating new tokens.\n\nEx: If you want to lock the ability to create new tokens for tokenIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (tokenIds: [1,2], ownershipTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.TokenMetadata":{"description":"This message defines the metadata for specific token IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the token metadata.","type":"string"},"tokenIds":{"description":"The token IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the token metadata.","type":"string"}}},"tokenization.v23.Transfer":{"description":"Transfer defines the details of a transfer of tokens.","type":"object","properties":{"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.Balance"}},"ethSignatureProofs":{"description":"The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ETHSignatureProof"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.MerkleProof"}},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/tokenization.v23.PrecalculateBalancesFromApprovalDetails"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"tokenization.v23.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from token IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"tokenization.v23.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/tokenization.v23.UserPermissions"}}},"tokenization.v23.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/tokenization.v23.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"tokenization.v23.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/tokenization.v23.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"tokenization.v23.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UintRange"}}}},"tokenization.v23.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.UserOutgoingApprovalPermission"}}}},"tokenization.v23.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"tokenization.v23.Voter":{"description":"Voter defines a voter with their address and weight.","type":"object","properties":{"address":{"description":"The address of the voter.","type":"string"},"weight":{"description":"The weight of this voter's vote.","type":"string"}}},"tokenization.v23.VotingChallenge":{"description":"VotingChallenge defines a rule for approval in the form of a voting/multi-sig challenge.\nRequires a weighted quorum threshold to be met through votes from specified voters.\nAll challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Votes are stored separately and can be updated. The threshold is calculated as a percentage\nof total possible weight (all voters), not just voted weight. If you update the proposal ID, then the\nvote tracker will reset and start a new tally. We recommend using a unique proposal ID for each challenge\nto prevent overlap and unexpected behavior.","type":"object","properties":{"customData":{"description":"Arbitrary custom data associated with this voting challenge.","type":"string"},"proposalId":{"type":"string","title":"The ID of this voting challenge for tracking votes (scoped like challengeTrackerId).\nFormat: collectionId-approverAddress-approvalLevel-approvalId-challengeId"},"quorumThreshold":{"description":"The quorum threshold as a percentage (0-100) of total possible weight that must vote \"yes\".\nExample: 50 means 50% of total voter weight must vote yes for approval.","type":"string"},"uri":{"description":"The URI associated with this voting challenge.","type":"string"},"voters":{"description":"List of voters with their weights. Each voter can cast a weighted vote.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v23.Voter"}}}},"tokenization.v24.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.AddressChecks":{"type":"object","title":"AddressChecks defines checks for address types (EVM contract, liquidity pool, etc.)","properties":{"mustBeEvmContract":{"description":"Require the address to be an EVM contract (has code).","type":"boolean"},"mustBeLiquidityPool":{"description":"Require the address to be a liquidity pool.","type":"boolean"},"mustNotBeEvmContract":{"description":"Require the address to not be an EVM contract (no code).","type":"boolean"},"mustNotBeLiquidityPool":{"description":"Require the address to not be a liquidity pool.","type":"boolean"}}},"tokenization.v24.AddressListInput":{"description":"AddressListInput is used for creating address lists via MsgCreateAddressLists.\nIt contains all fields from AddressList except createdBy, which is automatically set from the message creator.","type":"object","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"tokenization.v24.AliasPathAddObject":{"type":"object","properties":{"conversion":{"$ref":"#/definitions/tokenization.v24.ConversionWithoutDenom"},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.DenomUnit"}},"metadata":{"description":"The metadata for this alias path.","$ref":"#/definitions/tokenization.v24.PathMetadata"},"symbol":{"type":"string"}}},"tokenization.v24.AltTimeChecks":{"type":"object","title":"AltTimeChecks defines alternative time-based checks for approval denial.\nIf the transfer time falls within any of the specified offline hours or days, the approval is denied.\nUses UTC timezone for neutral timezone approach.\nofflineHours: ranges of hours (0-23) when transfers should be denied\nofflineDays: ranges of days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied","properties":{"offlineDays":{"description":"Days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied. Uses UTC timezone.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"offlineHours":{"description":"Hours (0-23) when transfers should be denied. Uses UTC timezone.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified token IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/tokenization.v24.ResetTimeIntervals"}}},"tokenization.v24.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.\nAll criteria must be satisfied for the approval to be considered valid.","type":"object","properties":{"allowBackedMinting":{"description":"If true, this collection approval allows backed minting operations (CosmosCoinBackedPath).\nWhen false, this approval cannot be used for transfers involving backed minting addresses.\nThis prevents accidental allowances when toListIds is \"All\".","type":"boolean"},"allowSpecialWrapping":{"description":"If true, this collection approval allows special wrapping operations (CosmosCoinWrapperPath).\nWhen false, this approval cannot be used for transfers involving wrapping addresses.\nThis prevents accidental allowances when toListIds is \"All\".","type":"boolean"},"altTimeChecks":{"description":"Alternative time-based checks for approval denial (offline hours/days). Defines time periods\nduring which this approval should be denied, such as specific hours of the day or days of the week.","$ref":"#/definitions/tokenization.v24.AltTimeChecks"},"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts\ntransferred and enforces maximum limits per approval.","$ref":"#/definitions/tokenization.v24.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options for this approval. Defines conditions under which this approval should be\nautomatically deleted (e.g., after a certain number of uses or time period).","$ref":"#/definitions/tokenization.v24.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,\nroyalties) that must be executed alongside the token transfer for the approval to be valid.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval. The initiator must provide\nvalid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval. The initiator must provide\nvalid Ethereum signatures for all specified challenges. Each signature can only be used once.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ETHSignatureChallenge"}},"initiatorChecks":{"description":"Address checks for the initiator of the transfer. Validates that the initiator address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.v24.AddressChecks"},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval. Tracks the count of transfers\nand enforces the limit to prevent exceeding the allowed number of uses.","$ref":"#/definitions/tokenization.v24.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs\nthat satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval. Defines token ownership requirements that must be satisfied for\nthe approval to be valid. The initiator must own the specified tokens at the specified ownership times.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.MustOwnTokens"}},"mustPrioritize":{"description":"If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.\nThis allows fine-grained control over which approvals are applied when multiple approvals could match.","type":"boolean"},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval. If true, this collection-level approval\ntakes precedence over any outgoing approvals defined by the sender, allowing the collection to\ncontrol outgoing transfer behavior.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval. If true, this collection-level approval\ntakes precedence over any incoming approvals defined by the recipient, allowing the collection to\ncontrol incoming transfer behavior.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs\nthat can be transferred when using this approval.","$ref":"#/definitions/tokenization.v24.PredeterminedBalances"},"recipientChecks":{"description":"Address checks for the recipient of the transfer. Validates that the recipient address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.v24.AddressChecks"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the sender equals the initiator are forbidden.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the sender matches the initiator are allowed.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the recipient equals the initiator are forbidden.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the recipient matches the initiator are allowed.","type":"boolean"},"senderChecks":{"description":"Address checks for the sender of the transfer. Validates that the sender address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.v24.AddressChecks"},"userRoyalties":{"description":"User level royalties to apply to the transfer. Defines the percentage and payout address for\nroyalties that should be collected when this approval is used for a transfer.","$ref":"#/definitions/tokenization.v24.UserRoyalties"},"votingChallenges":{"description":"Voting challenges that must be satisfied for approval. The initiator must provide\nvalid votes that meet the quorum threshold for all specified challenges.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.VotingChallenge"}}}},"tokenization.v24.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"tokenization.v24.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"},"allowCounterpartyPurge":{"type":"boolean","title":"Allow counterparty to purge this approval if they are the only initiator"},"allowPurgeIfExpired":{"type":"boolean","title":"Allow others to call PurgeApprovals on behalf of this approval owner"}}},"tokenization.v24.Balance":{"description":"Balance represents the balance of a token for a specific user.\nThe user amounts xAmount of a token specified for the time ranges specified.\n\nExample: User A owns x10 of token IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or tokenIDs have len \u003e 1, then the user owns all token IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the token owned by the user.","type":"string"},"ownershipTimes":{"description":"The time ranges during which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"tokenIds":{"description":"The token IDs for which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"tokenization.v24.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/tokenization.v24.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"tokenization.v24.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, tokenId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, tokenIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that token ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"tokenization.v24.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are three types of permissions for a collection: ActionPermission, TokenIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action or update a field.\n- TokenIdsActionPermission: defines when the manager can perform an action for specific tokens\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a token is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canAddMoreAliasPaths":{"description":"Permissions related to adding more alias paths to the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"canAddMoreCosmosCoinWrapperPaths":{"description":"Permissions related to adding more cosmos coin wrapper paths to the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"canUpdateTokenMetadata":{"description":"Permissions related to updating token metadata for specific tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.TokenIdsActionPermission"}},"canUpdateValidTokenIds":{"description":"Permissions related to creating more tokens for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.TokenIdsActionPermission"}}}},"tokenization.v24.Conversion":{"description":"Conversion defines a bidirectional conversion between a cosmos coin (with denom) and token balances.","type":"object","properties":{"sideA":{"description":"Side A: The cosmos coin side of the conversion (amount + denom).","$ref":"#/definitions/tokenization.v24.ConversionSideAWithDenom"},"sideB":{"description":"Side B: The token balances side of the conversion.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.Balance"}}}},"tokenization.v24.ConversionSideA":{"description":"ConversionSideA represents the cosmos coin amount side of a conversion without denomination.","type":"object","properties":{"amount":{"description":"The amount of the cosmos coin (0 decimals).","type":"string"}}},"tokenization.v24.ConversionSideAWithDenom":{"description":"ConversionSideAWithDenom represents the cosmos coin side of a conversion with denomination.","type":"object","properties":{"amount":{"description":"The amount of the cosmos coin (0 decimals).","type":"string"},"denom":{"description":"The denomination of the cosmos coin.","type":"string"}}},"tokenization.v24.ConversionWithoutDenom":{"description":"ConversionWithoutDenom defines a bidirectional conversion between a cosmos coin amount (without denom) and token balances.\nThe denom is stored at the base level (e.g., in AliasPath or CosmosCoinWrapperPath).","type":"object","properties":{"sideA":{"description":"Side A: The cosmos coin amount side of the conversion (amount only, denom stored separately).","$ref":"#/definitions/tokenization.v24.ConversionSideA"},"sideB":{"description":"Side B: The token balances side of the conversion.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.Balance"}}}},"tokenization.v24.CosmosCoinBackedPathAddObject":{"type":"object","properties":{"conversion":{"$ref":"#/definitions/tokenization.v24.Conversion"}}},"tokenization.v24.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"allowOverrideWithAnyValidToken":{"type":"boolean"},"conversion":{"$ref":"#/definitions/tokenization.v24.ConversionWithoutDenom"},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.DenomUnit"}},"metadata":{"description":"The metadata for this wrapper path.","$ref":"#/definitions/tokenization.v24.PathMetadata"},"symbol":{"type":"string"}}},"tokenization.v24.DenomUnit":{"type":"object","properties":{"decimals":{"description":"The number of decimal places for this unit. Defines the precision of the unit.","type":"string"},"isDefaultDisplay":{"description":"If true, this is the default display unit. Only one unit should be marked as the default display unit.\nThis unit will be used by default when displaying the coin amount. If none are marked default, we use the base level.","type":"boolean"},"metadata":{"description":"The metadata for this denomination unit.","$ref":"#/definitions/tokenization.v24.PathMetadata"},"symbol":{"description":"The symbol for this unit (e.g., \"BADGE\", \"nBADGE\"). Used for display purposes.","type":"string"}}},"tokenization.v24.DynamicStoreChallenge":{"description":"DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.","type":"object","properties":{"ownershipCheckParty":{"description":"The party to check ownership for. Options are \"initiator\", \"sender\", \"recipient\", or any valid bb1 address.\nIf a valid bb1 address is provided, ownership will be checked for that specific address.\nThis enables use cases like halt tokens where ownership is checked for an arbitrary address (e.g., halt token owner).\nDefaults to \"initiator\" if empty or if the value is not a recognized option or valid bb1 address.","type":"string"},"storeId":{"description":"The ID of the dynamic store to check.","type":"string"}}},"tokenization.v24.ETHSignatureChallenge":{"description":"ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.\n\nAn ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.\nThe signature scheme is ETHSign(nonce + \"-\" + initiatorAddress + \"-\" + collectionId + \"-\" + approverAddress + \"-\" + approvalLevel + \"-\" + approvalId + \"-\" + challengeId) and each signature can only be used once.\nAll challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.\nIf you update the challenge ID, then the used signatures tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this ETH signature challenge for tracking the number of uses per signature.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this ETH signature challenge.","type":"string"},"signer":{"description":"The Ethereum address that must sign the nonce for verification.","type":"string"},"uri":{"description":"The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.","type":"string"}}},"tokenization.v24.ETHSignatureProof":{"description":"ETHSignatureProof represents an Ethereum signature proof for a challenge.","type":"object","properties":{"nonce":{"description":"The nonce that was signed. The signature scheme is ETHSign(nonce + \"-\" + initiatorAddress + \"-\" + collectionId + \"-\" + approverAddress + \"-\" + approvalLevel + \"-\" + approvalId + \"-\" + challengeId).","type":"string"},"signature":{"description":"The Ethereum signature of the nonce.","type":"string"}}},"tokenization.v24.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.\nThis is used for user-level incoming approvals and only includes fields relevant to incoming transfers.\nAll criteria must be satisfied for the approval to be considered valid.","type":"object","properties":{"altTimeChecks":{"description":"Alternative time-based checks for approval denial (offline hours/days). Defines time periods\nduring which this approval should be denied, such as specific hours of the day or days of the week.","$ref":"#/definitions/tokenization.v24.AltTimeChecks"},"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts\ntransferred and enforces maximum limits per approval.","$ref":"#/definitions/tokenization.v24.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options for this approval. Defines conditions under which this approval should be\nautomatically deleted (e.g., after a certain number of uses or time period).","$ref":"#/definitions/tokenization.v24.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,\nroyalties) that must be executed alongside the token transfer for the approval to be valid.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval. The initiator must provide\nvalid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval. The initiator must provide\nvalid Ethereum signatures for all specified challenges. Each signature can only be used once.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ETHSignatureChallenge"}},"initiatorChecks":{"description":"Address checks for the initiator of the transfer. Validates that the initiator address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.v24.AddressChecks"},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval. Tracks the count of transfers\nand enforces the limit to prevent exceeding the allowed number of uses.","$ref":"#/definitions/tokenization.v24.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs\nthat satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval. Defines token ownership requirements that must be satisfied for\nthe approval to be valid. The initiator must own the specified tokens at the specified ownership times.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.MustOwnTokens"}},"mustPrioritize":{"description":"If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.\nThis allows fine-grained control over which approvals are applied when multiple approvals could match.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs\nthat can be transferred when using this approval.","$ref":"#/definitions/tokenization.v24.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the sender equals the initiator are forbidden.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the sender matches the initiator are allowed.","type":"boolean"},"senderChecks":{"description":"Address checks for the sender of the transfer. Validates that the sender address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).\nNote: No recipient checks are included for incoming approvals since the recipient is the user themselves.","$ref":"#/definitions/tokenization.v24.AddressChecks"},"votingChallenges":{"description":"Voting challenges that must be satisfied for approval. The initiator must provide\nvalid votes that meet the quorum threshold for all specified challenges.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.VotingChallenge"}}}},"tokenization.v24.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidToken":{"type":"boolean","title":"Allow override of any valid ID"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"incrementTokenIdsBy":{"description":"The amount by which to increment token IDs.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/tokenization.v24.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.Balance"}}}},"tokenization.v24.InvariantsAddObject":{"description":"InvariantsAddObject is used for adding invariants without specifying addresses.\nAddresses are generated by the keeper and stored in the collection.","type":"object","properties":{"cosmosCoinBackedPath":{"description":"The IBC backed (sdk.coin) path for the collection. Only one path is allowed.\nAddress will be generated by the keeper.","$ref":"#/definitions/tokenization.v24.CosmosCoinBackedPathAddObject"},"disablePoolCreation":{"description":"If true, disallows pool creation with this collection's assets.\nWhen true, any attempt to create a pool with tokenization assets from this collection will fail.","type":"boolean"},"maxSupplyPerId":{"description":"Maximum supply per token ID. If set, no balance can exceed this amount.\nThis prevents any single token ID from having more than the specified supply.","type":"string"},"noCustomOwnershipTimes":{"description":"If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].\nThis prevents time-based restrictions on token ownership.","type":"boolean"},"noForcefulPostMintTransfers":{"description":"If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.\nThis prevents forceful transfers that bypass user-level approvals.\nThis only applies to transfers where the from address does not equal \"Mint\".","type":"boolean"}}},"tokenization.v24.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.Balance"}}}},"tokenization.v24.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified token IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/tokenization.v24.ResetTimeIntervals"}}},"tokenization.v24.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"description":"Ethereum address that must sign the leaf. Used to protect against man-in-the-middle attacks.\nSignature scheme: sign(leaf + \"-\" + creatorAddress), verified using elliptic curve signature verification.","type":"string"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"tokenization.v24.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"tokenization.v24.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"tokenization.v24.MsgCastVote":{"description":"MsgCastVote allows a voter to cast or update their vote for a voting challenge.","type":"object","properties":{"approvalId":{"description":"The approval ID.","type":"string"},"approvalLevel":{"description":"The approval level (\"collection\", \"incoming\", or \"outgoing\").","type":"string"},"approverAddress":{"description":"The approver address (empty string for collection-level approvals).","type":"string"},"collectionId":{"description":"The collection ID for the voting challenge.","type":"string"},"creator":{"description":"The address of the voter casting the vote.","type":"string"},"proposalId":{"description":"The proposal ID (challenge ID) from the VotingChallenge.","type":"string"},"yesWeight":{"description":"The percentage weight (0-100) allocated to \"yes\" vote.\nThe remaining percentage (100 - yesWeight) is allocated to \"no\" vote.\nExample: yesWeight=70 means 70% yes, 30% no.","type":"string"}}},"tokenization.v24.MsgCastVoteResponse":{"type":"object"},"tokenization.v24.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create. The createdBy field will be automatically set to the creator address.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.AddressListInput"}},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v24.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"tokenization.v24.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"aliasPathsToAdd":{"description":"Alias (non-wrapping) paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.AliasPathAddObject"}},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CollectionApproval"}},"collectionMetadata":{"description":"Collection metadata.","$ref":"#/definitions/tokenization.v24.CollectionMetadata"},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/tokenization.v24.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"Custom data.","type":"string"},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/tokenization.v24.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nAddresses are generated by the keeper and stored in the collection.","$ref":"#/definitions/tokenization.v24.InvariantsAddObject"},"isArchived":{"description":"isArchived flag.","type":"boolean"},"manager":{"description":"Manager address.","type":"string"},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standards":{"description":"Standards entries.","type":"array","items":{"type":"string"}},"tokenMetadata":{"description":"Token metadata entries.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.TokenMetadata"}},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v24.MsgCreateDynamicStore":{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"Custom data field for storing arbitrary data associated with this dynamic store.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses (true/false).","type":"boolean"},"uri":{"description":"URI for additional metadata or resources associated with this dynamic store.","type":"string"}}},"tokenization.v24.MsgCreateDynamicStoreResponse":{"description":"MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.","type":"object","properties":{"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"tokenization.v24.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v24.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"tokenization.v24.MsgDeleteDynamicStore":{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store to delete.","type":"string"}}},"tokenization.v24.MsgDeleteDynamicStoreResponse":{"description":"MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.","type":"object"},"tokenization.v24.MsgDeleteIncomingApproval":{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v24.MsgDeleteIncomingApprovalResponse":{"description":"MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.","type":"object"},"tokenization.v24.MsgDeleteOutgoingApproval":{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v24.MsgDeleteOutgoingApprovalResponse":{"description":"MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.","type":"object"},"tokenization.v24.MsgPurgeApprovals":{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","type":"object","properties":{"approvalsToPurge":{"description":"Specific approvals to purge. If empty, purges all applicable approvals based on other flags.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ApprovalIdentifierDetails"}},"approverAddress":{"description":"Address of the user whose approvals to purge. If empty, defaults to creator.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"purgeCounterpartyApprovals":{"description":"Whether to purge counterparty approvals (approvals where the creator is the only initiator).","type":"boolean"},"purgeExpired":{"description":"Whether to purge expired approvals (approvals with no future valid transfer times).","type":"boolean"}}},"tokenization.v24.MsgPurgeApprovalsResponse":{"description":"MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.","type":"object","properties":{"numPurged":{"description":"Number of approvals purged.","type":"string"}}},"tokenization.v24.MsgSetCollectionApprovals":{"type":"object","title":"MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission","properties":{"canUpdateCollectionApprovals":{"type":"array","title":"Permission to update collection approvals","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CollectionApprovalPermission"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CollectionApproval"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v24.MsgSetCollectionApprovalsResponse":{"description":"MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v24.MsgSetCollectionMetadata":{"type":"object","title":"MsgSetCollectionMetadata sets the collection metadata and canUpdateCollectionMetadata permission","properties":{"canUpdateCollectionMetadata":{"type":"array","title":"Permission to update collection metadata","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"collectionMetadata":{"description":"New collection metadata to set.","$ref":"#/definitions/tokenization.v24.CollectionMetadata"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v24.MsgSetCollectionMetadataResponse":{"description":"MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v24.MsgSetCustomData":{"type":"object","title":"MsgSetCustomData sets the custom data and canUpdateCustomData permission","properties":{"canUpdateCustomData":{"type":"array","title":"Permission to update custom data","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"New custom data to set.","type":"string"}}},"tokenization.v24.MsgSetCustomDataResponse":{"description":"MsgSetCustomDataResponse is the response to MsgSetCustomData.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v24.MsgSetDynamicStoreValue":{"description":"MsgSetDynamicStoreValue is used to set a boolean value for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to set the value.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"},"value":{"description":"The boolean value to set (true/false).","type":"boolean"}}},"tokenization.v24.MsgSetDynamicStoreValueResponse":{"description":"MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.","type":"object"},"tokenization.v24.MsgSetIncomingApproval":{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","type":"object","properties":{"approval":{"description":"The incoming approval to set.","$ref":"#/definitions/tokenization.v24.UserIncomingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v24.MsgSetIncomingApprovalResponse":{"description":"MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.","type":"object"},"tokenization.v24.MsgSetIsArchived":{"type":"object","title":"MsgSetIsArchived sets the isArchived and canArchiveCollection permission","properties":{"canArchiveCollection":{"type":"array","title":"Permission to archive collection","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"isArchived":{"description":"New isArchived to set.","type":"boolean"}}},"tokenization.v24.MsgSetIsArchivedResponse":{"description":"MsgSetIsArchivedResponse is the response to MsgSetIsArchived.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v24.MsgSetManager":{"type":"object","title":"MsgSetManager sets the manager and canUpdateManager permission","properties":{"canUpdateManager":{"type":"array","title":"Permission to update manager","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"manager":{"description":"New manager to set.","type":"string"}}},"tokenization.v24.MsgSetManagerResponse":{"description":"MsgSetManagerResponse is the response to MsgSetManager.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v24.MsgSetOutgoingApproval":{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","type":"object","properties":{"approval":{"description":"The outgoing approval to set.","$ref":"#/definitions/tokenization.v24.UserOutgoingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"tokenization.v24.MsgSetOutgoingApprovalResponse":{"description":"MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.","type":"object"},"tokenization.v24.MsgSetReservedProtocolAddress":{"description":"MsgSetReservedProtocolAddress sets or unsets a reserved protocol address (governance-only).","type":"object","properties":{"address":{"description":"Address to set or unset as reserved protocol address.","type":"string"},"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"isReservedProtocol":{"description":"Whether the address should be a reserved protocol address (true) or not (false).","type":"boolean"}}},"tokenization.v24.MsgSetReservedProtocolAddressResponse":{"description":"MsgSetReservedProtocolAddressResponse is the response to MsgSetReservedProtocolAddress.","type":"object"},"tokenization.v24.MsgSetStandards":{"type":"object","title":"MsgSetStandards sets the standards and canUpdateStandards permission","properties":{"canUpdateStandards":{"type":"array","title":"Permission to update standards","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"standards":{"description":"New standards to set.","type":"array","items":{"type":"string"}}}},"tokenization.v24.MsgSetStandardsResponse":{"description":"MsgSetStandardsResponse is the response to MsgSetStandards.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v24.MsgSetTokenMetadata":{"type":"object","title":"MsgSetTokenMetadata sets the token metadata and canUpdateTokenMetadata permission","properties":{"canUpdateTokenMetadata":{"type":"array","title":"Permission to update token metadata","items":{"type":"object","$ref":"#/definitions/tokenization.v24.TokenIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"tokenMetadata":{"description":"New token metadata to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.TokenMetadata"}}}},"tokenization.v24.MsgSetTokenMetadataResponse":{"description":"MsgSetTokenMetadataResponse is the response to MsgSetTokenMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v24.MsgSetValidTokenIds":{"type":"object","title":"MsgSetValidTokenIds sets the validTokenIds and canUpdateValidTokenIds permission","properties":{"canUpdateValidTokenIds":{"type":"array","title":"Permission to update valid token IDs","items":{"type":"object","$ref":"#/definitions/tokenization.v24.TokenIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.MsgSetValidTokenIdsResponse":{"description":"MsgSetValidTokenIdsResponse is the response to MsgSetValidTokenIds.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v24.MsgTransferTokens":{"description":"MsgTransferTokens is used to transfer tokens.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.Transfer"}}}},"tokenization.v24.MsgTransferTokensResponse":{"description":"MsgTransferTokensResponse is the response to MsgTransferTokens.","type":"object"},"tokenization.v24.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the tokens module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"aliasPathsToAdd":{"description":"Alias (non-wrapping) paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.AliasPathAddObject"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadata":{"description":"New collection metadata to set.","$ref":"#/definitions/tokenization.v24.CollectionMetadata"},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/tokenization.v24.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"New custom data to set.","type":"string"},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/tokenization.v24.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.\nAddresses are generated by the keeper and stored in the collection.","$ref":"#/definitions/tokenization.v24.InvariantsAddObject"},"isArchived":{"description":"New isArchived to set.","type":"boolean"},"manager":{"description":"New manager to set.","type":"string"},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standards":{"description":"New standards to set.","type":"array","items":{"type":"string"}},"tokenMetadata":{"description":"New token metadata to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.TokenMetadata"}},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadata":{"description":"Indicates if the collection metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomData":{"description":"Indicates if the custom data should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchived":{"description":"Indicates if the isArchived should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManager":{"description":"Indicates if the manager should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandards":{"description":"Indicates if the standards should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateTokenMetadata":{"description":"Indicates if the token metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidTokenIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v24.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"aliasPathsToAdd":{"description":"Alias (non-wrapping) paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.AliasPathAddObject"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadata":{"description":"New collection metadata to set.","$ref":"#/definitions/tokenization.v24.CollectionMetadata"},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/tokenization.v24.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"New custom data to set.","type":"string"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.\nAddresses are generated by the keeper and stored in the collection.","$ref":"#/definitions/tokenization.v24.InvariantsAddObject"},"isArchived":{"description":"New isArchived to set.","type":"boolean"},"manager":{"description":"New manager to set.","type":"string"},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standards":{"description":"New standards to set.","type":"array","items":{"type":"string"}},"tokenMetadata":{"description":"New token metadata to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.TokenMetadata"}},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadata":{"description":"Indicates if the collection metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomData":{"description":"Indicates if the custom data should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchived":{"description":"Indicates if the isArchived should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManager":{"description":"Indicates if the manager should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandards":{"description":"Indicates if the standards should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateTokenMetadata":{"description":"Indicates if the token metadata should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidTokenIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"tokenization.v24.MsgUpdateDynamicStore":{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"customData":{"description":"Custom data field for storing arbitrary data associated with this dynamic store.","type":"string"},"defaultValue":{"description":"The new default value for uninitialized addresses (true/false).","type":"boolean"},"globalEnabled":{"description":"The global kill switch state (true = enabled, false = disabled/halted).\nCallers should query the current value first if they want to keep it unchanged.","type":"boolean"},"storeId":{"description":"ID of the dynamic store to update.","type":"string"},"uri":{"description":"URI for additional metadata or resources associated with this dynamic store.","type":"string"}}},"tokenization.v24.MsgUpdateDynamicStoreResponse":{"description":"MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.","type":"object"},"tokenization.v24.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/tokenization.v24.Params"}}},"tokenization.v24.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"tokenization.v24.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/tokenization.v24.UserPermissions"}}},"tokenization.v24.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"tokenization.v24.MustOwnTokens":{"description":"MustOwnTokens represents a condition where a user must own specific tokens\nto be approved to transfer.\n\n- collectionId: The ID of the collection for the tokens that must be owned\n- amountRange: The range of amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the tokens.\n- tokenIds: The token IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified tokens; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of amounts the user must own (min to max).","$ref":"#/definitions/tokenization.v24.UintRange"},"collectionId":{"description":"The ID of the collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipCheckParty":{"description":"The party to check ownership for. Options are \"initiator\", \"sender\", \"recipient\", or any valid bb1 address.\nIf a valid bb1 address is provided, ownership will be checked for that specific address.\nThis enables use cases like halt tokens where ownership is checked for an arbitrary address (e.g., halt token owner).\nDefaults to \"initiator\" if empty or if the value is not a recognized option or valid bb1 address.","type":"string"},"ownershipTimes":{"description":"The time ranges during which the user must own the tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"tokenIds":{"description":"The token IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.\nThis is used for user-level outgoing approvals and only includes fields relevant to outgoing transfers.\nAll criteria must be satisfied for the approval to be considered valid.","type":"object","properties":{"altTimeChecks":{"description":"Alternative time-based checks for approval denial (offline hours/days). Defines time periods\nduring which this approval should be denied, such as specific hours of the day or days of the week.","$ref":"#/definitions/tokenization.v24.AltTimeChecks"},"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts\ntransferred and enforces maximum limits per approval.","$ref":"#/definitions/tokenization.v24.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options for this approval. Defines conditions under which this approval should be\nautomatically deleted (e.g., after a certain number of uses or time period).","$ref":"#/definitions/tokenization.v24.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,\nroyalties) that must be executed alongside the token transfer for the approval to be valid.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval. The initiator must provide\nvalid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval. The initiator must provide\nvalid Ethereum signatures for all specified challenges. Each signature can only be used once.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ETHSignatureChallenge"}},"initiatorChecks":{"description":"Address checks for the initiator of the transfer. Validates that the initiator address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).","$ref":"#/definitions/tokenization.v24.AddressChecks"},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval. Tracks the count of transfers\nand enforces the limit to prevent exceeding the allowed number of uses.","$ref":"#/definitions/tokenization.v24.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs\nthat satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval. Defines token ownership requirements that must be satisfied for\nthe approval to be valid. The initiator must own the specified tokens at the specified ownership times.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.MustOwnTokens"}},"mustPrioritize":{"description":"If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.\nThis allows fine-grained control over which approvals are applied when multiple approvals could match.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs\nthat can be transferred when using this approval.","$ref":"#/definitions/tokenization.v24.PredeterminedBalances"},"recipientChecks":{"description":"Address checks for the recipient of the transfer. Validates that the recipient address meets the\nspecified criteria (e.g., whitelist, blacklist, protocol address requirements).\nNote: No sender checks are included for outgoing approvals since the sender is the user themselves.","$ref":"#/definitions/tokenization.v24.AddressChecks"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.\nIf true, transfers where the recipient equals the initiator are forbidden.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.\nIf true, only transfers where the recipient matches the initiator are allowed.","type":"boolean"},"votingChallenges":{"description":"Voting challenges that must be satisfied for approval. The initiator must provide\nvalid votes that meet the quorum threshold for all specified challenges.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.VotingChallenge"}}}},"tokenization.v24.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"affiliate_percentage":{"type":"string","title":"affiliate_percentage defines the percentage of the transfer amount that goes to the affiliate"},"allowed_denoms":{"type":"array","title":"allowed_denoms defines the list of denoms that are allowed to be used in coin_transfers","items":{"type":"string"}}}},"tokenization.v24.PathMetadata":{"description":"This message defines the metadata for paths (alias paths and cosmos coin wrapper paths).\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the path metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the path metadata.","type":"string"}}},"tokenization.v24.PrecalculateBalancesFromApprovalDetails":{"description":"PrecalculateBalancesFromApprovalDetails defines the details for precalculating balances from an approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/tokenization.v24.PrecalculationOptions"},"version":{"description":"The version of the approval.","type":"string"}}},"tokenization.v24.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"},"tokenIdsOverride":{"description":"The IDs to override for the transfer. Only applicable if using this option in precalculation.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/tokenization.v24.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/tokenization.v24.PredeterminedOrderCalculationMethod"}}},"tokenization.v24.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"tokenization.v24.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"tokenization.v24.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"tokenization.v24.TokenIdsActionPermission":{"description":"TokenIdsActionPermission defines the permissions for performing an action for specific tokens.\nCurrently, this is only used for creating new tokens.\n\nEx: If you want to lock the ability to create new tokens for tokenIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (tokenIds: [1,2], ownershipTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.TokenMetadata":{"description":"This message defines the metadata for specific token IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the token metadata.","type":"string"},"tokenIds":{"description":"The token IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the token metadata.","type":"string"}}},"tokenization.v24.Transfer":{"description":"Transfer defines the details of a transfer of tokens.","type":"object","properties":{"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.Balance"}},"ethSignatureProofs":{"description":"The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ETHSignatureProof"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.MerkleProof"}},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/tokenization.v24.PrecalculateBalancesFromApprovalDetails"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"tokenization.v24.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from token IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"tokenization.v24.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/tokenization.v24.UserPermissions"}}},"tokenization.v24.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/tokenization.v24.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"tokenization.v24.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/tokenization.v24.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"tokenization.v24.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UintRange"}}}},"tokenization.v24.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.UserOutgoingApprovalPermission"}}}},"tokenization.v24.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"tokenization.v24.Voter":{"description":"Voter defines a voter with their address and weight.","type":"object","properties":{"address":{"description":"The address of the voter.","type":"string"},"weight":{"description":"The weight of this voter's vote.","type":"string"}}},"tokenization.v24.VotingChallenge":{"description":"VotingChallenge defines a rule for approval in the form of a voting/multi-sig challenge.\nRequires a weighted quorum threshold to be met through votes from specified voters.\nAll challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Votes are stored separately and can be updated. The threshold is calculated as a percentage\nof total possible weight (all voters), not just voted weight. If you update the proposal ID, then the\nvote tracker will reset and start a new tally. We recommend using a unique proposal ID for each challenge\nto prevent overlap and unexpected behavior.","type":"object","properties":{"customData":{"description":"Arbitrary custom data associated with this voting challenge.","type":"string"},"proposalId":{"type":"string","title":"The ID of this voting challenge for tracking votes (scoped like challengeTrackerId).\nFormat: collectionId-approverAddress-approvalLevel-approvalId-challengeId"},"quorumThreshold":{"description":"The quorum threshold as a percentage (0-100) of total possible weight that must vote \"yes\".\nExample: 50 means 50% of total voter weight must vote yes for approval.","type":"string"},"uri":{"description":"The URI associated with this voting challenge.","type":"string"},"voters":{"description":"List of voters with their weights. Each voter can cast a weighted vote.","type":"array","items":{"type":"object","$ref":"#/definitions/tokenization.v24.Voter"}}}}},"tags":[{"name":"Query"},{"name":"Msg"}]}