{"id":"github.com/bitbadges/bitbadgeschain","consumes":["application/json"],"produces":["application/json"],"swagger":"2.0","info":{"description":"Chain github.com/bitbadges/bitbadgeschain REST API","title":"HTTP API Console","contact":{"name":"github.com/bitbadges/bitbadgeschain"},"version":"version not set"},"paths":{"/anchor.Msg/AddCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_AddCustomData","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/anchor.MsgAddCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.MsgAddCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/anchor.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParams","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/anchor.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressLists","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollection","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/CreateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateDynamicStore","parameters":[{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgCreateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgCreateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DecrementStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DecrementStoreValue","parameters":[{"description":"MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDecrementStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDecrementStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollection","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DeleteDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteDynamicStore","parameters":[{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDeleteDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDeleteDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DeleteIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteIncomingApproval","parameters":[{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDeleteIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDeleteIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/DeleteOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteOutgoingApproval","parameters":[{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgDeleteOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgDeleteOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/IncrementStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_IncrementStoreValue","parameters":[{"description":"MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgIncrementStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgIncrementStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/PurgeApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_PurgeApprovals","parameters":[{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgPurgeApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgPurgeApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetCollectionApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionApprovals","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetCollectionApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetCollectionApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetCollectionMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionMetadata","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetCollectionMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetCollectionMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCustomData","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetDynamicStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDynamicStoreValue","parameters":[{"description":"MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetDynamicStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIncomingApproval","parameters":[{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetIsArchived":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIsArchived","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetIsArchived"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetIsArchivedResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetManager":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetManager","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetManager"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetManagerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetOutgoingApproval","parameters":[{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetStandards":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetStandards","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetStandards"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetStandardsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetTokenMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetTokenMetadata","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetTokenMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetTokenMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/SetValidTokenIds":{"post":{"tags":["Msg"],"summary":"Helper message types for UniversalUpdateCollection subsets","operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValidTokenIds","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgSetValidTokenIds"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgSetValidTokenIdsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/TransferTokens":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferTokens","parameters":[{"description":"MsgTransferTokens is used to transfer tokens.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgTransferTokens"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgTransferTokensResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollection","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the tokens module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollection","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateDynamicStore","parameters":[{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin18","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovals","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressListsMixin30","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollectionMixin30","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/CreateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateDynamicStoreMixin30","parameters":[{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgCreateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgCreateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/DecrementStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DecrementStoreValueMixin30","parameters":[{"description":"MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgDecrementStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgDecrementStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollectionMixin30","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/DeleteDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteDynamicStoreMixin30","parameters":[{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgDeleteDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgDeleteDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/DeleteIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteIncomingApprovalMixin30","parameters":[{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgDeleteIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgDeleteIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/DeleteOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteOutgoingApprovalMixin30","parameters":[{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgDeleteOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgDeleteOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/IncrementStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_IncrementStoreValueMixin30","parameters":[{"description":"MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgIncrementStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgIncrementStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/PurgeApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_PurgeApprovalsMixin30","parameters":[{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgPurgeApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgPurgeApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/SetBadgeMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetBadgeMetadata","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgSetBadgeMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgSetBadgeMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/SetCollectionApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionApprovalsMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgSetCollectionApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgSetCollectionApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/SetCollectionMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionMetadataMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgSetCollectionMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgSetCollectionMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/SetCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCustomDataMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgSetCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgSetCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/SetDynamicStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDynamicStoreValueMixin30","parameters":[{"description":"MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgSetDynamicStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgSetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/SetIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIncomingApprovalMixin30","parameters":[{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgSetIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgSetIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/SetIsArchived":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIsArchivedMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgSetIsArchived"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgSetIsArchivedResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/SetManager":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetManagerMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgSetManager"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgSetManagerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/SetOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetOutgoingApprovalMixin30","parameters":[{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgSetOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgSetOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/SetStandards":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetStandardsMixin30","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgSetStandards"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgSetStandardsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/SetValidBadgeIds":{"post":{"tags":["Msg"],"summary":"Helper message types for UniversalUpdateCollection subsets","operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValidBadgeIds","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgSetValidBadgeIds"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgSetValidBadgeIdsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/TransferBadges":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferBadges","parameters":[{"description":"MsgTransferBadges is used to transfer tokens.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgTransferBadges"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgTransferBadgesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollectionMixin30","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollectionMixin30","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/UpdateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateDynamicStoreMixin30","parameters":[{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgUpdateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgUpdateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin30","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v16.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovalsMixin30","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v16.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v16.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/CreateAddressLists":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateAddressListsMixin42","parameters":[{"description":"MsgCreateAddressLists is used to create address lists.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgCreateAddressLists"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgCreateAddressListsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/CreateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateCollectionMixin42","parameters":[{"description":"MsgCreateCollection is used to create a new collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgCreateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgCreateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/CreateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateDynamicStoreMixin42","parameters":[{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgCreateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgCreateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/DecrementStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DecrementStoreValueMixin42","parameters":[{"description":"MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgDecrementStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgDecrementStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/DeleteCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteCollectionMixin42","parameters":[{"description":"MsgDeleteCollection is used to delete a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgDeleteCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgDeleteCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/DeleteDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteDynamicStoreMixin42","parameters":[{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgDeleteDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgDeleteDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/DeleteIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteIncomingApprovalMixin42","parameters":[{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgDeleteIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgDeleteIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/DeleteOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteOutgoingApprovalMixin42","parameters":[{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgDeleteOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgDeleteOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/IncrementStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_IncrementStoreValueMixin42","parameters":[{"description":"MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgIncrementStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgIncrementStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/PurgeApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_PurgeApprovalsMixin42","parameters":[{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgPurgeApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgPurgeApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/SetBadgeMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetBadgeMetadataMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgSetBadgeMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgSetBadgeMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/SetCollectionApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionApprovalsMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgSetCollectionApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgSetCollectionApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/SetCollectionMetadata":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCollectionMetadataMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgSetCollectionMetadata"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgSetCollectionMetadataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/SetCustomData":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetCustomDataMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgSetCustomData"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgSetCustomDataResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/SetDynamicStoreValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDynamicStoreValueMixin42","parameters":[{"description":"MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgSetDynamicStoreValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgSetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/SetIncomingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIncomingApprovalMixin42","parameters":[{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgSetIncomingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgSetIncomingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/SetIsArchived":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetIsArchivedMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgSetIsArchived"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgSetIsArchivedResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/SetManager":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetManagerMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgSetManager"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgSetManagerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/SetOutgoingApproval":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetOutgoingApprovalMixin42","parameters":[{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgSetOutgoingApproval"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgSetOutgoingApprovalResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/SetStandards":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetStandardsMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgSetStandards"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgSetStandardsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/SetValidBadgeIds":{"post":{"tags":["Msg"],"summary":"Helper message types for UniversalUpdateCollection subsets","operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValidBadgeIdsMixin42","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgSetValidBadgeIds"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgSetValidBadgeIdsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/TransferBadges":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_TransferBadgesMixin42","parameters":[{"description":"MsgTransferBadges is used to transfer tokens.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgTransferBadges"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgTransferBadgesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/UniversalUpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UniversalUpdateCollectionMixin42","parameters":[{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgUniversalUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgUniversalUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/UpdateCollection":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateCollectionMixin42","parameters":[{"description":"MsgUpdateCollection is used to update a collection.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgUpdateCollection"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgUpdateCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/UpdateDynamicStore":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateDynamicStoreMixin42","parameters":[{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgUpdateDynamicStore"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgUpdateDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin42","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/badges.v17.Msg/UpdateUserApprovals":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateUserApprovalsMixin42","parameters":[{"description":"MsgUpdateUserApprovals is used to update user approvals.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/badges.v17.MsgUpdateUserApprovals"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.v17.MsgUpdateUserApprovalsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_address_list/{listId}":{"get":{"tags":["Query"],"summary":"Queries an address list by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetAddressList","parameters":[{"type":"string","name":"listId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetAddressListResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_approvals_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{amountTrackerId}/{trackerType}/{approvedAddress}":{"get":{"tags":["Query"],"summary":"Queries an approvals tracker by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetApprovalTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"amountTrackerId","in":"path","required":true},{"type":"string","name":"trackerType","in":"path","required":true},{"type":"string","description":"if trackerType is \"overall\", leave blank","name":"approvedAddress","in":"path","required":true},{"type":"string","name":"approvalId","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetApprovalTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_balance/{collectionId}/{address}":{"get":{"tags":["Query"],"summary":"Queries an addresses balance for a collection, specified by its ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetBalance","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetBalanceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_challenge_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{challengeTrackerId}/{leafIndex}":{"get":{"tags":["Query"],"summary":"Queries the number of times a given leaf has been used for a given merkle challenge.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetChallengeTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"challengeTrackerId","in":"path","required":true},{"type":"string","name":"leafIndex","in":"path","required":true},{"type":"string","name":"approvalId","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetChallengeTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_collection/{collectionId}":{"get":{"tags":["Query"],"summary":"Queries a collection by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetCollection","parameters":[{"type":"string","name":"collectionId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetCollectionResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_dynamic_store/{storeId}":{"get":{"tags":["Query"],"summary":"Queries a dynamic store by ID.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetDynamicStore","parameters":[{"type":"string","name":"storeId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetDynamicStoreResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_dynamic_store_value/{storeId}/{address}":{"get":{"tags":["Query"],"summary":"Queries a dynamic store value by store ID and address.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetDynamicStoreValue","parameters":[{"type":"string","name":"storeId","in":"path","required":true},{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetDynamicStoreValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_eth_signature_tracker/{collectionId}/{approvalLevel}/{approverAddress}/{approvalId}/{challengeTrackerId}/{signature}":{"get":{"tags":["Query"],"summary":"Queries the number of times a given signature has been used for a given ETH signature challenge.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetETHSignatureTracker","parameters":[{"type":"string","name":"collectionId","in":"path","required":true},{"type":"string","description":"\"collection\" or \"incoming\" or \"outgoing\"","name":"approvalLevel","in":"path","required":true},{"type":"string","description":"if approvalLevel is \"collection\", leave blank","name":"approverAddress","in":"path","required":true},{"type":"string","name":"approvalId","in":"path","required":true},{"type":"string","name":"challengeTrackerId","in":"path","required":true},{"type":"string","name":"signature","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetETHSignatureTrackerResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/get_wrappable_balances/{denom}/{address}":{"get":{"tags":["Query"],"summary":"Queries the maximum wrappable amount for a given denom and user address.","operationId":"GithubCombitbadgesbitbadgeschainQuery_GetWrappableBalances","parameters":[{"type":"string","name":"denom","in":"path","required":true},{"type":"string","name":"address","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryGetWrappableBalancesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/badges/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin15","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/badges.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin62","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/{mapId}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_Map","parameters":[{"type":"string","name":"mapId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryGetMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/maps/{mapId}/{key}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_MapValue","parameters":[{"type":"string","name":"mapId","in":"path","required":true},{"type":"string","name":"key","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.QueryGetMapValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/wasmx/v1/module_state":{"get":{"tags":["Query"],"summary":"Retrieves the entire wasmx module's state","operationId":"GithubCombitbadgesbitbadgeschainQuery_WasmxModuleState","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.QueryModuleStateResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadges/bitbadgeschain/wasmx/v1/params":{"get":{"tags":["Query"],"summary":"Retrieves wasmx params","operationId":"GithubCombitbadgesbitbadgeschainQuery_WasmxParams","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.QueryWasmxParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/anchor/locations/{locationId}":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_GetValueAtLocation","parameters":[{"type":"string","name":"locationId","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.QueryGetValueAtLocationResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/anchor/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_Params","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/anchor.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/bitbadgeschain/wasmx/params":{"get":{"tags":["Query"],"summary":"Parameters queries the parameters of the module.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin77","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.QueryParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.poolmodels.balancer.Msg/CreateBalancerPool":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateBalancerPool","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.poolmodels.balancer.MsgCreateBalancerPool"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.poolmodels.balancer.MsgCreateBalancerPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.poolmodels.stableswap.Msg/CreateStableswapPool":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateStableswapPool","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.poolmodels.stableswap.MsgCreateStableswapPool"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.poolmodels.stableswap.MsgCreateStableswapPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.poolmodels.stableswap.Msg/StableSwapAdjustScalingFactors":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_StableSwapAdjustScalingFactors","parameters":[{"description":"Sender must be the pool's scaling_factor_governor in order for the tx to\nsucceed. Adjusts stableswap scaling factors.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.poolmodels.stableswap.MsgStableSwapAdjustScalingFactors"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.poolmodels.stableswap.MsgStableSwapAdjustScalingFactorsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/ExitPool":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_ExitPool","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitPool"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/ExitSwapExternAmountOut":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_ExitSwapExternAmountOut","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitSwapExternAmountOut"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitSwapExternAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/ExitSwapShareAmountIn":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_ExitSwapShareAmountIn","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitSwapShareAmountIn"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgExitSwapShareAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/JoinPool":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_JoinPool","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinPool"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/JoinSwapExternAmountIn":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_JoinSwapExternAmountIn","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinSwapExternAmountIn"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinSwapExternAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/JoinSwapShareAmountOut":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_JoinSwapShareAmountOut","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinSwapShareAmountOut"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgJoinSwapShareAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/SwapExactAmountIn":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SwapExactAmountIn","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgSwapExactAmountIn"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Msg/SwapExactAmountOut":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SwapExactAmountOut","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.MsgSwapExactAmountOut"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.MsgSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/gamm.v1beta1.Query/CalcJoinPoolNoSwapShares":{"post":{"tags":["Query"],"summary":"Simulates joining pool without a swap. Returns the amount of shares you'd\nget and tokens needed to provide","operationId":"GithubCombitbadgesbitbadgeschainQuery_CalcJoinPoolNoSwapShares","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/gamm.v1beta1.QueryCalcJoinPoolNoSwapSharesRequest"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryCalcJoinPoolNoSwapSharesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/CreateMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_CreateMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgCreateMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgCreateMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/DeleteMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_DeleteMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgDeleteMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgDeleteMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/SetValue":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetValue","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgSetValue"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgSetValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/UpdateMap":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateMap","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgUpdateMap"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgUpdateMapResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/maps.Msg/UpdateParams":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin64","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/maps.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/maps.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/filtered_pools":{"get":{"tags":["Query"],"summary":"PoolsWithFilter allows you to query specific pools with requested\nparameters","operationId":"GithubCombitbadgesbitbadgeschainQuery_PoolsWithFilter","parameters":[{"type":"string","description":"String of the coins in single string separated by comma. Ex)\n10uatom,100uosmo","name":"min_liquidity","in":"query"},{"type":"string","name":"pool_type","in":"query"},{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryPoolsWithFilterResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/num_pools":{"get":{"tags":["Query"],"summary":"Deprecated: please use the alternative in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_NumPools","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryNumPoolsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/params":{"get":{"tags":["Query"],"summary":"Params returns gamm module params.","operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin53","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.ParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pool_type/{pool_id}":{"get":{"tags":["Query"],"summary":"PoolType returns the type of the pool.\nReturns \"Balancer\" as a string literal when the pool is a balancer pool.\nErrors if the pool is failed to be type caseted.","operationId":"GithubCombitbadgesbitbadgeschainQuery_PoolType","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryPoolTypeResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_Pools","parameters":[{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","name":"pagination.key","in":"query"},{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","name":"pagination.offset","in":"query"},{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","name":"pagination.limit","in":"query"},{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","name":"pagination.count_total","in":"query"},{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","name":"pagination.reverse","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryPoolsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}":{"get":{"tags":["Query"],"summary":"Deprecated: please use the alternative in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_Pool","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/exit_swap_share_amount_in":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_CalcExitPoolCoinsFromShares","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"share_in_amount","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryCalcExitPoolCoinsFromSharesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/join_swap_exact_in":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_CalcJoinPoolShares","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryCalcJoinPoolSharesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/params":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_PoolParams","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryPoolParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/prices":{"get":{"tags":["Query"],"summary":"SpotPrice defines a gRPC query handler that returns the spot price given\na base denomination and a quote denomination.","operationId":"GithubCombitbadgesbitbadgeschainQuery_SpotPrice","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"base_asset_denom","in":"query"},{"type":"string","name":"quote_asset_denom","in":"query"},{"type":"boolean","description":"DEPRECATED","name":"withSwapFee","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QuerySpotPriceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/total_pool_liquidity":{"get":{"tags":["Query"],"summary":"Deprecated: please use the alternative in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalPoolLiquidity","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryTotalPoolLiquidityResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/pools/{pool_id}/total_shares":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalShares","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryTotalSharesResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/total_liquidity":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalLiquidity","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QueryTotalLiquidityResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/{pool_id}/estimate/swap_exact_amount_in":{"get":{"tags":["Query"],"summary":"Deprecated: please use the alternative in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountIn","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"sender","in":"query"},{"type":"string","name":"token_in","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QuerySwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v1beta1/{pool_id}/estimate/swap_exact_amount_out":{"get":{"tags":["Query"],"summary":"Deprecated: please use the alternative in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountOut","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"sender","in":"query"},{"type":"string","name":"token_out","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v1beta1.QuerySwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/gamm/v2/pools/{pool_id}/prices":{"get":{"tags":["Query"],"summary":"Deprecated: please use alternate in x/poolmanager","operationId":"GithubCombitbadgesbitbadgeschainQuery_SpotPriceMixin55","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"base_asset_denom","in":"query"},{"type":"string","name":"quote_asset_denom","in":"query"},{"type":"boolean","description":"DEPRECATED","name":"withSwapFee","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/gamm.v2.QuerySpotPriceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/pools/{pool_id}/prices":{"get":{"tags":["Query"],"summary":"SpotPrice defines a gRPC query handler that returns the spot price given\na base denomination and a quote denomination.","operationId":"GithubCombitbadgesbitbadgeschainQuery_SpotPriceMixin67","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"base_asset_denom","in":"query"},{"type":"string","name":"quote_asset_denom","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.SpotPriceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/Params":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_ParamsMixin67","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.ParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/all-pools":{"get":{"tags":["Query"],"summary":"AllPools returns all pools on the Osmosis chain sorted by IDs.","operationId":"GithubCombitbadgesbitbadgeschainQuery_AllPools","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.AllPoolsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/all_registered_alloyed_pools":{"get":{"tags":["Query"],"summary":"AllRegisteredAlloyedPools returns all registered alloyed pools. The\nregistered alloyed pool contains the pool's contract address, along with\nthe current distribution composition of taker fee share denoms within the\nalloyed pool.","operationId":"GithubCombitbadgesbitbadgeschainQuery_AllRegisteredAlloyedPools","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.AllRegisteredAlloyedPoolsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/all_taker_fee_share_accumulators":{"get":{"tags":["Query"],"summary":"AllTakerFeeShareAccumulators returns all taker fee share accumulators. A\ntaker fee share accumulator includes the denom of the denom getting the\ntaker fees, and an accumulated value of coins that the denom has accrued\nsince the last time it was distributed in the epoch prior.","operationId":"GithubCombitbadgesbitbadgeschainQuery_AllTakerFeeShareAccumulators","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.AllTakerFeeShareAccumulatorsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/all_taker_fee_share_agreements":{"get":{"tags":["Query"],"summary":"AllTakerFeeShareAgreements returns all taker fee share agreements.\nA taker fee share agreement includes the denom of the denom getting the\ntaker fees, the percent of the taker fees that the denom gets when it is\nin the route being traded against, and the address that the taker fees are\nsent to at epoch.","operationId":"GithubCombitbadgesbitbadgeschainQuery_AllTakerFeeShareAgreements","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.AllTakerFeeShareAgreementsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/list-pools-by-denom":{"get":{"tags":["Query"],"summary":"ListPoolsByDenom return all pools by denom","operationId":"GithubCombitbadgesbitbadgeschainQuery_ListPoolsByDenom","parameters":[{"type":"string","name":"denom","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.ListPoolsByDenomResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/num_pools":{"get":{"tags":["Query"],"summary":"Returns the total number of pools existing in Osmosis.","operationId":"GithubCombitbadgesbitbadgeschainQuery_NumPoolsMixin67","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.NumPoolsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/pools/{pool_id}":{"get":{"tags":["Query"],"summary":"Pool returns the Pool specified by the pool id","operationId":"GithubCombitbadgesbitbadgeschainQuery_PoolMixin67","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.PoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/pools/{pool_id}/total_pool_liquidity":{"get":{"tags":["Query"],"summary":"TotalPoolLiquidity returns the total liquidity of the specified pool.","operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalPoolLiquidityMixin67","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TotalPoolLiquidityResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/pools/{pool_id}/total_volume":{"get":{"tags":["Query"],"summary":"TotalVolumeForPool returns the total volume of the specified pool.","operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalVolumeForPool","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TotalVolumeForPoolResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/total_liquidity":{"get":{"tags":["Query"],"summary":"TotalLiquidity returns the total liquidity across all pools.","operationId":"GithubCombitbadgesbitbadgeschainQuery_TotalLiquidityMixin67","responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TotalLiquidityResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/trading_pair_takerfee":{"get":{"tags":["Query"],"summary":"TradingPairTakerFee returns the taker fee for a given set of denoms","operationId":"GithubCombitbadgesbitbadgeschainQuery_TradingPairTakerFee","parameters":[{"type":"string","name":"denom_0","in":"query"},{"type":"string","name":"denom_1","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TradingPairTakerFeeResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{denom}/registered_alloyed_pool_from_denom":{"get":{"tags":["Query"],"summary":"RegisteredAlloyedPoolFromDenom returns the registered alloyed pool state\nfrom the given denom. The registered alloyed pool contains the pool's\ncontract address, along with the current distribution composition of taker\nfee share denoms within the alloyed pool.","operationId":"GithubCombitbadgesbitbadgeschainQuery_RegisteredAlloyedPoolFromDenom","parameters":[{"type":"string","name":"denom","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.RegisteredAlloyedPoolFromDenomResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{denom}/taker_fee_share_agreement_from_denom":{"get":{"tags":["Query"],"summary":"TakerFeeShareAgreementFromDenom returns the taker fee share agreement for a\ngiven denom. A taker fee share agreement includes the denom of the denom\ngetting the taker fees, the percent of the taker fees that the denom gets\nwhen it is in the route being traded against, and the address that the\ntaker fees are sent to at epoch.","operationId":"GithubCombitbadgesbitbadgeschainQuery_TakerFeeShareAgreementFromDenom","parameters":[{"type":"string","name":"denom","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TakerFeeShareAgreementFromDenomResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate/single_pool_swap_exact_amount_in":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSinglePoolSwapExactAmountIn","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"token_in","in":"query"},{"type":"string","name":"token_out_denom","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate/swap_exact_amount_in":{"get":{"tags":["Query"],"summary":"Estimates swap amount out given in.","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountInMixin67","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","description":"DEPRECATED","name":"sender","in":"query"},{"type":"string","name":"token_in","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate/swap_exact_amount_in_with_primitive_types":{"get":{"tags":["Query"],"summary":"EstimateSwapExactAmountInWithPrimitiveTypes is an alternative query for\nEstimateSwapExactAmountIn. Supports query via GRPC-Gateway by using\nprimitive types instead of repeated structs. Each index in the\nroutes_pool_id field corresponds to the respective routes_token_out_denom\nvalue, thus they are required to have the same length and are grouped\ntogether as pairs.\nexample usage:\nhttp://0.0.0.0:1317/osmosis/poolmanager/v1beta1/1/estimate/\nswap_exact_amount_in_with_primitive_types?token_in=100000stake\u0026routes_token_out_denom=uatom\n\u0026routes_token_out_denom=uion\u0026routes_pool_id=1\u0026routes_pool_id=2","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountInWithPrimitiveTypes","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"token_in","in":"query"},{"type":"array","items":{"type":"string","format":"uint64"},"collectionFormat":"multi","name":"routes_pool_id","in":"query"},{"type":"array","items":{"type":"string"},"collectionFormat":"multi","name":"routes_token_out_denom","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate/swap_exact_amount_out":{"get":{"tags":["Query"],"summary":"Estimates swap amount in given out.","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountOutMixin67","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","description":"DEPRECATED","name":"sender","in":"query"},{"type":"string","name":"token_out","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate/swap_exact_amount_out_with_primitive_types":{"get":{"tags":["Query"],"summary":"Estimates swap amount in given out.","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSwapExactAmountOutWithPrimitiveTypes","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"array","items":{"type":"string","format":"uint64"},"collectionFormat":"multi","name":"routes_pool_id","in":"query"},{"type":"array","items":{"type":"string"},"collectionFormat":"multi","name":"routes_token_in_denom","in":"query"},{"type":"string","name":"token_out","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate_out/single_pool_swap_exact_amount_out":{"get":{"tags":["Query"],"operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateSinglePoolSwapExactAmountOut","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"token_in_denom","in":"query"},{"type":"string","name":"token_out","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/estimate_trade":{"get":{"tags":["Query"],"summary":"EstimateTradeBasedOnPriceImpact returns an estimated trade based on price\nimpact, if a trade cannot be estimated a 0 input and 0 output would be\nreturned.","operationId":"GithubCombitbadgesbitbadgeschainQuery_EstimateTradeBasedOnPriceImpact","parameters":[{"type":"string","format":"uint64","description":"pool_id is the identifier of the liquidity pool that the trade will occur\non.","name":"pool_id","in":"path","required":true},{"type":"string","name":"from_coin.denom","in":"query"},{"type":"string","name":"from_coin.amount","in":"query"},{"type":"string","description":"to_coin_denom is the denom identifier of the token that the user wants to\nbuy.","name":"to_coin_denom","in":"query"},{"type":"string","description":"max_price_impact is the maximum percentage that the user is willing\nto affect the price of the liquidity pool.","name":"max_price_impact","in":"query"},{"type":"string","description":"external_price is an optional external price that the user can enter.\nIt adjusts the MaxPriceImpact as the SpotPrice of a pool can be changed at\nany time.","name":"external_price","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.EstimateTradeBasedOnPriceImpactResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{pool_id}/registered_alloyed_pool_from_pool_id":{"get":{"tags":["Query"],"summary":"RegisteredAlloyedPoolFromPoolId returns the registered alloyed pool state\nfrom the given pool id. The registered alloyed pool contains the pool's\ncontract address, along with the current distribution composition of taker\nfee share denoms within the alloyed pool.","operationId":"GithubCombitbadgesbitbadgeschainQuery_RegisteredAlloyedPoolFromPoolId","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.RegisteredAlloyedPoolFromPoolIdResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v1beta1/{takerFeeDenom}/{denom}/taker_fee_share_denoms_to_accrued_value":{"get":{"tags":["Query"],"summary":"TakerFeeShareDenomsToAccruedValue returns the accrued value (as an Int) of\nthe given taker fee denom (the collected fees) for the given fee share\ndenom (the denom with the taker fee share agreement)","operationId":"GithubCombitbadgesbitbadgeschainQuery_TakerFeeShareDenomsToAccruedValue","parameters":[{"type":"string","name":"takerFeeDenom","in":"path","required":true},{"type":"string","name":"denom","in":"path","required":true}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.TakerFeeShareDenomsToAccruedValueResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/osmosis/poolmanager/v2/pools/{pool_id}/prices":{"get":{"tags":["Query"],"summary":"SpotPriceV2 defines a gRPC query handler that returns the spot price given\na base denomination and a quote denomination.\nThe returned spot price has 36 decimal places. However, some of\nmodules perform sig fig rounding so most of the rightmost decimals can be\nzeroes.","operationId":"GithubCombitbadgesbitbadgeschainQuery_SpotPriceV2","parameters":[{"type":"string","format":"uint64","name":"pool_id","in":"path","required":true},{"type":"string","name":"base_asset_denom","in":"query"},{"type":"string","name":"quote_asset_denom","in":"query"}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v2.SpotPriceResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SetDenomPairTakerFee":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetDenomPairTakerFee","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSetDenomPairTakerFee"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSetDenomPairTakerFeeResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SetTakerFeeShareAgreementForDenom":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SetTakerFeeShareAgreementForDenom","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenom"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenomResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SplitRouteSwapExactAmountIn":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SplitRouteSwapExactAmountIn","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSplitRouteSwapExactAmountIn"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSplitRouteSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SplitRouteSwapExactAmountOut":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SplitRouteSwapExactAmountOut","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOut"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SwapExactAmountIn":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SwapExactAmountInMixin71","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSwapExactAmountIn"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSwapExactAmountInResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/poolmanager.v1beta1.Msg/SwapExactAmountOut":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_SwapExactAmountOutMixin71","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSwapExactAmountOut"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/poolmanager.v1beta1.MsgSwapExactAmountOutResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/wasmx.Msg/ExecuteContractCompat":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_ExecuteContractCompat","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/wasmx.MsgExecuteContractCompat"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.MsgExecuteContractCompatResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/wasmx.Msg/InstantiateContractCompat":{"post":{"tags":["Msg"],"operationId":"GithubCombitbadgesbitbadgeschainMsg_InstantiateContractCompat","parameters":[{"name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/wasmx.MsgInstantiateContractCompat"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.MsgInstantiateContractCompatResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}},"/wasmx.Msg/UpdateParams":{"post":{"tags":["Msg"],"summary":"UpdateParams defines a (governance) operation for updating the module\nparameters. The authority defaults to the x/gov module account.","operationId":"GithubCombitbadgesbitbadgeschainMsg_UpdateParamsMixin78","parameters":[{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","name":"body","in":"body","required":true,"schema":{"$ref":"#/definitions/wasmx.MsgUpdateParams"}}],"responses":{"200":{"description":"A successful response.","schema":{"$ref":"#/definitions/wasmx.MsgUpdateParamsResponse"}},"default":{"description":"An unexpected error response.","schema":{"$ref":"#/definitions/google.rpc.Status"}}}}}},"definitions":{"anchor.AnchorData":{"type":"object","properties":{"creator":{"type":"string"},"data":{"type":"string"},"timestamp":{"type":"string"}}},"anchor.MsgAddCustomData":{"type":"object","properties":{"creator":{"type":"string"},"data":{"type":"string"}}},"anchor.MsgAddCustomDataResponse":{"type":"object","properties":{"locationId":{"description":"ID of the anchor location.","type":"string"}}},"anchor.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"NOTE: All parameters must be supplied.","$ref":"#/definitions/anchor.Params"}}},"anchor.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"anchor.Params":{"description":"Params defines the parameters for the module.","type":"object"},"anchor.QueryGetValueAtLocationResponse":{"type":"object","properties":{"anchorData":{"$ref":"#/definitions/anchor.AnchorData"}}},"anchor.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/anchor.Params"}}},"badges.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"badges.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified token IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.ResetTimeIntervals"}}},"badges.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnTokens"}},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"userRoyalties":{"description":"User level royalties to apply to the transfer.","$ref":"#/definitions/badges.UserRoyalties"}}},"badges.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"badges.ApprovalTracker":{"description":"ApprovalTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.","type":"object","properties":{"amounts":{"description":"Cumulative balances associated with the transfers that have been processed.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"lastUpdatedAt":{"description":"Last updated at time.","type":"string"},"numTransfers":{"description":"The number of transfers that have been processed.","type":"string"}}},"badges.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"},"allowCounterpartyPurge":{"type":"boolean","title":"Allow counterparty to purge this approval if they are the only initiator"},"allowPurgeIfExpired":{"type":"boolean","title":"Allow others to call PurgeApprovals on behalf of this approval owner"}}},"badges.Balance":{"description":"Balance represents the balance of a token for a specific user.\nThe user amounts xAmount of a token specified for the time ranges specified.\n\nExample: User A owns x10 of token IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or tokenIDs have len \u003e 1, then the user owns all token IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the token owned by the user.","type":"string"},"ownershipTimes":{"description":"The time ranges during which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"tokenIds":{"description":"The token IDs for which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"badges.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, tokenId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, tokenIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\nTimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that token ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden at all timelineTimes.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CollectionInvariants":{"description":"CollectionInvariants defines the invariants that apply to a collection.","type":"object","properties":{"maxSupplyPerId":{"description":"Maximum supply per token ID. If set, no balance can exceed this amount.\nThis prevents any single token ID from having more than the specified supply.","type":"string"},"noCustomOwnershipTimes":{"description":"If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].\nThis prevents time-based restrictions on token ownership.","type":"boolean"}}},"badges.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"badges.CollectionMetadataTimeline":{"description":"CollectionMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"collectionMetadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/badges.CollectionMetadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithTokenIdsPermission, TokenIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action.\n- TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.\n- TimedUpdateWithTokenIdsPermission: defines when the manager can update a timeline-based field for specific tokens and what times of the timeline can be updated.\n- TokenIdsActionPermission: defines when the manager can perform an action for specific tokens\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- timelineTimes: the times when a timeline-based field is a specific value\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a token is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"canUpdateTokenMetadata":{"description":"Permissions related to updating token metadata for specific tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdateWithTokenIdsPermission"}},"canUpdateValidTokenIds":{"description":"Permissions related to creating more tokens for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TokenIdsActionPermission"}}}},"badges.CosmosCoinWrapperPath":{"type":"object","properties":{"address":{"type":"string"},"allowCosmosWrapping":{"type":"boolean"},"allowOverrideWithAnyValidToken":{"type":"boolean"},"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.DenomUnit"}},"symbol":{"type":"string"}}},"badges.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"allowCosmosWrapping":{"type":"boolean"},"allowOverrideWithAnyValidToken":{"type":"boolean"},"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.DenomUnit"}},"symbol":{"type":"string"}}},"badges.CustomDataTimeline":{"description":"CustomDataTimeline defines custom data at different timeline times.","type":"object","properties":{"customData":{"description":"The custom data for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the custom data is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.DenomUnit":{"type":"object","properties":{"decimals":{"type":"string"},"isDefaultDisplay":{"type":"boolean"},"symbol":{"type":"string"}}},"badges.DynamicStore":{"description":"A DynamicStore is a flexible storage object that can store arbitrary data.\nIt is identified by a unique ID assigned by the blockchain, which is a uint64 that increments.\nDynamic stores are created by users and can only be updated or deleted by their creator.\nThey provide a way to store custom data on-chain with proper access control.","type":"object","properties":{"createdBy":{"description":"The address of the creator of this dynamic store.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses (number of uses).","type":"string"},"storeId":{"description":"The unique identifier for this dynamic store. This is assigned by the blockchain.","type":"string"}}},"badges.DynamicStoreChallenge":{"description":"DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.","type":"object","properties":{"storeId":{"description":"The ID of the dynamic store to check.","type":"string"}}},"badges.DynamicStoreValue":{"description":"A DynamicStoreValue stores a usage count for a specific address in a dynamic store.\nThis allows the creator to set usage counts per address that can be decremented on use.","type":"object","properties":{"address":{"description":"The address for which this value is stored.","type":"string"},"storeId":{"description":"The unique identifier for this dynamic store.","type":"string"},"value":{"description":"The usage count (number of times this address can use the approval).","type":"string"}}},"badges.ETHSignatureChallenge":{"description":"ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.\n\nAn ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.\nThe signature scheme is ETHSign(nonce + \"-\" + creatorAddress) and each signature can only be used once.\nAll challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.\nIf you update the challenge ID, then the used signatures tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this ETH signature challenge for tracking the number of uses per signature.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this ETH signature challenge.","type":"string"},"signer":{"description":"The Ethereum address that must sign the nonce for verification.","type":"string"},"uri":{"description":"The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.","type":"string"}}},"badges.ETHSignatureProof":{"description":"ETHSignatureProof represents an Ethereum signature proof for a challenge.","type":"object","properties":{"nonce":{"description":"The nonce that was signed. The signature scheme is ETHSign(nonce + \"-\" + creatorAddress).","type":"string"},"signature":{"description":"The Ethereum signature of the nonce.","type":"string"}}},"badges.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnTokens"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidToken":{"type":"boolean","title":"Allow override of any valid ID"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"incrementTokenIdsBy":{"description":"The amount by which to increment token IDs.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/badges.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}}}},"badges.IsArchivedTimeline":{"description":"IsArchivedTimeline defines whether a collection is archived at different timeline times.","type":"object","properties":{"isArchived":{"description":"Indicates whether the collection is archived for a specific timeline element.","type":"boolean"},"timelineTimes":{"description":"The timeline times when the archived status is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}}}},"badges.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified token IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.ResetTimeIntervals"}}},"badges.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"type":"string","title":"Leaf must be signed by. Used to protect against man in the middle attacks.`\nScheme we use is sign(leaf + \"-\" +"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"badges.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"badges.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"badges.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.AddressList"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"badges.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionMetadataTimeline":{"description":"Collection metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"Custom data timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.","$ref":"#/definitions/badges.CollectionInvariants"},"isArchivedTimeline":{"description":"isArchived timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"Manager timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standardsTimeline":{"description":"Standards timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"tokenMetadataTimeline":{"description":"Token metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TokenMetadataTimeline"}},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgCreateDynamicStore":{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses (number of uses).","type":"string"}}},"badges.MsgCreateDynamicStoreResponse":{"description":"MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.","type":"object","properties":{"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.MsgDecrementStoreValue":{"description":"MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to decrement the value.","type":"string"},"amount":{"description":"The amount to decrement by.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"setToZeroOnUnderflow":{"description":"If true, set to zero on underflow. If false, throw error on underflow.","type":"boolean"},"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.MsgDecrementStoreValueResponse":{"description":"MsgDecrementStoreValueResponse is the response to MsgDecrementStoreValue.","type":"object"},"badges.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"badges.MsgDeleteDynamicStore":{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store to delete.","type":"string"}}},"badges.MsgDeleteDynamicStoreResponse":{"description":"MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.","type":"object"},"badges.MsgDeleteIncomingApproval":{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgDeleteIncomingApprovalResponse":{"description":"MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.","type":"object"},"badges.MsgDeleteOutgoingApproval":{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgDeleteOutgoingApprovalResponse":{"description":"MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.","type":"object"},"badges.MsgIncrementStoreValue":{"description":"MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to increment the value.","type":"string"},"amount":{"description":"The amount to increment by.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.MsgIncrementStoreValueResponse":{"description":"MsgIncrementStoreValueResponse is the response to MsgIncrementStoreValue.","type":"object"},"badges.MsgPurgeApprovals":{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","type":"object","properties":{"approvalsToPurge":{"description":"Specific approvals to purge. If empty, purges all applicable approvals based on other flags.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ApprovalIdentifierDetails"}},"approverAddress":{"description":"Address of the user whose approvals to purge. If empty, defaults to creator.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"purgeCounterpartyApprovals":{"description":"Whether to purge counterparty approvals (approvals where the creator is the only initiator).","type":"boolean"},"purgeExpired":{"description":"Whether to purge expired approvals (approvals with no future valid transfer times).","type":"boolean"}}},"badges.MsgPurgeApprovalsResponse":{"description":"MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.","type":"object","properties":{"numPurged":{"description":"Number of approvals purged.","type":"string"}}},"badges.MsgSetCollectionApprovals":{"type":"object","title":"MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission","properties":{"canUpdateCollectionApprovals":{"type":"array","title":"Permission to update collection approvals","items":{"type":"object","$ref":"#/definitions/badges.CollectionApprovalPermission"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgSetCollectionApprovalsResponse":{"description":"MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetCollectionMetadata":{"type":"object","title":"MsgSetCollectionMetadata sets the collection metadata timeline and canUpdateCollectionMetadata permission","properties":{"canUpdateCollectionMetadata":{"type":"array","title":"Permission to update collection metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgSetCollectionMetadataResponse":{"description":"MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetCustomData":{"type":"object","title":"MsgSetCustomData sets the custom data timeline and canUpdateCustomData permission","properties":{"canUpdateCustomData":{"type":"array","title":"Permission to update custom data timeline","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}}}},"badges.MsgSetCustomDataResponse":{"description":"MsgSetCustomDataResponse is the response to MsgSetCustomData.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetDynamicStoreValue":{"description":"MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to set the value.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"},"value":{"description":"The usage count to set (number of times this address can use the approval).","type":"string"}}},"badges.MsgSetDynamicStoreValueResponse":{"description":"MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.","type":"object"},"badges.MsgSetIncomingApproval":{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","type":"object","properties":{"approval":{"description":"The incoming approval to set.","$ref":"#/definitions/badges.UserIncomingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgSetIncomingApprovalResponse":{"description":"MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.","type":"object"},"badges.MsgSetIsArchived":{"type":"object","title":"MsgSetIsArchived sets the isArchived timeline and canArchiveCollection permission","properties":{"canArchiveCollection":{"type":"array","title":"Permission to archive collection","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}}}},"badges.MsgSetIsArchivedResponse":{"description":"MsgSetIsArchivedResponse is the response to MsgSetIsArchived.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetManager":{"type":"object","title":"MsgSetManager sets the manager timeline and canUpdateManager permission","properties":{"canUpdateManager":{"type":"array","title":"Permission to update manager timeline","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}}}},"badges.MsgSetManagerResponse":{"description":"MsgSetManagerResponse is the response to MsgSetManager.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetOutgoingApproval":{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","type":"object","properties":{"approval":{"description":"The outgoing approval to set.","$ref":"#/definitions/badges.UserOutgoingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.MsgSetOutgoingApprovalResponse":{"description":"MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.","type":"object"},"badges.MsgSetStandards":{"type":"object","title":"MsgSetStandards sets the standards timeline and canUpdateStandards permission","properties":{"canUpdateStandards":{"type":"array","title":"Permission to update standards timeline","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}}}},"badges.MsgSetStandardsResponse":{"description":"MsgSetStandardsResponse is the response to MsgSetStandards.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetTokenMetadata":{"type":"object","title":"MsgSetTokenMetadata sets the token metadata timeline and canUpdateTokenMetadata permission","properties":{"canUpdateTokenMetadata":{"type":"array","title":"Permission to update token metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.TimedUpdateWithTokenIdsPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"tokenMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TokenMetadataTimeline"}}}},"badges.MsgSetTokenMetadataResponse":{"description":"MsgSetTokenMetadataResponse is the response to MsgSetTokenMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgSetValidTokenIds":{"type":"object","title":"MsgSetValidTokenIds sets the validTokenIds and canUpdateValidTokenIds permission","properties":{"canUpdateValidTokenIds":{"type":"array","title":"Permission to update valid token IDs","items":{"type":"object","$ref":"#/definitions/badges.TokenIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgSetValidTokenIdsResponse":{"description":"MsgSetValidTokenIdsResponse is the response to MsgSetValidTokenIds.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgTransferTokens":{"description":"MsgTransferTokens is used to transfer tokens.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Transfer"}}}},"badges.MsgTransferTokensResponse":{"description":"MsgTransferTokensResponse is the response to MsgTransferTokens.","type":"object"},"badges.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the tokens module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.CollectionInvariants"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"tokenMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TokenMetadataTimeline"}},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateTokenMetadataTimeline":{"description":"Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidTokenIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.CollectionInvariants"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"tokenMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TokenMetadataTimeline"}},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateTokenMetadataTimeline":{"description":"Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidTokenIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validTokenIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.MsgUpdateDynamicStore":{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The new default value for uninitialized addresses (optional, only set if updating).","type":"string"},"storeId":{"description":"ID of the dynamic store to update.","type":"string"}}},"badges.MsgUpdateDynamicStoreResponse":{"description":"MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.","type":"object"},"badges.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/badges.Params"}}},"badges.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"badges.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/badges.UserPermissions"}}},"badges.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"badges.MustOwnTokens":{"description":"MustOwnTokens represents a condition where a user must own specific tokens\nto be approved to transfer.\n\n- collectionId: The ID of the collection for the tokens that must be owned\n- amountRange: The range of amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the tokens.\n- tokenIds: The token IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified tokens; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of amounts the user must own (min to max).","$ref":"#/definitions/badges.UintRange"},"collectionId":{"description":"The ID of the collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipCheckParty":{"description":"The party to check ownership for. Options are \"initiator\", \"sender\", or \"recipient\". Defaults to \"initiator\" if empty.","type":"string"},"ownershipTimes":{"description":"The time ranges during which the user must own the tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"tokenIds":{"description":"The token IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleChallenge"}},"mustOwnTokens":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MustOwnTokens"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.PredeterminedBalances"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"affiliate_percentage":{"type":"string","title":"affiliate_percentage defines the percentage of the transfer amount that goes to the affiliate"},"allowed_denoms":{"type":"array","title":"allowed_denoms defines the list of denoms that are allowed to be used in coin_transfers","items":{"type":"string"}}}},"badges.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"},"tokenIdsOverride":{"description":"The IDs to override for the transfer. Only applicable if using this option in precalculation.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/badges.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/badges.PredeterminedOrderCalculationMethod"}}},"badges.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"badges.QueryGetAddressListResponse":{"type":"object","properties":{"list":{"$ref":"#/definitions/badges.AddressList"}}},"badges.QueryGetApprovalTrackerResponse":{"type":"object","properties":{"tracker":{"$ref":"#/definitions/badges.ApprovalTracker"}}},"badges.QueryGetBalanceResponse":{"type":"object","properties":{"balance":{"$ref":"#/definitions/badges.UserBalanceStore"}}},"badges.QueryGetChallengeTrackerResponse":{"type":"object","properties":{"numUsed":{"type":"string"}}},"badges.QueryGetCollectionResponse":{"type":"object","properties":{"collection":{"$ref":"#/definitions/badges.TokenCollection"}}},"badges.QueryGetDynamicStoreResponse":{"type":"object","properties":{"store":{"$ref":"#/definitions/badges.DynamicStore"}}},"badges.QueryGetDynamicStoreValueResponse":{"type":"object","properties":{"value":{"$ref":"#/definitions/badges.DynamicStoreValue"}}},"badges.QueryGetETHSignatureTrackerResponse":{"type":"object","properties":{"numUsed":{"type":"string"}}},"badges.QueryGetWrappableBalancesResponse":{"type":"object","properties":{"maxWrappableAmount":{"type":"string"}}},"badges.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/badges.Params"}}},"badges.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"badges.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"badges.StandardsTimeline":{"description":"StandardsTimeline defines the standards used for a collection at different timeline times.","type":"object","properties":{"standards":{"description":"The standards applied to the collection for a specific timeline element.","type":"array","items":{"type":"string"}},"timelineTimes":{"description":"The timeline times when the standards are valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.TimedUpdateWithTokenIdsPermission":{"description":"TimedUpdateWithTokenIdsPermission defines the permissions for updating a timeline-based field for specific tokens.\n\nEx: If you want to lock the ability to update the metadata for tokenIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (tokenIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.TokenCollection":{"description":"A TokenCollection is the top-level object for a collection of tokens. \nIt defines everything about the collection, such as the manager, metadata, etc.\n\nAll collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).\n\nAll collections can have a manager who is responsible for managing the collection and can be granted certain admin\npermissions, such as the ability to mint new tokens.\n\nCertain fields are timeline-based, which means they may have different values at different block heights. \nWe fetch the value according to the current time.\nFor example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.\n\nCollections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.\n\nSee documentation for more details.","type":"object","properties":{"collectionApprovals":{"description":"Transferability of the collection for collections with standard balances, subject to changes over time.\nOverrides user approvals for a transfer if specified.\nTransfer must satisfy both user and collection-level approvals.\nOnly applicable to on-chain balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionApproval"}},"collectionId":{"description":"The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.","type":"string"},"collectionMetadataTimeline":{"description":"The metadata for the collection itself, which can vary over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Permissions that define what the manager of the collection can do or not do.","$ref":"#/definitions/badges.CollectionPermissions"},"cosmosCoinWrapperPaths":{"description":"The IBC wrapper (sdk.coin) paths for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CosmosCoinWrapperPath"}},"createdBy":{"description":"The user or entity who created the collection.","type":"string"},"customDataTimeline":{"description":"An arbitrary field that can store any data, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.CustomDataTimeline"}},"defaultBalances":{"description":"The default store of a balance / approvals for a user, upon genesis.","$ref":"#/definitions/badges.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.CollectionInvariants"},"isArchivedTimeline":{"description":"Whether the collection is archived or not, subject to changes over time.\nWhen archived, it becomes read-only, and no transactions can be processed until it is unarchived.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.IsArchivedTimeline"}},"managerTimeline":{"description":"The address of the manager of this collection, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ManagerTimeline"}},"mintEscrowAddress":{"description":"The generated address of the collection. Also used to escrow Mint balances.","type":"string"},"standardsTimeline":{"description":"Standards that define how to interpret the fields of the collection, subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.StandardsTimeline"}},"tokenMetadataTimeline":{"description":"The metadata for each token in the collection, also subject to changes over time.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TokenMetadataTimeline"}},"validTokenIds":{"description":"The valid token IDs for this collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.TokenIdsActionPermission":{"description":"TokenIdsActionPermission defines the permissions for updating a timeline-based field for specific tokens and specific token ownership times.\nCurrently, this is only used for creating new tokens.\n\nEx: If you want to lock the ability to create new tokens for tokenIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (tokenIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.TokenMetadata":{"description":"This message defines the metadata for specific token IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the token metadata.","type":"string"},"tokenIds":{"description":"The token IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the token metadata.","type":"string"}}},"badges.TokenMetadataTimeline":{"description":"TokenMetadataTimeline defines the metadata for tokens at different timeline times.","type":"object","properties":{"timelineTimes":{"description":"The timeline times when the token metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"tokenMetadata":{"description":"The token metadata for a specific timeline element.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.TokenMetadata"}}}},"badges.Transfer":{"description":"Transfer defines the details of a transfer of tokens.","type":"object","properties":{"affiliateAddress":{"description":"Affiliate address for the transfer.","type":"string"},"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"ethSignatureProofs":{"description":"The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ETHSignatureProof"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.MerkleProof"}},"numAttempts":{"description":"The number of times to attempt approval validation. If 0 / not specified, we default to only one.","type":"string"},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/badges.ApprovalIdentifierDetails"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/badges.PrecalculationOptions"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"badges.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from token IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"badges.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/badges.UserPermissions"}}},"badges.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"tokenIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"tokenIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UintRange"}}}},"badges.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.UserOutgoingApprovalPermission"}}}},"badges.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"badges.v16.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"badges.v16.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified token IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v16.ResetTimeIntervals"}}},"badges.v16.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v16.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v16.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v16.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.MustOwnBadges"}},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v16.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"userRoyalties":{"description":"User level royalties to apply to the transfer.","$ref":"#/definitions/badges.v16.UserRoyalties"}}},"badges.v16.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"badges.v16.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"},"allowCounterpartyPurge":{"type":"boolean","title":"Allow counterparty to purge this approval if they are the only initiator"},"allowPurgeIfExpired":{"type":"boolean","title":"Allow others to call PurgeApprovals on behalf of this approval owner"}}},"badges.v16.BadgeIdsActionPermission":{"description":"BadgeIdsActionPermission defines the permissions for updating a timeline-based field for specific tokens and specific token ownership times.\nCurrently, this is only used for creating new tokens.\n\nEx: If you want to lock the ability to create new tokens for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.BadgeMetadata":{"description":"This message defines the metadata for specific token IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"badgeIds":{"description":"The token IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"customData":{"description":"Custom data or additional information related to the token metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the token metadata.","type":"string"}}},"badges.v16.BadgeMetadataTimeline":{"description":"BadgeMetadataTimeline defines the metadata for tokens at different timeline times.","type":"object","properties":{"badgeMetadata":{"description":"The token metadata for a specific timeline element.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.BadgeMetadata"}},"timelineTimes":{"description":"The timeline times when the token metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.Balance":{"description":"Balance represents the balance of a token for a specific user.\nThe user amounts xAmount of a token for the badgeID specified for the time ranges specified.\n\nExample: User A owns x10 of token IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or badgeIDs have len \u003e 1, then the user owns all token IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the token owned by the user.","type":"string"},"badgeIds":{"description":"The token IDs for which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"ownershipTimes":{"description":"The time ranges during which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"badges.v16.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v16.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v16.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, badgeIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\nTimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that token ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden at all timelineTimes.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.CollectionInvariants":{"description":"CollectionInvariants defines the invariants that apply to a collection.","type":"object","properties":{"maxSupplyPerId":{"description":"Maximum supply per token ID. If set, no balance can exceed this amount.\nThis prevents any single token ID from having more than the specified supply.","type":"string"},"noCustomOwnershipTimes":{"description":"If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].\nThis prevents time-based restrictions on token ownership.","type":"boolean"}}},"badges.v16.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"badges.v16.CollectionMetadataTimeline":{"description":"CollectionMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"collectionMetadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/badges.v16.CollectionMetadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BadgeIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action.\n- TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.\n- TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific tokens and what times of the timeline can be updated.\n- BadgeIdsActionPermission: defines when the manager can perform an action for specific tokens\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- timelineTimes: the times when a timeline-based field is a specific value\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a token is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdatePermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ActionPermission"}},"canUpdateBadgeMetadata":{"description":"Permissions related to updating token metadata for specific tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdateWithBadgeIdsPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdatePermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdatePermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdatePermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdatePermission"}},"canUpdateValidBadgeIds":{"description":"Permissions related to creating more tokens for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.BadgeIdsActionPermission"}}}},"badges.v16.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"allowCosmosWrapping":{"type":"boolean"},"allowOverrideWithAnyValidToken":{"type":"boolean"},"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.Balance"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.DenomUnit"}},"symbol":{"type":"string"}}},"badges.v16.CustomDataTimeline":{"description":"CustomDataTimeline defines custom data at different timeline times.","type":"object","properties":{"customData":{"description":"The custom data for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the custom data is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.DenomUnit":{"type":"object","properties":{"decimals":{"type":"string"},"isDefaultDisplay":{"type":"boolean"},"symbol":{"type":"string"}}},"badges.v16.DynamicStoreChallenge":{"description":"DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.","type":"object","properties":{"storeId":{"description":"The ID of the dynamic store to check.","type":"string"}}},"badges.v16.ETHSignatureChallenge":{"description":"ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.\n\nAn ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.\nThe signature scheme is ETHSign(nonce + \"-\" + creatorAddress) and each signature can only be used once.\nAll challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.\nIf you update the challenge ID, then the used signatures tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this ETH signature challenge for tracking the number of uses per signature.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this ETH signature challenge.","type":"string"},"signer":{"description":"The Ethereum address that must sign the nonce for verification.","type":"string"},"uri":{"description":"The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.","type":"string"}}},"badges.v16.ETHSignatureProof":{"description":"ETHSignatureProof represents an Ethereum signature proof for a challenge.","type":"object","properties":{"nonce":{"description":"The nonce that was signed. The signature scheme is ETHSign(nonce + \"-\" + creatorAddress).","type":"string"},"signature":{"description":"The Ethereum signature of the nonce.","type":"string"}}},"badges.v16.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v16.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v16.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v16.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v16.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v16.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidBadge":{"type":"boolean","title":"Allow override of any valid ID"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementBadgeIdsBy":{"description":"The amount by which to increment token IDs.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/badges.v16.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.Balance"}}}},"badges.v16.IsArchivedTimeline":{"description":"IsArchivedTimeline defines whether a collection is archived at different timeline times.","type":"object","properties":{"isArchived":{"description":"Indicates whether the collection is archived for a specific timeline element.","type":"boolean"},"timelineTimes":{"description":"The timeline times when the archived status is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.Balance"}}}},"badges.v16.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified token IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v16.ResetTimeIntervals"}}},"badges.v16.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"type":"string","title":"Leaf must be signed by. Used to protect against man in the middle attacks.`\nScheme we use is sign(leaf + \"-\" +"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"badges.v16.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"badges.v16.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"badges.v16.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.AddressList"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v16.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"badges.v16.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"Token metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CollectionApproval"}},"collectionMetadataTimeline":{"description":"Collection metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/badges.v16.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"Custom data timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v16.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.","$ref":"#/definitions/badges.v16.CollectionInvariants"},"isArchivedTimeline":{"description":"isArchived timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.IsArchivedTimeline"}},"managerTimeline":{"description":"Manager timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standardsTimeline":{"description":"Standards timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.StandardsTimeline"}},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v16.MsgCreateDynamicStore":{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses (number of uses).","type":"string"}}},"badges.v16.MsgCreateDynamicStoreResponse":{"description":"MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.","type":"object","properties":{"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.v16.MsgDecrementStoreValue":{"description":"MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to decrement the value.","type":"string"},"amount":{"description":"The amount to decrement by.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"setToZeroOnUnderflow":{"description":"If true, set to zero on underflow. If false, throw error on underflow.","type":"boolean"},"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.v16.MsgDecrementStoreValueResponse":{"description":"MsgDecrementStoreValueResponse is the response to MsgDecrementStoreValue.","type":"object"},"badges.v16.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v16.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"badges.v16.MsgDeleteDynamicStore":{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store to delete.","type":"string"}}},"badges.v16.MsgDeleteDynamicStoreResponse":{"description":"MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.","type":"object"},"badges.v16.MsgDeleteIncomingApproval":{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v16.MsgDeleteIncomingApprovalResponse":{"description":"MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.","type":"object"},"badges.v16.MsgDeleteOutgoingApproval":{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v16.MsgDeleteOutgoingApprovalResponse":{"description":"MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.","type":"object"},"badges.v16.MsgIncrementStoreValue":{"description":"MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to increment the value.","type":"string"},"amount":{"description":"The amount to increment by.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.v16.MsgIncrementStoreValueResponse":{"description":"MsgIncrementStoreValueResponse is the response to MsgIncrementStoreValue.","type":"object"},"badges.v16.MsgPurgeApprovals":{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","type":"object","properties":{"approvalsToPurge":{"description":"Specific approvals to purge. If empty, purges all applicable approvals based on other flags.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ApprovalIdentifierDetails"}},"approverAddress":{"description":"Address of the user whose approvals to purge. If empty, defaults to creator.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"purgeCounterpartyApprovals":{"description":"Whether to purge counterparty approvals (approvals where the creator is the only initiator).","type":"boolean"},"purgeExpired":{"description":"Whether to purge expired approvals (approvals with no future valid transfer times).","type":"boolean"}}},"badges.v16.MsgPurgeApprovalsResponse":{"description":"MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.","type":"object","properties":{"numPurged":{"description":"Number of approvals purged.","type":"string"}}},"badges.v16.MsgSetBadgeMetadata":{"type":"object","title":"MsgSetBadgeMetadata sets the token metadata timeline and canUpdateBadgeMetadata permission","properties":{"badgeMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.BadgeMetadataTimeline"}},"canUpdateBadgeMetadata":{"type":"array","title":"Permission to update token metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdateWithBadgeIdsPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v16.MsgSetBadgeMetadataResponse":{"description":"MsgSetBadgeMetadataResponse is the response to MsgSetBadgeMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v16.MsgSetCollectionApprovals":{"type":"object","title":"MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission","properties":{"canUpdateCollectionApprovals":{"type":"array","title":"Permission to update collection approvals","items":{"type":"object","$ref":"#/definitions/badges.v16.CollectionApprovalPermission"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CollectionApproval"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v16.MsgSetCollectionApprovalsResponse":{"description":"MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v16.MsgSetCollectionMetadata":{"type":"object","title":"MsgSetCollectionMetadata sets the collection metadata timeline and canUpdateCollectionMetadata permission","properties":{"canUpdateCollectionMetadata":{"type":"array","title":"Permission to update collection metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CollectionMetadataTimeline"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v16.MsgSetCollectionMetadataResponse":{"description":"MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v16.MsgSetCustomData":{"type":"object","title":"MsgSetCustomData sets the custom data timeline and canUpdateCustomData permission","properties":{"canUpdateCustomData":{"type":"array","title":"Permission to update custom data timeline","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CustomDataTimeline"}}}},"badges.v16.MsgSetCustomDataResponse":{"description":"MsgSetCustomDataResponse is the response to MsgSetCustomData.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v16.MsgSetDynamicStoreValue":{"description":"MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to set the value.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"},"value":{"description":"The usage count to set (number of times this address can use the approval).","type":"string"}}},"badges.v16.MsgSetDynamicStoreValueResponse":{"description":"MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.","type":"object"},"badges.v16.MsgSetIncomingApproval":{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","type":"object","properties":{"approval":{"description":"The incoming approval to set.","$ref":"#/definitions/badges.v16.UserIncomingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v16.MsgSetIncomingApprovalResponse":{"description":"MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.","type":"object"},"badges.v16.MsgSetIsArchived":{"type":"object","title":"MsgSetIsArchived sets the isArchived timeline and canArchiveCollection permission","properties":{"canArchiveCollection":{"type":"array","title":"Permission to archive collection","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.IsArchivedTimeline"}}}},"badges.v16.MsgSetIsArchivedResponse":{"description":"MsgSetIsArchivedResponse is the response to MsgSetIsArchived.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v16.MsgSetManager":{"type":"object","title":"MsgSetManager sets the manager timeline and canUpdateManager permission","properties":{"canUpdateManager":{"type":"array","title":"Permission to update manager timeline","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ManagerTimeline"}}}},"badges.v16.MsgSetManagerResponse":{"description":"MsgSetManagerResponse is the response to MsgSetManager.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v16.MsgSetOutgoingApproval":{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","type":"object","properties":{"approval":{"description":"The outgoing approval to set.","$ref":"#/definitions/badges.v16.UserOutgoingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v16.MsgSetOutgoingApprovalResponse":{"description":"MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.","type":"object"},"badges.v16.MsgSetStandards":{"type":"object","title":"MsgSetStandards sets the standards timeline and canUpdateStandards permission","properties":{"canUpdateStandards":{"type":"array","title":"Permission to update standards timeline","items":{"type":"object","$ref":"#/definitions/badges.v16.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.StandardsTimeline"}}}},"badges.v16.MsgSetStandardsResponse":{"description":"MsgSetStandardsResponse is the response to MsgSetStandards.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v16.MsgSetValidBadgeIds":{"type":"object","title":"MsgSetValidBadgeIds sets the validBadgeIds and canUpdateValidBadgeIds permission","properties":{"canUpdateValidBadgeIds":{"type":"array","title":"Permission to update valid token IDs","items":{"type":"object","$ref":"#/definitions/badges.v16.BadgeIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.MsgSetValidBadgeIdsResponse":{"description":"MsgSetValidBadgeIdsResponse is the response to MsgSetValidBadgeIds.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v16.MsgTransferBadges":{"description":"MsgTransferBadges is used to transfer tokens.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.Transfer"}}}},"badges.v16.MsgTransferBadgesResponse":{"description":"MsgTransferBadgesResponse is the response to MsgTransferBadges.","type":"object"},"badges.v16.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v16.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v16.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.v16.CollectionInvariants"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v16.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v16.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CustomDataTimeline"}},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.v16.CollectionInvariants"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v16.MsgUpdateDynamicStore":{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The new default value for uninitialized addresses (optional, only set if updating).","type":"string"},"storeId":{"description":"ID of the dynamic store to update.","type":"string"}}},"badges.v16.MsgUpdateDynamicStoreResponse":{"description":"MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.","type":"object"},"badges.v16.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/badges.v16.Params"}}},"badges.v16.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"badges.v16.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/badges.v16.UserPermissions"}}},"badges.v16.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"badges.v16.MustOwnBadges":{"description":"MustOwnBadges represents a condition where a user must own specific tokens\nto be approved to transfer.\n\n- collectionId: The ID of the collection for the tokens that must be owned\n- amountRange: The range of amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the tokens.\n- badgeIds: The token IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified tokens; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of amounts the user must own (min to max).","$ref":"#/definitions/badges.v16.UintRange"},"badgeIds":{"description":"The token IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"collectionId":{"description":"The ID of the collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipCheckParty":{"description":"The party to check ownership for. Options are \"initiator\", \"sender\", or \"recipient\". Defaults to \"initiator\" if empty.","type":"string"},"ownershipTimes":{"description":"The time ranges during which the user must own the tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v16.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v16.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v16.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v16.PredeterminedBalances"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v16.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"affiliate_percentage":{"type":"string","title":"affiliate_percentage defines the percentage of the transfer amount that goes to the affiliate"},"allowed_denoms":{"type":"array","title":"allowed_denoms defines the list of denoms that are allowed to be used in coin_transfers","items":{"type":"string"}}}},"badges.v16.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"badgeIdsOverride":{"description":"The IDs to override for the transfer. Only applicable if using this option in precalculation.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"}}},"badges.v16.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/badges.v16.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/badges.v16.PredeterminedOrderCalculationMethod"}}},"badges.v16.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"badges.v16.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"badges.v16.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"badges.v16.StandardsTimeline":{"description":"StandardsTimeline defines the standards used for a collection at different timeline times.","type":"object","properties":{"standards":{"description":"The standards applied to the collection for a specific timeline element.","type":"array","items":{"type":"string"}},"timelineTimes":{"description":"The timeline times when the standards are valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.TimedUpdateWithBadgeIdsPermission":{"description":"TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific tokens.\n\nEx: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.Transfer":{"description":"Transfer defines the details of a transfer of tokens.","type":"object","properties":{"affiliateAddress":{"description":"Affiliate address for the transfer.","type":"string"},"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.Balance"}},"ethSignatureProofs":{"description":"The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ETHSignatureProof"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.MerkleProof"}},"numAttempts":{"description":"The number of times to attempt approval validation. If 0 / not specified, we default to only one.","type":"string"},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/badges.v16.ApprovalIdentifierDetails"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/badges.v16.PrecalculationOptions"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"badges.v16.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from token IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"badges.v16.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/badges.v16.UserPermissions"}}},"badges.v16.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v16.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v16.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v16.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v16.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UintRange"}}}},"badges.v16.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v16.UserOutgoingApprovalPermission"}}}},"badges.v16.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"badges.v17.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.AddressList":{"type":"object","title":"An AddressList is a list of addresses that are referenced by an ID.\nAddressLists are used in defining approvals ia a reusbale identifier. \nNote: We also support a reserved ID system by string ID; \"Mint\", \"!Mint\"","properties":{"addresses":{"description":"List of addresses included in the list.","type":"array","items":{"type":"string"}},"createdBy":{"description":"The user or entity who created the address list.","type":"string"},"customData":{"description":"Custom arbitrary data or additional information related to the address list.","type":"string"},"listId":{"description":"Unique identifier for the address list.","type":"string"},"uri":{"description":"URI (Uniform Resource Identifier) associated with the address list to provide metadata, if applicable.","type":"string"},"whitelist":{"description":"Indicates whether the list includes the specified addresses (true) or excludes them (false).","type":"boolean"}}},"badges.v17.ApprovalAmounts":{"description":"ApprovalAmounts defines approval amounts per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the amounts transferred for the specified token IDs and ownership times \nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallApprovalAmount":{"description":"Overall approval amount.","type":"string"},"perFromAddressApprovalAmount":{"description":"Approval amount per \"from\" address.","type":"string"},"perInitiatedByAddressApprovalAmount":{"description":"Approval amount per \"initiated by\" address.","type":"string"},"perToAddressApprovalAmount":{"description":"Approval amount per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v17.ResetTimeIntervals"}}},"badges.v17.ApprovalCriteria":{"description":"ApprovalCriteria defines the criteria for approving transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v17.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v17.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v17.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.MustOwnBadges"}},"overridesFromOutgoingApprovals":{"description":"Overrides the user's outgoing approvals for approval.","type":"boolean"},"overridesToIncomingApprovals":{"description":"Overrides the user's incoming approvals for approval.","type":"boolean"},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v17.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"},"userRoyalties":{"description":"User level royalties to apply to the transfer.","$ref":"#/definitions/badges.v17.UserRoyalties"}}},"badges.v17.ApprovalIdentifierDetails":{"description":"ApprovalIdentifierDetails defines the details to identify a specific approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval.","type":"string"},"approvalLevel":{"description":"The level of the approval. Can be \"collection\", \"incoming\", or \"outgoing\".","type":"string"},"approverAddress":{"description":"The address of the approver. Leave blank \"\" if approvalLevel == \"collection\".","type":"string"},"version":{"description":"The version of the approval.","type":"string"}}},"badges.v17.AutoDeletionOptions":{"description":"AutoDeletionOptions defines the options for auto-deletion of approvals.","type":"object","properties":{"afterOneUse":{"type":"boolean","title":"After one use?"},"afterOverallMaxNumTransfers":{"type":"boolean","title":"After overall max number of uses threshold is met?"},"allowCounterpartyPurge":{"type":"boolean","title":"Allow counterparty to purge this approval if they are the only initiator"},"allowPurgeIfExpired":{"type":"boolean","title":"Allow others to call PurgeApprovals on behalf of this approval owner"}}},"badges.v17.BadgeIdsActionPermission":{"description":"BadgeIdsActionPermission defines the permissions for updating a timeline-based field for specific tokens and specific token ownership times.\nCurrently, this is only used for creating new tokens.\n\nEx: If you want to lock the ability to create new tokens for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021, \nyou could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.BadgeMetadata":{"description":"This message defines the metadata for specific token IDs.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"badgeIds":{"description":"The token IDs to which this metadata applies.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"customData":{"description":"Custom data or additional information related to the token metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the token metadata.","type":"string"}}},"badges.v17.BadgeMetadataTimeline":{"description":"BadgeMetadataTimeline defines the metadata for tokens at different timeline times.","type":"object","properties":{"badgeMetadata":{"description":"The token metadata for a specific timeline element.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.BadgeMetadata"}},"timelineTimes":{"description":"The timeline times when the token metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.Balance":{"description":"Balance represents the balance of a token for a specific user.\nThe user amounts xAmount of a token for the badgeID specified for the time ranges specified.\n\nExample: User A owns x10 of token IDs 1-10 from 1/1/2020 to 1/1/2021.\n\nIf times or badgeIDs have len \u003e 1, then the user owns all token IDs specified for all time ranges specified.","type":"object","properties":{"amount":{"description":"The amount of the token owned by the user.","type":"string"},"badgeIds":{"description":"The token IDs for which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"ownershipTimes":{"description":"The time ranges during which the user owns the token.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.CoinTransfer":{"type":"object","properties":{"coins":{"description":"The sdk.Coins to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"overrideFromWithApproverAddress":{"description":"By default, the from address is the initiator of the transaction.\nIf this is set to true, we will override the from address with the approver address.\nNote: This is not applicable for collection approvals (since approverAddress == '').","type":"boolean"},"overrideToWithInitiator":{"description":"By default, the to address is what is specified in the coin transfer.\nIf this is set to true, we will override the to address with the initiator of the transaction.","type":"boolean"},"to":{"description":"The address of the recipient of the transfer.","type":"string"}}},"badges.v17.CollectionApproval":{"type":"object","title":"CollectionApproval defines the rules for the approval of a transfer on the collection level","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v17.ApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v17.CollectionApprovalPermission":{"description":"CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.\n\nEach transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.\nFor a transfer to match, we need to match ALL of the fields in the combination. \nThese are determined by the fromListId, toListId, initiatedByListId, transferTimes, badgeIds fields.\nAddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists). \n\nTimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?\npermanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?\n\nEx: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", 10, 1000).\nWe would check to find the FIRST CollectionApprovalPermission that matches this combination.\nIf we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).\n\nEx: So if you wanted to freeze the transferability to enforce that token ID 1 will always be transferable, you could set\nthe combination (\"AllWithoutMint\", \"AllWithoutMint\", \"AllWithoutMint\", \"All Transfer Times\", 1) to always be forbidden at all timelineTimes.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.CollectionInvariants":{"description":"CollectionInvariants defines the invariants that apply to a collection.","type":"object","properties":{"maxSupplyPerId":{"description":"Maximum supply per token ID. If set, no balance can exceed this amount.\nThis prevents any single token ID from having more than the specified supply.","type":"string"},"noCustomOwnershipTimes":{"description":"If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].\nThis prevents time-based restrictions on token ownership.","type":"boolean"}}},"badges.v17.CollectionMetadata":{"description":"This message defines the metadata for the collection.\nThe interpretation of this metadata should follow the collection standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the collection metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the collection metadata.","type":"string"}}},"badges.v17.CollectionMetadataTimeline":{"description":"CollectionMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"collectionMetadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/badges.v17.CollectionMetadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.CollectionPermissions":{"description":"CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).\n\nThere are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BadgeIdsActionPermission, and CollectionApprovalPermission.\n\nThe permission type allows fine-grained access control for each action.\n- ActionPermission: defines when the manager can perform an action.\n- TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.\n- TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific tokens and what times of the timeline can be updated.\n- BadgeIdsActionPermission: defines when the manager can perform an action for specific tokens\n- CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.\n\nNote there are a few different times here which could get confusing:\n- timelineTimes: the times when a timeline-based field is a specific value\n- permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed\n- transferTimes - the times that a transfer occurs\n- ownershipTimes - the times when a token is owned by a user\n\nThe permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.\nOnce a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.\nIf a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.\n\nIMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1, \nwe will only check the first permission (forbid time T) and not the second permission (permit time T).","type":"object","properties":{"canArchiveCollection":{"description":"Permissions related to archiving the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdatePermission"}},"canDeleteCollection":{"description":"Permissions related to deleting the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ActionPermission"}},"canUpdateBadgeMetadata":{"description":"Permissions related to updating token metadata for specific tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdateWithBadgeIdsPermission"}},"canUpdateCollectionApprovals":{"description":"Permissions related to updating collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CollectionApprovalPermission"}},"canUpdateCollectionMetadata":{"description":"Permissions related to updating the metadata of the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdatePermission"}},"canUpdateCustomData":{"description":"Permissions related to updating custom data for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdatePermission"}},"canUpdateManager":{"description":"Permissions related to updating the collection's manager.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdatePermission"}},"canUpdateStandards":{"description":"Permissions related to updating standards for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdatePermission"}},"canUpdateValidBadgeIds":{"description":"Permissions related to creating more tokens for the collection.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.BadgeIdsActionPermission"}}}},"badges.v17.CosmosCoinWrapperPathAddObject":{"type":"object","properties":{"allowCosmosWrapping":{"type":"boolean"},"allowOverrideWithAnyValidToken":{"type":"boolean"},"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.Balance"}},"denom":{"type":"string"},"denomUnits":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.DenomUnit"}},"symbol":{"type":"string"}}},"badges.v17.CustomDataTimeline":{"description":"CustomDataTimeline defines custom data at different timeline times.","type":"object","properties":{"customData":{"description":"The custom data for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the custom data is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.DenomUnit":{"type":"object","properties":{"decimals":{"type":"string"},"isDefaultDisplay":{"type":"boolean"},"symbol":{"type":"string"}}},"badges.v17.DynamicStoreChallenge":{"description":"DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.","type":"object","properties":{"storeId":{"description":"The ID of the dynamic store to check.","type":"string"}}},"badges.v17.ETHSignatureChallenge":{"description":"ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.\n\nAn ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.\nThe signature scheme is ETHSign(nonce + \"-\" + creatorAddress) and each signature can only be used once.\nAll challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.\nIf you update the challenge ID, then the used signatures tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this ETH signature challenge for tracking the number of uses per signature.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this ETH signature challenge.","type":"string"},"signer":{"description":"The Ethereum address that must sign the nonce for verification.","type":"string"},"uri":{"description":"The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.","type":"string"}}},"badges.v17.ETHSignatureProof":{"description":"ETHSignatureProof represents an Ethereum signature proof for a challenge.","type":"object","properties":{"nonce":{"description":"The nonce that was signed. The signature scheme is ETHSign(nonce + \"-\" + creatorAddress).","type":"string"},"signature":{"description":"The Ethereum signature of the nonce.","type":"string"}}},"badges.v17.IncomingApprovalCriteria":{"description":"IncomingApprovalCriteria defines the criteria for approving incoming transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v17.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v17.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v17.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v17.PredeterminedBalances"},"requireFromDoesNotEqualInitiatedBy":{"description":"Require the \"from\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireFromEqualsInitiatedBy":{"description":"Require the \"from\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v17.IncrementedBalances":{"description":"IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.","type":"object","properties":{"allowOverrideTimestamp":{"description":"Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).","type":"boolean"},"allowOverrideWithAnyValidBadge":{"type":"boolean","title":"Allow override of any valid ID"},"durationFromTimestamp":{"description":"The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.","type":"string"},"incrementBadgeIdsBy":{"description":"The amount by which to increment token IDs.","type":"string"},"incrementOwnershipTimesBy":{"description":"The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.","type":"string"},"recurringOwnershipTimes":{"description":"Recurring ownership times.","$ref":"#/definitions/badges.v17.RecurringOwnershipTimes"},"startBalances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.Balance"}}}},"badges.v17.IsArchivedTimeline":{"description":"IsArchivedTimeline defines whether a collection is archived at different timeline times.","type":"object","properties":{"isArchived":{"description":"Indicates whether the collection is archived for a specific timeline element.","type":"boolean"},"timelineTimes":{"description":"The timeline times when the archived status is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.ManualBalances":{"description":"ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.","type":"object","properties":{"balances":{"type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.Balance"}}}},"badges.v17.MaxNumTransfers":{"description":"MaxNumTransfers defines the maximum number of transfers per unique \"from,\" \"to,\" and/or \"initiated by\" address.\nIf any of these are nil or \"0\", we assume unlimited approvals.\nIf they are set to a value, then the running tally of the number of transfers for the specified token IDs and ownership times\nmust not exceed the corresponding value.","type":"object","properties":{"amountTrackerId":{"description":"The ID of the amount tracker associated with this approval.\nWe use this ID to track the number of transfers and amounts transferred.","type":"string"},"overallMaxNumTransfers":{"description":"Overall maximum number of transfers.","type":"string"},"perFromAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"from\" address.","type":"string"},"perInitiatedByAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"initiated by\" address.","type":"string"},"perToAddressMaxNumTransfers":{"description":"Maximum number of transfers per \"to\" address.","type":"string"},"resetTimeIntervals":{"description":"Time intervals to reset the trackers at.","$ref":"#/definitions/badges.v17.ResetTimeIntervals"}}},"badges.v17.MerkleChallenge":{"description":"Challenges define a rule for the approval in the form of a Merkle challenge.\n\nA Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,\nthen the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.\n\nIMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.\n\nIMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.\nIf you update the challenge ID, then the used leaves tracker will reset and start a new tally.\nWe recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.","type":"object","properties":{"challengeTrackerId":{"description":"The ID of this Merkle challenge for tracking the number of uses per leaf.","type":"string"},"customData":{"description":"Arbitrary custom data associated with this Merkle challenge.","type":"string"},"expectedProofLength":{"description":"The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.","type":"string"},"leafSigner":{"type":"string","title":"Leaf must be signed by. Used to protect against man in the middle attacks.`\nScheme we use is sign(leaf + \"-\" +"},"maxUsesPerLeaf":{"description":"The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.","type":"string"},"root":{"description":"The root hash of the Merkle tree to which the Merkle path must lead for verification.","type":"string"},"uri":{"description":"The URI associated with this Merkle challenge, optionally providing metadata about the challenge.","type":"string"},"useCreatorAddressAsLeaf":{"description":"If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.","type":"boolean"}}},"badges.v17.MerklePathItem":{"description":"MerklePathItem represents an item in a Merkle path.","type":"object","properties":{"aunt":{"description":"The hash of the sibling node (aunt) in the Merkle path.","type":"string"},"onRight":{"description":"Indicates whether the aunt node is on the right side of the path.","type":"boolean"}}},"badges.v17.MerkleProof":{"description":"MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.","type":"object","properties":{"aunts":{"description":"List of Merkle path items (aunts) that make up the proof.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.MerklePathItem"}},"leaf":{"description":"The hash of the leaf node for which the proof is generated.","type":"string"},"leafSignature":{"description":"The signature of the leaf node tying the address to the leaf node.","type":"string"}}},"badges.v17.MsgCreateAddressLists":{"description":"MsgCreateAddressLists is used to create address lists.","type":"object","properties":{"addressLists":{"description":"Address lists to create.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.AddressList"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v17.MsgCreateAddressListsResponse":{"description":"MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.","type":"object"},"badges.v17.MsgCreateCollection":{"description":"MsgCreateCollection is used to create a new collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"Token metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"Collection approvals.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CollectionApproval"}},"collectionMetadataTimeline":{"description":"Collection metadata timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"Collection permissions.","$ref":"#/definitions/badges.v17.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"Custom data timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v17.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.","$ref":"#/definitions/badges.v17.CollectionInvariants"},"isArchivedTimeline":{"description":"isArchived timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.IsArchivedTimeline"}},"managerTimeline":{"description":"Manager timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standardsTimeline":{"description":"Standards timeline entries.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.StandardsTimeline"}},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.MsgCreateCollectionResponse":{"description":"MsgCreateCollectionResponse is the response to MsgCreateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v17.MsgCreateDynamicStore":{"description":"MsgCreateDynamicStore is used to create a new dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The default value for uninitialized addresses (number of uses).","type":"string"}}},"badges.v17.MsgCreateDynamicStoreResponse":{"description":"MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.","type":"object","properties":{"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.v17.MsgDecrementStoreValue":{"description":"MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to decrement the value.","type":"string"},"amount":{"description":"The amount to decrement by.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"setToZeroOnUnderflow":{"description":"If true, set to zero on underflow. If false, throw error on underflow.","type":"boolean"},"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.v17.MsgDecrementStoreValueResponse":{"description":"MsgDecrementStoreValueResponse is the response to MsgDecrementStoreValue.","type":"object"},"badges.v17.MsgDeleteCollection":{"description":"MsgDeleteCollection is used to delete a collection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v17.MsgDeleteCollectionResponse":{"description":"MsgDeleteCollectionResponse is the response to MsgDeleteCollection.","type":"object"},"badges.v17.MsgDeleteDynamicStore":{"description":"MsgDeleteDynamicStore is used to delete a dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store to delete.","type":"string"}}},"badges.v17.MsgDeleteDynamicStoreResponse":{"description":"MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.","type":"object"},"badges.v17.MsgDeleteIncomingApproval":{"description":"MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v17.MsgDeleteIncomingApprovalResponse":{"description":"MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.","type":"object"},"badges.v17.MsgDeleteOutgoingApproval":{"description":"MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.","type":"object","properties":{"approvalId":{"description":"The ID of the approval to delete.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v17.MsgDeleteOutgoingApprovalResponse":{"description":"MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.","type":"object"},"badges.v17.MsgIncrementStoreValue":{"description":"MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to increment the value.","type":"string"},"amount":{"description":"The amount to increment by.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"}}},"badges.v17.MsgIncrementStoreValueResponse":{"description":"MsgIncrementStoreValueResponse is the response to MsgIncrementStoreValue.","type":"object"},"badges.v17.MsgPurgeApprovals":{"description":"MsgPurgeApprovals is a helper message to purge expired approvals.","type":"object","properties":{"approvalsToPurge":{"description":"Specific approvals to purge. If empty, purges all applicable approvals based on other flags.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ApprovalIdentifierDetails"}},"approverAddress":{"description":"Address of the user whose approvals to purge. If empty, defaults to creator.","type":"string"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"purgeCounterpartyApprovals":{"description":"Whether to purge counterparty approvals (approvals where the creator is the only initiator).","type":"boolean"},"purgeExpired":{"description":"Whether to purge expired approvals (approvals with no future valid transfer times).","type":"boolean"}}},"badges.v17.MsgPurgeApprovalsResponse":{"description":"MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.","type":"object","properties":{"numPurged":{"description":"Number of approvals purged.","type":"string"}}},"badges.v17.MsgSetBadgeMetadata":{"type":"object","title":"MsgSetBadgeMetadata sets the token metadata timeline and canUpdateBadgeMetadata permission","properties":{"badgeMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.BadgeMetadataTimeline"}},"canUpdateBadgeMetadata":{"type":"array","title":"Permission to update token metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdateWithBadgeIdsPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v17.MsgSetBadgeMetadataResponse":{"description":"MsgSetBadgeMetadataResponse is the response to MsgSetBadgeMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v17.MsgSetCollectionApprovals":{"type":"object","title":"MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission","properties":{"canUpdateCollectionApprovals":{"type":"array","title":"Permission to update collection approvals","items":{"type":"object","$ref":"#/definitions/badges.v17.CollectionApprovalPermission"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CollectionApproval"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v17.MsgSetCollectionApprovalsResponse":{"description":"MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v17.MsgSetCollectionMetadata":{"type":"object","title":"MsgSetCollectionMetadata sets the collection metadata timeline and canUpdateCollectionMetadata permission","properties":{"canUpdateCollectionMetadata":{"type":"array","title":"Permission to update collection metadata timeline","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CollectionMetadataTimeline"}},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v17.MsgSetCollectionMetadataResponse":{"description":"MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v17.MsgSetCustomData":{"type":"object","title":"MsgSetCustomData sets the custom data timeline and canUpdateCustomData permission","properties":{"canUpdateCustomData":{"type":"array","title":"Permission to update custom data timeline","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CustomDataTimeline"}}}},"badges.v17.MsgSetCustomDataResponse":{"description":"MsgSetCustomDataResponse is the response to MsgSetCustomData.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v17.MsgSetDynamicStoreValue":{"description":"MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.","type":"object","properties":{"address":{"description":"The address for which to set the value.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"storeId":{"description":"ID of the dynamic store.","type":"string"},"value":{"description":"The usage count to set (number of times this address can use the approval).","type":"string"}}},"badges.v17.MsgSetDynamicStoreValueResponse":{"description":"MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.","type":"object"},"badges.v17.MsgSetIncomingApproval":{"description":"MsgSetIncomingApproval is a helper message to set a single incoming approval.","type":"object","properties":{"approval":{"description":"The incoming approval to set.","$ref":"#/definitions/badges.v17.UserIncomingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v17.MsgSetIncomingApprovalResponse":{"description":"MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.","type":"object"},"badges.v17.MsgSetIsArchived":{"type":"object","title":"MsgSetIsArchived sets the isArchived timeline and canArchiveCollection permission","properties":{"canArchiveCollection":{"type":"array","title":"Permission to archive collection","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.IsArchivedTimeline"}}}},"badges.v17.MsgSetIsArchivedResponse":{"description":"MsgSetIsArchivedResponse is the response to MsgSetIsArchived.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v17.MsgSetManager":{"type":"object","title":"MsgSetManager sets the manager timeline and canUpdateManager permission","properties":{"canUpdateManager":{"type":"array","title":"Permission to update manager timeline","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ManagerTimeline"}}}},"badges.v17.MsgSetManagerResponse":{"description":"MsgSetManagerResponse is the response to MsgSetManager.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v17.MsgSetOutgoingApproval":{"description":"MsgSetOutgoingApproval is a helper message to set a single outgoing approval.","type":"object","properties":{"approval":{"description":"The outgoing approval to set.","$ref":"#/definitions/badges.v17.UserOutgoingApproval"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"}}},"badges.v17.MsgSetOutgoingApprovalResponse":{"description":"MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.","type":"object"},"badges.v17.MsgSetStandards":{"type":"object","title":"MsgSetStandards sets the standards timeline and canUpdateStandards permission","properties":{"canUpdateStandards":{"type":"array","title":"Permission to update standards timeline","items":{"type":"object","$ref":"#/definitions/badges.v17.TimedUpdatePermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.StandardsTimeline"}}}},"badges.v17.MsgSetStandardsResponse":{"description":"MsgSetStandardsResponse is the response to MsgSetStandards.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v17.MsgSetValidBadgeIds":{"type":"object","title":"MsgSetValidBadgeIds sets the validBadgeIds and canUpdateValidBadgeIds permission","properties":{"canUpdateValidBadgeIds":{"type":"array","title":"Permission to update valid token IDs","items":{"type":"object","$ref":"#/definitions/badges.v17.BadgeIdsActionPermission"}},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.MsgSetValidBadgeIdsResponse":{"description":"MsgSetValidBadgeIdsResponse is the response to MsgSetValidBadgeIds.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v17.MsgTransferBadges":{"description":"MsgTransferBadges is used to transfer tokens.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"transfers":{"description":"Transfers to execute.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.Transfer"}}}},"badges.v17.MsgTransferBadgesResponse":{"description":"MsgTransferBadgesResponse is the response to MsgTransferBadges.","type":"object"},"badges.v17.MsgUniversalUpdateCollection":{"description":"MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.\nIt is a universal interface that can be used for both creating and updating collections.\nWe have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v17.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CustomDataTimeline"}},"defaultBalances":{"title":"The default balances for the user","$ref":"#/definitions/badges.v17.UserBalanceStore"},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.v17.CollectionInvariants"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.MsgUniversalUpdateCollectionResponse":{"description":"MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v17.MsgUpdateCollection":{"description":"MsgUpdateCollection is used to update a collection.","type":"object","properties":{"badgeMetadataTimeline":{"description":"New token metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.BadgeMetadataTimeline"}},"collectionApprovals":{"description":"New collection approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CollectionApproval"}},"collectionId":{"description":"ID of the collection (0 for new collection).","type":"string"},"collectionMetadataTimeline":{"description":"New collection metadata timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CollectionMetadataTimeline"}},"collectionPermissions":{"description":"New collection permissions to set.","$ref":"#/definitions/badges.v17.CollectionPermissions"},"cosmosCoinWrapperPathsToAdd":{"description":"IBC wrapper paths to add.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CosmosCoinWrapperPathAddObject"}},"creator":{"description":"Address of the creator.","type":"string"},"customDataTimeline":{"description":"New custom data timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CustomDataTimeline"}},"invariants":{"description":"Collection-level invariants that cannot be broken.\nThese are set upon genesis and cannot be modified.","$ref":"#/definitions/badges.v17.CollectionInvariants"},"isArchivedTimeline":{"description":"New isArchived timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.IsArchivedTimeline"}},"managerTimeline":{"description":"New manager timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ManagerTimeline"}},"mintEscrowCoinsToTransfer":{"description":"Coins to be transferred to the mint escrow address.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"standardsTimeline":{"description":"New standards timeline to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.StandardsTimeline"}},"updateBadgeMetadataTimeline":{"description":"Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionApprovals":{"description":"Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionMetadataTimeline":{"description":"Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCollectionPermissions":{"description":"Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateCustomDataTimeline":{"description":"Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIsArchivedTimeline":{"description":"Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateManagerTimeline":{"description":"Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateStandardsTimeline":{"description":"Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateValidBadgeIds":{"description":"Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"validBadgeIds":{"type":"array","title":"New token IDs to add to this collection","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.MsgUpdateCollectionResponse":{"description":"MsgUpdateCollectionResponse is the response to MsgUpdateCollection.","type":"object","properties":{"collectionId":{"description":"ID of the collection.","type":"string"}}},"badges.v17.MsgUpdateDynamicStore":{"description":"MsgUpdateDynamicStore is used to update an existing dynamic store.","type":"object","properties":{"creator":{"description":"Address of the creator.","type":"string"},"defaultValue":{"description":"The new default value for uninitialized addresses (optional, only set if updating).","type":"string"},"storeId":{"description":"ID of the dynamic store to update.","type":"string"}}},"badges.v17.MsgUpdateDynamicStoreResponse":{"description":"MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.","type":"object"},"badges.v17.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/badges.v17.Params"}}},"badges.v17.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"badges.v17.MsgUpdateUserApprovals":{"description":"MsgUpdateUserApprovals is used to update user approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Auto-approve setting for all incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Auto-approve setting for self-initiated incoming transfers.","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Auto-approve setting for self-initiated outgoing transfers.","type":"boolean"},"collectionId":{"description":"ID of the collection.","type":"string"},"creator":{"description":"Address of the creator.","type":"string"},"incomingApprovals":{"description":"New incoming approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UserIncomingApproval"}},"outgoingApprovals":{"description":"New outgoing approvals to set.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UserOutgoingApproval"}},"updateAutoApproveAllIncomingTransfers":{"description":"Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateIncomingApprovals":{"description":"Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateOutgoingApprovals":{"description":"Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"updateUserPermissions":{"description":"Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.","type":"boolean"},"userPermissions":{"description":"New user permissions to set.","$ref":"#/definitions/badges.v17.UserPermissions"}}},"badges.v17.MsgUpdateUserApprovalsResponse":{"description":"MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.","type":"object"},"badges.v17.MustOwnBadges":{"description":"MustOwnBadges represents a condition where a user must own specific tokens\nto be approved to transfer.\n\n- collectionId: The ID of the collection for the tokens that must be owned\n- amountRange: The range of amounts the user must own (min to max)\n- ownershipTimes: The time ranges during which the user must own the tokens.\n- badgeIds: The token IDs the user must own.\n- overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.\n- mustSatisfyForAllAssets: If true, the user must own all specified tokens; otherwise, owning any one for \u003e= 1 millisecond is sufficient.","type":"object","properties":{"amountRange":{"description":"The range of amounts the user must own (min to max).","$ref":"#/definitions/badges.v17.UintRange"},"badgeIds":{"description":"The token IDs the user must own.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"collectionId":{"description":"The ID of the collection.","type":"string"},"mustSatisfyForAllAssets":{"description":"If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.","type":"boolean"},"overrideWithCurrentTime":{"description":"If true, override ownershipTimes with the current time.","type":"boolean"},"ownershipCheckParty":{"description":"The party to check ownership for. Options are \"initiator\", \"sender\", or \"recipient\". Defaults to \"initiator\" if empty.","type":"string"},"ownershipTimes":{"description":"The time ranges during which the user must own the tokens.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.OutgoingApprovalCriteria":{"description":"OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.","type":"object","properties":{"approvalAmounts":{"description":"Threshold limit of amounts that can be transferred using this approval.","$ref":"#/definitions/badges.v17.ApprovalAmounts"},"autoDeletionOptions":{"description":"Auto-deletion options.","$ref":"#/definitions/badges.v17.AutoDeletionOptions"},"coinTransfers":{"description":"The sdk.Coins that need to be transferred for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.CoinTransfer"}},"dynamicStoreChallenges":{"description":"Dynamic store challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.DynamicStoreChallenge"}},"ethSignatureChallenges":{"description":"ETH signature challenges that the initiator must pass for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ETHSignatureChallenge"}},"maxNumTransfers":{"description":"Maximum number of transfers that can be processed using this approval.","$ref":"#/definitions/badges.v17.MaxNumTransfers"},"merkleChallenges":{"description":"Merkle challenge that must be satisfied for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.MerkleChallenge"}},"mustOwnBadges":{"description":"Must own tokens for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.MustOwnBadges"}},"predeterminedBalances":{"description":"Predetermined balances for eeach approval.","$ref":"#/definitions/badges.v17.PredeterminedBalances"},"requireToDoesNotEqualInitiatedBy":{"description":"Require the \"to\" address to not be equal to the \"initiated by\" address for approval.","type":"boolean"},"requireToEqualsInitiatedBy":{"description":"Require the \"to\" address to be equal to the \"initiated by\" address for approval.","type":"boolean"}}},"badges.v17.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"affiliate_percentage":{"type":"string","title":"affiliate_percentage defines the percentage of the transfer amount that goes to the affiliate"},"allowed_denoms":{"type":"array","title":"allowed_denoms defines the list of denoms that are allowed to be used in coin_transfers","items":{"type":"string"}}}},"badges.v17.PrecalculationOptions":{"description":"PrecalculationOptions defines the options for precalculating the balances.","type":"object","properties":{"badgeIdsOverride":{"description":"The IDs to override for the transfer. Only applicable if using this option in precalculation.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"overrideTimestamp":{"description":"The timestamp to override with when calculating the balances.","type":"string"}}},"badges.v17.PredeterminedBalances":{"description":"PredeterminedBalances represents balances with predetermined order calculation.","type":"object","properties":{"incrementedBalances":{"description":"Balances that have a starting amount and increment. If this is nil, then we use the manual balances.","$ref":"#/definitions/badges.v17.IncrementedBalances"},"manualBalances":{"description":"Manual balances that can be entered. If this is nil, then we use the incremented balances.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ManualBalances"}},"orderCalculationMethod":{"description":"The method to calculate the order of predetermined balances.","$ref":"#/definitions/badges.v17.PredeterminedOrderCalculationMethod"}}},"badges.v17.PredeterminedOrderCalculationMethod":{"description":"PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.","type":"object","properties":{"challengeTrackerId":{"description":"If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.","type":"string"},"useMerkleChallengeLeafIndex":{"description":"Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.","type":"boolean"},"useOverallNumTransfers":{"description":"Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.","type":"boolean"},"usePerFromAddressNumTransfers":{"description":"Use the number of transfers per \"from\" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.","type":"boolean"},"usePerInitiatedByAddressNumTransfers":{"description":"Use the number of transfers per \"initiated by\" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.","type":"boolean"},"usePerToAddressNumTransfers":{"description":"Use the number of transfers per \"to\" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.","type":"boolean"}}},"badges.v17.RecurringOwnershipTimes":{"description":"RecurringOwnershipTimes represents a list of recurring ownership times.","type":"object","properties":{"chargePeriodLength":{"type":"string","title":"Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period"},"intervalLength":{"description":"The interval length in unix milliseconds.","type":"string"},"startTime":{"description":"The original start time of the first interval.","type":"string"}}},"badges.v17.ResetTimeIntervals":{"description":"Time intervals to reset the trackers at.","type":"object","properties":{"intervalLength":{"description":"Interval length in unix milliseconds.","type":"string"},"startTime":{"description":"Original start time of the first interval.","type":"string"}}},"badges.v17.StandardsTimeline":{"description":"StandardsTimeline defines the standards used for a collection at different timeline times.","type":"object","properties":{"standards":{"description":"The standards applied to the collection for a specific timeline element.","type":"array","items":{"type":"string"}},"timelineTimes":{"description":"The timeline times when the standards are valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.TimedUpdateWithBadgeIdsPermission":{"description":"TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific tokens.\n\nEx: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.Transfer":{"description":"Transfer defines the details of a transfer of tokens.","type":"object","properties":{"affiliateAddress":{"description":"Affiliate address for the transfer.","type":"string"},"balances":{"description":"The balances to be transferred.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.Balance"}},"ethSignatureProofs":{"description":"The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ETHSignatureProof"}},"from":{"description":"The address of the sender of the transfer.","type":"string"},"memo":{"description":"The memo for the transfer.","type":"string"},"merkleProofs":{"description":"The Merkle proofs / solutions for all Merkle challenges required for the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.MerkleProof"}},"numAttempts":{"description":"The number of times to attempt approval validation. If 0 / not specified, we default to only one.","type":"string"},"onlyCheckPrioritizedCollectionApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedIncomingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"onlyCheckPrioritizedOutgoingApprovals":{"description":"Whether to only check prioritized approvals for the transfer. \nIf true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).\nIf false, we will check the prioritized approvals first and then scan through the rest of the approvals.","type":"boolean"},"precalculateBalancesFromApproval":{"description":"If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.\nWe will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.","$ref":"#/definitions/badges.v17.ApprovalIdentifierDetails"},"precalculationOptions":{"description":"The options for precalculating the balances.","$ref":"#/definitions/badges.v17.PrecalculationOptions"},"prioritizedApprovals":{"description":"The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.\nThis field can be used to prioritize specific approvals and scan through them first.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ApprovalIdentifierDetails"}},"toAddresses":{"description":"The addresses of the recipients of the transfer.","type":"array","items":{"type":"string"}}}},"badges.v17.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\nuintRanges are one of the core types used.\n\nThey are used for everything from token IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"badges.v17.UserBalanceStore":{"description":"UserBalanceStore is the store for the user balances for a collection.\n\nIt consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,\nas well as the permissions for updating the approved incoming/outgoing transfers.\n\nUpon initialization, all fields (minus the balances) are set to the defaults specified by the collection.\n\nThe outgoing transfers can be used to allow / disallow transfers which are sent from this user.\nIf a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedOutgoingTransfers is set to true.\n\nThe incoming transfers can be used to allow / disallow transfers which are sent to this user.\nIf a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)\nand autoApproveSelfInitiatedIncomingTransfers is set to true.\n\nNote that the user approved transfers are only checked if the collection approved transfers do not specify to override\nthe user approved transfers. \n\nThe permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.","type":"object","properties":{"autoApproveAllIncomingTransfers":{"description":"Whether to auto-approve all incoming transfers by default. \nThis is just shorthand for adding an accept everything incoming approval\nwith no restrictions.","type":"boolean"},"autoApproveSelfInitiatedIncomingTransfers":{"description":"Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).","type":"boolean"},"autoApproveSelfInitiatedOutgoingTransfers":{"description":"Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).","type":"boolean"},"balances":{"description":"The list of balances associated with this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.Balance"}},"incomingApprovals":{"description":"The list of approved incoming transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UserIncomingApproval"}},"outgoingApprovals":{"description":"The list of approved outgoing transfers for this user.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UserOutgoingApproval"}},"userPermissions":{"description":"The permissions for this user's actions and transfers.","$ref":"#/definitions/badges.v17.UserPermissions"}}},"badges.v17.UserIncomingApproval":{"description":"UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v17.IncomingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"fromListId":{"description":"The list ID for the sender of the transfer.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v17.UserIncomingApprovalPermission":{"description":"UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.\n\nSee CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"fromListId":{"description":"Identifier for the sender list.","type":"string"},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.UserOutgoingApproval":{"description":"UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.","type":"object","properties":{"approvalCriteria":{"description":"The criteria that must be met for this approval to be considered.","$ref":"#/definitions/badges.v17.OutgoingApprovalCriteria"},"approvalId":{"description":"The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).","type":"string"},"badgeIds":{"description":"The allowed range of token IDs for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"customData":{"description":"Arbitrary custom data associated with this approval.","type":"string"},"initiatedByListId":{"description":"The list ID for the user who initiated the transfer.","type":"string"},"ownershipTimes":{"description":"The allowed range of ownership times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"toListId":{"description":"The list ID for the recipient of the transfer.","type":"string"},"transferTimes":{"description":"The allowed range of transfer times for approval.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"uri":{"description":"The URI associated with this approval, optionally providing metadata about the approval.","type":"string"},"version":{"description":"Version of the approval. Maintained internally.","type":"string"}}},"badges.v17.UserOutgoingApprovalPermission":{"description":"UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.","type":"object","properties":{"approvalId":{"description":"Identifier for the approvalId. You can use \"All\" or \"!approvalId\" for shorthand.\nIf you use \"All\", this approval will match to all approvalIds.\nIf you use \"!approvalId\", this approval will match to all approvalIds except for approvalId.\nIf you use \"approvalId\", this approval will match to only the specified approvalId and fail on all others.","type":"string"},"badgeIds":{"description":"Specifies the token IDs involved in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"initiatedByListId":{"description":"Identifier for the initiator list (who is approved?).","type":"string"},"ownershipTimes":{"description":"Specifies the ownership times for the tokens in the transfer.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}},"toListId":{"description":"Identifier for the recipient list.","type":"string"},"transferTimes":{"description":"Specifies the times when the transfer can occur.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UintRange"}}}},"badges.v17.UserPermissions":{"description":"UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).\n\nSee CollectionPermissions for more details on the different types of permissions.\n\ncanUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,\nbut certain fields are removed because they are not relevant to the user.","type":"object","properties":{"canUpdateAutoApproveAllIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedIncomingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ActionPermission"}},"canUpdateAutoApproveSelfInitiatedOutgoingTransfers":{"description":"Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.ActionPermission"}},"canUpdateIncomingApprovals":{"description":"Permissions related to updating the user's approved incoming transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UserIncomingApprovalPermission"}},"canUpdateOutgoingApprovals":{"description":"Permissions related to updating the user's approved outgoing transfers.","type":"array","items":{"type":"object","$ref":"#/definitions/badges.v17.UserOutgoingApprovalPermission"}}}},"badges.v17.UserRoyalties":{"description":"UserRoyalties defines the royalties for a user.","type":"object","properties":{"payoutAddress":{"description":"Payout address for the royalties.","type":"string"},"percentage":{"description":"Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.","type":"string"}}},"cosmos.base.query.v1beta1.PageRequest":{"description":"message SomeRequest {\n         Foo some_parameter = 1;\n         PageRequest pagination = 2;\n }","type":"object","title":"PageRequest is to be embedded in gRPC request messages for efficient\npagination. Ex:","properties":{"count_total":{"description":"count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.","type":"boolean"},"key":{"description":"key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.","type":"string","format":"byte"},"limit":{"description":"limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.","type":"string","format":"uint64"},"offset":{"description":"offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.","type":"string","format":"uint64"},"reverse":{"description":"reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43","type":"boolean"}}},"cosmos.base.query.v1beta1.PageResponse":{"description":"PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }","type":"object","properties":{"next_key":{"description":"next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.","type":"string","format":"byte"},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"}}},"cosmos.base.v1beta1.Coin":{"description":"Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.","type":"object","properties":{"amount":{"type":"string"},"denom":{"type":"string"}}},"gamm.poolmodels.balancer.MsgCreateBalancerPool":{"type":"object","title":"===================== MsgCreatePool","properties":{"pool_assets":{"type":"array","items":{"type":"object","$ref":"#/definitions/gamm.poolmodels.balancer.PoolAsset"}},"pool_params":{"$ref":"#/definitions/gamm.poolmodels.balancer.PoolParams"},"sender":{"type":"string"}}},"gamm.poolmodels.balancer.MsgCreateBalancerPoolResponse":{"type":"object","title":"Returns the poolID","properties":{"pool_id":{"type":"string","format":"uint64"}}},"gamm.poolmodels.balancer.PoolAsset":{"description":"Pool asset is an internal struct that combines the amount of the\ntoken in the pool, and its balancer weight.\nThis is an awkward packaging of data,\nand should be revisited in a future state migration.","type":"object","properties":{"token":{"description":"Coins we are talking about,\nthe denomination must be unique amongst all PoolAssets for this pool.","$ref":"#/definitions/cosmos.base.v1beta1.Coin"},"weight":{"type":"string","title":"Weight that is not normalized. This weight must be less than 2^50"}}},"gamm.poolmodels.balancer.PoolParams":{"description":"PoolParams defined the parameters that will be managed by the pool\ngovernance in the future. This params are not managed by the chain\ngovernance. Instead they will be managed by the token holders of the pool.","type":"object","properties":{"exit_fee":{"type":"string","title":"N.B.: exit fee is disabled during pool creation in x/poolmanager. While old\npools can maintain a non-zero fee. No new pool can be created with non-zero\nfee anymore"},"swap_fee":{"type":"string"}}},"gamm.poolmodels.stableswap.MsgCreateStableswapPool":{"type":"object","title":"===================== MsgCreatePool","properties":{"future_pool_governor":{"type":"string"},"initial_pool_liquidity":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}},"pool_params":{"$ref":"#/definitions/gamm.poolmodels.stableswap.PoolParams"},"scaling_factor_controller":{"type":"string"},"scaling_factors":{"type":"array","items":{"type":"string","format":"uint64"}},"sender":{"type":"string"}}},"gamm.poolmodels.stableswap.MsgCreateStableswapPoolResponse":{"description":"Returns a poolID with custom poolName.","type":"object","properties":{"pool_id":{"type":"string","format":"uint64"}}},"gamm.poolmodels.stableswap.MsgStableSwapAdjustScalingFactors":{"description":"Sender must be the pool's scaling_factor_governor in order for the tx to\nsucceed. Adjusts stableswap scaling factors.","type":"object","properties":{"pool_id":{"type":"string","format":"uint64"},"scaling_factors":{"type":"array","items":{"type":"string","format":"uint64"}},"sender":{"type":"string"}}},"gamm.poolmodels.stableswap.MsgStableSwapAdjustScalingFactorsResponse":{"type":"object"},"gamm.poolmodels.stableswap.PoolParams":{"description":"PoolParams defined the parameters that will be managed by the pool\ngovernance in the future. This params are not managed by the chain\ngovernance. Instead they will be managed by the token holders of the pool.\nThe pool's token holders are specified in future_pool_governor.","type":"object","properties":{"exit_fee":{"type":"string","title":"N.B.: exit fee is disabled during pool creation in x/poolmanager. While old\npools can maintain a non-zero fee. No new pool can be created with non-zero\nfee anymore"},"swap_fee":{"type":"string"}}},"gamm.v1beta1.MsgExitPool":{"type":"object","title":"===================== MsgExitPool","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_in_amount":{"type":"string"},"token_out_mins":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.MsgExitPoolResponse":{"type":"object","properties":{"token_out":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.MsgExitSwapExternAmountOut":{"type":"object","title":"===================== MsgExitSwapExternAmountOut","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_in_max_amount":{"type":"string"},"token_out":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"gamm.v1beta1.MsgExitSwapExternAmountOutResponse":{"type":"object","properties":{"share_in_amount":{"type":"string"}}},"gamm.v1beta1.MsgExitSwapShareAmountIn":{"type":"object","title":"===================== MsgExitSwapShareAmountIn","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_in_amount":{"type":"string"},"token_out_denom":{"type":"string"},"token_out_min_amount":{"type":"string"}}},"gamm.v1beta1.MsgExitSwapShareAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"gamm.v1beta1.MsgJoinPool":{"type":"object","title":"===================== MsgJoinPool\nThis is really MsgJoinPoolNoSwap","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_out_amount":{"type":"string"},"token_in_maxs":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.MsgJoinPoolResponse":{"type":"object","properties":{"share_out_amount":{"type":"string"},"token_in":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.MsgJoinSwapExternAmountIn":{"type":"object","title":"===================== MsgJoinSwapExternAmountIn\nTODO: Rename to MsgJoinSwapExactAmountIn","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_out_min_amount":{"type":"string","title":"repeated cosmos.base.v1beta1.Coin tokensIn = 5 [\n   (gogoproto.moretags) = \"yaml:\\\"tokens_in\\\"\",\n   (gogoproto.nullable) = false\n ];"},"token_in":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"gamm.v1beta1.MsgJoinSwapExternAmountInResponse":{"type":"object","properties":{"share_out_amount":{"type":"string"}}},"gamm.v1beta1.MsgJoinSwapShareAmountOut":{"type":"object","title":"===================== MsgJoinSwapShareAmountOut","properties":{"pool_id":{"type":"string","format":"uint64"},"sender":{"type":"string"},"share_out_amount":{"type":"string"},"token_in_denom":{"type":"string"},"token_in_max_amount":{"type":"string"}}},"gamm.v1beta1.MsgJoinSwapShareAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"gamm.v1beta1.MsgSwapExactAmountIn":{"type":"object","title":"===================== MsgSwapExactAmountIn","properties":{"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountInRoute"}},"sender":{"type":"string"},"token_in":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"},"token_out_min_amount":{"type":"string"}}},"gamm.v1beta1.MsgSwapExactAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"gamm.v1beta1.MsgSwapExactAmountOut":{"type":"object","properties":{"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountOutRoute"}},"sender":{"type":"string"},"token_in_max_amount":{"type":"string"},"token_out":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"gamm.v1beta1.MsgSwapExactAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"gamm.v1beta1.Params":{"type":"object","title":"Params holds parameters for the incentives module"},"gamm.v1beta1.ParamsResponse":{"type":"object","properties":{"params":{"$ref":"#/definitions/gamm.v1beta1.Params"}}},"gamm.v1beta1.QueryCalcExitPoolCoinsFromSharesResponse":{"type":"object","properties":{"tokens_out":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryCalcJoinPoolNoSwapSharesRequest":{"type":"object","title":"=============================== CalcJoinPoolNoSwapShares","properties":{"pool_id":{"type":"string","format":"uint64"},"tokens_in":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryCalcJoinPoolNoSwapSharesResponse":{"type":"object","properties":{"shares_out":{"type":"string"},"tokens_out":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryCalcJoinPoolSharesResponse":{"type":"object","properties":{"share_out_amount":{"type":"string"},"tokens_out":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryNumPoolsResponse":{"type":"object","properties":{"num_pools":{"type":"string","format":"uint64"}}},"gamm.v1beta1.QueryPoolParamsResponse":{"type":"object","properties":{"params":{"$ref":"#/definitions/google.protobuf.Any"}}},"gamm.v1beta1.QueryPoolResponse":{"type":"object","title":"Deprecated: please use the alternative in x/poolmanager","properties":{"pool":{"$ref":"#/definitions/google.protobuf.Any"}}},"gamm.v1beta1.QueryPoolTypeResponse":{"type":"object","properties":{"pool_type":{"type":"string"}}},"gamm.v1beta1.QueryPoolsResponse":{"type":"object","properties":{"pagination":{"description":"pagination defines the pagination in the response.","$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"},"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}}}},"gamm.v1beta1.QueryPoolsWithFilterResponse":{"type":"object","properties":{"pagination":{"description":"pagination defines the pagination in the response.","$ref":"#/definitions/cosmos.base.query.v1beta1.PageResponse"},"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}}}},"gamm.v1beta1.QuerySpotPriceResponse":{"description":"QuerySpotPriceResponse defines the gRPC response structure for a SpotPrice\nquery.","type":"object","properties":{"spot_price":{"type":"string","title":"String of the Dec. Ex) 10.203uatom"}}},"gamm.v1beta1.QuerySwapExactAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"gamm.v1beta1.QuerySwapExactAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"gamm.v1beta1.QueryTotalLiquidityResponse":{"type":"object","properties":{"liquidity":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryTotalPoolLiquidityResponse":{"type":"object","title":"Deprecated: please use the alternative in x/poolmanager","properties":{"liquidity":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"gamm.v1beta1.QueryTotalSharesResponse":{"type":"object","properties":{"total_shares":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"gamm.v2.QuerySpotPriceResponse":{"type":"object","title":"Deprecated: please use alternate in x/poolmanager","properties":{"spot_price":{"type":"string","title":"String of the Dec. Ex) 10.203uatom"}}},"google.protobuf.Any":{"type":"object","properties":{"@type":{"type":"string"}},"additionalProperties":{}},"google.rpc.Status":{"type":"object","properties":{"code":{"type":"integer","format":"int32"},"details":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}},"message":{"type":"string"}}},"maps.ActionPermission":{"description":"ActionPermission defines the permissions for performing an action.\n\nThis is simple and straightforward as the only thing we need to check is the permitted/forbidden times.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.ManagerTimeline":{"description":"ManagerTimeline defines the manager address at different timeline times.","type":"object","properties":{"manager":{"description":"The manager address for a specific timeline element.","type":"string"},"timelineTimes":{"description":"The timeline times when the manager address is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.Map":{"type":"object","properties":{"creator":{"type":"string"},"defaultValue":{"type":"string"},"inheritManagerTimelineFrom":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateCriteria":{"title":"config options that will not change at all","$ref":"#/definitions/maps.MapUpdateCriteria"},"valueOptions":{"$ref":"#/definitions/maps.ValueOptions"}}},"maps.MapMetadataTimeline":{"description":"MapMetadataTimeline defines the metadata for a collection at different timeline times.","type":"object","properties":{"metadata":{"description":"The collection metadata for a specific timeline element.","$ref":"#/definitions/maps.Metadata"},"timelineTimes":{"description":"The timeline times when the collection metadata is valid. Can not overlap with other timeline elements in same array.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.MapPermissions":{"type":"object","properties":{"canDeleteMap":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ActionPermission"}},"canUpdateManager":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.TimedUpdatePermission"}},"canUpdateMetadata":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.TimedUpdatePermission"}}}},"maps.MapUpdateCriteria":{"type":"object","properties":{"collectionId":{"type":"string","title":"ID slots are only updatable by token ID owner of this collection (\u003e1 balance at current time)"},"creatorOnly":{"type":"boolean","title":"Keys are address based and can only be updated by that respective address"},"firstComeFirstServe":{"description":"Claim slots. Can unclaim by setting to blank. Uses lastSetBy.","type":"boolean"},"managerOnly":{"type":"boolean","title":"All ID slots are only updatable by manager"}}},"maps.Metadata":{"description":"This message defines the metadata for the map.\nThe interpretation of this metadata should follow the map standard.","type":"object","properties":{"customData":{"description":"Custom data or additional information related to the map metadata.","type":"string"},"uri":{"description":"The URI (Uniform Resource Identifier) associated with the map metadata.","type":"string"}}},"maps.MsgCreateMap":{"type":"object","properties":{"creator":{"type":"string"},"defaultValue":{"type":"string"},"inheritManagerTimelineFrom":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateCriteria":{"title":"config options that will not change at all","$ref":"#/definitions/maps.MapUpdateCriteria"},"valueOptions":{"$ref":"#/definitions/maps.ValueOptions"}}},"maps.MsgCreateMapResponse":{"type":"object"},"maps.MsgDeleteMap":{"type":"object","properties":{"creator":{"type":"string"},"mapId":{"type":"string"}}},"maps.MsgDeleteMapResponse":{"type":"object"},"maps.MsgSetValue":{"type":"object","properties":{"creator":{"type":"string"},"key":{"type":"string"},"mapId":{"type":"string"},"options":{"$ref":"#/definitions/maps.SetOptions"},"value":{"type":"string"}}},"maps.MsgSetValueResponse":{"type":"object"},"maps.MsgUpdateMap":{"type":"object","properties":{"creator":{"type":"string"},"managerTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.ManagerTimeline"}},"mapId":{"type":"string"},"metadataTimeline":{"type":"array","items":{"type":"object","$ref":"#/definitions/maps.MapMetadataTimeline"}},"permissions":{"$ref":"#/definitions/maps.MapPermissions"},"updateManagerTimeline":{"type":"boolean"},"updateMetadataTimeline":{"type":"boolean"},"updatePermissions":{"type":"boolean"}}},"maps.MsgUpdateMapResponse":{"type":"object"},"maps.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/maps.Params"}}},"maps.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"maps.Params":{"description":"Params defines the parameters for the module.","type":"object"},"maps.QueryGetMapResponse":{"type":"object","properties":{"map":{"$ref":"#/definitions/maps.Map"}}},"maps.QueryGetMapValueResponse":{"type":"object","properties":{"value":{"$ref":"#/definitions/maps.ValueStore"}}},"maps.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/maps.Params"}}},"maps.SetOptions":{"type":"object","properties":{"useMostRecentCollectionId":{"type":"boolean"}}},"maps.TimedUpdatePermission":{"description":"TimedUpdatePermission defines the permissions for updating a timeline-based field.\n\nEx: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,\nyou could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.","type":"object","properties":{"permanentlyForbiddenTimes":{"description":"Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"permanentlyPermittedTimes":{"description":"Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}},"timelineTimes":{"description":"Specifies the times when the timeline-based field is a specific value.","type":"array","items":{"type":"object","$ref":"#/definitions/maps.UintRange"}}}},"maps.UintRange":{"description":"The UintRange is a range of IDs from some start to some end (inclusive).\n\nuintRanges are one of the core types used in the BitBadgesChain module.\nThey are used for everything from token IDs to time ranges to min/max balance amounts.\n\nSee the BitBadges documentation for more information.","type":"object","properties":{"end":{"description":"The ending value of the range (inclusive).","type":"string"},"start":{"description":"The starting value of the range (inclusive).","type":"string"}}},"maps.ValueOptions":{"type":"object","properties":{"expectAddress":{"type":"boolean"},"expectBoolean":{"type":"boolean"},"expectUint":{"type":"boolean"},"expectUri":{"type":"boolean"},"noDuplicates":{"type":"boolean"},"permanentOnceSet":{"type":"boolean"}}},"maps.ValueStore":{"type":"object","properties":{"key":{"type":"string"},"lastSetBy":{"type":"string"},"value":{"type":"string"}}},"poolmanager.v1beta1.AllPoolsResponse":{"type":"object","properties":{"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}}}},"poolmanager.v1beta1.AllRegisteredAlloyedPoolsResponse":{"type":"object","properties":{"contract_states":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.AlloyContractTakerFeeShareState"}}}},"poolmanager.v1beta1.AllTakerFeeShareAccumulatorsResponse":{"type":"object","properties":{"taker_fee_skim_accumulators":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeSkimAccumulator"}}}},"poolmanager.v1beta1.AllTakerFeeShareAgreementsResponse":{"type":"object","properties":{"taker_fee_share_agreements":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeShareAgreement"}}}},"poolmanager.v1beta1.AlloyContractTakerFeeShareState":{"description":"AlloyContractTakerFeeShareState contains the contract address of the alloyed\nasset pool, along with the adjusted taker fee share agreements for any asset\nwithin the alloyed asset pool that has a taker fee share agreement. If for\ninstance there are two denoms, and denomA makes up 50 percent and denomB\nmakes up 50 percent, and denom A has a taker fee share agreement with a skim\npercent of 10%, then the adjusted taker fee share agreement for denomA will\nbe 5%.","type":"object","properties":{"contract_address":{"description":"contract_address is the address of the alloyed asset pool contract.","type":"string"},"taker_fee_share_agreements":{"description":"taker_fee_share_agreements is the adjusted taker fee share agreements for\nany asset within the alloyed asset pool that has a taker fee share\nagreement.","type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeShareAgreement"}}}},"poolmanager.v1beta1.DenomPairTakerFee":{"type":"object","properties":{"denom0":{"description":"DEPRECATED: Now that we are using uni-directional trading pairs, we are\nusing tokenInDenom and tokenOutDenom instead of denom0 and denom1 to\nprevent confusion.","type":"string"},"denom1":{"type":"string"},"taker_fee":{"type":"string"},"tokenInDenom":{"type":"string"},"tokenOutDenom":{"type":"string"}}},"poolmanager.v1beta1.EstimateSwapExactAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"poolmanager.v1beta1.EstimateSwapExactAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"poolmanager.v1beta1.EstimateTradeBasedOnPriceImpactResponse":{"description":"EstimateTradeBasedOnPriceImpactResponse represents the response data\nfor an estimated trade based on price impact. If a trade fails to be\nestimated the response would be 0,0 for input_coin and output_coin and will\nnot error.","type":"object","properties":{"input_coin":{"description":"input_coin is the actual input amount that would be tradeable\nunder the specified price impact.","$ref":"#/definitions/cosmos.base.v1beta1.Coin"},"output_coin":{"description":"output_coin is the amount of tokens of the ToCoinDenom type\nthat will be received for the actual InputCoin trade.","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"poolmanager.v1beta1.ListPoolsByDenomResponse":{"type":"object","properties":{"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/google.protobuf.Any"}}}},"poolmanager.v1beta1.MsgSetDenomPairTakerFee":{"type":"object","title":"===================== MsgSetDenomPairTakerFee","properties":{"denom_pair_taker_fee":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.DenomPairTakerFee"}},"sender":{"type":"string"}}},"poolmanager.v1beta1.MsgSetDenomPairTakerFeeResponse":{"type":"object","properties":{"success":{"type":"boolean"}}},"poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenom":{"type":"object","title":"===================== MsgSetTakerFeeShareAgreementForDenom","properties":{"denom":{"description":"denom is the denom that the taker fee share agreement is being set for.\nEx. If this is set to \"nBTC\", then any trade route that includes \"nBTC\"\nwill have the skim_percent skimmed from the taker fees and sent to the\nskim_address.","type":"string"},"sender":{"type":"string"},"skim_address":{"description":"skim_address is the address belonging to the respective bridge provider\nthat the skimmed taker fees will be sent to at the end of each epoch.","type":"string"},"skim_percent":{"description":"skim_percent is the percentage of taker fees that will be skimmed for the\nbridge provider, in the event that the bridge provider's denom is included\nin the swap route.","type":"string"}}},"poolmanager.v1beta1.MsgSetTakerFeeShareAgreementForDenomResponse":{"type":"object"},"poolmanager.v1beta1.MsgSplitRouteSwapExactAmountIn":{"type":"object","title":"===================== MsgSplitRouteSwapExactAmountIn","properties":{"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountInSplitRoute"}},"sender":{"type":"string"},"token_in_denom":{"type":"string"},"token_out_min_amount":{"type":"string"}}},"poolmanager.v1beta1.MsgSplitRouteSwapExactAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOut":{"type":"object","title":"===================== MsgSplitRouteSwapExactAmountOut","properties":{"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountOutSplitRoute"}},"sender":{"type":"string"},"token_in_max_amount":{"type":"string"},"token_out_denom":{"type":"string"}}},"poolmanager.v1beta1.MsgSplitRouteSwapExactAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"poolmanager.v1beta1.MsgSwapExactAmountIn":{"type":"object","title":"===================== MsgSwapExactAmountIn","properties":{"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountInRoute"}},"sender":{"type":"string"},"token_in":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"},"token_out_min_amount":{"type":"string"}}},"poolmanager.v1beta1.MsgSwapExactAmountInResponse":{"type":"object","properties":{"token_out_amount":{"type":"string"}}},"poolmanager.v1beta1.MsgSwapExactAmountOut":{"type":"object","title":"===================== MsgSwapExactAmountOut","properties":{"routes":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountOutRoute"}},"sender":{"type":"string"},"token_in_max_amount":{"type":"string"},"token_out":{"$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}},"poolmanager.v1beta1.MsgSwapExactAmountOutResponse":{"type":"object","properties":{"token_in_amount":{"type":"string"}}},"poolmanager.v1beta1.NumPoolsResponse":{"type":"object","properties":{"num_pools":{"type":"string","format":"uint64"}}},"poolmanager.v1beta1.Params":{"type":"object","title":"Params holds parameters for the poolmanager module","properties":{"taker_fee_params":{"description":"taker_fee_params is the container of taker fee parameters.","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeParams"}}},"poolmanager.v1beta1.ParamsResponse":{"type":"object","properties":{"params":{"$ref":"#/definitions/poolmanager.v1beta1.Params"}}},"poolmanager.v1beta1.PoolResponse":{"type":"object","properties":{"pool":{"$ref":"#/definitions/google.protobuf.Any"}}},"poolmanager.v1beta1.RegisteredAlloyedPoolFromDenomResponse":{"type":"object","properties":{"contract_state":{"$ref":"#/definitions/poolmanager.v1beta1.AlloyContractTakerFeeShareState"}}},"poolmanager.v1beta1.RegisteredAlloyedPoolFromPoolIdResponse":{"type":"object","properties":{"contract_state":{"$ref":"#/definitions/poolmanager.v1beta1.AlloyContractTakerFeeShareState"}}},"poolmanager.v1beta1.SpotPriceResponse":{"description":"SpotPriceResponse defines the gRPC response structure for a SpotPrice\nquery.","type":"object","properties":{"spot_price":{"type":"string","title":"String of the Dec. Ex) 10.203uatom"}}},"poolmanager.v1beta1.SwapAmountInRoute":{"type":"object","properties":{"pool_id":{"type":"string","format":"uint64"},"token_out_denom":{"type":"string"}}},"poolmanager.v1beta1.SwapAmountInSplitRoute":{"type":"object","properties":{"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountInRoute"}},"token_in_amount":{"type":"string"}}},"poolmanager.v1beta1.SwapAmountOutRoute":{"type":"object","properties":{"pool_id":{"type":"string","format":"uint64"},"token_in_denom":{"type":"string"}}},"poolmanager.v1beta1.SwapAmountOutSplitRoute":{"type":"object","properties":{"pools":{"type":"array","items":{"type":"object","$ref":"#/definitions/poolmanager.v1beta1.SwapAmountOutRoute"}},"token_out_amount":{"type":"string"}}},"poolmanager.v1beta1.TakerFeeDistributionPercentage":{"description":"TakerFeeDistributionPercentage defines what percent of the taker fee category\ngets distributed to the available categories.","type":"object","properties":{"community_pool":{"type":"string"},"staking_rewards":{"type":"string"}}},"poolmanager.v1beta1.TakerFeeParams":{"description":"TakerFeeParams consolidates the taker fee parameters for the poolmanager.","type":"object","properties":{"admin_addresses":{"description":"admin_addresses is a list of addresses that are allowed to set and remove\ncustom taker fees for denom pairs. Governance also has the ability to set\nand remove custom taker fees for denom pairs, but with the normal\ngovernance delay.","type":"array","items":{"type":"string"}},"community_pool_denom_to_swap_non_whitelisted_assets_to":{"description":"community_pool_denom_to_swap_non_whitelisted_assets_to is the denom that\nnon-whitelisted taker fees will be swapped to before being sent to\nthe community pool.","type":"string"},"community_pool_denom_whitelist":{"description":"community_pool_denom_whitelist is a list of denoms that should be sent\ndirectly to the community pool instead of being swapped to the\n`community_pool_denom_to_swap_non_whitelisted_assets_to`.","type":"array","items":{"type":"string"}},"default_taker_fee":{"description":"default_taker_fee is the fee used when creating a new pool that doesn't\nfall under a custom pool taker fee or stableswap taker fee category.","type":"string"},"non_osmo_taker_fee_distribution":{"description":"non_osmo_taker_fee_distribution defines the distribution of taker fees\ngenerated in non-OSMO. As of this writing, it has two categories:\n- staking_rewards: the percent of the taker fee that gets swapped to OSMO\n  and then distributed to stakers.\n- community_pool: the percent of the taker fee that gets sent to the\n  community pool. Note: If the non-OSMO asset is an authorized_quote_denom,\n  that denom is sent directly to the community pool. Otherwise, it is\n  swapped to the community_pool_denom_to_swap_non_whitelisted_assets_to and\n  then sent to the community pool as that denom.","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeDistributionPercentage"},"osmo_taker_fee_distribution":{"description":"osmo_taker_fee_distribution defines the distribution of taker fees\ngenerated in OSMO. As of this writing, it has two categories:\n- staking_rewards: the percent of the taker fee that gets distributed to\n  stakers.\n- community_pool: the percent of the taker fee that gets sent to the\n  community pool.","$ref":"#/definitions/poolmanager.v1beta1.TakerFeeDistributionPercentage"},"reduced_fee_whitelist":{"description":"reduced_fee_whitelist is a list of addresses that are\nallowed to pay a reduce taker fee when performing a swap\n(i.e. swap without paying the taker fee).\nIt is intended to be used for integrators who meet qualifying factors\nthat are approved by governance.\nInitially, the taker fee is allowed to be bypassed completely. However\nIn the future, we will charge a reduced taker fee instead of no fee at all.","type":"array","items":{"type":"string"}}}},"poolmanager.v1beta1.TakerFeeShareAgreement":{"description":"TakerFeeShareAgreement represents the agreement between the Osmosis protocol\nand a specific denom to share a certain percent of taker fees generated in\nany route that contains said denom. For example, if the agreement specifies a\n10% skim_percent, this means 10% of the taker fees generated in a swap route\ncontaining the specified denom will be sent to the address specified\nin the skim_address field at the end of each epoch. These skim_percents are\nadditive, so if three taker fee agreements have skim percents of 10%, 20%,\nand 30%, the total skim percent for the route will be 60%.","type":"object","properties":{"denom":{"description":"denom is the denom that has the taker fee share agreement.","type":"string"},"skim_address":{"description":"skim_address is the address belonging to the respective denom\nthat the skimmed taker fees will be sent to at the end of each epoch.","type":"string"},"skim_percent":{"description":"skim_percent is the percentage of taker fees that will be skimmed for the\ndenom, in the event that the denom is included in the swap route.","type":"string"}}},"poolmanager.v1beta1.TakerFeeShareAgreementFromDenomResponse":{"type":"object","properties":{"taker_fee_share_agreement":{"$ref":"#/definitions/poolmanager.v1beta1.TakerFeeShareAgreement"}}},"poolmanager.v1beta1.TakerFeeShareDenomsToAccruedValueResponse":{"type":"object","properties":{"amount":{"type":"string"}}},"poolmanager.v1beta1.TakerFeeSkimAccumulator":{"description":"TakerFeeSkimAccumulator accumulates the total skimmed taker fees for each\ndenom that has a taker fee share agreement.","type":"object","properties":{"denom":{"description":"denom is the denom that has the taker fee share agreement.","type":"string"},"skimmed_taker_fees":{"description":"skimmed_taker_fees is the total skimmed taker fees for the denom.","type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"poolmanager.v1beta1.TotalLiquidityResponse":{"type":"object","properties":{"liquidity":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"poolmanager.v1beta1.TotalPoolLiquidityResponse":{"type":"object","properties":{"liquidity":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"poolmanager.v1beta1.TotalVolumeForPoolResponse":{"type":"object","properties":{"volume":{"type":"array","items":{"type":"object","$ref":"#/definitions/cosmos.base.v1beta1.Coin"}}}},"poolmanager.v1beta1.TradingPairTakerFeeResponse":{"type":"object","properties":{"taker_fee":{"type":"string"}}},"poolmanager.v2.SpotPriceResponse":{"description":"SpotPriceResponse defines the gRPC response structure for a SpotPrice\nquery.","type":"object","properties":{"spot_price":{"type":"string","title":"String of the BigDec. Ex) 10.203uatom"}}},"wasmx.GenesisState":{"description":"GenesisState defines the wasmx module's genesis state.","type":"object","properties":{"params":{"description":"params defines all the parameters of the module.","$ref":"#/definitions/wasmx.Params"},"port_id":{"type":"string"}}},"wasmx.MsgExecuteContractCompat":{"type":"object","title":"MsgExecuteContractCompat submits the given message data to a smart contract, compatible with EIP712","properties":{"contract":{"type":"string","title":"Contract is the address of the smart contract"},"funds":{"type":"string","title":"Funds coins that are transferred to the contract on execution"},"msg":{"type":"string","title":"Msg json encoded message to be passed to the contract"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"wasmx.MsgExecuteContractCompatResponse":{"description":"MsgExecuteContractCompatResponse returns execution result data.","type":"object","properties":{"data":{"type":"string","format":"byte","title":"Data contains bytes to returned from the contract"}}},"wasmx.MsgInstantiateContractCompat":{"type":"object","properties":{"codeId":{"type":"string","title":"Code ID obtained from store wasm code"},"funds":{"type":"string","title":"Funds coins that are transferred to the contract on instantiation"},"label":{"type":"string","title":"Label is a human-readable string for labelling the contract"},"sender":{"type":"string","title":"Sender is the that actor that signed the messages"}}},"wasmx.MsgInstantiateContractCompatResponse":{"description":"MsgInstantiateContractCompatResponse returns store result data.","type":"object","properties":{"address":{"type":"string"},"data":{"type":"string","format":"byte"}}},"wasmx.MsgUpdateParams":{"description":"MsgUpdateParams is the Msg/UpdateParams request type.","type":"object","properties":{"authority":{"description":"authority is the address that controls the module (defaults to x/gov unless overwritten).","type":"string"},"params":{"description":"params defines the module parameters to update.\n\nNOTE: All parameters must be supplied.","$ref":"#/definitions/wasmx.Params"}}},"wasmx.MsgUpdateParamsResponse":{"description":"MsgUpdateParamsResponse defines the response structure for executing a\nMsgUpdateParams message.","type":"object"},"wasmx.Params":{"description":"Params defines the parameters for the module.","type":"object","properties":{"is_execution_enabled":{"description":"Set the status to active to indicate that contracts can be executed in begin blocker.","type":"boolean"},"max_begin_block_total_gas":{"description":"Maximum aggregate total gas to be used for the contract executions in the BeginBlocker.","type":"string","format":"uint64"},"max_contract_gas_limit":{"description":"the maximum gas limit each individual contract can consume in the BeginBlocker.","type":"string","format":"uint64"},"min_gas_price":{"description":"min_gas_price defines the minimum gas price the contracts must pay to be executed in the BeginBlocker.","type":"string","format":"uint64"}}},"wasmx.QueryModuleStateResponse":{"description":"QueryModuleStateResponse is the response type for the Query/WasmxModuleState RPC method.","type":"object","properties":{"state":{"$ref":"#/definitions/wasmx.GenesisState"}}},"wasmx.QueryParamsResponse":{"description":"QueryParamsResponse is response type for the Query/Params RPC method.","type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","$ref":"#/definitions/wasmx.Params"}}},"wasmx.QueryWasmxParamsResponse":{"description":"QueryWasmxParamsRequest is the response type for the Query/WasmxParams RPC method.","type":"object","properties":{"params":{"$ref":"#/definitions/wasmx.Params"}}}},"tags":[{"name":"Query"},{"name":"Msg"}]}