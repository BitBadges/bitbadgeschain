// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package maps

import (
	_ "cosmossdk.io/api/amino"
	_ "cosmossdk.io/api/cosmos/msg/v1"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	reflect "reflect"
	sync "sync"
)

var (
	md_MsgUpdateParams           protoreflect.MessageDescriptor
	fd_MsgUpdateParams_authority protoreflect.FieldDescriptor
	fd_MsgUpdateParams_params    protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MsgUpdateParams = File_maps_tx_proto.Messages().ByName("MsgUpdateParams")
	fd_MsgUpdateParams_authority = md_MsgUpdateParams.Fields().ByName("authority")
	fd_MsgUpdateParams_params = md_MsgUpdateParams.Fields().ByName("params")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateParams)(nil)

type fastReflection_MsgUpdateParams MsgUpdateParams

func (x *MsgUpdateParams) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateParams)(x)
}

func (x *MsgUpdateParams) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateParams_messageType fastReflection_MsgUpdateParams_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateParams_messageType{}

type fastReflection_MsgUpdateParams_messageType struct{}

func (x fastReflection_MsgUpdateParams_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateParams)(nil)
}
func (x fastReflection_MsgUpdateParams_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateParams)
}
func (x fastReflection_MsgUpdateParams_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateParams
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateParams) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateParams
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateParams) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateParams_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateParams) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateParams)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateParams) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateParams)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateParams) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Authority != "" {
		value := protoreflect.ValueOfString(x.Authority)
		if !f(fd_MsgUpdateParams_authority, value) {
			return
		}
	}
	if x.Params != nil {
		value := protoreflect.ValueOfMessage(x.Params.ProtoReflect())
		if !f(fd_MsgUpdateParams_params, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateParams) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.MsgUpdateParams.authority":
		return x.Authority != ""
	case "maps.MsgUpdateParams.params":
		return x.Params != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParams does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParams) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.MsgUpdateParams.authority":
		x.Authority = ""
	case "maps.MsgUpdateParams.params":
		x.Params = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParams does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateParams) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.MsgUpdateParams.authority":
		value := x.Authority
		return protoreflect.ValueOfString(value)
	case "maps.MsgUpdateParams.params":
		value := x.Params
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParams does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParams) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.MsgUpdateParams.authority":
		x.Authority = value.Interface().(string)
	case "maps.MsgUpdateParams.params":
		x.Params = value.Message().Interface().(*Params)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParams does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParams) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MsgUpdateParams.params":
		if x.Params == nil {
			x.Params = new(Params)
		}
		return protoreflect.ValueOfMessage(x.Params.ProtoReflect())
	case "maps.MsgUpdateParams.authority":
		panic(fmt.Errorf("field authority of message maps.MsgUpdateParams is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParams does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateParams) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MsgUpdateParams.authority":
		return protoreflect.ValueOfString("")
	case "maps.MsgUpdateParams.params":
		m := new(Params)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParams does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateParams) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MsgUpdateParams", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateParams) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParams) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateParams) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateParams) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateParams)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Authority)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Params != nil {
			l = options.Size(x.Params)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateParams)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Params != nil {
			encoded, err := options.Marshal(x.Params)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Authority) > 0 {
			i -= len(x.Authority)
			copy(dAtA[i:], x.Authority)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Authority)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateParams)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Authority = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Params == nil {
					x.Params = &Params{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Params); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgUpdateParamsResponse protoreflect.MessageDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MsgUpdateParamsResponse = File_maps_tx_proto.Messages().ByName("MsgUpdateParamsResponse")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateParamsResponse)(nil)

type fastReflection_MsgUpdateParamsResponse MsgUpdateParamsResponse

func (x *MsgUpdateParamsResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateParamsResponse)(x)
}

func (x *MsgUpdateParamsResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateParamsResponse_messageType fastReflection_MsgUpdateParamsResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateParamsResponse_messageType{}

type fastReflection_MsgUpdateParamsResponse_messageType struct{}

func (x fastReflection_MsgUpdateParamsResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateParamsResponse)(nil)
}
func (x fastReflection_MsgUpdateParamsResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateParamsResponse)
}
func (x fastReflection_MsgUpdateParamsResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateParamsResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateParamsResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateParamsResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateParamsResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateParamsResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateParamsResponse) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateParamsResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateParamsResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateParamsResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateParamsResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateParamsResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParamsResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParamsResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParamsResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateParamsResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParamsResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParamsResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParamsResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParamsResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParamsResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateParamsResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateParamsResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateParamsResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MsgUpdateParamsResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateParamsResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParamsResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateParamsResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateParamsResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateParamsResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateParamsResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateParamsResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MapCustomMsgType              protoreflect.MessageDescriptor
	fd_MapCustomMsgType_setValueMsg  protoreflect.FieldDescriptor
	fd_MapCustomMsgType_createMapMsg protoreflect.FieldDescriptor
	fd_MapCustomMsgType_updateMapMsg protoreflect.FieldDescriptor
	fd_MapCustomMsgType_deleteMapMsg protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MapCustomMsgType = File_maps_tx_proto.Messages().ByName("MapCustomMsgType")
	fd_MapCustomMsgType_setValueMsg = md_MapCustomMsgType.Fields().ByName("setValueMsg")
	fd_MapCustomMsgType_createMapMsg = md_MapCustomMsgType.Fields().ByName("createMapMsg")
	fd_MapCustomMsgType_updateMapMsg = md_MapCustomMsgType.Fields().ByName("updateMapMsg")
	fd_MapCustomMsgType_deleteMapMsg = md_MapCustomMsgType.Fields().ByName("deleteMapMsg")
}

var _ protoreflect.Message = (*fastReflection_MapCustomMsgType)(nil)

type fastReflection_MapCustomMsgType MapCustomMsgType

func (x *MapCustomMsgType) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MapCustomMsgType)(x)
}

func (x *MapCustomMsgType) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MapCustomMsgType_messageType fastReflection_MapCustomMsgType_messageType
var _ protoreflect.MessageType = fastReflection_MapCustomMsgType_messageType{}

type fastReflection_MapCustomMsgType_messageType struct{}

func (x fastReflection_MapCustomMsgType_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MapCustomMsgType)(nil)
}
func (x fastReflection_MapCustomMsgType_messageType) New() protoreflect.Message {
	return new(fastReflection_MapCustomMsgType)
}
func (x fastReflection_MapCustomMsgType_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MapCustomMsgType
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MapCustomMsgType) Descriptor() protoreflect.MessageDescriptor {
	return md_MapCustomMsgType
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MapCustomMsgType) Type() protoreflect.MessageType {
	return _fastReflection_MapCustomMsgType_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MapCustomMsgType) New() protoreflect.Message {
	return new(fastReflection_MapCustomMsgType)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MapCustomMsgType) Interface() protoreflect.ProtoMessage {
	return (*MapCustomMsgType)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MapCustomMsgType) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.SetValueMsg != nil {
		value := protoreflect.ValueOfMessage(x.SetValueMsg.ProtoReflect())
		if !f(fd_MapCustomMsgType_setValueMsg, value) {
			return
		}
	}
	if x.CreateMapMsg != nil {
		value := protoreflect.ValueOfMessage(x.CreateMapMsg.ProtoReflect())
		if !f(fd_MapCustomMsgType_createMapMsg, value) {
			return
		}
	}
	if x.UpdateMapMsg != nil {
		value := protoreflect.ValueOfMessage(x.UpdateMapMsg.ProtoReflect())
		if !f(fd_MapCustomMsgType_updateMapMsg, value) {
			return
		}
	}
	if x.DeleteMapMsg != nil {
		value := protoreflect.ValueOfMessage(x.DeleteMapMsg.ProtoReflect())
		if !f(fd_MapCustomMsgType_deleteMapMsg, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MapCustomMsgType) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.MapCustomMsgType.setValueMsg":
		return x.SetValueMsg != nil
	case "maps.MapCustomMsgType.createMapMsg":
		return x.CreateMapMsg != nil
	case "maps.MapCustomMsgType.updateMapMsg":
		return x.UpdateMapMsg != nil
	case "maps.MapCustomMsgType.deleteMapMsg":
		return x.DeleteMapMsg != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapCustomMsgType"))
		}
		panic(fmt.Errorf("message maps.MapCustomMsgType does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapCustomMsgType) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.MapCustomMsgType.setValueMsg":
		x.SetValueMsg = nil
	case "maps.MapCustomMsgType.createMapMsg":
		x.CreateMapMsg = nil
	case "maps.MapCustomMsgType.updateMapMsg":
		x.UpdateMapMsg = nil
	case "maps.MapCustomMsgType.deleteMapMsg":
		x.DeleteMapMsg = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapCustomMsgType"))
		}
		panic(fmt.Errorf("message maps.MapCustomMsgType does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MapCustomMsgType) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.MapCustomMsgType.setValueMsg":
		value := x.SetValueMsg
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "maps.MapCustomMsgType.createMapMsg":
		value := x.CreateMapMsg
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "maps.MapCustomMsgType.updateMapMsg":
		value := x.UpdateMapMsg
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "maps.MapCustomMsgType.deleteMapMsg":
		value := x.DeleteMapMsg
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapCustomMsgType"))
		}
		panic(fmt.Errorf("message maps.MapCustomMsgType does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapCustomMsgType) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.MapCustomMsgType.setValueMsg":
		x.SetValueMsg = value.Message().Interface().(*MsgSetValue)
	case "maps.MapCustomMsgType.createMapMsg":
		x.CreateMapMsg = value.Message().Interface().(*MsgCreateMap)
	case "maps.MapCustomMsgType.updateMapMsg":
		x.UpdateMapMsg = value.Message().Interface().(*MsgUpdateMap)
	case "maps.MapCustomMsgType.deleteMapMsg":
		x.DeleteMapMsg = value.Message().Interface().(*MsgDeleteMap)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapCustomMsgType"))
		}
		panic(fmt.Errorf("message maps.MapCustomMsgType does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapCustomMsgType) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MapCustomMsgType.setValueMsg":
		if x.SetValueMsg == nil {
			x.SetValueMsg = new(MsgSetValue)
		}
		return protoreflect.ValueOfMessage(x.SetValueMsg.ProtoReflect())
	case "maps.MapCustomMsgType.createMapMsg":
		if x.CreateMapMsg == nil {
			x.CreateMapMsg = new(MsgCreateMap)
		}
		return protoreflect.ValueOfMessage(x.CreateMapMsg.ProtoReflect())
	case "maps.MapCustomMsgType.updateMapMsg":
		if x.UpdateMapMsg == nil {
			x.UpdateMapMsg = new(MsgUpdateMap)
		}
		return protoreflect.ValueOfMessage(x.UpdateMapMsg.ProtoReflect())
	case "maps.MapCustomMsgType.deleteMapMsg":
		if x.DeleteMapMsg == nil {
			x.DeleteMapMsg = new(MsgDeleteMap)
		}
		return protoreflect.ValueOfMessage(x.DeleteMapMsg.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapCustomMsgType"))
		}
		panic(fmt.Errorf("message maps.MapCustomMsgType does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MapCustomMsgType) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MapCustomMsgType.setValueMsg":
		m := new(MsgSetValue)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "maps.MapCustomMsgType.createMapMsg":
		m := new(MsgCreateMap)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "maps.MapCustomMsgType.updateMapMsg":
		m := new(MsgUpdateMap)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "maps.MapCustomMsgType.deleteMapMsg":
		m := new(MsgDeleteMap)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapCustomMsgType"))
		}
		panic(fmt.Errorf("message maps.MapCustomMsgType does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MapCustomMsgType) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MapCustomMsgType", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MapCustomMsgType) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapCustomMsgType) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MapCustomMsgType) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MapCustomMsgType) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MapCustomMsgType)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.SetValueMsg != nil {
			l = options.Size(x.SetValueMsg)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CreateMapMsg != nil {
			l = options.Size(x.CreateMapMsg)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.UpdateMapMsg != nil {
			l = options.Size(x.UpdateMapMsg)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.DeleteMapMsg != nil {
			l = options.Size(x.DeleteMapMsg)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MapCustomMsgType)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.DeleteMapMsg != nil {
			encoded, err := options.Marshal(x.DeleteMapMsg)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if x.UpdateMapMsg != nil {
			encoded, err := options.Marshal(x.UpdateMapMsg)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if x.CreateMapMsg != nil {
			encoded, err := options.Marshal(x.CreateMapMsg)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.SetValueMsg != nil {
			encoded, err := options.Marshal(x.SetValueMsg)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MapCustomMsgType)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MapCustomMsgType: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MapCustomMsgType: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SetValueMsg", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.SetValueMsg == nil {
					x.SetValueMsg = &MsgSetValue{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.SetValueMsg); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreateMapMsg", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CreateMapMsg == nil {
					x.CreateMapMsg = &MsgCreateMap{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CreateMapMsg); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UpdateMapMsg", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.UpdateMapMsg == nil {
					x.UpdateMapMsg = &MsgUpdateMap{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.UpdateMapMsg); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DeleteMapMsg", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.DeleteMapMsg == nil {
					x.DeleteMapMsg = &MsgDeleteMap{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.DeleteMapMsg); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ValueStore           protoreflect.MessageDescriptor
	fd_ValueStore_key       protoreflect.FieldDescriptor
	fd_ValueStore_value     protoreflect.FieldDescriptor
	fd_ValueStore_lastSetBy protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_ValueStore = File_maps_tx_proto.Messages().ByName("ValueStore")
	fd_ValueStore_key = md_ValueStore.Fields().ByName("key")
	fd_ValueStore_value = md_ValueStore.Fields().ByName("value")
	fd_ValueStore_lastSetBy = md_ValueStore.Fields().ByName("lastSetBy")
}

var _ protoreflect.Message = (*fastReflection_ValueStore)(nil)

type fastReflection_ValueStore ValueStore

func (x *ValueStore) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ValueStore)(x)
}

func (x *ValueStore) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ValueStore_messageType fastReflection_ValueStore_messageType
var _ protoreflect.MessageType = fastReflection_ValueStore_messageType{}

type fastReflection_ValueStore_messageType struct{}

func (x fastReflection_ValueStore_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ValueStore)(nil)
}
func (x fastReflection_ValueStore_messageType) New() protoreflect.Message {
	return new(fastReflection_ValueStore)
}
func (x fastReflection_ValueStore_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ValueStore
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ValueStore) Descriptor() protoreflect.MessageDescriptor {
	return md_ValueStore
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ValueStore) Type() protoreflect.MessageType {
	return _fastReflection_ValueStore_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ValueStore) New() protoreflect.Message {
	return new(fastReflection_ValueStore)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ValueStore) Interface() protoreflect.ProtoMessage {
	return (*ValueStore)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ValueStore) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Key != "" {
		value := protoreflect.ValueOfString(x.Key)
		if !f(fd_ValueStore_key, value) {
			return
		}
	}
	if x.Value != "" {
		value := protoreflect.ValueOfString(x.Value)
		if !f(fd_ValueStore_value, value) {
			return
		}
	}
	if x.LastSetBy != "" {
		value := protoreflect.ValueOfString(x.LastSetBy)
		if !f(fd_ValueStore_lastSetBy, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ValueStore) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.ValueStore.key":
		return x.Key != ""
	case "maps.ValueStore.value":
		return x.Value != ""
	case "maps.ValueStore.lastSetBy":
		return x.LastSetBy != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueStore"))
		}
		panic(fmt.Errorf("message maps.ValueStore does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ValueStore) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.ValueStore.key":
		x.Key = ""
	case "maps.ValueStore.value":
		x.Value = ""
	case "maps.ValueStore.lastSetBy":
		x.LastSetBy = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueStore"))
		}
		panic(fmt.Errorf("message maps.ValueStore does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ValueStore) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.ValueStore.key":
		value := x.Key
		return protoreflect.ValueOfString(value)
	case "maps.ValueStore.value":
		value := x.Value
		return protoreflect.ValueOfString(value)
	case "maps.ValueStore.lastSetBy":
		value := x.LastSetBy
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueStore"))
		}
		panic(fmt.Errorf("message maps.ValueStore does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ValueStore) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.ValueStore.key":
		x.Key = value.Interface().(string)
	case "maps.ValueStore.value":
		x.Value = value.Interface().(string)
	case "maps.ValueStore.lastSetBy":
		x.LastSetBy = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueStore"))
		}
		panic(fmt.Errorf("message maps.ValueStore does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ValueStore) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.ValueStore.key":
		panic(fmt.Errorf("field key of message maps.ValueStore is not mutable"))
	case "maps.ValueStore.value":
		panic(fmt.Errorf("field value of message maps.ValueStore is not mutable"))
	case "maps.ValueStore.lastSetBy":
		panic(fmt.Errorf("field lastSetBy of message maps.ValueStore is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueStore"))
		}
		panic(fmt.Errorf("message maps.ValueStore does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ValueStore) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.ValueStore.key":
		return protoreflect.ValueOfString("")
	case "maps.ValueStore.value":
		return protoreflect.ValueOfString("")
	case "maps.ValueStore.lastSetBy":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueStore"))
		}
		panic(fmt.Errorf("message maps.ValueStore does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ValueStore) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.ValueStore", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ValueStore) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ValueStore) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ValueStore) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ValueStore) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ValueStore)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Key)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Value)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LastSetBy)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ValueStore)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.LastSetBy) > 0 {
			i -= len(x.LastSetBy)
			copy(dAtA[i:], x.LastSetBy)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LastSetBy)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Value) > 0 {
			i -= len(x.Value)
			copy(dAtA[i:], x.Value)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Value)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Key) > 0 {
			i -= len(x.Key)
			copy(dAtA[i:], x.Key)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Key)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ValueStore)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ValueStore: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ValueStore: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Key = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Value = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastSetBy", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LastSetBy = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MapUpdateCriteria                     protoreflect.MessageDescriptor
	fd_MapUpdateCriteria_managerOnly         protoreflect.FieldDescriptor
	fd_MapUpdateCriteria_collectionId        protoreflect.FieldDescriptor
	fd_MapUpdateCriteria_creatorOnly         protoreflect.FieldDescriptor
	fd_MapUpdateCriteria_firstComeFirstServe protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MapUpdateCriteria = File_maps_tx_proto.Messages().ByName("MapUpdateCriteria")
	fd_MapUpdateCriteria_managerOnly = md_MapUpdateCriteria.Fields().ByName("managerOnly")
	fd_MapUpdateCriteria_collectionId = md_MapUpdateCriteria.Fields().ByName("collectionId")
	fd_MapUpdateCriteria_creatorOnly = md_MapUpdateCriteria.Fields().ByName("creatorOnly")
	fd_MapUpdateCriteria_firstComeFirstServe = md_MapUpdateCriteria.Fields().ByName("firstComeFirstServe")
}

var _ protoreflect.Message = (*fastReflection_MapUpdateCriteria)(nil)

type fastReflection_MapUpdateCriteria MapUpdateCriteria

func (x *MapUpdateCriteria) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MapUpdateCriteria)(x)
}

func (x *MapUpdateCriteria) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MapUpdateCriteria_messageType fastReflection_MapUpdateCriteria_messageType
var _ protoreflect.MessageType = fastReflection_MapUpdateCriteria_messageType{}

type fastReflection_MapUpdateCriteria_messageType struct{}

func (x fastReflection_MapUpdateCriteria_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MapUpdateCriteria)(nil)
}
func (x fastReflection_MapUpdateCriteria_messageType) New() protoreflect.Message {
	return new(fastReflection_MapUpdateCriteria)
}
func (x fastReflection_MapUpdateCriteria_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MapUpdateCriteria
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MapUpdateCriteria) Descriptor() protoreflect.MessageDescriptor {
	return md_MapUpdateCriteria
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MapUpdateCriteria) Type() protoreflect.MessageType {
	return _fastReflection_MapUpdateCriteria_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MapUpdateCriteria) New() protoreflect.Message {
	return new(fastReflection_MapUpdateCriteria)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MapUpdateCriteria) Interface() protoreflect.ProtoMessage {
	return (*MapUpdateCriteria)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MapUpdateCriteria) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.ManagerOnly != false {
		value := protoreflect.ValueOfBool(x.ManagerOnly)
		if !f(fd_MapUpdateCriteria_managerOnly, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MapUpdateCriteria_collectionId, value) {
			return
		}
	}
	if x.CreatorOnly != false {
		value := protoreflect.ValueOfBool(x.CreatorOnly)
		if !f(fd_MapUpdateCriteria_creatorOnly, value) {
			return
		}
	}
	if x.FirstComeFirstServe != false {
		value := protoreflect.ValueOfBool(x.FirstComeFirstServe)
		if !f(fd_MapUpdateCriteria_firstComeFirstServe, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MapUpdateCriteria) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.MapUpdateCriteria.managerOnly":
		return x.ManagerOnly != false
	case "maps.MapUpdateCriteria.collectionId":
		return x.CollectionId != ""
	case "maps.MapUpdateCriteria.creatorOnly":
		return x.CreatorOnly != false
	case "maps.MapUpdateCriteria.firstComeFirstServe":
		return x.FirstComeFirstServe != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapUpdateCriteria"))
		}
		panic(fmt.Errorf("message maps.MapUpdateCriteria does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapUpdateCriteria) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.MapUpdateCriteria.managerOnly":
		x.ManagerOnly = false
	case "maps.MapUpdateCriteria.collectionId":
		x.CollectionId = ""
	case "maps.MapUpdateCriteria.creatorOnly":
		x.CreatorOnly = false
	case "maps.MapUpdateCriteria.firstComeFirstServe":
		x.FirstComeFirstServe = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapUpdateCriteria"))
		}
		panic(fmt.Errorf("message maps.MapUpdateCriteria does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MapUpdateCriteria) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.MapUpdateCriteria.managerOnly":
		value := x.ManagerOnly
		return protoreflect.ValueOfBool(value)
	case "maps.MapUpdateCriteria.collectionId":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "maps.MapUpdateCriteria.creatorOnly":
		value := x.CreatorOnly
		return protoreflect.ValueOfBool(value)
	case "maps.MapUpdateCriteria.firstComeFirstServe":
		value := x.FirstComeFirstServe
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapUpdateCriteria"))
		}
		panic(fmt.Errorf("message maps.MapUpdateCriteria does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapUpdateCriteria) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.MapUpdateCriteria.managerOnly":
		x.ManagerOnly = value.Bool()
	case "maps.MapUpdateCriteria.collectionId":
		x.CollectionId = value.Interface().(string)
	case "maps.MapUpdateCriteria.creatorOnly":
		x.CreatorOnly = value.Bool()
	case "maps.MapUpdateCriteria.firstComeFirstServe":
		x.FirstComeFirstServe = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapUpdateCriteria"))
		}
		panic(fmt.Errorf("message maps.MapUpdateCriteria does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapUpdateCriteria) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MapUpdateCriteria.managerOnly":
		panic(fmt.Errorf("field managerOnly of message maps.MapUpdateCriteria is not mutable"))
	case "maps.MapUpdateCriteria.collectionId":
		panic(fmt.Errorf("field collectionId of message maps.MapUpdateCriteria is not mutable"))
	case "maps.MapUpdateCriteria.creatorOnly":
		panic(fmt.Errorf("field creatorOnly of message maps.MapUpdateCriteria is not mutable"))
	case "maps.MapUpdateCriteria.firstComeFirstServe":
		panic(fmt.Errorf("field firstComeFirstServe of message maps.MapUpdateCriteria is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapUpdateCriteria"))
		}
		panic(fmt.Errorf("message maps.MapUpdateCriteria does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MapUpdateCriteria) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MapUpdateCriteria.managerOnly":
		return protoreflect.ValueOfBool(false)
	case "maps.MapUpdateCriteria.collectionId":
		return protoreflect.ValueOfString("")
	case "maps.MapUpdateCriteria.creatorOnly":
		return protoreflect.ValueOfBool(false)
	case "maps.MapUpdateCriteria.firstComeFirstServe":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapUpdateCriteria"))
		}
		panic(fmt.Errorf("message maps.MapUpdateCriteria does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MapUpdateCriteria) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MapUpdateCriteria", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MapUpdateCriteria) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapUpdateCriteria) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MapUpdateCriteria) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MapUpdateCriteria) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MapUpdateCriteria)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.ManagerOnly {
			n += 2
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CreatorOnly {
			n += 2
		}
		if x.FirstComeFirstServe {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MapUpdateCriteria)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.FirstComeFirstServe {
			i--
			if x.FirstComeFirstServe {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x20
		}
		if x.CreatorOnly {
			i--
			if x.CreatorOnly {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x18
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x12
		}
		if x.ManagerOnly {
			i--
			if x.ManagerOnly {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MapUpdateCriteria)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MapUpdateCriteria: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MapUpdateCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ManagerOnly", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.ManagerOnly = bool(v != 0)
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CreatorOnly", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.CreatorOnly = bool(v != 0)
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FirstComeFirstServe", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.FirstComeFirstServe = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ValueOptions                  protoreflect.MessageDescriptor
	fd_ValueOptions_noDuplicates     protoreflect.FieldDescriptor
	fd_ValueOptions_permanentOnceSet protoreflect.FieldDescriptor
	fd_ValueOptions_expectUint       protoreflect.FieldDescriptor
	fd_ValueOptions_expectBoolean    protoreflect.FieldDescriptor
	fd_ValueOptions_expectAddress    protoreflect.FieldDescriptor
	fd_ValueOptions_expectUri        protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_ValueOptions = File_maps_tx_proto.Messages().ByName("ValueOptions")
	fd_ValueOptions_noDuplicates = md_ValueOptions.Fields().ByName("noDuplicates")
	fd_ValueOptions_permanentOnceSet = md_ValueOptions.Fields().ByName("permanentOnceSet")
	fd_ValueOptions_expectUint = md_ValueOptions.Fields().ByName("expectUint")
	fd_ValueOptions_expectBoolean = md_ValueOptions.Fields().ByName("expectBoolean")
	fd_ValueOptions_expectAddress = md_ValueOptions.Fields().ByName("expectAddress")
	fd_ValueOptions_expectUri = md_ValueOptions.Fields().ByName("expectUri")
}

var _ protoreflect.Message = (*fastReflection_ValueOptions)(nil)

type fastReflection_ValueOptions ValueOptions

func (x *ValueOptions) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ValueOptions)(x)
}

func (x *ValueOptions) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ValueOptions_messageType fastReflection_ValueOptions_messageType
var _ protoreflect.MessageType = fastReflection_ValueOptions_messageType{}

type fastReflection_ValueOptions_messageType struct{}

func (x fastReflection_ValueOptions_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ValueOptions)(nil)
}
func (x fastReflection_ValueOptions_messageType) New() protoreflect.Message {
	return new(fastReflection_ValueOptions)
}
func (x fastReflection_ValueOptions_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ValueOptions
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ValueOptions) Descriptor() protoreflect.MessageDescriptor {
	return md_ValueOptions
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ValueOptions) Type() protoreflect.MessageType {
	return _fastReflection_ValueOptions_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ValueOptions) New() protoreflect.Message {
	return new(fastReflection_ValueOptions)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ValueOptions) Interface() protoreflect.ProtoMessage {
	return (*ValueOptions)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ValueOptions) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.NoDuplicates != false {
		value := protoreflect.ValueOfBool(x.NoDuplicates)
		if !f(fd_ValueOptions_noDuplicates, value) {
			return
		}
	}
	if x.PermanentOnceSet != false {
		value := protoreflect.ValueOfBool(x.PermanentOnceSet)
		if !f(fd_ValueOptions_permanentOnceSet, value) {
			return
		}
	}
	if x.ExpectUint != false {
		value := protoreflect.ValueOfBool(x.ExpectUint)
		if !f(fd_ValueOptions_expectUint, value) {
			return
		}
	}
	if x.ExpectBoolean != false {
		value := protoreflect.ValueOfBool(x.ExpectBoolean)
		if !f(fd_ValueOptions_expectBoolean, value) {
			return
		}
	}
	if x.ExpectAddress != false {
		value := protoreflect.ValueOfBool(x.ExpectAddress)
		if !f(fd_ValueOptions_expectAddress, value) {
			return
		}
	}
	if x.ExpectUri != false {
		value := protoreflect.ValueOfBool(x.ExpectUri)
		if !f(fd_ValueOptions_expectUri, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ValueOptions) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.ValueOptions.noDuplicates":
		return x.NoDuplicates != false
	case "maps.ValueOptions.permanentOnceSet":
		return x.PermanentOnceSet != false
	case "maps.ValueOptions.expectUint":
		return x.ExpectUint != false
	case "maps.ValueOptions.expectBoolean":
		return x.ExpectBoolean != false
	case "maps.ValueOptions.expectAddress":
		return x.ExpectAddress != false
	case "maps.ValueOptions.expectUri":
		return x.ExpectUri != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueOptions"))
		}
		panic(fmt.Errorf("message maps.ValueOptions does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ValueOptions) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.ValueOptions.noDuplicates":
		x.NoDuplicates = false
	case "maps.ValueOptions.permanentOnceSet":
		x.PermanentOnceSet = false
	case "maps.ValueOptions.expectUint":
		x.ExpectUint = false
	case "maps.ValueOptions.expectBoolean":
		x.ExpectBoolean = false
	case "maps.ValueOptions.expectAddress":
		x.ExpectAddress = false
	case "maps.ValueOptions.expectUri":
		x.ExpectUri = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueOptions"))
		}
		panic(fmt.Errorf("message maps.ValueOptions does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ValueOptions) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.ValueOptions.noDuplicates":
		value := x.NoDuplicates
		return protoreflect.ValueOfBool(value)
	case "maps.ValueOptions.permanentOnceSet":
		value := x.PermanentOnceSet
		return protoreflect.ValueOfBool(value)
	case "maps.ValueOptions.expectUint":
		value := x.ExpectUint
		return protoreflect.ValueOfBool(value)
	case "maps.ValueOptions.expectBoolean":
		value := x.ExpectBoolean
		return protoreflect.ValueOfBool(value)
	case "maps.ValueOptions.expectAddress":
		value := x.ExpectAddress
		return protoreflect.ValueOfBool(value)
	case "maps.ValueOptions.expectUri":
		value := x.ExpectUri
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueOptions"))
		}
		panic(fmt.Errorf("message maps.ValueOptions does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ValueOptions) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.ValueOptions.noDuplicates":
		x.NoDuplicates = value.Bool()
	case "maps.ValueOptions.permanentOnceSet":
		x.PermanentOnceSet = value.Bool()
	case "maps.ValueOptions.expectUint":
		x.ExpectUint = value.Bool()
	case "maps.ValueOptions.expectBoolean":
		x.ExpectBoolean = value.Bool()
	case "maps.ValueOptions.expectAddress":
		x.ExpectAddress = value.Bool()
	case "maps.ValueOptions.expectUri":
		x.ExpectUri = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueOptions"))
		}
		panic(fmt.Errorf("message maps.ValueOptions does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ValueOptions) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.ValueOptions.noDuplicates":
		panic(fmt.Errorf("field noDuplicates of message maps.ValueOptions is not mutable"))
	case "maps.ValueOptions.permanentOnceSet":
		panic(fmt.Errorf("field permanentOnceSet of message maps.ValueOptions is not mutable"))
	case "maps.ValueOptions.expectUint":
		panic(fmt.Errorf("field expectUint of message maps.ValueOptions is not mutable"))
	case "maps.ValueOptions.expectBoolean":
		panic(fmt.Errorf("field expectBoolean of message maps.ValueOptions is not mutable"))
	case "maps.ValueOptions.expectAddress":
		panic(fmt.Errorf("field expectAddress of message maps.ValueOptions is not mutable"))
	case "maps.ValueOptions.expectUri":
		panic(fmt.Errorf("field expectUri of message maps.ValueOptions is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueOptions"))
		}
		panic(fmt.Errorf("message maps.ValueOptions does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ValueOptions) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.ValueOptions.noDuplicates":
		return protoreflect.ValueOfBool(false)
	case "maps.ValueOptions.permanentOnceSet":
		return protoreflect.ValueOfBool(false)
	case "maps.ValueOptions.expectUint":
		return protoreflect.ValueOfBool(false)
	case "maps.ValueOptions.expectBoolean":
		return protoreflect.ValueOfBool(false)
	case "maps.ValueOptions.expectAddress":
		return protoreflect.ValueOfBool(false)
	case "maps.ValueOptions.expectUri":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.ValueOptions"))
		}
		panic(fmt.Errorf("message maps.ValueOptions does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ValueOptions) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.ValueOptions", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ValueOptions) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ValueOptions) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ValueOptions) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ValueOptions) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ValueOptions)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.NoDuplicates {
			n += 2
		}
		if x.PermanentOnceSet {
			n += 2
		}
		if x.ExpectUint {
			n += 2
		}
		if x.ExpectBoolean {
			n += 2
		}
		if x.ExpectAddress {
			n += 2
		}
		if x.ExpectUri {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ValueOptions)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ExpectUri {
			i--
			if x.ExpectUri {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x30
		}
		if x.ExpectAddress {
			i--
			if x.ExpectAddress {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if x.ExpectBoolean {
			i--
			if x.ExpectBoolean {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x20
		}
		if x.ExpectUint {
			i--
			if x.ExpectUint {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x18
		}
		if x.PermanentOnceSet {
			i--
			if x.PermanentOnceSet {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
		}
		if x.NoDuplicates {
			i--
			if x.NoDuplicates {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ValueOptions)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ValueOptions: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ValueOptions: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NoDuplicates", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.NoDuplicates = bool(v != 0)
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PermanentOnceSet", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.PermanentOnceSet = bool(v != 0)
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExpectUint", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.ExpectUint = bool(v != 0)
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExpectBoolean", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.ExpectBoolean = bool(v != 0)
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExpectAddress", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.ExpectAddress = bool(v != 0)
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExpectUri", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.ExpectUri = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_MapPermissions_1_list)(nil)

type _MapPermissions_1_list struct {
	list *[]*TimedUpdatePermission
}

func (x *_MapPermissions_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MapPermissions_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_MapPermissions_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*TimedUpdatePermission)
	(*x.list)[i] = concreteValue
}

func (x *_MapPermissions_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*TimedUpdatePermission)
	*x.list = append(*x.list, concreteValue)
}

func (x *_MapPermissions_1_list) AppendMutable() protoreflect.Value {
	v := new(TimedUpdatePermission)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MapPermissions_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_MapPermissions_1_list) NewElement() protoreflect.Value {
	v := new(TimedUpdatePermission)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MapPermissions_1_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_MapPermissions_2_list)(nil)

type _MapPermissions_2_list struct {
	list *[]*TimedUpdatePermission
}

func (x *_MapPermissions_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MapPermissions_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_MapPermissions_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*TimedUpdatePermission)
	(*x.list)[i] = concreteValue
}

func (x *_MapPermissions_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*TimedUpdatePermission)
	*x.list = append(*x.list, concreteValue)
}

func (x *_MapPermissions_2_list) AppendMutable() protoreflect.Value {
	v := new(TimedUpdatePermission)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MapPermissions_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_MapPermissions_2_list) NewElement() protoreflect.Value {
	v := new(TimedUpdatePermission)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MapPermissions_2_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_MapPermissions_3_list)(nil)

type _MapPermissions_3_list struct {
	list *[]*ActionPermission
}

func (x *_MapPermissions_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MapPermissions_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_MapPermissions_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ActionPermission)
	(*x.list)[i] = concreteValue
}

func (x *_MapPermissions_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ActionPermission)
	*x.list = append(*x.list, concreteValue)
}

func (x *_MapPermissions_3_list) AppendMutable() protoreflect.Value {
	v := new(ActionPermission)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MapPermissions_3_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_MapPermissions_3_list) NewElement() protoreflect.Value {
	v := new(ActionPermission)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MapPermissions_3_list) IsValid() bool {
	return x.list != nil
}

var (
	md_MapPermissions                   protoreflect.MessageDescriptor
	fd_MapPermissions_canUpdateMetadata protoreflect.FieldDescriptor
	fd_MapPermissions_canUpdateManager  protoreflect.FieldDescriptor
	fd_MapPermissions_canDeleteMap      protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MapPermissions = File_maps_tx_proto.Messages().ByName("MapPermissions")
	fd_MapPermissions_canUpdateMetadata = md_MapPermissions.Fields().ByName("canUpdateMetadata")
	fd_MapPermissions_canUpdateManager = md_MapPermissions.Fields().ByName("canUpdateManager")
	fd_MapPermissions_canDeleteMap = md_MapPermissions.Fields().ByName("canDeleteMap")
}

var _ protoreflect.Message = (*fastReflection_MapPermissions)(nil)

type fastReflection_MapPermissions MapPermissions

func (x *MapPermissions) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MapPermissions)(x)
}

func (x *MapPermissions) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MapPermissions_messageType fastReflection_MapPermissions_messageType
var _ protoreflect.MessageType = fastReflection_MapPermissions_messageType{}

type fastReflection_MapPermissions_messageType struct{}

func (x fastReflection_MapPermissions_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MapPermissions)(nil)
}
func (x fastReflection_MapPermissions_messageType) New() protoreflect.Message {
	return new(fastReflection_MapPermissions)
}
func (x fastReflection_MapPermissions_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MapPermissions
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MapPermissions) Descriptor() protoreflect.MessageDescriptor {
	return md_MapPermissions
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MapPermissions) Type() protoreflect.MessageType {
	return _fastReflection_MapPermissions_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MapPermissions) New() protoreflect.Message {
	return new(fastReflection_MapPermissions)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MapPermissions) Interface() protoreflect.ProtoMessage {
	return (*MapPermissions)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MapPermissions) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.CanUpdateMetadata) != 0 {
		value := protoreflect.ValueOfList(&_MapPermissions_1_list{list: &x.CanUpdateMetadata})
		if !f(fd_MapPermissions_canUpdateMetadata, value) {
			return
		}
	}
	if len(x.CanUpdateManager) != 0 {
		value := protoreflect.ValueOfList(&_MapPermissions_2_list{list: &x.CanUpdateManager})
		if !f(fd_MapPermissions_canUpdateManager, value) {
			return
		}
	}
	if len(x.CanDeleteMap) != 0 {
		value := protoreflect.ValueOfList(&_MapPermissions_3_list{list: &x.CanDeleteMap})
		if !f(fd_MapPermissions_canDeleteMap, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MapPermissions) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.MapPermissions.canUpdateMetadata":
		return len(x.CanUpdateMetadata) != 0
	case "maps.MapPermissions.canUpdateManager":
		return len(x.CanUpdateManager) != 0
	case "maps.MapPermissions.canDeleteMap":
		return len(x.CanDeleteMap) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapPermissions"))
		}
		panic(fmt.Errorf("message maps.MapPermissions does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapPermissions) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.MapPermissions.canUpdateMetadata":
		x.CanUpdateMetadata = nil
	case "maps.MapPermissions.canUpdateManager":
		x.CanUpdateManager = nil
	case "maps.MapPermissions.canDeleteMap":
		x.CanDeleteMap = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapPermissions"))
		}
		panic(fmt.Errorf("message maps.MapPermissions does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MapPermissions) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.MapPermissions.canUpdateMetadata":
		if len(x.CanUpdateMetadata) == 0 {
			return protoreflect.ValueOfList(&_MapPermissions_1_list{})
		}
		listValue := &_MapPermissions_1_list{list: &x.CanUpdateMetadata}
		return protoreflect.ValueOfList(listValue)
	case "maps.MapPermissions.canUpdateManager":
		if len(x.CanUpdateManager) == 0 {
			return protoreflect.ValueOfList(&_MapPermissions_2_list{})
		}
		listValue := &_MapPermissions_2_list{list: &x.CanUpdateManager}
		return protoreflect.ValueOfList(listValue)
	case "maps.MapPermissions.canDeleteMap":
		if len(x.CanDeleteMap) == 0 {
			return protoreflect.ValueOfList(&_MapPermissions_3_list{})
		}
		listValue := &_MapPermissions_3_list{list: &x.CanDeleteMap}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapPermissions"))
		}
		panic(fmt.Errorf("message maps.MapPermissions does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapPermissions) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.MapPermissions.canUpdateMetadata":
		lv := value.List()
		clv := lv.(*_MapPermissions_1_list)
		x.CanUpdateMetadata = *clv.list
	case "maps.MapPermissions.canUpdateManager":
		lv := value.List()
		clv := lv.(*_MapPermissions_2_list)
		x.CanUpdateManager = *clv.list
	case "maps.MapPermissions.canDeleteMap":
		lv := value.List()
		clv := lv.(*_MapPermissions_3_list)
		x.CanDeleteMap = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapPermissions"))
		}
		panic(fmt.Errorf("message maps.MapPermissions does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapPermissions) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MapPermissions.canUpdateMetadata":
		if x.CanUpdateMetadata == nil {
			x.CanUpdateMetadata = []*TimedUpdatePermission{}
		}
		value := &_MapPermissions_1_list{list: &x.CanUpdateMetadata}
		return protoreflect.ValueOfList(value)
	case "maps.MapPermissions.canUpdateManager":
		if x.CanUpdateManager == nil {
			x.CanUpdateManager = []*TimedUpdatePermission{}
		}
		value := &_MapPermissions_2_list{list: &x.CanUpdateManager}
		return protoreflect.ValueOfList(value)
	case "maps.MapPermissions.canDeleteMap":
		if x.CanDeleteMap == nil {
			x.CanDeleteMap = []*ActionPermission{}
		}
		value := &_MapPermissions_3_list{list: &x.CanDeleteMap}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapPermissions"))
		}
		panic(fmt.Errorf("message maps.MapPermissions does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MapPermissions) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MapPermissions.canUpdateMetadata":
		list := []*TimedUpdatePermission{}
		return protoreflect.ValueOfList(&_MapPermissions_1_list{list: &list})
	case "maps.MapPermissions.canUpdateManager":
		list := []*TimedUpdatePermission{}
		return protoreflect.ValueOfList(&_MapPermissions_2_list{list: &list})
	case "maps.MapPermissions.canDeleteMap":
		list := []*ActionPermission{}
		return protoreflect.ValueOfList(&_MapPermissions_3_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MapPermissions"))
		}
		panic(fmt.Errorf("message maps.MapPermissions does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MapPermissions) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MapPermissions", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MapPermissions) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MapPermissions) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MapPermissions) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MapPermissions) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MapPermissions)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.CanUpdateMetadata) > 0 {
			for _, e := range x.CanUpdateMetadata {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.CanUpdateManager) > 0 {
			for _, e := range x.CanUpdateManager {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.CanDeleteMap) > 0 {
			for _, e := range x.CanDeleteMap {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MapPermissions)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CanDeleteMap) > 0 {
			for iNdEx := len(x.CanDeleteMap) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.CanDeleteMap[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x1a
			}
		}
		if len(x.CanUpdateManager) > 0 {
			for iNdEx := len(x.CanUpdateManager) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.CanUpdateManager[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.CanUpdateMetadata) > 0 {
			for iNdEx := len(x.CanUpdateMetadata) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.CanUpdateMetadata[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MapPermissions)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MapPermissions: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MapPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CanUpdateMetadata", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CanUpdateMetadata = append(x.CanUpdateMetadata, &TimedUpdatePermission{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CanUpdateMetadata[len(x.CanUpdateMetadata)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CanUpdateManager", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CanUpdateManager = append(x.CanUpdateManager, &TimedUpdatePermission{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CanUpdateManager[len(x.CanUpdateManager)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CanDeleteMap", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CanDeleteMap = append(x.CanDeleteMap, &ActionPermission{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CanDeleteMap[len(x.CanDeleteMap)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_Map_4_list)(nil)

type _Map_4_list struct {
	list *[]*ManagerTimeline
}

func (x *_Map_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Map_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_Map_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ManagerTimeline)
	(*x.list)[i] = concreteValue
}

func (x *_Map_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ManagerTimeline)
	*x.list = append(*x.list, concreteValue)
}

func (x *_Map_4_list) AppendMutable() protoreflect.Value {
	v := new(ManagerTimeline)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Map_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_Map_4_list) NewElement() protoreflect.Value {
	v := new(ManagerTimeline)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Map_4_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_Map_10_list)(nil)

type _Map_10_list struct {
	list *[]*MapMetadataTimeline
}

func (x *_Map_10_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Map_10_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_Map_10_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MapMetadataTimeline)
	(*x.list)[i] = concreteValue
}

func (x *_Map_10_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MapMetadataTimeline)
	*x.list = append(*x.list, concreteValue)
}

func (x *_Map_10_list) AppendMutable() protoreflect.Value {
	v := new(MapMetadataTimeline)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Map_10_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_Map_10_list) NewElement() protoreflect.Value {
	v := new(MapMetadataTimeline)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Map_10_list) IsValid() bool {
	return x.list != nil
}

var (
	md_Map                            protoreflect.MessageDescriptor
	fd_Map_creator                    protoreflect.FieldDescriptor
	fd_Map_mapId                      protoreflect.FieldDescriptor
	fd_Map_inheritManagerTimelineFrom protoreflect.FieldDescriptor
	fd_Map_managerTimeline            protoreflect.FieldDescriptor
	fd_Map_updateCriteria             protoreflect.FieldDescriptor
	fd_Map_valueOptions               protoreflect.FieldDescriptor
	fd_Map_defaultValue               protoreflect.FieldDescriptor
	fd_Map_metadataTimeline           protoreflect.FieldDescriptor
	fd_Map_permissions                protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_Map = File_maps_tx_proto.Messages().ByName("Map")
	fd_Map_creator = md_Map.Fields().ByName("creator")
	fd_Map_mapId = md_Map.Fields().ByName("mapId")
	fd_Map_inheritManagerTimelineFrom = md_Map.Fields().ByName("inheritManagerTimelineFrom")
	fd_Map_managerTimeline = md_Map.Fields().ByName("managerTimeline")
	fd_Map_updateCriteria = md_Map.Fields().ByName("updateCriteria")
	fd_Map_valueOptions = md_Map.Fields().ByName("valueOptions")
	fd_Map_defaultValue = md_Map.Fields().ByName("defaultValue")
	fd_Map_metadataTimeline = md_Map.Fields().ByName("metadataTimeline")
	fd_Map_permissions = md_Map.Fields().ByName("permissions")
}

var _ protoreflect.Message = (*fastReflection_Map)(nil)

type fastReflection_Map Map

func (x *Map) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Map)(x)
}

func (x *Map) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Map_messageType fastReflection_Map_messageType
var _ protoreflect.MessageType = fastReflection_Map_messageType{}

type fastReflection_Map_messageType struct{}

func (x fastReflection_Map_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Map)(nil)
}
func (x fastReflection_Map_messageType) New() protoreflect.Message {
	return new(fastReflection_Map)
}
func (x fastReflection_Map_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Map
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Map) Descriptor() protoreflect.MessageDescriptor {
	return md_Map
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Map) Type() protoreflect.MessageType {
	return _fastReflection_Map_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Map) New() protoreflect.Message {
	return new(fastReflection_Map)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Map) Interface() protoreflect.ProtoMessage {
	return (*Map)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Map) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_Map_creator, value) {
			return
		}
	}
	if x.MapId != "" {
		value := protoreflect.ValueOfString(x.MapId)
		if !f(fd_Map_mapId, value) {
			return
		}
	}
	if x.InheritManagerTimelineFrom != "" {
		value := protoreflect.ValueOfString(x.InheritManagerTimelineFrom)
		if !f(fd_Map_inheritManagerTimelineFrom, value) {
			return
		}
	}
	if len(x.ManagerTimeline) != 0 {
		value := protoreflect.ValueOfList(&_Map_4_list{list: &x.ManagerTimeline})
		if !f(fd_Map_managerTimeline, value) {
			return
		}
	}
	if x.UpdateCriteria != nil {
		value := protoreflect.ValueOfMessage(x.UpdateCriteria.ProtoReflect())
		if !f(fd_Map_updateCriteria, value) {
			return
		}
	}
	if x.ValueOptions != nil {
		value := protoreflect.ValueOfMessage(x.ValueOptions.ProtoReflect())
		if !f(fd_Map_valueOptions, value) {
			return
		}
	}
	if x.DefaultValue != "" {
		value := protoreflect.ValueOfString(x.DefaultValue)
		if !f(fd_Map_defaultValue, value) {
			return
		}
	}
	if len(x.MetadataTimeline) != 0 {
		value := protoreflect.ValueOfList(&_Map_10_list{list: &x.MetadataTimeline})
		if !f(fd_Map_metadataTimeline, value) {
			return
		}
	}
	if x.Permissions != nil {
		value := protoreflect.ValueOfMessage(x.Permissions.ProtoReflect())
		if !f(fd_Map_permissions, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Map) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.Map.creator":
		return x.Creator != ""
	case "maps.Map.mapId":
		return x.MapId != ""
	case "maps.Map.inheritManagerTimelineFrom":
		return x.InheritManagerTimelineFrom != ""
	case "maps.Map.managerTimeline":
		return len(x.ManagerTimeline) != 0
	case "maps.Map.updateCriteria":
		return x.UpdateCriteria != nil
	case "maps.Map.valueOptions":
		return x.ValueOptions != nil
	case "maps.Map.defaultValue":
		return x.DefaultValue != ""
	case "maps.Map.metadataTimeline":
		return len(x.MetadataTimeline) != 0
	case "maps.Map.permissions":
		return x.Permissions != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.Map"))
		}
		panic(fmt.Errorf("message maps.Map does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Map) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.Map.creator":
		x.Creator = ""
	case "maps.Map.mapId":
		x.MapId = ""
	case "maps.Map.inheritManagerTimelineFrom":
		x.InheritManagerTimelineFrom = ""
	case "maps.Map.managerTimeline":
		x.ManagerTimeline = nil
	case "maps.Map.updateCriteria":
		x.UpdateCriteria = nil
	case "maps.Map.valueOptions":
		x.ValueOptions = nil
	case "maps.Map.defaultValue":
		x.DefaultValue = ""
	case "maps.Map.metadataTimeline":
		x.MetadataTimeline = nil
	case "maps.Map.permissions":
		x.Permissions = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.Map"))
		}
		panic(fmt.Errorf("message maps.Map does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Map) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.Map.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "maps.Map.mapId":
		value := x.MapId
		return protoreflect.ValueOfString(value)
	case "maps.Map.inheritManagerTimelineFrom":
		value := x.InheritManagerTimelineFrom
		return protoreflect.ValueOfString(value)
	case "maps.Map.managerTimeline":
		if len(x.ManagerTimeline) == 0 {
			return protoreflect.ValueOfList(&_Map_4_list{})
		}
		listValue := &_Map_4_list{list: &x.ManagerTimeline}
		return protoreflect.ValueOfList(listValue)
	case "maps.Map.updateCriteria":
		value := x.UpdateCriteria
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "maps.Map.valueOptions":
		value := x.ValueOptions
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "maps.Map.defaultValue":
		value := x.DefaultValue
		return protoreflect.ValueOfString(value)
	case "maps.Map.metadataTimeline":
		if len(x.MetadataTimeline) == 0 {
			return protoreflect.ValueOfList(&_Map_10_list{})
		}
		listValue := &_Map_10_list{list: &x.MetadataTimeline}
		return protoreflect.ValueOfList(listValue)
	case "maps.Map.permissions":
		value := x.Permissions
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.Map"))
		}
		panic(fmt.Errorf("message maps.Map does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Map) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.Map.creator":
		x.Creator = value.Interface().(string)
	case "maps.Map.mapId":
		x.MapId = value.Interface().(string)
	case "maps.Map.inheritManagerTimelineFrom":
		x.InheritManagerTimelineFrom = value.Interface().(string)
	case "maps.Map.managerTimeline":
		lv := value.List()
		clv := lv.(*_Map_4_list)
		x.ManagerTimeline = *clv.list
	case "maps.Map.updateCriteria":
		x.UpdateCriteria = value.Message().Interface().(*MapUpdateCriteria)
	case "maps.Map.valueOptions":
		x.ValueOptions = value.Message().Interface().(*ValueOptions)
	case "maps.Map.defaultValue":
		x.DefaultValue = value.Interface().(string)
	case "maps.Map.metadataTimeline":
		lv := value.List()
		clv := lv.(*_Map_10_list)
		x.MetadataTimeline = *clv.list
	case "maps.Map.permissions":
		x.Permissions = value.Message().Interface().(*MapPermissions)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.Map"))
		}
		panic(fmt.Errorf("message maps.Map does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Map) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.Map.managerTimeline":
		if x.ManagerTimeline == nil {
			x.ManagerTimeline = []*ManagerTimeline{}
		}
		value := &_Map_4_list{list: &x.ManagerTimeline}
		return protoreflect.ValueOfList(value)
	case "maps.Map.updateCriteria":
		if x.UpdateCriteria == nil {
			x.UpdateCriteria = new(MapUpdateCriteria)
		}
		return protoreflect.ValueOfMessage(x.UpdateCriteria.ProtoReflect())
	case "maps.Map.valueOptions":
		if x.ValueOptions == nil {
			x.ValueOptions = new(ValueOptions)
		}
		return protoreflect.ValueOfMessage(x.ValueOptions.ProtoReflect())
	case "maps.Map.metadataTimeline":
		if x.MetadataTimeline == nil {
			x.MetadataTimeline = []*MapMetadataTimeline{}
		}
		value := &_Map_10_list{list: &x.MetadataTimeline}
		return protoreflect.ValueOfList(value)
	case "maps.Map.permissions":
		if x.Permissions == nil {
			x.Permissions = new(MapPermissions)
		}
		return protoreflect.ValueOfMessage(x.Permissions.ProtoReflect())
	case "maps.Map.creator":
		panic(fmt.Errorf("field creator of message maps.Map is not mutable"))
	case "maps.Map.mapId":
		panic(fmt.Errorf("field mapId of message maps.Map is not mutable"))
	case "maps.Map.inheritManagerTimelineFrom":
		panic(fmt.Errorf("field inheritManagerTimelineFrom of message maps.Map is not mutable"))
	case "maps.Map.defaultValue":
		panic(fmt.Errorf("field defaultValue of message maps.Map is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.Map"))
		}
		panic(fmt.Errorf("message maps.Map does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Map) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.Map.creator":
		return protoreflect.ValueOfString("")
	case "maps.Map.mapId":
		return protoreflect.ValueOfString("")
	case "maps.Map.inheritManagerTimelineFrom":
		return protoreflect.ValueOfString("")
	case "maps.Map.managerTimeline":
		list := []*ManagerTimeline{}
		return protoreflect.ValueOfList(&_Map_4_list{list: &list})
	case "maps.Map.updateCriteria":
		m := new(MapUpdateCriteria)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "maps.Map.valueOptions":
		m := new(ValueOptions)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "maps.Map.defaultValue":
		return protoreflect.ValueOfString("")
	case "maps.Map.metadataTimeline":
		list := []*MapMetadataTimeline{}
		return protoreflect.ValueOfList(&_Map_10_list{list: &list})
	case "maps.Map.permissions":
		m := new(MapPermissions)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.Map"))
		}
		panic(fmt.Errorf("message maps.Map does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Map) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.Map", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Map) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Map) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Map) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Map) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Map)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MapId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.InheritManagerTimelineFrom)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.ManagerTimeline) > 0 {
			for _, e := range x.ManagerTimeline {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.UpdateCriteria != nil {
			l = options.Size(x.UpdateCriteria)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ValueOptions != nil {
			l = options.Size(x.ValueOptions)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.DefaultValue)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.MetadataTimeline) > 0 {
			for _, e := range x.MetadataTimeline {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.Permissions != nil {
			l = options.Size(x.Permissions)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Map)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Permissions != nil {
			encoded, err := options.Marshal(x.Permissions)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x5a
		}
		if len(x.MetadataTimeline) > 0 {
			for iNdEx := len(x.MetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.MetadataTimeline[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x52
			}
		}
		if len(x.DefaultValue) > 0 {
			i -= len(x.DefaultValue)
			copy(dAtA[i:], x.DefaultValue)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DefaultValue)))
			i--
			dAtA[i] = 0x3a
		}
		if x.ValueOptions != nil {
			encoded, err := options.Marshal(x.ValueOptions)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		}
		if x.UpdateCriteria != nil {
			encoded, err := options.Marshal(x.UpdateCriteria)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.ManagerTimeline) > 0 {
			for iNdEx := len(x.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.ManagerTimeline[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if len(x.InheritManagerTimelineFrom) > 0 {
			i -= len(x.InheritManagerTimelineFrom)
			copy(dAtA[i:], x.InheritManagerTimelineFrom)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.InheritManagerTimelineFrom)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.MapId) > 0 {
			i -= len(x.MapId)
			copy(dAtA[i:], x.MapId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MapId)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Map)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Map: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Map: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MapId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InheritManagerTimelineFrom", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.InheritManagerTimelineFrom = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ManagerTimeline = append(x.ManagerTimeline, &ManagerTimeline{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ManagerTimeline[len(x.ManagerTimeline)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UpdateCriteria", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.UpdateCriteria == nil {
					x.UpdateCriteria = &MapUpdateCriteria{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.UpdateCriteria); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ValueOptions", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ValueOptions == nil {
					x.ValueOptions = &ValueOptions{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ValueOptions); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DefaultValue = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MetadataTimeline", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MetadataTimeline = append(x.MetadataTimeline, &MapMetadataTimeline{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MetadataTimeline[len(x.MetadataTimeline)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Permissions == nil {
					x.Permissions = &MapPermissions{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Permissions); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_MsgCreateMap_4_list)(nil)

type _MsgCreateMap_4_list struct {
	list *[]*ManagerTimeline
}

func (x *_MsgCreateMap_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MsgCreateMap_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_MsgCreateMap_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ManagerTimeline)
	(*x.list)[i] = concreteValue
}

func (x *_MsgCreateMap_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ManagerTimeline)
	*x.list = append(*x.list, concreteValue)
}

func (x *_MsgCreateMap_4_list) AppendMutable() protoreflect.Value {
	v := new(ManagerTimeline)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MsgCreateMap_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_MsgCreateMap_4_list) NewElement() protoreflect.Value {
	v := new(ManagerTimeline)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MsgCreateMap_4_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_MsgCreateMap_9_list)(nil)

type _MsgCreateMap_9_list struct {
	list *[]*MapMetadataTimeline
}

func (x *_MsgCreateMap_9_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MsgCreateMap_9_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_MsgCreateMap_9_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MapMetadataTimeline)
	(*x.list)[i] = concreteValue
}

func (x *_MsgCreateMap_9_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MapMetadataTimeline)
	*x.list = append(*x.list, concreteValue)
}

func (x *_MsgCreateMap_9_list) AppendMutable() protoreflect.Value {
	v := new(MapMetadataTimeline)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MsgCreateMap_9_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_MsgCreateMap_9_list) NewElement() protoreflect.Value {
	v := new(MapMetadataTimeline)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MsgCreateMap_9_list) IsValid() bool {
	return x.list != nil
}

var (
	md_MsgCreateMap                            protoreflect.MessageDescriptor
	fd_MsgCreateMap_creator                    protoreflect.FieldDescriptor
	fd_MsgCreateMap_mapId                      protoreflect.FieldDescriptor
	fd_MsgCreateMap_inheritManagerTimelineFrom protoreflect.FieldDescriptor
	fd_MsgCreateMap_managerTimeline            protoreflect.FieldDescriptor
	fd_MsgCreateMap_updateCriteria             protoreflect.FieldDescriptor
	fd_MsgCreateMap_valueOptions               protoreflect.FieldDescriptor
	fd_MsgCreateMap_defaultValue               protoreflect.FieldDescriptor
	fd_MsgCreateMap_metadataTimeline           protoreflect.FieldDescriptor
	fd_MsgCreateMap_permissions                protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MsgCreateMap = File_maps_tx_proto.Messages().ByName("MsgCreateMap")
	fd_MsgCreateMap_creator = md_MsgCreateMap.Fields().ByName("creator")
	fd_MsgCreateMap_mapId = md_MsgCreateMap.Fields().ByName("mapId")
	fd_MsgCreateMap_inheritManagerTimelineFrom = md_MsgCreateMap.Fields().ByName("inheritManagerTimelineFrom")
	fd_MsgCreateMap_managerTimeline = md_MsgCreateMap.Fields().ByName("managerTimeline")
	fd_MsgCreateMap_updateCriteria = md_MsgCreateMap.Fields().ByName("updateCriteria")
	fd_MsgCreateMap_valueOptions = md_MsgCreateMap.Fields().ByName("valueOptions")
	fd_MsgCreateMap_defaultValue = md_MsgCreateMap.Fields().ByName("defaultValue")
	fd_MsgCreateMap_metadataTimeline = md_MsgCreateMap.Fields().ByName("metadataTimeline")
	fd_MsgCreateMap_permissions = md_MsgCreateMap.Fields().ByName("permissions")
}

var _ protoreflect.Message = (*fastReflection_MsgCreateMap)(nil)

type fastReflection_MsgCreateMap MsgCreateMap

func (x *MsgCreateMap) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgCreateMap)(x)
}

func (x *MsgCreateMap) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgCreateMap_messageType fastReflection_MsgCreateMap_messageType
var _ protoreflect.MessageType = fastReflection_MsgCreateMap_messageType{}

type fastReflection_MsgCreateMap_messageType struct{}

func (x fastReflection_MsgCreateMap_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgCreateMap)(nil)
}
func (x fastReflection_MsgCreateMap_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgCreateMap)
}
func (x fastReflection_MsgCreateMap_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgCreateMap
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgCreateMap) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgCreateMap
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgCreateMap) Type() protoreflect.MessageType {
	return _fastReflection_MsgCreateMap_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgCreateMap) New() protoreflect.Message {
	return new(fastReflection_MsgCreateMap)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgCreateMap) Interface() protoreflect.ProtoMessage {
	return (*MsgCreateMap)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgCreateMap) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgCreateMap_creator, value) {
			return
		}
	}
	if x.MapId != "" {
		value := protoreflect.ValueOfString(x.MapId)
		if !f(fd_MsgCreateMap_mapId, value) {
			return
		}
	}
	if x.InheritManagerTimelineFrom != "" {
		value := protoreflect.ValueOfString(x.InheritManagerTimelineFrom)
		if !f(fd_MsgCreateMap_inheritManagerTimelineFrom, value) {
			return
		}
	}
	if len(x.ManagerTimeline) != 0 {
		value := protoreflect.ValueOfList(&_MsgCreateMap_4_list{list: &x.ManagerTimeline})
		if !f(fd_MsgCreateMap_managerTimeline, value) {
			return
		}
	}
	if x.UpdateCriteria != nil {
		value := protoreflect.ValueOfMessage(x.UpdateCriteria.ProtoReflect())
		if !f(fd_MsgCreateMap_updateCriteria, value) {
			return
		}
	}
	if x.ValueOptions != nil {
		value := protoreflect.ValueOfMessage(x.ValueOptions.ProtoReflect())
		if !f(fd_MsgCreateMap_valueOptions, value) {
			return
		}
	}
	if x.DefaultValue != "" {
		value := protoreflect.ValueOfString(x.DefaultValue)
		if !f(fd_MsgCreateMap_defaultValue, value) {
			return
		}
	}
	if len(x.MetadataTimeline) != 0 {
		value := protoreflect.ValueOfList(&_MsgCreateMap_9_list{list: &x.MetadataTimeline})
		if !f(fd_MsgCreateMap_metadataTimeline, value) {
			return
		}
	}
	if x.Permissions != nil {
		value := protoreflect.ValueOfMessage(x.Permissions.ProtoReflect())
		if !f(fd_MsgCreateMap_permissions, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgCreateMap) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.MsgCreateMap.creator":
		return x.Creator != ""
	case "maps.MsgCreateMap.mapId":
		return x.MapId != ""
	case "maps.MsgCreateMap.inheritManagerTimelineFrom":
		return x.InheritManagerTimelineFrom != ""
	case "maps.MsgCreateMap.managerTimeline":
		return len(x.ManagerTimeline) != 0
	case "maps.MsgCreateMap.updateCriteria":
		return x.UpdateCriteria != nil
	case "maps.MsgCreateMap.valueOptions":
		return x.ValueOptions != nil
	case "maps.MsgCreateMap.defaultValue":
		return x.DefaultValue != ""
	case "maps.MsgCreateMap.metadataTimeline":
		return len(x.MetadataTimeline) != 0
	case "maps.MsgCreateMap.permissions":
		return x.Permissions != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMap"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMap does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateMap) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.MsgCreateMap.creator":
		x.Creator = ""
	case "maps.MsgCreateMap.mapId":
		x.MapId = ""
	case "maps.MsgCreateMap.inheritManagerTimelineFrom":
		x.InheritManagerTimelineFrom = ""
	case "maps.MsgCreateMap.managerTimeline":
		x.ManagerTimeline = nil
	case "maps.MsgCreateMap.updateCriteria":
		x.UpdateCriteria = nil
	case "maps.MsgCreateMap.valueOptions":
		x.ValueOptions = nil
	case "maps.MsgCreateMap.defaultValue":
		x.DefaultValue = ""
	case "maps.MsgCreateMap.metadataTimeline":
		x.MetadataTimeline = nil
	case "maps.MsgCreateMap.permissions":
		x.Permissions = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMap"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMap does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgCreateMap) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.MsgCreateMap.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "maps.MsgCreateMap.mapId":
		value := x.MapId
		return protoreflect.ValueOfString(value)
	case "maps.MsgCreateMap.inheritManagerTimelineFrom":
		value := x.InheritManagerTimelineFrom
		return protoreflect.ValueOfString(value)
	case "maps.MsgCreateMap.managerTimeline":
		if len(x.ManagerTimeline) == 0 {
			return protoreflect.ValueOfList(&_MsgCreateMap_4_list{})
		}
		listValue := &_MsgCreateMap_4_list{list: &x.ManagerTimeline}
		return protoreflect.ValueOfList(listValue)
	case "maps.MsgCreateMap.updateCriteria":
		value := x.UpdateCriteria
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "maps.MsgCreateMap.valueOptions":
		value := x.ValueOptions
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "maps.MsgCreateMap.defaultValue":
		value := x.DefaultValue
		return protoreflect.ValueOfString(value)
	case "maps.MsgCreateMap.metadataTimeline":
		if len(x.MetadataTimeline) == 0 {
			return protoreflect.ValueOfList(&_MsgCreateMap_9_list{})
		}
		listValue := &_MsgCreateMap_9_list{list: &x.MetadataTimeline}
		return protoreflect.ValueOfList(listValue)
	case "maps.MsgCreateMap.permissions":
		value := x.Permissions
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMap"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMap does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateMap) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.MsgCreateMap.creator":
		x.Creator = value.Interface().(string)
	case "maps.MsgCreateMap.mapId":
		x.MapId = value.Interface().(string)
	case "maps.MsgCreateMap.inheritManagerTimelineFrom":
		x.InheritManagerTimelineFrom = value.Interface().(string)
	case "maps.MsgCreateMap.managerTimeline":
		lv := value.List()
		clv := lv.(*_MsgCreateMap_4_list)
		x.ManagerTimeline = *clv.list
	case "maps.MsgCreateMap.updateCriteria":
		x.UpdateCriteria = value.Message().Interface().(*MapUpdateCriteria)
	case "maps.MsgCreateMap.valueOptions":
		x.ValueOptions = value.Message().Interface().(*ValueOptions)
	case "maps.MsgCreateMap.defaultValue":
		x.DefaultValue = value.Interface().(string)
	case "maps.MsgCreateMap.metadataTimeline":
		lv := value.List()
		clv := lv.(*_MsgCreateMap_9_list)
		x.MetadataTimeline = *clv.list
	case "maps.MsgCreateMap.permissions":
		x.Permissions = value.Message().Interface().(*MapPermissions)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMap"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMap does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateMap) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MsgCreateMap.managerTimeline":
		if x.ManagerTimeline == nil {
			x.ManagerTimeline = []*ManagerTimeline{}
		}
		value := &_MsgCreateMap_4_list{list: &x.ManagerTimeline}
		return protoreflect.ValueOfList(value)
	case "maps.MsgCreateMap.updateCriteria":
		if x.UpdateCriteria == nil {
			x.UpdateCriteria = new(MapUpdateCriteria)
		}
		return protoreflect.ValueOfMessage(x.UpdateCriteria.ProtoReflect())
	case "maps.MsgCreateMap.valueOptions":
		if x.ValueOptions == nil {
			x.ValueOptions = new(ValueOptions)
		}
		return protoreflect.ValueOfMessage(x.ValueOptions.ProtoReflect())
	case "maps.MsgCreateMap.metadataTimeline":
		if x.MetadataTimeline == nil {
			x.MetadataTimeline = []*MapMetadataTimeline{}
		}
		value := &_MsgCreateMap_9_list{list: &x.MetadataTimeline}
		return protoreflect.ValueOfList(value)
	case "maps.MsgCreateMap.permissions":
		if x.Permissions == nil {
			x.Permissions = new(MapPermissions)
		}
		return protoreflect.ValueOfMessage(x.Permissions.ProtoReflect())
	case "maps.MsgCreateMap.creator":
		panic(fmt.Errorf("field creator of message maps.MsgCreateMap is not mutable"))
	case "maps.MsgCreateMap.mapId":
		panic(fmt.Errorf("field mapId of message maps.MsgCreateMap is not mutable"))
	case "maps.MsgCreateMap.inheritManagerTimelineFrom":
		panic(fmt.Errorf("field inheritManagerTimelineFrom of message maps.MsgCreateMap is not mutable"))
	case "maps.MsgCreateMap.defaultValue":
		panic(fmt.Errorf("field defaultValue of message maps.MsgCreateMap is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMap"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMap does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgCreateMap) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MsgCreateMap.creator":
		return protoreflect.ValueOfString("")
	case "maps.MsgCreateMap.mapId":
		return protoreflect.ValueOfString("")
	case "maps.MsgCreateMap.inheritManagerTimelineFrom":
		return protoreflect.ValueOfString("")
	case "maps.MsgCreateMap.managerTimeline":
		list := []*ManagerTimeline{}
		return protoreflect.ValueOfList(&_MsgCreateMap_4_list{list: &list})
	case "maps.MsgCreateMap.updateCriteria":
		m := new(MapUpdateCriteria)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "maps.MsgCreateMap.valueOptions":
		m := new(ValueOptions)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "maps.MsgCreateMap.defaultValue":
		return protoreflect.ValueOfString("")
	case "maps.MsgCreateMap.metadataTimeline":
		list := []*MapMetadataTimeline{}
		return protoreflect.ValueOfList(&_MsgCreateMap_9_list{list: &list})
	case "maps.MsgCreateMap.permissions":
		m := new(MapPermissions)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMap"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMap does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgCreateMap) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MsgCreateMap", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgCreateMap) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateMap) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgCreateMap) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgCreateMap) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgCreateMap)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MapId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.InheritManagerTimelineFrom)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.ManagerTimeline) > 0 {
			for _, e := range x.ManagerTimeline {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.UpdateCriteria != nil {
			l = options.Size(x.UpdateCriteria)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ValueOptions != nil {
			l = options.Size(x.ValueOptions)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.DefaultValue)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.MetadataTimeline) > 0 {
			for _, e := range x.MetadataTimeline {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.Permissions != nil {
			l = options.Size(x.Permissions)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgCreateMap)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Permissions != nil {
			encoded, err := options.Marshal(x.Permissions)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x52
		}
		if len(x.MetadataTimeline) > 0 {
			for iNdEx := len(x.MetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.MetadataTimeline[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x4a
			}
		}
		if len(x.DefaultValue) > 0 {
			i -= len(x.DefaultValue)
			copy(dAtA[i:], x.DefaultValue)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DefaultValue)))
			i--
			dAtA[i] = 0x3a
		}
		if x.ValueOptions != nil {
			encoded, err := options.Marshal(x.ValueOptions)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		}
		if x.UpdateCriteria != nil {
			encoded, err := options.Marshal(x.UpdateCriteria)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.ManagerTimeline) > 0 {
			for iNdEx := len(x.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.ManagerTimeline[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if len(x.InheritManagerTimelineFrom) > 0 {
			i -= len(x.InheritManagerTimelineFrom)
			copy(dAtA[i:], x.InheritManagerTimelineFrom)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.InheritManagerTimelineFrom)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.MapId) > 0 {
			i -= len(x.MapId)
			copy(dAtA[i:], x.MapId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MapId)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgCreateMap)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgCreateMap: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgCreateMap: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MapId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InheritManagerTimelineFrom", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.InheritManagerTimelineFrom = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ManagerTimeline = append(x.ManagerTimeline, &ManagerTimeline{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ManagerTimeline[len(x.ManagerTimeline)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UpdateCriteria", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.UpdateCriteria == nil {
					x.UpdateCriteria = &MapUpdateCriteria{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.UpdateCriteria); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ValueOptions", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ValueOptions == nil {
					x.ValueOptions = &ValueOptions{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ValueOptions); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DefaultValue = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MetadataTimeline", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MetadataTimeline = append(x.MetadataTimeline, &MapMetadataTimeline{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MetadataTimeline[len(x.MetadataTimeline)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Permissions == nil {
					x.Permissions = &MapPermissions{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Permissions); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgCreateMapResponse protoreflect.MessageDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MsgCreateMapResponse = File_maps_tx_proto.Messages().ByName("MsgCreateMapResponse")
}

var _ protoreflect.Message = (*fastReflection_MsgCreateMapResponse)(nil)

type fastReflection_MsgCreateMapResponse MsgCreateMapResponse

func (x *MsgCreateMapResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgCreateMapResponse)(x)
}

func (x *MsgCreateMapResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgCreateMapResponse_messageType fastReflection_MsgCreateMapResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgCreateMapResponse_messageType{}

type fastReflection_MsgCreateMapResponse_messageType struct{}

func (x fastReflection_MsgCreateMapResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgCreateMapResponse)(nil)
}
func (x fastReflection_MsgCreateMapResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgCreateMapResponse)
}
func (x fastReflection_MsgCreateMapResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgCreateMapResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgCreateMapResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgCreateMapResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgCreateMapResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgCreateMapResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgCreateMapResponse) New() protoreflect.Message {
	return new(fastReflection_MsgCreateMapResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgCreateMapResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgCreateMapResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgCreateMapResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgCreateMapResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMapResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateMapResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMapResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgCreateMapResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMapResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateMapResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMapResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateMapResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMapResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgCreateMapResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgCreateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgCreateMapResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgCreateMapResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MsgCreateMapResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgCreateMapResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateMapResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgCreateMapResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgCreateMapResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgCreateMapResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgCreateMapResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgCreateMapResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgCreateMapResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgCreateMapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_MsgUpdateMap_4_list)(nil)

type _MsgUpdateMap_4_list struct {
	list *[]*ManagerTimeline
}

func (x *_MsgUpdateMap_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MsgUpdateMap_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_MsgUpdateMap_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ManagerTimeline)
	(*x.list)[i] = concreteValue
}

func (x *_MsgUpdateMap_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ManagerTimeline)
	*x.list = append(*x.list, concreteValue)
}

func (x *_MsgUpdateMap_4_list) AppendMutable() protoreflect.Value {
	v := new(ManagerTimeline)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MsgUpdateMap_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_MsgUpdateMap_4_list) NewElement() protoreflect.Value {
	v := new(ManagerTimeline)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MsgUpdateMap_4_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_MsgUpdateMap_8_list)(nil)

type _MsgUpdateMap_8_list struct {
	list *[]*MapMetadataTimeline
}

func (x *_MsgUpdateMap_8_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MsgUpdateMap_8_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_MsgUpdateMap_8_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MapMetadataTimeline)
	(*x.list)[i] = concreteValue
}

func (x *_MsgUpdateMap_8_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MapMetadataTimeline)
	*x.list = append(*x.list, concreteValue)
}

func (x *_MsgUpdateMap_8_list) AppendMutable() protoreflect.Value {
	v := new(MapMetadataTimeline)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MsgUpdateMap_8_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_MsgUpdateMap_8_list) NewElement() protoreflect.Value {
	v := new(MapMetadataTimeline)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MsgUpdateMap_8_list) IsValid() bool {
	return x.list != nil
}

var (
	md_MsgUpdateMap                        protoreflect.MessageDescriptor
	fd_MsgUpdateMap_creator                protoreflect.FieldDescriptor
	fd_MsgUpdateMap_mapId                  protoreflect.FieldDescriptor
	fd_MsgUpdateMap_updateManagerTimeline  protoreflect.FieldDescriptor
	fd_MsgUpdateMap_managerTimeline        protoreflect.FieldDescriptor
	fd_MsgUpdateMap_updateMetadataTimeline protoreflect.FieldDescriptor
	fd_MsgUpdateMap_metadataTimeline       protoreflect.FieldDescriptor
	fd_MsgUpdateMap_updatePermissions      protoreflect.FieldDescriptor
	fd_MsgUpdateMap_permissions            protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MsgUpdateMap = File_maps_tx_proto.Messages().ByName("MsgUpdateMap")
	fd_MsgUpdateMap_creator = md_MsgUpdateMap.Fields().ByName("creator")
	fd_MsgUpdateMap_mapId = md_MsgUpdateMap.Fields().ByName("mapId")
	fd_MsgUpdateMap_updateManagerTimeline = md_MsgUpdateMap.Fields().ByName("updateManagerTimeline")
	fd_MsgUpdateMap_managerTimeline = md_MsgUpdateMap.Fields().ByName("managerTimeline")
	fd_MsgUpdateMap_updateMetadataTimeline = md_MsgUpdateMap.Fields().ByName("updateMetadataTimeline")
	fd_MsgUpdateMap_metadataTimeline = md_MsgUpdateMap.Fields().ByName("metadataTimeline")
	fd_MsgUpdateMap_updatePermissions = md_MsgUpdateMap.Fields().ByName("updatePermissions")
	fd_MsgUpdateMap_permissions = md_MsgUpdateMap.Fields().ByName("permissions")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateMap)(nil)

type fastReflection_MsgUpdateMap MsgUpdateMap

func (x *MsgUpdateMap) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateMap)(x)
}

func (x *MsgUpdateMap) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateMap_messageType fastReflection_MsgUpdateMap_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateMap_messageType{}

type fastReflection_MsgUpdateMap_messageType struct{}

func (x fastReflection_MsgUpdateMap_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateMap)(nil)
}
func (x fastReflection_MsgUpdateMap_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateMap)
}
func (x fastReflection_MsgUpdateMap_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateMap
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateMap) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateMap
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateMap) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateMap_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateMap) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateMap)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateMap) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateMap)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateMap) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgUpdateMap_creator, value) {
			return
		}
	}
	if x.MapId != "" {
		value := protoreflect.ValueOfString(x.MapId)
		if !f(fd_MsgUpdateMap_mapId, value) {
			return
		}
	}
	if x.UpdateManagerTimeline != false {
		value := protoreflect.ValueOfBool(x.UpdateManagerTimeline)
		if !f(fd_MsgUpdateMap_updateManagerTimeline, value) {
			return
		}
	}
	if len(x.ManagerTimeline) != 0 {
		value := protoreflect.ValueOfList(&_MsgUpdateMap_4_list{list: &x.ManagerTimeline})
		if !f(fd_MsgUpdateMap_managerTimeline, value) {
			return
		}
	}
	if x.UpdateMetadataTimeline != false {
		value := protoreflect.ValueOfBool(x.UpdateMetadataTimeline)
		if !f(fd_MsgUpdateMap_updateMetadataTimeline, value) {
			return
		}
	}
	if len(x.MetadataTimeline) != 0 {
		value := protoreflect.ValueOfList(&_MsgUpdateMap_8_list{list: &x.MetadataTimeline})
		if !f(fd_MsgUpdateMap_metadataTimeline, value) {
			return
		}
	}
	if x.UpdatePermissions != false {
		value := protoreflect.ValueOfBool(x.UpdatePermissions)
		if !f(fd_MsgUpdateMap_updatePermissions, value) {
			return
		}
	}
	if x.Permissions != nil {
		value := protoreflect.ValueOfMessage(x.Permissions.ProtoReflect())
		if !f(fd_MsgUpdateMap_permissions, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateMap) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.MsgUpdateMap.creator":
		return x.Creator != ""
	case "maps.MsgUpdateMap.mapId":
		return x.MapId != ""
	case "maps.MsgUpdateMap.updateManagerTimeline":
		return x.UpdateManagerTimeline != false
	case "maps.MsgUpdateMap.managerTimeline":
		return len(x.ManagerTimeline) != 0
	case "maps.MsgUpdateMap.updateMetadataTimeline":
		return x.UpdateMetadataTimeline != false
	case "maps.MsgUpdateMap.metadataTimeline":
		return len(x.MetadataTimeline) != 0
	case "maps.MsgUpdateMap.updatePermissions":
		return x.UpdatePermissions != false
	case "maps.MsgUpdateMap.permissions":
		return x.Permissions != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMap"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMap does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMap) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.MsgUpdateMap.creator":
		x.Creator = ""
	case "maps.MsgUpdateMap.mapId":
		x.MapId = ""
	case "maps.MsgUpdateMap.updateManagerTimeline":
		x.UpdateManagerTimeline = false
	case "maps.MsgUpdateMap.managerTimeline":
		x.ManagerTimeline = nil
	case "maps.MsgUpdateMap.updateMetadataTimeline":
		x.UpdateMetadataTimeline = false
	case "maps.MsgUpdateMap.metadataTimeline":
		x.MetadataTimeline = nil
	case "maps.MsgUpdateMap.updatePermissions":
		x.UpdatePermissions = false
	case "maps.MsgUpdateMap.permissions":
		x.Permissions = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMap"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMap does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateMap) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.MsgUpdateMap.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "maps.MsgUpdateMap.mapId":
		value := x.MapId
		return protoreflect.ValueOfString(value)
	case "maps.MsgUpdateMap.updateManagerTimeline":
		value := x.UpdateManagerTimeline
		return protoreflect.ValueOfBool(value)
	case "maps.MsgUpdateMap.managerTimeline":
		if len(x.ManagerTimeline) == 0 {
			return protoreflect.ValueOfList(&_MsgUpdateMap_4_list{})
		}
		listValue := &_MsgUpdateMap_4_list{list: &x.ManagerTimeline}
		return protoreflect.ValueOfList(listValue)
	case "maps.MsgUpdateMap.updateMetadataTimeline":
		value := x.UpdateMetadataTimeline
		return protoreflect.ValueOfBool(value)
	case "maps.MsgUpdateMap.metadataTimeline":
		if len(x.MetadataTimeline) == 0 {
			return protoreflect.ValueOfList(&_MsgUpdateMap_8_list{})
		}
		listValue := &_MsgUpdateMap_8_list{list: &x.MetadataTimeline}
		return protoreflect.ValueOfList(listValue)
	case "maps.MsgUpdateMap.updatePermissions":
		value := x.UpdatePermissions
		return protoreflect.ValueOfBool(value)
	case "maps.MsgUpdateMap.permissions":
		value := x.Permissions
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMap"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMap does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMap) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.MsgUpdateMap.creator":
		x.Creator = value.Interface().(string)
	case "maps.MsgUpdateMap.mapId":
		x.MapId = value.Interface().(string)
	case "maps.MsgUpdateMap.updateManagerTimeline":
		x.UpdateManagerTimeline = value.Bool()
	case "maps.MsgUpdateMap.managerTimeline":
		lv := value.List()
		clv := lv.(*_MsgUpdateMap_4_list)
		x.ManagerTimeline = *clv.list
	case "maps.MsgUpdateMap.updateMetadataTimeline":
		x.UpdateMetadataTimeline = value.Bool()
	case "maps.MsgUpdateMap.metadataTimeline":
		lv := value.List()
		clv := lv.(*_MsgUpdateMap_8_list)
		x.MetadataTimeline = *clv.list
	case "maps.MsgUpdateMap.updatePermissions":
		x.UpdatePermissions = value.Bool()
	case "maps.MsgUpdateMap.permissions":
		x.Permissions = value.Message().Interface().(*MapPermissions)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMap"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMap does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMap) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MsgUpdateMap.managerTimeline":
		if x.ManagerTimeline == nil {
			x.ManagerTimeline = []*ManagerTimeline{}
		}
		value := &_MsgUpdateMap_4_list{list: &x.ManagerTimeline}
		return protoreflect.ValueOfList(value)
	case "maps.MsgUpdateMap.metadataTimeline":
		if x.MetadataTimeline == nil {
			x.MetadataTimeline = []*MapMetadataTimeline{}
		}
		value := &_MsgUpdateMap_8_list{list: &x.MetadataTimeline}
		return protoreflect.ValueOfList(value)
	case "maps.MsgUpdateMap.permissions":
		if x.Permissions == nil {
			x.Permissions = new(MapPermissions)
		}
		return protoreflect.ValueOfMessage(x.Permissions.ProtoReflect())
	case "maps.MsgUpdateMap.creator":
		panic(fmt.Errorf("field creator of message maps.MsgUpdateMap is not mutable"))
	case "maps.MsgUpdateMap.mapId":
		panic(fmt.Errorf("field mapId of message maps.MsgUpdateMap is not mutable"))
	case "maps.MsgUpdateMap.updateManagerTimeline":
		panic(fmt.Errorf("field updateManagerTimeline of message maps.MsgUpdateMap is not mutable"))
	case "maps.MsgUpdateMap.updateMetadataTimeline":
		panic(fmt.Errorf("field updateMetadataTimeline of message maps.MsgUpdateMap is not mutable"))
	case "maps.MsgUpdateMap.updatePermissions":
		panic(fmt.Errorf("field updatePermissions of message maps.MsgUpdateMap is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMap"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMap does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateMap) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MsgUpdateMap.creator":
		return protoreflect.ValueOfString("")
	case "maps.MsgUpdateMap.mapId":
		return protoreflect.ValueOfString("")
	case "maps.MsgUpdateMap.updateManagerTimeline":
		return protoreflect.ValueOfBool(false)
	case "maps.MsgUpdateMap.managerTimeline":
		list := []*ManagerTimeline{}
		return protoreflect.ValueOfList(&_MsgUpdateMap_4_list{list: &list})
	case "maps.MsgUpdateMap.updateMetadataTimeline":
		return protoreflect.ValueOfBool(false)
	case "maps.MsgUpdateMap.metadataTimeline":
		list := []*MapMetadataTimeline{}
		return protoreflect.ValueOfList(&_MsgUpdateMap_8_list{list: &list})
	case "maps.MsgUpdateMap.updatePermissions":
		return protoreflect.ValueOfBool(false)
	case "maps.MsgUpdateMap.permissions":
		m := new(MapPermissions)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMap"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMap does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateMap) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MsgUpdateMap", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateMap) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMap) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateMap) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateMap) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateMap)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MapId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.UpdateManagerTimeline {
			n += 2
		}
		if len(x.ManagerTimeline) > 0 {
			for _, e := range x.ManagerTimeline {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.UpdateMetadataTimeline {
			n += 2
		}
		if len(x.MetadataTimeline) > 0 {
			for _, e := range x.MetadataTimeline {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.UpdatePermissions {
			n += 2
		}
		if x.Permissions != nil {
			l = options.Size(x.Permissions)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateMap)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Permissions != nil {
			encoded, err := options.Marshal(x.Permissions)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x52
		}
		if x.UpdatePermissions {
			i--
			if x.UpdatePermissions {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x48
		}
		if len(x.MetadataTimeline) > 0 {
			for iNdEx := len(x.MetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.MetadataTimeline[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x42
			}
		}
		if x.UpdateMetadataTimeline {
			i--
			if x.UpdateMetadataTimeline {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x38
		}
		if len(x.ManagerTimeline) > 0 {
			for iNdEx := len(x.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.ManagerTimeline[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if x.UpdateManagerTimeline {
			i--
			if x.UpdateManagerTimeline {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x18
		}
		if len(x.MapId) > 0 {
			i -= len(x.MapId)
			copy(dAtA[i:], x.MapId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MapId)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateMap)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateMap: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateMap: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MapId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UpdateManagerTimeline", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UpdateManagerTimeline = bool(v != 0)
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ManagerTimeline = append(x.ManagerTimeline, &ManagerTimeline{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ManagerTimeline[len(x.ManagerTimeline)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UpdateMetadataTimeline", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UpdateMetadataTimeline = bool(v != 0)
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MetadataTimeline", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MetadataTimeline = append(x.MetadataTimeline, &MapMetadataTimeline{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MetadataTimeline[len(x.MetadataTimeline)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UpdatePermissions", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UpdatePermissions = bool(v != 0)
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Permissions == nil {
					x.Permissions = &MapPermissions{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Permissions); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgUpdateMapResponse protoreflect.MessageDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MsgUpdateMapResponse = File_maps_tx_proto.Messages().ByName("MsgUpdateMapResponse")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateMapResponse)(nil)

type fastReflection_MsgUpdateMapResponse MsgUpdateMapResponse

func (x *MsgUpdateMapResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateMapResponse)(x)
}

func (x *MsgUpdateMapResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateMapResponse_messageType fastReflection_MsgUpdateMapResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateMapResponse_messageType{}

type fastReflection_MsgUpdateMapResponse_messageType struct{}

func (x fastReflection_MsgUpdateMapResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateMapResponse)(nil)
}
func (x fastReflection_MsgUpdateMapResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateMapResponse)
}
func (x fastReflection_MsgUpdateMapResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateMapResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateMapResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateMapResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateMapResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateMapResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateMapResponse) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateMapResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateMapResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateMapResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateMapResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateMapResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMapResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMapResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMapResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateMapResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMapResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMapResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMapResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMapResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMapResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateMapResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgUpdateMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgUpdateMapResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateMapResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MsgUpdateMapResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateMapResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateMapResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateMapResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateMapResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateMapResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateMapResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateMapResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateMapResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateMapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgDeleteMap         protoreflect.MessageDescriptor
	fd_MsgDeleteMap_creator protoreflect.FieldDescriptor
	fd_MsgDeleteMap_mapId   protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MsgDeleteMap = File_maps_tx_proto.Messages().ByName("MsgDeleteMap")
	fd_MsgDeleteMap_creator = md_MsgDeleteMap.Fields().ByName("creator")
	fd_MsgDeleteMap_mapId = md_MsgDeleteMap.Fields().ByName("mapId")
}

var _ protoreflect.Message = (*fastReflection_MsgDeleteMap)(nil)

type fastReflection_MsgDeleteMap MsgDeleteMap

func (x *MsgDeleteMap) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgDeleteMap)(x)
}

func (x *MsgDeleteMap) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgDeleteMap_messageType fastReflection_MsgDeleteMap_messageType
var _ protoreflect.MessageType = fastReflection_MsgDeleteMap_messageType{}

type fastReflection_MsgDeleteMap_messageType struct{}

func (x fastReflection_MsgDeleteMap_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgDeleteMap)(nil)
}
func (x fastReflection_MsgDeleteMap_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgDeleteMap)
}
func (x fastReflection_MsgDeleteMap_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgDeleteMap
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgDeleteMap) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgDeleteMap
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgDeleteMap) Type() protoreflect.MessageType {
	return _fastReflection_MsgDeleteMap_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgDeleteMap) New() protoreflect.Message {
	return new(fastReflection_MsgDeleteMap)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgDeleteMap) Interface() protoreflect.ProtoMessage {
	return (*MsgDeleteMap)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgDeleteMap) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgDeleteMap_creator, value) {
			return
		}
	}
	if x.MapId != "" {
		value := protoreflect.ValueOfString(x.MapId)
		if !f(fd_MsgDeleteMap_mapId, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgDeleteMap) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.MsgDeleteMap.creator":
		return x.Creator != ""
	case "maps.MsgDeleteMap.mapId":
		return x.MapId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMap"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMap does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgDeleteMap) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.MsgDeleteMap.creator":
		x.Creator = ""
	case "maps.MsgDeleteMap.mapId":
		x.MapId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMap"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMap does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgDeleteMap) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.MsgDeleteMap.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "maps.MsgDeleteMap.mapId":
		value := x.MapId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMap"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMap does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgDeleteMap) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.MsgDeleteMap.creator":
		x.Creator = value.Interface().(string)
	case "maps.MsgDeleteMap.mapId":
		x.MapId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMap"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMap does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgDeleteMap) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MsgDeleteMap.creator":
		panic(fmt.Errorf("field creator of message maps.MsgDeleteMap is not mutable"))
	case "maps.MsgDeleteMap.mapId":
		panic(fmt.Errorf("field mapId of message maps.MsgDeleteMap is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMap"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMap does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgDeleteMap) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MsgDeleteMap.creator":
		return protoreflect.ValueOfString("")
	case "maps.MsgDeleteMap.mapId":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMap"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMap does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgDeleteMap) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MsgDeleteMap", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgDeleteMap) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgDeleteMap) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgDeleteMap) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgDeleteMap) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgDeleteMap)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MapId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgDeleteMap)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.MapId) > 0 {
			i -= len(x.MapId)
			copy(dAtA[i:], x.MapId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MapId)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgDeleteMap)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgDeleteMap: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgDeleteMap: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MapId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgDeleteMapResponse protoreflect.MessageDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MsgDeleteMapResponse = File_maps_tx_proto.Messages().ByName("MsgDeleteMapResponse")
}

var _ protoreflect.Message = (*fastReflection_MsgDeleteMapResponse)(nil)

type fastReflection_MsgDeleteMapResponse MsgDeleteMapResponse

func (x *MsgDeleteMapResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgDeleteMapResponse)(x)
}

func (x *MsgDeleteMapResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgDeleteMapResponse_messageType fastReflection_MsgDeleteMapResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgDeleteMapResponse_messageType{}

type fastReflection_MsgDeleteMapResponse_messageType struct{}

func (x fastReflection_MsgDeleteMapResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgDeleteMapResponse)(nil)
}
func (x fastReflection_MsgDeleteMapResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgDeleteMapResponse)
}
func (x fastReflection_MsgDeleteMapResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgDeleteMapResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgDeleteMapResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgDeleteMapResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgDeleteMapResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgDeleteMapResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgDeleteMapResponse) New() protoreflect.Message {
	return new(fastReflection_MsgDeleteMapResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgDeleteMapResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgDeleteMapResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgDeleteMapResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgDeleteMapResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMapResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgDeleteMapResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMapResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgDeleteMapResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMapResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgDeleteMapResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMapResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgDeleteMapResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMapResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgDeleteMapResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgDeleteMapResponse"))
		}
		panic(fmt.Errorf("message maps.MsgDeleteMapResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgDeleteMapResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MsgDeleteMapResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgDeleteMapResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgDeleteMapResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgDeleteMapResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgDeleteMapResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgDeleteMapResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgDeleteMapResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgDeleteMapResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgDeleteMapResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgDeleteMapResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_SetOptions                           protoreflect.MessageDescriptor
	fd_SetOptions_useMostRecentCollectionId protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_SetOptions = File_maps_tx_proto.Messages().ByName("SetOptions")
	fd_SetOptions_useMostRecentCollectionId = md_SetOptions.Fields().ByName("useMostRecentCollectionId")
}

var _ protoreflect.Message = (*fastReflection_SetOptions)(nil)

type fastReflection_SetOptions SetOptions

func (x *SetOptions) ProtoReflect() protoreflect.Message {
	return (*fastReflection_SetOptions)(x)
}

func (x *SetOptions) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_SetOptions_messageType fastReflection_SetOptions_messageType
var _ protoreflect.MessageType = fastReflection_SetOptions_messageType{}

type fastReflection_SetOptions_messageType struct{}

func (x fastReflection_SetOptions_messageType) Zero() protoreflect.Message {
	return (*fastReflection_SetOptions)(nil)
}
func (x fastReflection_SetOptions_messageType) New() protoreflect.Message {
	return new(fastReflection_SetOptions)
}
func (x fastReflection_SetOptions_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_SetOptions
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_SetOptions) Descriptor() protoreflect.MessageDescriptor {
	return md_SetOptions
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_SetOptions) Type() protoreflect.MessageType {
	return _fastReflection_SetOptions_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_SetOptions) New() protoreflect.Message {
	return new(fastReflection_SetOptions)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_SetOptions) Interface() protoreflect.ProtoMessage {
	return (*SetOptions)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_SetOptions) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.UseMostRecentCollectionId != false {
		value := protoreflect.ValueOfBool(x.UseMostRecentCollectionId)
		if !f(fd_SetOptions_useMostRecentCollectionId, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_SetOptions) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.SetOptions.useMostRecentCollectionId":
		return x.UseMostRecentCollectionId != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.SetOptions"))
		}
		panic(fmt.Errorf("message maps.SetOptions does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SetOptions) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.SetOptions.useMostRecentCollectionId":
		x.UseMostRecentCollectionId = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.SetOptions"))
		}
		panic(fmt.Errorf("message maps.SetOptions does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_SetOptions) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.SetOptions.useMostRecentCollectionId":
		value := x.UseMostRecentCollectionId
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.SetOptions"))
		}
		panic(fmt.Errorf("message maps.SetOptions does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SetOptions) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.SetOptions.useMostRecentCollectionId":
		x.UseMostRecentCollectionId = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.SetOptions"))
		}
		panic(fmt.Errorf("message maps.SetOptions does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SetOptions) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.SetOptions.useMostRecentCollectionId":
		panic(fmt.Errorf("field useMostRecentCollectionId of message maps.SetOptions is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.SetOptions"))
		}
		panic(fmt.Errorf("message maps.SetOptions does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_SetOptions) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.SetOptions.useMostRecentCollectionId":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.SetOptions"))
		}
		panic(fmt.Errorf("message maps.SetOptions does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_SetOptions) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.SetOptions", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_SetOptions) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SetOptions) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_SetOptions) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_SetOptions) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*SetOptions)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.UseMostRecentCollectionId {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*SetOptions)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.UseMostRecentCollectionId {
			i--
			if x.UseMostRecentCollectionId {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*SetOptions)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SetOptions: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SetOptions: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UseMostRecentCollectionId", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UseMostRecentCollectionId = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgSetValue         protoreflect.MessageDescriptor
	fd_MsgSetValue_creator protoreflect.FieldDescriptor
	fd_MsgSetValue_mapId   protoreflect.FieldDescriptor
	fd_MsgSetValue_key     protoreflect.FieldDescriptor
	fd_MsgSetValue_value   protoreflect.FieldDescriptor
	fd_MsgSetValue_options protoreflect.FieldDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MsgSetValue = File_maps_tx_proto.Messages().ByName("MsgSetValue")
	fd_MsgSetValue_creator = md_MsgSetValue.Fields().ByName("creator")
	fd_MsgSetValue_mapId = md_MsgSetValue.Fields().ByName("mapId")
	fd_MsgSetValue_key = md_MsgSetValue.Fields().ByName("key")
	fd_MsgSetValue_value = md_MsgSetValue.Fields().ByName("value")
	fd_MsgSetValue_options = md_MsgSetValue.Fields().ByName("options")
}

var _ protoreflect.Message = (*fastReflection_MsgSetValue)(nil)

type fastReflection_MsgSetValue MsgSetValue

func (x *MsgSetValue) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgSetValue)(x)
}

func (x *MsgSetValue) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgSetValue_messageType fastReflection_MsgSetValue_messageType
var _ protoreflect.MessageType = fastReflection_MsgSetValue_messageType{}

type fastReflection_MsgSetValue_messageType struct{}

func (x fastReflection_MsgSetValue_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgSetValue)(nil)
}
func (x fastReflection_MsgSetValue_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgSetValue)
}
func (x fastReflection_MsgSetValue_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgSetValue
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgSetValue) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgSetValue
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgSetValue) Type() protoreflect.MessageType {
	return _fastReflection_MsgSetValue_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgSetValue) New() protoreflect.Message {
	return new(fastReflection_MsgSetValue)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgSetValue) Interface() protoreflect.ProtoMessage {
	return (*MsgSetValue)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgSetValue) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgSetValue_creator, value) {
			return
		}
	}
	if x.MapId != "" {
		value := protoreflect.ValueOfString(x.MapId)
		if !f(fd_MsgSetValue_mapId, value) {
			return
		}
	}
	if x.Key != "" {
		value := protoreflect.ValueOfString(x.Key)
		if !f(fd_MsgSetValue_key, value) {
			return
		}
	}
	if x.Value != "" {
		value := protoreflect.ValueOfString(x.Value)
		if !f(fd_MsgSetValue_value, value) {
			return
		}
	}
	if x.Options != nil {
		value := protoreflect.ValueOfMessage(x.Options.ProtoReflect())
		if !f(fd_MsgSetValue_options, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgSetValue) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "maps.MsgSetValue.creator":
		return x.Creator != ""
	case "maps.MsgSetValue.mapId":
		return x.MapId != ""
	case "maps.MsgSetValue.key":
		return x.Key != ""
	case "maps.MsgSetValue.value":
		return x.Value != ""
	case "maps.MsgSetValue.options":
		return x.Options != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValue"))
		}
		panic(fmt.Errorf("message maps.MsgSetValue does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgSetValue) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "maps.MsgSetValue.creator":
		x.Creator = ""
	case "maps.MsgSetValue.mapId":
		x.MapId = ""
	case "maps.MsgSetValue.key":
		x.Key = ""
	case "maps.MsgSetValue.value":
		x.Value = ""
	case "maps.MsgSetValue.options":
		x.Options = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValue"))
		}
		panic(fmt.Errorf("message maps.MsgSetValue does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgSetValue) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "maps.MsgSetValue.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "maps.MsgSetValue.mapId":
		value := x.MapId
		return protoreflect.ValueOfString(value)
	case "maps.MsgSetValue.key":
		value := x.Key
		return protoreflect.ValueOfString(value)
	case "maps.MsgSetValue.value":
		value := x.Value
		return protoreflect.ValueOfString(value)
	case "maps.MsgSetValue.options":
		value := x.Options
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValue"))
		}
		panic(fmt.Errorf("message maps.MsgSetValue does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgSetValue) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "maps.MsgSetValue.creator":
		x.Creator = value.Interface().(string)
	case "maps.MsgSetValue.mapId":
		x.MapId = value.Interface().(string)
	case "maps.MsgSetValue.key":
		x.Key = value.Interface().(string)
	case "maps.MsgSetValue.value":
		x.Value = value.Interface().(string)
	case "maps.MsgSetValue.options":
		x.Options = value.Message().Interface().(*SetOptions)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValue"))
		}
		panic(fmt.Errorf("message maps.MsgSetValue does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgSetValue) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MsgSetValue.options":
		if x.Options == nil {
			x.Options = new(SetOptions)
		}
		return protoreflect.ValueOfMessage(x.Options.ProtoReflect())
	case "maps.MsgSetValue.creator":
		panic(fmt.Errorf("field creator of message maps.MsgSetValue is not mutable"))
	case "maps.MsgSetValue.mapId":
		panic(fmt.Errorf("field mapId of message maps.MsgSetValue is not mutable"))
	case "maps.MsgSetValue.key":
		panic(fmt.Errorf("field key of message maps.MsgSetValue is not mutable"))
	case "maps.MsgSetValue.value":
		panic(fmt.Errorf("field value of message maps.MsgSetValue is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValue"))
		}
		panic(fmt.Errorf("message maps.MsgSetValue does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgSetValue) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "maps.MsgSetValue.creator":
		return protoreflect.ValueOfString("")
	case "maps.MsgSetValue.mapId":
		return protoreflect.ValueOfString("")
	case "maps.MsgSetValue.key":
		return protoreflect.ValueOfString("")
	case "maps.MsgSetValue.value":
		return protoreflect.ValueOfString("")
	case "maps.MsgSetValue.options":
		m := new(SetOptions)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValue"))
		}
		panic(fmt.Errorf("message maps.MsgSetValue does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgSetValue) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MsgSetValue", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgSetValue) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgSetValue) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgSetValue) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgSetValue) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgSetValue)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MapId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Key)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Value)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Options != nil {
			l = options.Size(x.Options)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgSetValue)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Options != nil {
			encoded, err := options.Marshal(x.Options)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Value) > 0 {
			i -= len(x.Value)
			copy(dAtA[i:], x.Value)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Value)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Key) > 0 {
			i -= len(x.Key)
			copy(dAtA[i:], x.Key)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Key)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.MapId) > 0 {
			i -= len(x.MapId)
			copy(dAtA[i:], x.MapId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MapId)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgSetValue)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgSetValue: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgSetValue: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MapId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MapId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Key = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Value = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Options == nil {
					x.Options = &SetOptions{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Options); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgSetValueResponse protoreflect.MessageDescriptor
)

func init() {
	file_maps_tx_proto_init()
	md_MsgSetValueResponse = File_maps_tx_proto.Messages().ByName("MsgSetValueResponse")
}

var _ protoreflect.Message = (*fastReflection_MsgSetValueResponse)(nil)

type fastReflection_MsgSetValueResponse MsgSetValueResponse

func (x *MsgSetValueResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgSetValueResponse)(x)
}

func (x *MsgSetValueResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_maps_tx_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgSetValueResponse_messageType fastReflection_MsgSetValueResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgSetValueResponse_messageType{}

type fastReflection_MsgSetValueResponse_messageType struct{}

func (x fastReflection_MsgSetValueResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgSetValueResponse)(nil)
}
func (x fastReflection_MsgSetValueResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgSetValueResponse)
}
func (x fastReflection_MsgSetValueResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgSetValueResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgSetValueResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgSetValueResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgSetValueResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgSetValueResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgSetValueResponse) New() protoreflect.Message {
	return new(fastReflection_MsgSetValueResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgSetValueResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgSetValueResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgSetValueResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgSetValueResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValueResponse"))
		}
		panic(fmt.Errorf("message maps.MsgSetValueResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgSetValueResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValueResponse"))
		}
		panic(fmt.Errorf("message maps.MsgSetValueResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgSetValueResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValueResponse"))
		}
		panic(fmt.Errorf("message maps.MsgSetValueResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgSetValueResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValueResponse"))
		}
		panic(fmt.Errorf("message maps.MsgSetValueResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgSetValueResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValueResponse"))
		}
		panic(fmt.Errorf("message maps.MsgSetValueResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgSetValueResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: maps.MsgSetValueResponse"))
		}
		panic(fmt.Errorf("message maps.MsgSetValueResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgSetValueResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in maps.MsgSetValueResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgSetValueResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgSetValueResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgSetValueResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgSetValueResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgSetValueResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgSetValueResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgSetValueResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgSetValueResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgSetValueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: maps/tx.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the module parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params *Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params,omitempty"`
}

func (x *MsgUpdateParams) Reset() {
	*x = MsgUpdateParams{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateParams) ProtoMessage() {}

// Deprecated: Use MsgUpdateParams.ProtoReflect.Descriptor instead.
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{0}
}

func (x *MsgUpdateParams) GetAuthority() string {
	if x != nil {
		return x.Authority
	}
	return ""
}

func (x *MsgUpdateParams) GetParams() *Params {
	if x != nil {
		return x.Params
	}
	return nil
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *MsgUpdateParamsResponse) Reset() {
	*x = MsgUpdateParamsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateParamsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateParamsResponse) ProtoMessage() {}

// Deprecated: Use MsgUpdateParamsResponse.ProtoReflect.Descriptor instead.
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{1}
}

type MapCustomMsgType struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SetValueMsg  *MsgSetValue  `protobuf:"bytes,1,opt,name=setValueMsg,proto3" json:"setValueMsg,omitempty"`
	CreateMapMsg *MsgCreateMap `protobuf:"bytes,2,opt,name=createMapMsg,proto3" json:"createMapMsg,omitempty"`
	UpdateMapMsg *MsgUpdateMap `protobuf:"bytes,3,opt,name=updateMapMsg,proto3" json:"updateMapMsg,omitempty"`
	DeleteMapMsg *MsgDeleteMap `protobuf:"bytes,4,opt,name=deleteMapMsg,proto3" json:"deleteMapMsg,omitempty"`
}

func (x *MapCustomMsgType) Reset() {
	*x = MapCustomMsgType{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MapCustomMsgType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapCustomMsgType) ProtoMessage() {}

// Deprecated: Use MapCustomMsgType.ProtoReflect.Descriptor instead.
func (*MapCustomMsgType) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{2}
}

func (x *MapCustomMsgType) GetSetValueMsg() *MsgSetValue {
	if x != nil {
		return x.SetValueMsg
	}
	return nil
}

func (x *MapCustomMsgType) GetCreateMapMsg() *MsgCreateMap {
	if x != nil {
		return x.CreateMapMsg
	}
	return nil
}

func (x *MapCustomMsgType) GetUpdateMapMsg() *MsgUpdateMap {
	if x != nil {
		return x.UpdateMapMsg
	}
	return nil
}

func (x *MapCustomMsgType) GetDeleteMapMsg() *MsgDeleteMap {
	if x != nil {
		return x.DeleteMapMsg
	}
	return nil
}

type ValueStore struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key       string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value     string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	LastSetBy string `protobuf:"bytes,3,opt,name=lastSetBy,proto3" json:"lastSetBy,omitempty"`
}

func (x *ValueStore) Reset() {
	*x = ValueStore{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ValueStore) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValueStore) ProtoMessage() {}

// Deprecated: Use ValueStore.ProtoReflect.Descriptor instead.
func (*ValueStore) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{3}
}

func (x *ValueStore) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *ValueStore) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *ValueStore) GetLastSetBy() string {
	if x != nil {
		return x.LastSetBy
	}
	return ""
}

type MapUpdateCriteria struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// All ID slots are only updatable by manager
	ManagerOnly bool `protobuf:"varint,1,opt,name=managerOnly,proto3" json:"managerOnly,omitempty"`
	// ID slots are only updatable by badge ID owner of this collection (>1 balance at current time)
	CollectionId string `protobuf:"bytes,2,opt,name=collectionId,proto3" json:"collectionId,omitempty"`
	// Keys are address based and can only be updated by that respective address
	CreatorOnly bool `protobuf:"varint,3,opt,name=creatorOnly,proto3" json:"creatorOnly,omitempty"`
	// Claim slots. Can unclaim by setting to blank. Uses lastSetBy.
	FirstComeFirstServe bool `protobuf:"varint,4,opt,name=firstComeFirstServe,proto3" json:"firstComeFirstServe,omitempty"`
}

func (x *MapUpdateCriteria) Reset() {
	*x = MapUpdateCriteria{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MapUpdateCriteria) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapUpdateCriteria) ProtoMessage() {}

// Deprecated: Use MapUpdateCriteria.ProtoReflect.Descriptor instead.
func (*MapUpdateCriteria) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{4}
}

func (x *MapUpdateCriteria) GetManagerOnly() bool {
	if x != nil {
		return x.ManagerOnly
	}
	return false
}

func (x *MapUpdateCriteria) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MapUpdateCriteria) GetCreatorOnly() bool {
	if x != nil {
		return x.CreatorOnly
	}
	return false
}

func (x *MapUpdateCriteria) GetFirstComeFirstServe() bool {
	if x != nil {
		return x.FirstComeFirstServe
	}
	return false
}

type ValueOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NoDuplicates     bool `protobuf:"varint,1,opt,name=noDuplicates,proto3" json:"noDuplicates,omitempty"`
	PermanentOnceSet bool `protobuf:"varint,2,opt,name=permanentOnceSet,proto3" json:"permanentOnceSet,omitempty"`
	ExpectUint       bool `protobuf:"varint,3,opt,name=expectUint,proto3" json:"expectUint,omitempty"`
	ExpectBoolean    bool `protobuf:"varint,4,opt,name=expectBoolean,proto3" json:"expectBoolean,omitempty"`
	ExpectAddress    bool `protobuf:"varint,5,opt,name=expectAddress,proto3" json:"expectAddress,omitempty"`
	ExpectUri        bool `protobuf:"varint,6,opt,name=expectUri,proto3" json:"expectUri,omitempty"`
}

func (x *ValueOptions) Reset() {
	*x = ValueOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ValueOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValueOptions) ProtoMessage() {}

// Deprecated: Use ValueOptions.ProtoReflect.Descriptor instead.
func (*ValueOptions) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{5}
}

func (x *ValueOptions) GetNoDuplicates() bool {
	if x != nil {
		return x.NoDuplicates
	}
	return false
}

func (x *ValueOptions) GetPermanentOnceSet() bool {
	if x != nil {
		return x.PermanentOnceSet
	}
	return false
}

func (x *ValueOptions) GetExpectUint() bool {
	if x != nil {
		return x.ExpectUint
	}
	return false
}

func (x *ValueOptions) GetExpectBoolean() bool {
	if x != nil {
		return x.ExpectBoolean
	}
	return false
}

func (x *ValueOptions) GetExpectAddress() bool {
	if x != nil {
		return x.ExpectAddress
	}
	return false
}

func (x *ValueOptions) GetExpectUri() bool {
	if x != nil {
		return x.ExpectUri
	}
	return false
}

type MapPermissions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CanUpdateMetadata []*TimedUpdatePermission `protobuf:"bytes,1,rep,name=canUpdateMetadata,proto3" json:"canUpdateMetadata,omitempty"`
	CanUpdateManager  []*TimedUpdatePermission `protobuf:"bytes,2,rep,name=canUpdateManager,proto3" json:"canUpdateManager,omitempty"`
	CanDeleteMap      []*ActionPermission      `protobuf:"bytes,3,rep,name=canDeleteMap,proto3" json:"canDeleteMap,omitempty"`
}

func (x *MapPermissions) Reset() {
	*x = MapPermissions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MapPermissions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapPermissions) ProtoMessage() {}

// Deprecated: Use MapPermissions.ProtoReflect.Descriptor instead.
func (*MapPermissions) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{6}
}

func (x *MapPermissions) GetCanUpdateMetadata() []*TimedUpdatePermission {
	if x != nil {
		return x.CanUpdateMetadata
	}
	return nil
}

func (x *MapPermissions) GetCanUpdateManager() []*TimedUpdatePermission {
	if x != nil {
		return x.CanUpdateManager
	}
	return nil
}

func (x *MapPermissions) GetCanDeleteMap() []*ActionPermission {
	if x != nil {
		return x.CanDeleteMap
	}
	return nil
}

type Map struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator                    string             `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	MapId                      string             `protobuf:"bytes,2,opt,name=mapId,proto3" json:"mapId,omitempty"`
	InheritManagerTimelineFrom string             `protobuf:"bytes,3,opt,name=inheritManagerTimelineFrom,proto3" json:"inheritManagerTimelineFrom,omitempty"`
	ManagerTimeline            []*ManagerTimeline `protobuf:"bytes,4,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// config options that will not change at all
	UpdateCriteria   *MapUpdateCriteria     `protobuf:"bytes,5,opt,name=updateCriteria,proto3" json:"updateCriteria,omitempty"`
	ValueOptions     *ValueOptions          `protobuf:"bytes,6,opt,name=valueOptions,proto3" json:"valueOptions,omitempty"`
	DefaultValue     string                 `protobuf:"bytes,7,opt,name=defaultValue,proto3" json:"defaultValue,omitempty"`
	MetadataTimeline []*MapMetadataTimeline `protobuf:"bytes,10,rep,name=metadataTimeline,proto3" json:"metadataTimeline,omitempty"`
	Permissions      *MapPermissions        `protobuf:"bytes,11,opt,name=permissions,proto3" json:"permissions,omitempty"`
}

func (x *Map) Reset() {
	*x = Map{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Map) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Map) ProtoMessage() {}

// Deprecated: Use Map.ProtoReflect.Descriptor instead.
func (*Map) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{7}
}

func (x *Map) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *Map) GetMapId() string {
	if x != nil {
		return x.MapId
	}
	return ""
}

func (x *Map) GetInheritManagerTimelineFrom() string {
	if x != nil {
		return x.InheritManagerTimelineFrom
	}
	return ""
}

func (x *Map) GetManagerTimeline() []*ManagerTimeline {
	if x != nil {
		return x.ManagerTimeline
	}
	return nil
}

func (x *Map) GetUpdateCriteria() *MapUpdateCriteria {
	if x != nil {
		return x.UpdateCriteria
	}
	return nil
}

func (x *Map) GetValueOptions() *ValueOptions {
	if x != nil {
		return x.ValueOptions
	}
	return nil
}

func (x *Map) GetDefaultValue() string {
	if x != nil {
		return x.DefaultValue
	}
	return ""
}

func (x *Map) GetMetadataTimeline() []*MapMetadataTimeline {
	if x != nil {
		return x.MetadataTimeline
	}
	return nil
}

func (x *Map) GetPermissions() *MapPermissions {
	if x != nil {
		return x.Permissions
	}
	return nil
}

type MsgCreateMap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator                    string             `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	MapId                      string             `protobuf:"bytes,2,opt,name=mapId,proto3" json:"mapId,omitempty"`
	InheritManagerTimelineFrom string             `protobuf:"bytes,3,opt,name=inheritManagerTimelineFrom,proto3" json:"inheritManagerTimelineFrom,omitempty"`
	ManagerTimeline            []*ManagerTimeline `protobuf:"bytes,4,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// config options that will not change at all
	UpdateCriteria   *MapUpdateCriteria     `protobuf:"bytes,5,opt,name=updateCriteria,proto3" json:"updateCriteria,omitempty"`
	ValueOptions     *ValueOptions          `protobuf:"bytes,6,opt,name=valueOptions,proto3" json:"valueOptions,omitempty"`
	DefaultValue     string                 `protobuf:"bytes,7,opt,name=defaultValue,proto3" json:"defaultValue,omitempty"`
	MetadataTimeline []*MapMetadataTimeline `protobuf:"bytes,9,rep,name=metadataTimeline,proto3" json:"metadataTimeline,omitempty"`
	Permissions      *MapPermissions        `protobuf:"bytes,10,opt,name=permissions,proto3" json:"permissions,omitempty"`
}

func (x *MsgCreateMap) Reset() {
	*x = MsgCreateMap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgCreateMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgCreateMap) ProtoMessage() {}

// Deprecated: Use MsgCreateMap.ProtoReflect.Descriptor instead.
func (*MsgCreateMap) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{8}
}

func (x *MsgCreateMap) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgCreateMap) GetMapId() string {
	if x != nil {
		return x.MapId
	}
	return ""
}

func (x *MsgCreateMap) GetInheritManagerTimelineFrom() string {
	if x != nil {
		return x.InheritManagerTimelineFrom
	}
	return ""
}

func (x *MsgCreateMap) GetManagerTimeline() []*ManagerTimeline {
	if x != nil {
		return x.ManagerTimeline
	}
	return nil
}

func (x *MsgCreateMap) GetUpdateCriteria() *MapUpdateCriteria {
	if x != nil {
		return x.UpdateCriteria
	}
	return nil
}

func (x *MsgCreateMap) GetValueOptions() *ValueOptions {
	if x != nil {
		return x.ValueOptions
	}
	return nil
}

func (x *MsgCreateMap) GetDefaultValue() string {
	if x != nil {
		return x.DefaultValue
	}
	return ""
}

func (x *MsgCreateMap) GetMetadataTimeline() []*MapMetadataTimeline {
	if x != nil {
		return x.MetadataTimeline
	}
	return nil
}

func (x *MsgCreateMap) GetPermissions() *MapPermissions {
	if x != nil {
		return x.Permissions
	}
	return nil
}

type MsgCreateMapResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *MsgCreateMapResponse) Reset() {
	*x = MsgCreateMapResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgCreateMapResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgCreateMapResponse) ProtoMessage() {}

// Deprecated: Use MsgCreateMapResponse.ProtoReflect.Descriptor instead.
func (*MsgCreateMapResponse) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{9}
}

type MsgUpdateMap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator                string                 `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	MapId                  string                 `protobuf:"bytes,2,opt,name=mapId,proto3" json:"mapId,omitempty"`
	UpdateManagerTimeline  bool                   `protobuf:"varint,3,opt,name=updateManagerTimeline,proto3" json:"updateManagerTimeline,omitempty"`
	ManagerTimeline        []*ManagerTimeline     `protobuf:"bytes,4,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	UpdateMetadataTimeline bool                   `protobuf:"varint,7,opt,name=updateMetadataTimeline,proto3" json:"updateMetadataTimeline,omitempty"`
	MetadataTimeline       []*MapMetadataTimeline `protobuf:"bytes,8,rep,name=metadataTimeline,proto3" json:"metadataTimeline,omitempty"`
	UpdatePermissions      bool                   `protobuf:"varint,9,opt,name=updatePermissions,proto3" json:"updatePermissions,omitempty"`
	Permissions            *MapPermissions        `protobuf:"bytes,10,opt,name=permissions,proto3" json:"permissions,omitempty"`
}

func (x *MsgUpdateMap) Reset() {
	*x = MsgUpdateMap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateMap) ProtoMessage() {}

// Deprecated: Use MsgUpdateMap.ProtoReflect.Descriptor instead.
func (*MsgUpdateMap) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{10}
}

func (x *MsgUpdateMap) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgUpdateMap) GetMapId() string {
	if x != nil {
		return x.MapId
	}
	return ""
}

func (x *MsgUpdateMap) GetUpdateManagerTimeline() bool {
	if x != nil {
		return x.UpdateManagerTimeline
	}
	return false
}

func (x *MsgUpdateMap) GetManagerTimeline() []*ManagerTimeline {
	if x != nil {
		return x.ManagerTimeline
	}
	return nil
}

func (x *MsgUpdateMap) GetUpdateMetadataTimeline() bool {
	if x != nil {
		return x.UpdateMetadataTimeline
	}
	return false
}

func (x *MsgUpdateMap) GetMetadataTimeline() []*MapMetadataTimeline {
	if x != nil {
		return x.MetadataTimeline
	}
	return nil
}

func (x *MsgUpdateMap) GetUpdatePermissions() bool {
	if x != nil {
		return x.UpdatePermissions
	}
	return false
}

func (x *MsgUpdateMap) GetPermissions() *MapPermissions {
	if x != nil {
		return x.Permissions
	}
	return nil
}

type MsgUpdateMapResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *MsgUpdateMapResponse) Reset() {
	*x = MsgUpdateMapResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateMapResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateMapResponse) ProtoMessage() {}

// Deprecated: Use MsgUpdateMapResponse.ProtoReflect.Descriptor instead.
func (*MsgUpdateMapResponse) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{11}
}

type MsgDeleteMap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	MapId   string `protobuf:"bytes,2,opt,name=mapId,proto3" json:"mapId,omitempty"`
}

func (x *MsgDeleteMap) Reset() {
	*x = MsgDeleteMap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgDeleteMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgDeleteMap) ProtoMessage() {}

// Deprecated: Use MsgDeleteMap.ProtoReflect.Descriptor instead.
func (*MsgDeleteMap) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{12}
}

func (x *MsgDeleteMap) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgDeleteMap) GetMapId() string {
	if x != nil {
		return x.MapId
	}
	return ""
}

type MsgDeleteMapResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *MsgDeleteMapResponse) Reset() {
	*x = MsgDeleteMapResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgDeleteMapResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgDeleteMapResponse) ProtoMessage() {}

// Deprecated: Use MsgDeleteMapResponse.ProtoReflect.Descriptor instead.
func (*MsgDeleteMapResponse) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{13}
}

type SetOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UseMostRecentCollectionId bool `protobuf:"varint,1,opt,name=useMostRecentCollectionId,proto3" json:"useMostRecentCollectionId,omitempty"`
}

func (x *SetOptions) Reset() {
	*x = SetOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetOptions) ProtoMessage() {}

// Deprecated: Use SetOptions.ProtoReflect.Descriptor instead.
func (*SetOptions) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{14}
}

func (x *SetOptions) GetUseMostRecentCollectionId() bool {
	if x != nil {
		return x.UseMostRecentCollectionId
	}
	return false
}

type MsgSetValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator string      `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	MapId   string      `protobuf:"bytes,2,opt,name=mapId,proto3" json:"mapId,omitempty"`
	Key     string      `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Value   string      `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	Options *SetOptions `protobuf:"bytes,5,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *MsgSetValue) Reset() {
	*x = MsgSetValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgSetValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgSetValue) ProtoMessage() {}

// Deprecated: Use MsgSetValue.ProtoReflect.Descriptor instead.
func (*MsgSetValue) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{15}
}

func (x *MsgSetValue) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgSetValue) GetMapId() string {
	if x != nil {
		return x.MapId
	}
	return ""
}

func (x *MsgSetValue) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *MsgSetValue) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *MsgSetValue) GetOptions() *SetOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

type MsgSetValueResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *MsgSetValueResponse) Reset() {
	*x = MsgSetValueResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_maps_tx_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgSetValueResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgSetValueResponse) ProtoMessage() {}

// Deprecated: Use MsgSetValueResponse.ProtoReflect.Descriptor instead.
func (*MsgSetValueResponse) Descriptor() ([]byte, []int) {
	return file_maps_tx_proto_rawDescGZIP(), []int{16}
}

var File_maps_tx_proto protoreflect.FileDescriptor

var file_maps_tx_proto_rawDesc = []byte{
	0x0a, 0x0d, 0x6d, 0x61, 0x70, 0x73, 0x2f, 0x74, 0x78, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x04, 0x6d, 0x61, 0x70, 0x73, 0x1a, 0x11, 0x61, 0x6d, 0x69, 0x6e, 0x6f, 0x2f, 0x61, 0x6d, 0x69,
	0x6e, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2f, 0x6d, 0x73, 0x67, 0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x73, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x1a, 0x19, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x14, 0x67, 0x6f,
	0x67, 0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x1a, 0x16, 0x6d, 0x61, 0x70, 0x73, 0x2f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73,
	0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x14, 0x6d, 0x61, 0x70, 0x73,
	0x2f, 0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x13, 0x6d, 0x61, 0x70, 0x73, 0x2f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x11, 0x6d, 0x61, 0x70, 0x73, 0x2f, 0x70, 0x61, 0x72, 0x61,
	0x6d, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xa3, 0x01, 0x0a, 0x0f, 0x4d, 0x73, 0x67,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x12, 0x36, 0x0a, 0x09,
	0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x09, 0x61, 0x75, 0x74, 0x68, 0x6f,
	0x72, 0x69, 0x74, 0x79, 0x12, 0x2f, 0x0a, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x50, 0x61, 0x72, 0x61,
	0x6d, 0x73, 0x42, 0x09, 0xc8, 0xde, 0x1f, 0x00, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x06, 0x70,
	0x61, 0x72, 0x61, 0x6d, 0x73, 0x3a, 0x27, 0x82, 0xe7, 0xb0, 0x2a, 0x09, 0x61, 0x75, 0x74, 0x68,
	0x6f, 0x72, 0x69, 0x74, 0x79, 0x8a, 0xe7, 0xb0, 0x2a, 0x14, 0x6d, 0x61, 0x70, 0x73, 0x2f, 0x4d,
	0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x22, 0x19,
	0x0a, 0x17, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0xef, 0x01, 0x0a, 0x10, 0x4d, 0x61,
	0x70, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x4d, 0x73, 0x67, 0x54, 0x79, 0x70, 0x65, 0x12, 0x33,
	0x0a, 0x0b, 0x73, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4d, 0x73, 0x67, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x73, 0x67, 0x53, 0x65,
	0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x0b, 0x73, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x4d, 0x73, 0x67, 0x12, 0x36, 0x0a, 0x0c, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x70,
	0x4d, 0x73, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x61, 0x70, 0x73,
	0x2e, 0x4d, 0x73, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x52, 0x0c, 0x63,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x4d, 0x73, 0x67, 0x12, 0x36, 0x0a, 0x0c, 0x75,
	0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x4d, 0x73, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x4d, 0x61, 0x70, 0x52, 0x0c, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x70,
	0x4d, 0x73, 0x67, 0x12, 0x36, 0x0a, 0x0c, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x70,
	0x4d, 0x73, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x61, 0x70, 0x73,
	0x2e, 0x4d, 0x73, 0x67, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x52, 0x0c, 0x64,
	0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x4d, 0x73, 0x67, 0x22, 0x52, 0x0a, 0x0a, 0x56,
	0x61, 0x6c, 0x75, 0x65, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
	0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x53, 0x65, 0x74, 0x42, 0x79, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x53, 0x65, 0x74, 0x42, 0x79, 0x22,
	0xbb, 0x01, 0x0a, 0x11, 0x4d, 0x61, 0x70, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x72, 0x69,
	0x74, 0x65, 0x72, 0x69, 0x61, 0x12, 0x20, 0x0a, 0x0b, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72,
	0x4f, 0x6e, 0x6c, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x6d, 0x61, 0x6e, 0x61,
	0x67, 0x65, 0x72, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x30, 0x0a, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x0c, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0c, 0x63, 0x6f, 0x6c,
	0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x20, 0x0a, 0x0b, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x6f, 0x72, 0x4f, 0x6e, 0x6c, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b,
	0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x30, 0x0a, 0x13, 0x66,
	0x69, 0x72, 0x73, 0x74, 0x43, 0x6f, 0x6d, 0x65, 0x46, 0x69, 0x72, 0x73, 0x74, 0x53, 0x65, 0x72,
	0x76, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x13, 0x66, 0x69, 0x72, 0x73, 0x74, 0x43,
	0x6f, 0x6d, 0x65, 0x46, 0x69, 0x72, 0x73, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x22, 0xe8, 0x01,
	0x0a, 0x0c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x22,
	0x0a, 0x0c, 0x6e, 0x6f, 0x44, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x6e, 0x6f, 0x44, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74,
	0x65, 0x73, 0x12, 0x2a, 0x0a, 0x10, 0x70, 0x65, 0x72, 0x6d, 0x61, 0x6e, 0x65, 0x6e, 0x74, 0x4f,
	0x6e, 0x63, 0x65, 0x53, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10, 0x70, 0x65,
	0x72, 0x6d, 0x61, 0x6e, 0x65, 0x6e, 0x74, 0x4f, 0x6e, 0x63, 0x65, 0x53, 0x65, 0x74, 0x12, 0x1e,
	0x0a, 0x0a, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x55, 0x69, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x0a, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x55, 0x69, 0x6e, 0x74, 0x12, 0x24,
	0x0a, 0x0d, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x42, 0x6f, 0x6f,
	0x6c, 0x65, 0x61, 0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x41, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x65, 0x78, 0x70,
	0x65, 0x63, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x65, 0x78,
	0x70, 0x65, 0x63, 0x74, 0x55, 0x72, 0x69, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x65,
	0x78, 0x70, 0x65, 0x63, 0x74, 0x55, 0x72, 0x69, 0x22, 0xe0, 0x01, 0x0a, 0x0e, 0x4d, 0x61, 0x70,
	0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x49, 0x0a, 0x11, 0x63,
	0x61, 0x6e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x54, 0x69,
	0x6d, 0x65, 0x64, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73,
	0x69, 0x6f, 0x6e, 0x52, 0x11, 0x63, 0x61, 0x6e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x47, 0x0a, 0x10, 0x63, 0x61, 0x6e, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x1b, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x64, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x10, 0x63,
	0x61, 0x6e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x12,
	0x3a, 0x0a, 0x0c, 0x63, 0x61, 0x6e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x18,
	0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x41, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x63,
	0x61, 0x6e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x22, 0xe0, 0x03, 0x0a, 0x03,
	0x4d, 0x61, 0x70, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x14, 0x0a,
	0x05, 0x6d, 0x61, 0x70, 0x49, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x61,
	0x70, 0x49, 0x64, 0x12, 0x4c, 0x0a, 0x1a, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x4d, 0x61,
	0x6e, 0x61, 0x67, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x72, 0x6f,
	0x6d, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f,
	0x04, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x1a, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x4d, 0x61,
	0x6e, 0x61, 0x67, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x72, 0x6f,
	0x6d, 0x12, 0x3f, 0x0a, 0x0f, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65,
	0x6c, 0x69, 0x6e, 0x65, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x70,
	0x73, 0x2e, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e,
	0x65, 0x52, 0x0f, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69,
	0x6e, 0x65, 0x12, 0x3f, 0x0a, 0x0e, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x72, 0x69, 0x74,
	0x65, 0x72, 0x69, 0x61, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x61, 0x70,
	0x73, 0x2e, 0x4d, 0x61, 0x70, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x72, 0x69, 0x74, 0x65,
	0x72, 0x69, 0x61, 0x52, 0x0e, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x72, 0x69, 0x74, 0x65,
	0x72, 0x69, 0x61, 0x12, 0x36, 0x0a, 0x0c, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x4f, 0x70, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x61, 0x70, 0x73,
	0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x0c, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x22, 0x0a, 0x0c, 0x64,
	0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0c, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12,
	0x45, 0x0a, 0x10, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x54, 0x69, 0x6d, 0x65, 0x6c,
	0x69, 0x6e, 0x65, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x61, 0x70, 0x73,
	0x2e, 0x4d, 0x61, 0x70, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x54, 0x69, 0x6d, 0x65,
	0x6c, 0x69, 0x6e, 0x65, 0x52, 0x10, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x54, 0x69,
	0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x36, 0x0a, 0x0b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73,
	0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61,
	0x70, 0x73, 0x2e, 0x4d, 0x61, 0x70, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e,
	0x73, 0x52, 0x0b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0x8a,
	0x04, 0x0a, 0x0c, 0x4d, 0x73, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x12,
	0x18, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x61, 0x70,
	0x49, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x61, 0x70, 0x49, 0x64, 0x12,
	0x4c, 0x0a, 0x1a, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65,
	0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x04, 0x55, 0x69, 0x6e,
	0x74, 0x52, 0x1a, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65,
	0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x12, 0x3f, 0x0a,
	0x0f, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65,
	0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x61,
	0x6e, 0x61, 0x67, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x0f, 0x6d,
	0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x3f,
	0x0a, 0x0e, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x61,
	0x70, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x52,
	0x0e, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x12,
	0x36, 0x0a, 0x0c, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x56, 0x61, 0x6c,
	0x75, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x0c, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x22, 0x0a, 0x0c, 0x64, 0x65, 0x66, 0x61, 0x75,
	0x6c, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x64,
	0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x45, 0x0a, 0x10, 0x6d,
	0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x18,
	0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x61, 0x70,
	0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65,
	0x52, 0x10, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69,
	0x6e, 0x65, 0x12, 0x36, 0x0a, 0x0b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e,
	0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d,
	0x61, 0x70, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x0b, 0x70,
	0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x3a, 0x1f, 0x82, 0xe7, 0xb0, 0x2a,
	0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x0e, 0x6d, 0x61, 0x70,
	0x73, 0x2f, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x22, 0x16, 0x0a, 0x14, 0x4d,
	0x73, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x22, 0xbb, 0x03, 0x0a, 0x0c, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74,
	0x65, 0x4d, 0x61, 0x70, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x14,
	0x0a, 0x05, 0x6d, 0x61, 0x70, 0x49, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d,
	0x61, 0x70, 0x49, 0x64, 0x12, 0x34, 0x0a, 0x15, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x61,
	0x6e, 0x61, 0x67, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x15, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x6e, 0x61, 0x67,
	0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x3f, 0x0a, 0x0f, 0x6d, 0x61,
	0x6e, 0x61, 0x67, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x04, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x61, 0x6e, 0x61, 0x67,
	0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x0f, 0x6d, 0x61, 0x6e, 0x61,
	0x67, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x36, 0x0a, 0x16, 0x75,
	0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x54, 0x69, 0x6d,
	0x65, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x16, 0x75, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x54, 0x69, 0x6d, 0x65, 0x6c,
	0x69, 0x6e, 0x65, 0x12, 0x45, 0x0a, 0x10, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x54,
	0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e,
	0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x61, 0x70, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
	0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x10, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61,
	0x74, 0x61, 0x54, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x2c, 0x0a, 0x11, 0x75, 0x70,
	0x64, 0x61, 0x74, 0x65, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18,
	0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x65, 0x72,
	0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x36, 0x0a, 0x0b, 0x70, 0x65, 0x72, 0x6d,
	0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e,
	0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x61, 0x70, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x73, 0x52, 0x0b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73,
	0x3a, 0x1f, 0x82, 0xe7, 0xb0, 0x2a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7,
	0xb0, 0x2a, 0x0e, 0x6d, 0x61, 0x70, 0x73, 0x2f, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x61,
	0x70, 0x22, 0x16, 0x0a, 0x14, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x61,
	0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x5f, 0x0a, 0x0c, 0x4d, 0x73, 0x67,
	0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x61, 0x70, 0x49, 0x64, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x05, 0x6d, 0x61, 0x70, 0x49, 0x64, 0x3a, 0x1f, 0x82, 0xe7, 0xb0, 0x2a, 0x07,
	0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x0e, 0x6d, 0x61, 0x70, 0x73,
	0x2f, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x22, 0x16, 0x0a, 0x14, 0x4d, 0x73,
	0x67, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x4a, 0x0a, 0x0a, 0x53, 0x65, 0x74, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x12, 0x3c, 0x0a, 0x19, 0x75, 0x73, 0x65, 0x4d, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x63, 0x65, 0x6e,
	0x74, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x19, 0x75, 0x73, 0x65, 0x4d, 0x6f, 0x73, 0x74, 0x52, 0x65, 0x63, 0x65,
	0x6e, 0x74, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0xb1,
	0x01, 0x0a, 0x0b, 0x4d, 0x73, 0x67, 0x53, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x18,
	0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x61, 0x70, 0x49,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x61, 0x70, 0x49, 0x64, 0x12, 0x10,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x2a, 0x0a, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x53,
	0x65, 0x74, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x3a, 0x1e, 0x82, 0xe7, 0xb0, 0x2a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72,
	0x8a, 0xe7, 0xb0, 0x2a, 0x0d, 0x6d, 0x61, 0x70, 0x73, 0x2f, 0x53, 0x65, 0x74, 0x56, 0x61, 0x6c,
	0x75, 0x65, 0x22, 0x15, 0x0a, 0x13, 0x4d, 0x73, 0x67, 0x53, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x75,
	0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x32, 0xc3, 0x02, 0x0a, 0x03, 0x4d, 0x73,
	0x67, 0x12, 0x44, 0x0a, 0x0c, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x73, 0x12, 0x15, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x1a, 0x1d, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e,
	0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3b, 0x0a, 0x09, 0x43, 0x72, 0x65, 0x61, 0x74,
	0x65, 0x4d, 0x61, 0x70, 0x12, 0x12, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x73, 0x67, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x1a, 0x1a, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e,
	0x4d, 0x73, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3b, 0x0a, 0x09, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x61,
	0x70, 0x12, 0x12, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x4d, 0x61, 0x70, 0x1a, 0x1a, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x73, 0x67,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x3b, 0x0a, 0x09, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x12, 0x12,
	0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x73, 0x67, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d,
	0x61, 0x70, 0x1a, 0x1a, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x73, 0x67, 0x44, 0x65, 0x6c,
	0x65, 0x74, 0x65, 0x4d, 0x61, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x38,
	0x0a, 0x08, 0x53, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x11, 0x2e, 0x6d, 0x61, 0x70,
	0x73, 0x2e, 0x4d, 0x73, 0x67, 0x53, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x1a, 0x19, 0x2e,
	0x6d, 0x61, 0x70, 0x73, 0x2e, 0x4d, 0x73, 0x67, 0x53, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x1a, 0x05, 0x80, 0xe7, 0xb0, 0x2a, 0x01, 0x42,
	0x5c, 0x0a, 0x08, 0x63, 0x6f, 0x6d, 0x2e, 0x6d, 0x61, 0x70, 0x73, 0x42, 0x07, 0x54, 0x78, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x17, 0x62, 0x69, 0x74, 0x62, 0x61, 0x64, 0x67, 0x65,
	0x73, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x6d, 0x61, 0x70, 0x73, 0xa2,
	0x02, 0x03, 0x4d, 0x58, 0x58, 0xaa, 0x02, 0x04, 0x4d, 0x61, 0x70, 0x73, 0xca, 0x02, 0x04, 0x4d,
	0x61, 0x70, 0x73, 0xe2, 0x02, 0x10, 0x4d, 0x61, 0x70, 0x73, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65,
	0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x04, 0x4d, 0x61, 0x70, 0x73, 0x62, 0x06, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_maps_tx_proto_rawDescOnce sync.Once
	file_maps_tx_proto_rawDescData = file_maps_tx_proto_rawDesc
)

func file_maps_tx_proto_rawDescGZIP() []byte {
	file_maps_tx_proto_rawDescOnce.Do(func() {
		file_maps_tx_proto_rawDescData = protoimpl.X.CompressGZIP(file_maps_tx_proto_rawDescData)
	})
	return file_maps_tx_proto_rawDescData
}

var file_maps_tx_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_maps_tx_proto_goTypes = []interface{}{
	(*MsgUpdateParams)(nil),         // 0: maps.MsgUpdateParams
	(*MsgUpdateParamsResponse)(nil), // 1: maps.MsgUpdateParamsResponse
	(*MapCustomMsgType)(nil),        // 2: maps.MapCustomMsgType
	(*ValueStore)(nil),              // 3: maps.ValueStore
	(*MapUpdateCriteria)(nil),       // 4: maps.MapUpdateCriteria
	(*ValueOptions)(nil),            // 5: maps.ValueOptions
	(*MapPermissions)(nil),          // 6: maps.MapPermissions
	(*Map)(nil),                     // 7: maps.Map
	(*MsgCreateMap)(nil),            // 8: maps.MsgCreateMap
	(*MsgCreateMapResponse)(nil),    // 9: maps.MsgCreateMapResponse
	(*MsgUpdateMap)(nil),            // 10: maps.MsgUpdateMap
	(*MsgUpdateMapResponse)(nil),    // 11: maps.MsgUpdateMapResponse
	(*MsgDeleteMap)(nil),            // 12: maps.MsgDeleteMap
	(*MsgDeleteMapResponse)(nil),    // 13: maps.MsgDeleteMapResponse
	(*SetOptions)(nil),              // 14: maps.SetOptions
	(*MsgSetValue)(nil),             // 15: maps.MsgSetValue
	(*MsgSetValueResponse)(nil),     // 16: maps.MsgSetValueResponse
	(*Params)(nil),                  // 17: maps.Params
	(*TimedUpdatePermission)(nil),   // 18: maps.TimedUpdatePermission
	(*ActionPermission)(nil),        // 19: maps.ActionPermission
	(*ManagerTimeline)(nil),         // 20: maps.ManagerTimeline
	(*MapMetadataTimeline)(nil),     // 21: maps.MapMetadataTimeline
}
var file_maps_tx_proto_depIdxs = []int32{
	17, // 0: maps.MsgUpdateParams.params:type_name -> maps.Params
	15, // 1: maps.MapCustomMsgType.setValueMsg:type_name -> maps.MsgSetValue
	8,  // 2: maps.MapCustomMsgType.createMapMsg:type_name -> maps.MsgCreateMap
	10, // 3: maps.MapCustomMsgType.updateMapMsg:type_name -> maps.MsgUpdateMap
	12, // 4: maps.MapCustomMsgType.deleteMapMsg:type_name -> maps.MsgDeleteMap
	18, // 5: maps.MapPermissions.canUpdateMetadata:type_name -> maps.TimedUpdatePermission
	18, // 6: maps.MapPermissions.canUpdateManager:type_name -> maps.TimedUpdatePermission
	19, // 7: maps.MapPermissions.canDeleteMap:type_name -> maps.ActionPermission
	20, // 8: maps.Map.managerTimeline:type_name -> maps.ManagerTimeline
	4,  // 9: maps.Map.updateCriteria:type_name -> maps.MapUpdateCriteria
	5,  // 10: maps.Map.valueOptions:type_name -> maps.ValueOptions
	21, // 11: maps.Map.metadataTimeline:type_name -> maps.MapMetadataTimeline
	6,  // 12: maps.Map.permissions:type_name -> maps.MapPermissions
	20, // 13: maps.MsgCreateMap.managerTimeline:type_name -> maps.ManagerTimeline
	4,  // 14: maps.MsgCreateMap.updateCriteria:type_name -> maps.MapUpdateCriteria
	5,  // 15: maps.MsgCreateMap.valueOptions:type_name -> maps.ValueOptions
	21, // 16: maps.MsgCreateMap.metadataTimeline:type_name -> maps.MapMetadataTimeline
	6,  // 17: maps.MsgCreateMap.permissions:type_name -> maps.MapPermissions
	20, // 18: maps.MsgUpdateMap.managerTimeline:type_name -> maps.ManagerTimeline
	21, // 19: maps.MsgUpdateMap.metadataTimeline:type_name -> maps.MapMetadataTimeline
	6,  // 20: maps.MsgUpdateMap.permissions:type_name -> maps.MapPermissions
	14, // 21: maps.MsgSetValue.options:type_name -> maps.SetOptions
	0,  // 22: maps.Msg.UpdateParams:input_type -> maps.MsgUpdateParams
	8,  // 23: maps.Msg.CreateMap:input_type -> maps.MsgCreateMap
	10, // 24: maps.Msg.UpdateMap:input_type -> maps.MsgUpdateMap
	12, // 25: maps.Msg.DeleteMap:input_type -> maps.MsgDeleteMap
	15, // 26: maps.Msg.SetValue:input_type -> maps.MsgSetValue
	1,  // 27: maps.Msg.UpdateParams:output_type -> maps.MsgUpdateParamsResponse
	9,  // 28: maps.Msg.CreateMap:output_type -> maps.MsgCreateMapResponse
	11, // 29: maps.Msg.UpdateMap:output_type -> maps.MsgUpdateMapResponse
	13, // 30: maps.Msg.DeleteMap:output_type -> maps.MsgDeleteMapResponse
	16, // 31: maps.Msg.SetValue:output_type -> maps.MsgSetValueResponse
	27, // [27:32] is the sub-list for method output_type
	22, // [22:27] is the sub-list for method input_type
	22, // [22:22] is the sub-list for extension type_name
	22, // [22:22] is the sub-list for extension extendee
	0,  // [0:22] is the sub-list for field type_name
}

func init() { file_maps_tx_proto_init() }
func file_maps_tx_proto_init() {
	if File_maps_tx_proto != nil {
		return
	}
	file_maps_permissions_proto_init()
	file_maps_timelines_proto_init()
	file_maps_balances_proto_init()
	file_maps_params_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_maps_tx_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateParams); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateParamsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MapCustomMsgType); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ValueStore); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MapUpdateCriteria); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ValueOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MapPermissions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Map); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgCreateMap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgCreateMapResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateMap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateMapResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgDeleteMap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgDeleteMapResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgSetValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_maps_tx_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgSetValueResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_maps_tx_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_maps_tx_proto_goTypes,
		DependencyIndexes: file_maps_tx_proto_depIdxs,
		MessageInfos:      file_maps_tx_proto_msgTypes,
	}.Build()
	File_maps_tx_proto = out.File
	file_maps_tx_proto_rawDesc = nil
	file_maps_tx_proto_goTypes = nil
	file_maps_tx_proto_depIdxs = nil
}
