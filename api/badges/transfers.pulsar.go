// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package badges

import (
	v1beta1 "cosmossdk.io/api/cosmos/base/v1beta1"
	fmt "fmt"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	reflect "reflect"
	sync "sync"
)

var _ protoreflect.List = (*_UserBalanceStore_1_list)(nil)

type _UserBalanceStore_1_list struct {
	list *[]*Balance
}

func (x *_UserBalanceStore_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_UserBalanceStore_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_UserBalanceStore_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Balance)
	(*x.list)[i] = concreteValue
}

func (x *_UserBalanceStore_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Balance)
	*x.list = append(*x.list, concreteValue)
}

func (x *_UserBalanceStore_1_list) AppendMutable() protoreflect.Value {
	v := new(Balance)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserBalanceStore_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_UserBalanceStore_1_list) NewElement() protoreflect.Value {
	v := new(Balance)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserBalanceStore_1_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_UserBalanceStore_2_list)(nil)

type _UserBalanceStore_2_list struct {
	list *[]*UserOutgoingApproval
}

func (x *_UserBalanceStore_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_UserBalanceStore_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_UserBalanceStore_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UserOutgoingApproval)
	(*x.list)[i] = concreteValue
}

func (x *_UserBalanceStore_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UserOutgoingApproval)
	*x.list = append(*x.list, concreteValue)
}

func (x *_UserBalanceStore_2_list) AppendMutable() protoreflect.Value {
	v := new(UserOutgoingApproval)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserBalanceStore_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_UserBalanceStore_2_list) NewElement() protoreflect.Value {
	v := new(UserOutgoingApproval)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserBalanceStore_2_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_UserBalanceStore_3_list)(nil)

type _UserBalanceStore_3_list struct {
	list *[]*UserIncomingApproval
}

func (x *_UserBalanceStore_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_UserBalanceStore_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_UserBalanceStore_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UserIncomingApproval)
	(*x.list)[i] = concreteValue
}

func (x *_UserBalanceStore_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UserIncomingApproval)
	*x.list = append(*x.list, concreteValue)
}

func (x *_UserBalanceStore_3_list) AppendMutable() protoreflect.Value {
	v := new(UserIncomingApproval)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserBalanceStore_3_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_UserBalanceStore_3_list) NewElement() protoreflect.Value {
	v := new(UserIncomingApproval)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserBalanceStore_3_list) IsValid() bool {
	return x.list != nil
}

var (
	md_UserBalanceStore                                           protoreflect.MessageDescriptor
	fd_UserBalanceStore_balances                                  protoreflect.FieldDescriptor
	fd_UserBalanceStore_outgoingApprovals                         protoreflect.FieldDescriptor
	fd_UserBalanceStore_incomingApprovals                         protoreflect.FieldDescriptor
	fd_UserBalanceStore_autoApproveSelfInitiatedOutgoingTransfers protoreflect.FieldDescriptor
	fd_UserBalanceStore_autoApproveSelfInitiatedIncomingTransfers protoreflect.FieldDescriptor
	fd_UserBalanceStore_userPermissions                           protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_UserBalanceStore = File_badges_transfers_proto.Messages().ByName("UserBalanceStore")
	fd_UserBalanceStore_balances = md_UserBalanceStore.Fields().ByName("balances")
	fd_UserBalanceStore_outgoingApprovals = md_UserBalanceStore.Fields().ByName("outgoingApprovals")
	fd_UserBalanceStore_incomingApprovals = md_UserBalanceStore.Fields().ByName("incomingApprovals")
	fd_UserBalanceStore_autoApproveSelfInitiatedOutgoingTransfers = md_UserBalanceStore.Fields().ByName("autoApproveSelfInitiatedOutgoingTransfers")
	fd_UserBalanceStore_autoApproveSelfInitiatedIncomingTransfers = md_UserBalanceStore.Fields().ByName("autoApproveSelfInitiatedIncomingTransfers")
	fd_UserBalanceStore_userPermissions = md_UserBalanceStore.Fields().ByName("userPermissions")
}

var _ protoreflect.Message = (*fastReflection_UserBalanceStore)(nil)

type fastReflection_UserBalanceStore UserBalanceStore

func (x *UserBalanceStore) ProtoReflect() protoreflect.Message {
	return (*fastReflection_UserBalanceStore)(x)
}

func (x *UserBalanceStore) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_UserBalanceStore_messageType fastReflection_UserBalanceStore_messageType
var _ protoreflect.MessageType = fastReflection_UserBalanceStore_messageType{}

type fastReflection_UserBalanceStore_messageType struct{}

func (x fastReflection_UserBalanceStore_messageType) Zero() protoreflect.Message {
	return (*fastReflection_UserBalanceStore)(nil)
}
func (x fastReflection_UserBalanceStore_messageType) New() protoreflect.Message {
	return new(fastReflection_UserBalanceStore)
}
func (x fastReflection_UserBalanceStore_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_UserBalanceStore
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_UserBalanceStore) Descriptor() protoreflect.MessageDescriptor {
	return md_UserBalanceStore
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_UserBalanceStore) Type() protoreflect.MessageType {
	return _fastReflection_UserBalanceStore_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_UserBalanceStore) New() protoreflect.Message {
	return new(fastReflection_UserBalanceStore)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_UserBalanceStore) Interface() protoreflect.ProtoMessage {
	return (*UserBalanceStore)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_UserBalanceStore) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Balances) != 0 {
		value := protoreflect.ValueOfList(&_UserBalanceStore_1_list{list: &x.Balances})
		if !f(fd_UserBalanceStore_balances, value) {
			return
		}
	}
	if len(x.OutgoingApprovals) != 0 {
		value := protoreflect.ValueOfList(&_UserBalanceStore_2_list{list: &x.OutgoingApprovals})
		if !f(fd_UserBalanceStore_outgoingApprovals, value) {
			return
		}
	}
	if len(x.IncomingApprovals) != 0 {
		value := protoreflect.ValueOfList(&_UserBalanceStore_3_list{list: &x.IncomingApprovals})
		if !f(fd_UserBalanceStore_incomingApprovals, value) {
			return
		}
	}
	if x.AutoApproveSelfInitiatedOutgoingTransfers != false {
		value := protoreflect.ValueOfBool(x.AutoApproveSelfInitiatedOutgoingTransfers)
		if !f(fd_UserBalanceStore_autoApproveSelfInitiatedOutgoingTransfers, value) {
			return
		}
	}
	if x.AutoApproveSelfInitiatedIncomingTransfers != false {
		value := protoreflect.ValueOfBool(x.AutoApproveSelfInitiatedIncomingTransfers)
		if !f(fd_UserBalanceStore_autoApproveSelfInitiatedIncomingTransfers, value) {
			return
		}
	}
	if x.UserPermissions != nil {
		value := protoreflect.ValueOfMessage(x.UserPermissions.ProtoReflect())
		if !f(fd_UserBalanceStore_userPermissions, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_UserBalanceStore) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.UserBalanceStore.balances":
		return len(x.Balances) != 0
	case "badges.UserBalanceStore.outgoingApprovals":
		return len(x.OutgoingApprovals) != 0
	case "badges.UserBalanceStore.incomingApprovals":
		return len(x.IncomingApprovals) != 0
	case "badges.UserBalanceStore.autoApproveSelfInitiatedOutgoingTransfers":
		return x.AutoApproveSelfInitiatedOutgoingTransfers != false
	case "badges.UserBalanceStore.autoApproveSelfInitiatedIncomingTransfers":
		return x.AutoApproveSelfInitiatedIncomingTransfers != false
	case "badges.UserBalanceStore.userPermissions":
		return x.UserPermissions != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserBalanceStore"))
		}
		panic(fmt.Errorf("message badges.UserBalanceStore does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserBalanceStore) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.UserBalanceStore.balances":
		x.Balances = nil
	case "badges.UserBalanceStore.outgoingApprovals":
		x.OutgoingApprovals = nil
	case "badges.UserBalanceStore.incomingApprovals":
		x.IncomingApprovals = nil
	case "badges.UserBalanceStore.autoApproveSelfInitiatedOutgoingTransfers":
		x.AutoApproveSelfInitiatedOutgoingTransfers = false
	case "badges.UserBalanceStore.autoApproveSelfInitiatedIncomingTransfers":
		x.AutoApproveSelfInitiatedIncomingTransfers = false
	case "badges.UserBalanceStore.userPermissions":
		x.UserPermissions = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserBalanceStore"))
		}
		panic(fmt.Errorf("message badges.UserBalanceStore does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_UserBalanceStore) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.UserBalanceStore.balances":
		if len(x.Balances) == 0 {
			return protoreflect.ValueOfList(&_UserBalanceStore_1_list{})
		}
		listValue := &_UserBalanceStore_1_list{list: &x.Balances}
		return protoreflect.ValueOfList(listValue)
	case "badges.UserBalanceStore.outgoingApprovals":
		if len(x.OutgoingApprovals) == 0 {
			return protoreflect.ValueOfList(&_UserBalanceStore_2_list{})
		}
		listValue := &_UserBalanceStore_2_list{list: &x.OutgoingApprovals}
		return protoreflect.ValueOfList(listValue)
	case "badges.UserBalanceStore.incomingApprovals":
		if len(x.IncomingApprovals) == 0 {
			return protoreflect.ValueOfList(&_UserBalanceStore_3_list{})
		}
		listValue := &_UserBalanceStore_3_list{list: &x.IncomingApprovals}
		return protoreflect.ValueOfList(listValue)
	case "badges.UserBalanceStore.autoApproveSelfInitiatedOutgoingTransfers":
		value := x.AutoApproveSelfInitiatedOutgoingTransfers
		return protoreflect.ValueOfBool(value)
	case "badges.UserBalanceStore.autoApproveSelfInitiatedIncomingTransfers":
		value := x.AutoApproveSelfInitiatedIncomingTransfers
		return protoreflect.ValueOfBool(value)
	case "badges.UserBalanceStore.userPermissions":
		value := x.UserPermissions
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserBalanceStore"))
		}
		panic(fmt.Errorf("message badges.UserBalanceStore does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserBalanceStore) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.UserBalanceStore.balances":
		lv := value.List()
		clv := lv.(*_UserBalanceStore_1_list)
		x.Balances = *clv.list
	case "badges.UserBalanceStore.outgoingApprovals":
		lv := value.List()
		clv := lv.(*_UserBalanceStore_2_list)
		x.OutgoingApprovals = *clv.list
	case "badges.UserBalanceStore.incomingApprovals":
		lv := value.List()
		clv := lv.(*_UserBalanceStore_3_list)
		x.IncomingApprovals = *clv.list
	case "badges.UserBalanceStore.autoApproveSelfInitiatedOutgoingTransfers":
		x.AutoApproveSelfInitiatedOutgoingTransfers = value.Bool()
	case "badges.UserBalanceStore.autoApproveSelfInitiatedIncomingTransfers":
		x.AutoApproveSelfInitiatedIncomingTransfers = value.Bool()
	case "badges.UserBalanceStore.userPermissions":
		x.UserPermissions = value.Message().Interface().(*UserPermissions)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserBalanceStore"))
		}
		panic(fmt.Errorf("message badges.UserBalanceStore does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserBalanceStore) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.UserBalanceStore.balances":
		if x.Balances == nil {
			x.Balances = []*Balance{}
		}
		value := &_UserBalanceStore_1_list{list: &x.Balances}
		return protoreflect.ValueOfList(value)
	case "badges.UserBalanceStore.outgoingApprovals":
		if x.OutgoingApprovals == nil {
			x.OutgoingApprovals = []*UserOutgoingApproval{}
		}
		value := &_UserBalanceStore_2_list{list: &x.OutgoingApprovals}
		return protoreflect.ValueOfList(value)
	case "badges.UserBalanceStore.incomingApprovals":
		if x.IncomingApprovals == nil {
			x.IncomingApprovals = []*UserIncomingApproval{}
		}
		value := &_UserBalanceStore_3_list{list: &x.IncomingApprovals}
		return protoreflect.ValueOfList(value)
	case "badges.UserBalanceStore.userPermissions":
		if x.UserPermissions == nil {
			x.UserPermissions = new(UserPermissions)
		}
		return protoreflect.ValueOfMessage(x.UserPermissions.ProtoReflect())
	case "badges.UserBalanceStore.autoApproveSelfInitiatedOutgoingTransfers":
		panic(fmt.Errorf("field autoApproveSelfInitiatedOutgoingTransfers of message badges.UserBalanceStore is not mutable"))
	case "badges.UserBalanceStore.autoApproveSelfInitiatedIncomingTransfers":
		panic(fmt.Errorf("field autoApproveSelfInitiatedIncomingTransfers of message badges.UserBalanceStore is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserBalanceStore"))
		}
		panic(fmt.Errorf("message badges.UserBalanceStore does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_UserBalanceStore) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.UserBalanceStore.balances":
		list := []*Balance{}
		return protoreflect.ValueOfList(&_UserBalanceStore_1_list{list: &list})
	case "badges.UserBalanceStore.outgoingApprovals":
		list := []*UserOutgoingApproval{}
		return protoreflect.ValueOfList(&_UserBalanceStore_2_list{list: &list})
	case "badges.UserBalanceStore.incomingApprovals":
		list := []*UserIncomingApproval{}
		return protoreflect.ValueOfList(&_UserBalanceStore_3_list{list: &list})
	case "badges.UserBalanceStore.autoApproveSelfInitiatedOutgoingTransfers":
		return protoreflect.ValueOfBool(false)
	case "badges.UserBalanceStore.autoApproveSelfInitiatedIncomingTransfers":
		return protoreflect.ValueOfBool(false)
	case "badges.UserBalanceStore.userPermissions":
		m := new(UserPermissions)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserBalanceStore"))
		}
		panic(fmt.Errorf("message badges.UserBalanceStore does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_UserBalanceStore) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.UserBalanceStore", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_UserBalanceStore) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserBalanceStore) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_UserBalanceStore) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_UserBalanceStore) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*UserBalanceStore)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.Balances) > 0 {
			for _, e := range x.Balances {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.OutgoingApprovals) > 0 {
			for _, e := range x.OutgoingApprovals {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.IncomingApprovals) > 0 {
			for _, e := range x.IncomingApprovals {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.AutoApproveSelfInitiatedOutgoingTransfers {
			n += 2
		}
		if x.AutoApproveSelfInitiatedIncomingTransfers {
			n += 2
		}
		if x.UserPermissions != nil {
			l = options.Size(x.UserPermissions)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*UserBalanceStore)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.UserPermissions != nil {
			encoded, err := options.Marshal(x.UserPermissions)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		}
		if x.AutoApproveSelfInitiatedIncomingTransfers {
			i--
			if x.AutoApproveSelfInitiatedIncomingTransfers {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if x.AutoApproveSelfInitiatedOutgoingTransfers {
			i--
			if x.AutoApproveSelfInitiatedOutgoingTransfers {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x20
		}
		if len(x.IncomingApprovals) > 0 {
			for iNdEx := len(x.IncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.IncomingApprovals[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x1a
			}
		}
		if len(x.OutgoingApprovals) > 0 {
			for iNdEx := len(x.OutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.OutgoingApprovals[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.Balances) > 0 {
			for iNdEx := len(x.Balances) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Balances[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*UserBalanceStore)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: UserBalanceStore: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: UserBalanceStore: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Balances = append(x.Balances, &Balance{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Balances[len(x.Balances)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OutgoingApprovals", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OutgoingApprovals = append(x.OutgoingApprovals, &UserOutgoingApproval{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.OutgoingApprovals[len(x.OutgoingApprovals)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IncomingApprovals", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.IncomingApprovals = append(x.IncomingApprovals, &UserIncomingApproval{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.IncomingApprovals[len(x.IncomingApprovals)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedOutgoingTransfers", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.AutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedIncomingTransfers", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.AutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UserPermissions", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.UserPermissions == nil {
					x.UserPermissions = &UserPermissions{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.UserPermissions); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MerkleChallenge                         protoreflect.MessageDescriptor
	fd_MerkleChallenge_root                    protoreflect.FieldDescriptor
	fd_MerkleChallenge_expectedProofLength     protoreflect.FieldDescriptor
	fd_MerkleChallenge_useCreatorAddressAsLeaf protoreflect.FieldDescriptor
	fd_MerkleChallenge_maxUsesPerLeaf          protoreflect.FieldDescriptor
	fd_MerkleChallenge_uri                     protoreflect.FieldDescriptor
	fd_MerkleChallenge_customData              protoreflect.FieldDescriptor
	fd_MerkleChallenge_challengeTrackerId      protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_MerkleChallenge = File_badges_transfers_proto.Messages().ByName("MerkleChallenge")
	fd_MerkleChallenge_root = md_MerkleChallenge.Fields().ByName("root")
	fd_MerkleChallenge_expectedProofLength = md_MerkleChallenge.Fields().ByName("expectedProofLength")
	fd_MerkleChallenge_useCreatorAddressAsLeaf = md_MerkleChallenge.Fields().ByName("useCreatorAddressAsLeaf")
	fd_MerkleChallenge_maxUsesPerLeaf = md_MerkleChallenge.Fields().ByName("maxUsesPerLeaf")
	fd_MerkleChallenge_uri = md_MerkleChallenge.Fields().ByName("uri")
	fd_MerkleChallenge_customData = md_MerkleChallenge.Fields().ByName("customData")
	fd_MerkleChallenge_challengeTrackerId = md_MerkleChallenge.Fields().ByName("challengeTrackerId")
}

var _ protoreflect.Message = (*fastReflection_MerkleChallenge)(nil)

type fastReflection_MerkleChallenge MerkleChallenge

func (x *MerkleChallenge) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MerkleChallenge)(x)
}

func (x *MerkleChallenge) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MerkleChallenge_messageType fastReflection_MerkleChallenge_messageType
var _ protoreflect.MessageType = fastReflection_MerkleChallenge_messageType{}

type fastReflection_MerkleChallenge_messageType struct{}

func (x fastReflection_MerkleChallenge_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MerkleChallenge)(nil)
}
func (x fastReflection_MerkleChallenge_messageType) New() protoreflect.Message {
	return new(fastReflection_MerkleChallenge)
}
func (x fastReflection_MerkleChallenge_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MerkleChallenge
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MerkleChallenge) Descriptor() protoreflect.MessageDescriptor {
	return md_MerkleChallenge
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MerkleChallenge) Type() protoreflect.MessageType {
	return _fastReflection_MerkleChallenge_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MerkleChallenge) New() protoreflect.Message {
	return new(fastReflection_MerkleChallenge)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MerkleChallenge) Interface() protoreflect.ProtoMessage {
	return (*MerkleChallenge)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MerkleChallenge) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Root != "" {
		value := protoreflect.ValueOfString(x.Root)
		if !f(fd_MerkleChallenge_root, value) {
			return
		}
	}
	if x.ExpectedProofLength != "" {
		value := protoreflect.ValueOfString(x.ExpectedProofLength)
		if !f(fd_MerkleChallenge_expectedProofLength, value) {
			return
		}
	}
	if x.UseCreatorAddressAsLeaf != false {
		value := protoreflect.ValueOfBool(x.UseCreatorAddressAsLeaf)
		if !f(fd_MerkleChallenge_useCreatorAddressAsLeaf, value) {
			return
		}
	}
	if x.MaxUsesPerLeaf != "" {
		value := protoreflect.ValueOfString(x.MaxUsesPerLeaf)
		if !f(fd_MerkleChallenge_maxUsesPerLeaf, value) {
			return
		}
	}
	if x.Uri != "" {
		value := protoreflect.ValueOfString(x.Uri)
		if !f(fd_MerkleChallenge_uri, value) {
			return
		}
	}
	if x.CustomData != "" {
		value := protoreflect.ValueOfString(x.CustomData)
		if !f(fd_MerkleChallenge_customData, value) {
			return
		}
	}
	if x.ChallengeTrackerId != "" {
		value := protoreflect.ValueOfString(x.ChallengeTrackerId)
		if !f(fd_MerkleChallenge_challengeTrackerId, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MerkleChallenge) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.MerkleChallenge.root":
		return x.Root != ""
	case "badges.MerkleChallenge.expectedProofLength":
		return x.ExpectedProofLength != ""
	case "badges.MerkleChallenge.useCreatorAddressAsLeaf":
		return x.UseCreatorAddressAsLeaf != false
	case "badges.MerkleChallenge.maxUsesPerLeaf":
		return x.MaxUsesPerLeaf != ""
	case "badges.MerkleChallenge.uri":
		return x.Uri != ""
	case "badges.MerkleChallenge.customData":
		return x.CustomData != ""
	case "badges.MerkleChallenge.challengeTrackerId":
		return x.ChallengeTrackerId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleChallenge"))
		}
		panic(fmt.Errorf("message badges.MerkleChallenge does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerkleChallenge) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.MerkleChallenge.root":
		x.Root = ""
	case "badges.MerkleChallenge.expectedProofLength":
		x.ExpectedProofLength = ""
	case "badges.MerkleChallenge.useCreatorAddressAsLeaf":
		x.UseCreatorAddressAsLeaf = false
	case "badges.MerkleChallenge.maxUsesPerLeaf":
		x.MaxUsesPerLeaf = ""
	case "badges.MerkleChallenge.uri":
		x.Uri = ""
	case "badges.MerkleChallenge.customData":
		x.CustomData = ""
	case "badges.MerkleChallenge.challengeTrackerId":
		x.ChallengeTrackerId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleChallenge"))
		}
		panic(fmt.Errorf("message badges.MerkleChallenge does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MerkleChallenge) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.MerkleChallenge.root":
		value := x.Root
		return protoreflect.ValueOfString(value)
	case "badges.MerkleChallenge.expectedProofLength":
		value := x.ExpectedProofLength
		return protoreflect.ValueOfString(value)
	case "badges.MerkleChallenge.useCreatorAddressAsLeaf":
		value := x.UseCreatorAddressAsLeaf
		return protoreflect.ValueOfBool(value)
	case "badges.MerkleChallenge.maxUsesPerLeaf":
		value := x.MaxUsesPerLeaf
		return protoreflect.ValueOfString(value)
	case "badges.MerkleChallenge.uri":
		value := x.Uri
		return protoreflect.ValueOfString(value)
	case "badges.MerkleChallenge.customData":
		value := x.CustomData
		return protoreflect.ValueOfString(value)
	case "badges.MerkleChallenge.challengeTrackerId":
		value := x.ChallengeTrackerId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleChallenge"))
		}
		panic(fmt.Errorf("message badges.MerkleChallenge does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerkleChallenge) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.MerkleChallenge.root":
		x.Root = value.Interface().(string)
	case "badges.MerkleChallenge.expectedProofLength":
		x.ExpectedProofLength = value.Interface().(string)
	case "badges.MerkleChallenge.useCreatorAddressAsLeaf":
		x.UseCreatorAddressAsLeaf = value.Bool()
	case "badges.MerkleChallenge.maxUsesPerLeaf":
		x.MaxUsesPerLeaf = value.Interface().(string)
	case "badges.MerkleChallenge.uri":
		x.Uri = value.Interface().(string)
	case "badges.MerkleChallenge.customData":
		x.CustomData = value.Interface().(string)
	case "badges.MerkleChallenge.challengeTrackerId":
		x.ChallengeTrackerId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleChallenge"))
		}
		panic(fmt.Errorf("message badges.MerkleChallenge does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerkleChallenge) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.MerkleChallenge.root":
		panic(fmt.Errorf("field root of message badges.MerkleChallenge is not mutable"))
	case "badges.MerkleChallenge.expectedProofLength":
		panic(fmt.Errorf("field expectedProofLength of message badges.MerkleChallenge is not mutable"))
	case "badges.MerkleChallenge.useCreatorAddressAsLeaf":
		panic(fmt.Errorf("field useCreatorAddressAsLeaf of message badges.MerkleChallenge is not mutable"))
	case "badges.MerkleChallenge.maxUsesPerLeaf":
		panic(fmt.Errorf("field maxUsesPerLeaf of message badges.MerkleChallenge is not mutable"))
	case "badges.MerkleChallenge.uri":
		panic(fmt.Errorf("field uri of message badges.MerkleChallenge is not mutable"))
	case "badges.MerkleChallenge.customData":
		panic(fmt.Errorf("field customData of message badges.MerkleChallenge is not mutable"))
	case "badges.MerkleChallenge.challengeTrackerId":
		panic(fmt.Errorf("field challengeTrackerId of message badges.MerkleChallenge is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleChallenge"))
		}
		panic(fmt.Errorf("message badges.MerkleChallenge does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MerkleChallenge) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.MerkleChallenge.root":
		return protoreflect.ValueOfString("")
	case "badges.MerkleChallenge.expectedProofLength":
		return protoreflect.ValueOfString("")
	case "badges.MerkleChallenge.useCreatorAddressAsLeaf":
		return protoreflect.ValueOfBool(false)
	case "badges.MerkleChallenge.maxUsesPerLeaf":
		return protoreflect.ValueOfString("")
	case "badges.MerkleChallenge.uri":
		return protoreflect.ValueOfString("")
	case "badges.MerkleChallenge.customData":
		return protoreflect.ValueOfString("")
	case "badges.MerkleChallenge.challengeTrackerId":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleChallenge"))
		}
		panic(fmt.Errorf("message badges.MerkleChallenge does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MerkleChallenge) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.MerkleChallenge", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MerkleChallenge) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerkleChallenge) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MerkleChallenge) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MerkleChallenge) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MerkleChallenge)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Root)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ExpectedProofLength)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.UseCreatorAddressAsLeaf {
			n += 2
		}
		l = len(x.MaxUsesPerLeaf)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Uri)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CustomData)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ChallengeTrackerId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MerkleChallenge)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ChallengeTrackerId) > 0 {
			i -= len(x.ChallengeTrackerId)
			copy(dAtA[i:], x.ChallengeTrackerId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ChallengeTrackerId)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.CustomData) > 0 {
			i -= len(x.CustomData)
			copy(dAtA[i:], x.CustomData)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CustomData)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.Uri) > 0 {
			i -= len(x.Uri)
			copy(dAtA[i:], x.Uri)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Uri)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.MaxUsesPerLeaf) > 0 {
			i -= len(x.MaxUsesPerLeaf)
			copy(dAtA[i:], x.MaxUsesPerLeaf)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MaxUsesPerLeaf)))
			i--
			dAtA[i] = 0x22
		}
		if x.UseCreatorAddressAsLeaf {
			i--
			if x.UseCreatorAddressAsLeaf {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x18
		}
		if len(x.ExpectedProofLength) > 0 {
			i -= len(x.ExpectedProofLength)
			copy(dAtA[i:], x.ExpectedProofLength)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ExpectedProofLength)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Root) > 0 {
			i -= len(x.Root)
			copy(dAtA[i:], x.Root)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Root)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MerkleChallenge)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MerkleChallenge: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MerkleChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Root = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExpectedProofLength", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ExpectedProofLength = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UseCreatorAddressAsLeaf", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UseCreatorAddressAsLeaf = bool(v != 0)
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxUsesPerLeaf", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MaxUsesPerLeaf = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Uri = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CustomData = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_UserOutgoingApproval_3_list)(nil)

type _UserOutgoingApproval_3_list struct {
	list *[]*UintRange
}

func (x *_UserOutgoingApproval_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_UserOutgoingApproval_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_UserOutgoingApproval_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	(*x.list)[i] = concreteValue
}

func (x *_UserOutgoingApproval_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	*x.list = append(*x.list, concreteValue)
}

func (x *_UserOutgoingApproval_3_list) AppendMutable() protoreflect.Value {
	v := new(UintRange)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserOutgoingApproval_3_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_UserOutgoingApproval_3_list) NewElement() protoreflect.Value {
	v := new(UintRange)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserOutgoingApproval_3_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_UserOutgoingApproval_4_list)(nil)

type _UserOutgoingApproval_4_list struct {
	list *[]*UintRange
}

func (x *_UserOutgoingApproval_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_UserOutgoingApproval_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_UserOutgoingApproval_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	(*x.list)[i] = concreteValue
}

func (x *_UserOutgoingApproval_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	*x.list = append(*x.list, concreteValue)
}

func (x *_UserOutgoingApproval_4_list) AppendMutable() protoreflect.Value {
	v := new(UintRange)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserOutgoingApproval_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_UserOutgoingApproval_4_list) NewElement() protoreflect.Value {
	v := new(UintRange)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserOutgoingApproval_4_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_UserOutgoingApproval_5_list)(nil)

type _UserOutgoingApproval_5_list struct {
	list *[]*UintRange
}

func (x *_UserOutgoingApproval_5_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_UserOutgoingApproval_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_UserOutgoingApproval_5_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	(*x.list)[i] = concreteValue
}

func (x *_UserOutgoingApproval_5_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	*x.list = append(*x.list, concreteValue)
}

func (x *_UserOutgoingApproval_5_list) AppendMutable() protoreflect.Value {
	v := new(UintRange)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserOutgoingApproval_5_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_UserOutgoingApproval_5_list) NewElement() protoreflect.Value {
	v := new(UintRange)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserOutgoingApproval_5_list) IsValid() bool {
	return x.list != nil
}

var (
	md_UserOutgoingApproval                   protoreflect.MessageDescriptor
	fd_UserOutgoingApproval_toListId          protoreflect.FieldDescriptor
	fd_UserOutgoingApproval_initiatedByListId protoreflect.FieldDescriptor
	fd_UserOutgoingApproval_transferTimes     protoreflect.FieldDescriptor
	fd_UserOutgoingApproval_badgeIds          protoreflect.FieldDescriptor
	fd_UserOutgoingApproval_ownershipTimes    protoreflect.FieldDescriptor
	fd_UserOutgoingApproval_uri               protoreflect.FieldDescriptor
	fd_UserOutgoingApproval_customData        protoreflect.FieldDescriptor
	fd_UserOutgoingApproval_approvalId        protoreflect.FieldDescriptor
	fd_UserOutgoingApproval_approvalCriteria  protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_UserOutgoingApproval = File_badges_transfers_proto.Messages().ByName("UserOutgoingApproval")
	fd_UserOutgoingApproval_toListId = md_UserOutgoingApproval.Fields().ByName("toListId")
	fd_UserOutgoingApproval_initiatedByListId = md_UserOutgoingApproval.Fields().ByName("initiatedByListId")
	fd_UserOutgoingApproval_transferTimes = md_UserOutgoingApproval.Fields().ByName("transferTimes")
	fd_UserOutgoingApproval_badgeIds = md_UserOutgoingApproval.Fields().ByName("badgeIds")
	fd_UserOutgoingApproval_ownershipTimes = md_UserOutgoingApproval.Fields().ByName("ownershipTimes")
	fd_UserOutgoingApproval_uri = md_UserOutgoingApproval.Fields().ByName("uri")
	fd_UserOutgoingApproval_customData = md_UserOutgoingApproval.Fields().ByName("customData")
	fd_UserOutgoingApproval_approvalId = md_UserOutgoingApproval.Fields().ByName("approvalId")
	fd_UserOutgoingApproval_approvalCriteria = md_UserOutgoingApproval.Fields().ByName("approvalCriteria")
}

var _ protoreflect.Message = (*fastReflection_UserOutgoingApproval)(nil)

type fastReflection_UserOutgoingApproval UserOutgoingApproval

func (x *UserOutgoingApproval) ProtoReflect() protoreflect.Message {
	return (*fastReflection_UserOutgoingApproval)(x)
}

func (x *UserOutgoingApproval) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_UserOutgoingApproval_messageType fastReflection_UserOutgoingApproval_messageType
var _ protoreflect.MessageType = fastReflection_UserOutgoingApproval_messageType{}

type fastReflection_UserOutgoingApproval_messageType struct{}

func (x fastReflection_UserOutgoingApproval_messageType) Zero() protoreflect.Message {
	return (*fastReflection_UserOutgoingApproval)(nil)
}
func (x fastReflection_UserOutgoingApproval_messageType) New() protoreflect.Message {
	return new(fastReflection_UserOutgoingApproval)
}
func (x fastReflection_UserOutgoingApproval_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_UserOutgoingApproval
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_UserOutgoingApproval) Descriptor() protoreflect.MessageDescriptor {
	return md_UserOutgoingApproval
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_UserOutgoingApproval) Type() protoreflect.MessageType {
	return _fastReflection_UserOutgoingApproval_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_UserOutgoingApproval) New() protoreflect.Message {
	return new(fastReflection_UserOutgoingApproval)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_UserOutgoingApproval) Interface() protoreflect.ProtoMessage {
	return (*UserOutgoingApproval)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_UserOutgoingApproval) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.ToListId != "" {
		value := protoreflect.ValueOfString(x.ToListId)
		if !f(fd_UserOutgoingApproval_toListId, value) {
			return
		}
	}
	if x.InitiatedByListId != "" {
		value := protoreflect.ValueOfString(x.InitiatedByListId)
		if !f(fd_UserOutgoingApproval_initiatedByListId, value) {
			return
		}
	}
	if len(x.TransferTimes) != 0 {
		value := protoreflect.ValueOfList(&_UserOutgoingApproval_3_list{list: &x.TransferTimes})
		if !f(fd_UserOutgoingApproval_transferTimes, value) {
			return
		}
	}
	if len(x.BadgeIds) != 0 {
		value := protoreflect.ValueOfList(&_UserOutgoingApproval_4_list{list: &x.BadgeIds})
		if !f(fd_UserOutgoingApproval_badgeIds, value) {
			return
		}
	}
	if len(x.OwnershipTimes) != 0 {
		value := protoreflect.ValueOfList(&_UserOutgoingApproval_5_list{list: &x.OwnershipTimes})
		if !f(fd_UserOutgoingApproval_ownershipTimes, value) {
			return
		}
	}
	if x.Uri != "" {
		value := protoreflect.ValueOfString(x.Uri)
		if !f(fd_UserOutgoingApproval_uri, value) {
			return
		}
	}
	if x.CustomData != "" {
		value := protoreflect.ValueOfString(x.CustomData)
		if !f(fd_UserOutgoingApproval_customData, value) {
			return
		}
	}
	if x.ApprovalId != "" {
		value := protoreflect.ValueOfString(x.ApprovalId)
		if !f(fd_UserOutgoingApproval_approvalId, value) {
			return
		}
	}
	if x.ApprovalCriteria != nil {
		value := protoreflect.ValueOfMessage(x.ApprovalCriteria.ProtoReflect())
		if !f(fd_UserOutgoingApproval_approvalCriteria, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_UserOutgoingApproval) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.UserOutgoingApproval.toListId":
		return x.ToListId != ""
	case "badges.UserOutgoingApproval.initiatedByListId":
		return x.InitiatedByListId != ""
	case "badges.UserOutgoingApproval.transferTimes":
		return len(x.TransferTimes) != 0
	case "badges.UserOutgoingApproval.badgeIds":
		return len(x.BadgeIds) != 0
	case "badges.UserOutgoingApproval.ownershipTimes":
		return len(x.OwnershipTimes) != 0
	case "badges.UserOutgoingApproval.uri":
		return x.Uri != ""
	case "badges.UserOutgoingApproval.customData":
		return x.CustomData != ""
	case "badges.UserOutgoingApproval.approvalId":
		return x.ApprovalId != ""
	case "badges.UserOutgoingApproval.approvalCriteria":
		return x.ApprovalCriteria != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserOutgoingApproval"))
		}
		panic(fmt.Errorf("message badges.UserOutgoingApproval does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserOutgoingApproval) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.UserOutgoingApproval.toListId":
		x.ToListId = ""
	case "badges.UserOutgoingApproval.initiatedByListId":
		x.InitiatedByListId = ""
	case "badges.UserOutgoingApproval.transferTimes":
		x.TransferTimes = nil
	case "badges.UserOutgoingApproval.badgeIds":
		x.BadgeIds = nil
	case "badges.UserOutgoingApproval.ownershipTimes":
		x.OwnershipTimes = nil
	case "badges.UserOutgoingApproval.uri":
		x.Uri = ""
	case "badges.UserOutgoingApproval.customData":
		x.CustomData = ""
	case "badges.UserOutgoingApproval.approvalId":
		x.ApprovalId = ""
	case "badges.UserOutgoingApproval.approvalCriteria":
		x.ApprovalCriteria = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserOutgoingApproval"))
		}
		panic(fmt.Errorf("message badges.UserOutgoingApproval does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_UserOutgoingApproval) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.UserOutgoingApproval.toListId":
		value := x.ToListId
		return protoreflect.ValueOfString(value)
	case "badges.UserOutgoingApproval.initiatedByListId":
		value := x.InitiatedByListId
		return protoreflect.ValueOfString(value)
	case "badges.UserOutgoingApproval.transferTimes":
		if len(x.TransferTimes) == 0 {
			return protoreflect.ValueOfList(&_UserOutgoingApproval_3_list{})
		}
		listValue := &_UserOutgoingApproval_3_list{list: &x.TransferTimes}
		return protoreflect.ValueOfList(listValue)
	case "badges.UserOutgoingApproval.badgeIds":
		if len(x.BadgeIds) == 0 {
			return protoreflect.ValueOfList(&_UserOutgoingApproval_4_list{})
		}
		listValue := &_UserOutgoingApproval_4_list{list: &x.BadgeIds}
		return protoreflect.ValueOfList(listValue)
	case "badges.UserOutgoingApproval.ownershipTimes":
		if len(x.OwnershipTimes) == 0 {
			return protoreflect.ValueOfList(&_UserOutgoingApproval_5_list{})
		}
		listValue := &_UserOutgoingApproval_5_list{list: &x.OwnershipTimes}
		return protoreflect.ValueOfList(listValue)
	case "badges.UserOutgoingApproval.uri":
		value := x.Uri
		return protoreflect.ValueOfString(value)
	case "badges.UserOutgoingApproval.customData":
		value := x.CustomData
		return protoreflect.ValueOfString(value)
	case "badges.UserOutgoingApproval.approvalId":
		value := x.ApprovalId
		return protoreflect.ValueOfString(value)
	case "badges.UserOutgoingApproval.approvalCriteria":
		value := x.ApprovalCriteria
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserOutgoingApproval"))
		}
		panic(fmt.Errorf("message badges.UserOutgoingApproval does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserOutgoingApproval) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.UserOutgoingApproval.toListId":
		x.ToListId = value.Interface().(string)
	case "badges.UserOutgoingApproval.initiatedByListId":
		x.InitiatedByListId = value.Interface().(string)
	case "badges.UserOutgoingApproval.transferTimes":
		lv := value.List()
		clv := lv.(*_UserOutgoingApproval_3_list)
		x.TransferTimes = *clv.list
	case "badges.UserOutgoingApproval.badgeIds":
		lv := value.List()
		clv := lv.(*_UserOutgoingApproval_4_list)
		x.BadgeIds = *clv.list
	case "badges.UserOutgoingApproval.ownershipTimes":
		lv := value.List()
		clv := lv.(*_UserOutgoingApproval_5_list)
		x.OwnershipTimes = *clv.list
	case "badges.UserOutgoingApproval.uri":
		x.Uri = value.Interface().(string)
	case "badges.UserOutgoingApproval.customData":
		x.CustomData = value.Interface().(string)
	case "badges.UserOutgoingApproval.approvalId":
		x.ApprovalId = value.Interface().(string)
	case "badges.UserOutgoingApproval.approvalCriteria":
		x.ApprovalCriteria = value.Message().Interface().(*OutgoingApprovalCriteria)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserOutgoingApproval"))
		}
		panic(fmt.Errorf("message badges.UserOutgoingApproval does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserOutgoingApproval) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.UserOutgoingApproval.transferTimes":
		if x.TransferTimes == nil {
			x.TransferTimes = []*UintRange{}
		}
		value := &_UserOutgoingApproval_3_list{list: &x.TransferTimes}
		return protoreflect.ValueOfList(value)
	case "badges.UserOutgoingApproval.badgeIds":
		if x.BadgeIds == nil {
			x.BadgeIds = []*UintRange{}
		}
		value := &_UserOutgoingApproval_4_list{list: &x.BadgeIds}
		return protoreflect.ValueOfList(value)
	case "badges.UserOutgoingApproval.ownershipTimes":
		if x.OwnershipTimes == nil {
			x.OwnershipTimes = []*UintRange{}
		}
		value := &_UserOutgoingApproval_5_list{list: &x.OwnershipTimes}
		return protoreflect.ValueOfList(value)
	case "badges.UserOutgoingApproval.approvalCriteria":
		if x.ApprovalCriteria == nil {
			x.ApprovalCriteria = new(OutgoingApprovalCriteria)
		}
		return protoreflect.ValueOfMessage(x.ApprovalCriteria.ProtoReflect())
	case "badges.UserOutgoingApproval.toListId":
		panic(fmt.Errorf("field toListId of message badges.UserOutgoingApproval is not mutable"))
	case "badges.UserOutgoingApproval.initiatedByListId":
		panic(fmt.Errorf("field initiatedByListId of message badges.UserOutgoingApproval is not mutable"))
	case "badges.UserOutgoingApproval.uri":
		panic(fmt.Errorf("field uri of message badges.UserOutgoingApproval is not mutable"))
	case "badges.UserOutgoingApproval.customData":
		panic(fmt.Errorf("field customData of message badges.UserOutgoingApproval is not mutable"))
	case "badges.UserOutgoingApproval.approvalId":
		panic(fmt.Errorf("field approvalId of message badges.UserOutgoingApproval is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserOutgoingApproval"))
		}
		panic(fmt.Errorf("message badges.UserOutgoingApproval does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_UserOutgoingApproval) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.UserOutgoingApproval.toListId":
		return protoreflect.ValueOfString("")
	case "badges.UserOutgoingApproval.initiatedByListId":
		return protoreflect.ValueOfString("")
	case "badges.UserOutgoingApproval.transferTimes":
		list := []*UintRange{}
		return protoreflect.ValueOfList(&_UserOutgoingApproval_3_list{list: &list})
	case "badges.UserOutgoingApproval.badgeIds":
		list := []*UintRange{}
		return protoreflect.ValueOfList(&_UserOutgoingApproval_4_list{list: &list})
	case "badges.UserOutgoingApproval.ownershipTimes":
		list := []*UintRange{}
		return protoreflect.ValueOfList(&_UserOutgoingApproval_5_list{list: &list})
	case "badges.UserOutgoingApproval.uri":
		return protoreflect.ValueOfString("")
	case "badges.UserOutgoingApproval.customData":
		return protoreflect.ValueOfString("")
	case "badges.UserOutgoingApproval.approvalId":
		return protoreflect.ValueOfString("")
	case "badges.UserOutgoingApproval.approvalCriteria":
		m := new(OutgoingApprovalCriteria)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserOutgoingApproval"))
		}
		panic(fmt.Errorf("message badges.UserOutgoingApproval does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_UserOutgoingApproval) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.UserOutgoingApproval", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_UserOutgoingApproval) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserOutgoingApproval) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_UserOutgoingApproval) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_UserOutgoingApproval) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*UserOutgoingApproval)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.ToListId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.InitiatedByListId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.TransferTimes) > 0 {
			for _, e := range x.TransferTimes {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.BadgeIds) > 0 {
			for _, e := range x.BadgeIds {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.OwnershipTimes) > 0 {
			for _, e := range x.OwnershipTimes {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.Uri)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CustomData)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ApprovalId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ApprovalCriteria != nil {
			l = options.Size(x.ApprovalCriteria)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*UserOutgoingApproval)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ApprovalCriteria != nil {
			encoded, err := options.Marshal(x.ApprovalCriteria)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x5a
		}
		if len(x.ApprovalId) > 0 {
			i -= len(x.ApprovalId)
			copy(dAtA[i:], x.ApprovalId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ApprovalId)))
			i--
			dAtA[i] = 0x52
		}
		if len(x.CustomData) > 0 {
			i -= len(x.CustomData)
			copy(dAtA[i:], x.CustomData)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CustomData)))
			i--
			dAtA[i] = 0x4a
		}
		if len(x.Uri) > 0 {
			i -= len(x.Uri)
			copy(dAtA[i:], x.Uri)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Uri)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.OwnershipTimes) > 0 {
			for iNdEx := len(x.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.OwnershipTimes[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x2a
			}
		}
		if len(x.BadgeIds) > 0 {
			for iNdEx := len(x.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.BadgeIds[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if len(x.TransferTimes) > 0 {
			for iNdEx := len(x.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.TransferTimes[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x1a
			}
		}
		if len(x.InitiatedByListId) > 0 {
			i -= len(x.InitiatedByListId)
			copy(dAtA[i:], x.InitiatedByListId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.InitiatedByListId)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.ToListId) > 0 {
			i -= len(x.ToListId)
			copy(dAtA[i:], x.ToListId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ToListId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*UserOutgoingApproval)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: UserOutgoingApproval: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: UserOutgoingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ToListId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ToListId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.InitiatedByListId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TransferTimes = append(x.TransferTimes, &UintRange{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.TransferTimes[len(x.TransferTimes)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BadgeIds = append(x.BadgeIds, &UintRange{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.BadgeIds[len(x.BadgeIds)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OwnershipTimes = append(x.OwnershipTimes, &UintRange{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.OwnershipTimes[len(x.OwnershipTimes)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Uri = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CustomData = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ApprovalId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ApprovalCriteria == nil {
					x.ApprovalCriteria = &OutgoingApprovalCriteria{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ApprovalCriteria); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_UserIncomingApproval_3_list)(nil)

type _UserIncomingApproval_3_list struct {
	list *[]*UintRange
}

func (x *_UserIncomingApproval_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_UserIncomingApproval_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_UserIncomingApproval_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	(*x.list)[i] = concreteValue
}

func (x *_UserIncomingApproval_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	*x.list = append(*x.list, concreteValue)
}

func (x *_UserIncomingApproval_3_list) AppendMutable() protoreflect.Value {
	v := new(UintRange)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserIncomingApproval_3_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_UserIncomingApproval_3_list) NewElement() protoreflect.Value {
	v := new(UintRange)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserIncomingApproval_3_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_UserIncomingApproval_4_list)(nil)

type _UserIncomingApproval_4_list struct {
	list *[]*UintRange
}

func (x *_UserIncomingApproval_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_UserIncomingApproval_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_UserIncomingApproval_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	(*x.list)[i] = concreteValue
}

func (x *_UserIncomingApproval_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	*x.list = append(*x.list, concreteValue)
}

func (x *_UserIncomingApproval_4_list) AppendMutable() protoreflect.Value {
	v := new(UintRange)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserIncomingApproval_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_UserIncomingApproval_4_list) NewElement() protoreflect.Value {
	v := new(UintRange)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserIncomingApproval_4_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_UserIncomingApproval_5_list)(nil)

type _UserIncomingApproval_5_list struct {
	list *[]*UintRange
}

func (x *_UserIncomingApproval_5_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_UserIncomingApproval_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_UserIncomingApproval_5_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	(*x.list)[i] = concreteValue
}

func (x *_UserIncomingApproval_5_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	*x.list = append(*x.list, concreteValue)
}

func (x *_UserIncomingApproval_5_list) AppendMutable() protoreflect.Value {
	v := new(UintRange)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserIncomingApproval_5_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_UserIncomingApproval_5_list) NewElement() protoreflect.Value {
	v := new(UintRange)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_UserIncomingApproval_5_list) IsValid() bool {
	return x.list != nil
}

var (
	md_UserIncomingApproval                   protoreflect.MessageDescriptor
	fd_UserIncomingApproval_fromListId        protoreflect.FieldDescriptor
	fd_UserIncomingApproval_initiatedByListId protoreflect.FieldDescriptor
	fd_UserIncomingApproval_transferTimes     protoreflect.FieldDescriptor
	fd_UserIncomingApproval_badgeIds          protoreflect.FieldDescriptor
	fd_UserIncomingApproval_ownershipTimes    protoreflect.FieldDescriptor
	fd_UserIncomingApproval_uri               protoreflect.FieldDescriptor
	fd_UserIncomingApproval_customData        protoreflect.FieldDescriptor
	fd_UserIncomingApproval_approvalId        protoreflect.FieldDescriptor
	fd_UserIncomingApproval_approvalCriteria  protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_UserIncomingApproval = File_badges_transfers_proto.Messages().ByName("UserIncomingApproval")
	fd_UserIncomingApproval_fromListId = md_UserIncomingApproval.Fields().ByName("fromListId")
	fd_UserIncomingApproval_initiatedByListId = md_UserIncomingApproval.Fields().ByName("initiatedByListId")
	fd_UserIncomingApproval_transferTimes = md_UserIncomingApproval.Fields().ByName("transferTimes")
	fd_UserIncomingApproval_badgeIds = md_UserIncomingApproval.Fields().ByName("badgeIds")
	fd_UserIncomingApproval_ownershipTimes = md_UserIncomingApproval.Fields().ByName("ownershipTimes")
	fd_UserIncomingApproval_uri = md_UserIncomingApproval.Fields().ByName("uri")
	fd_UserIncomingApproval_customData = md_UserIncomingApproval.Fields().ByName("customData")
	fd_UserIncomingApproval_approvalId = md_UserIncomingApproval.Fields().ByName("approvalId")
	fd_UserIncomingApproval_approvalCriteria = md_UserIncomingApproval.Fields().ByName("approvalCriteria")
}

var _ protoreflect.Message = (*fastReflection_UserIncomingApproval)(nil)

type fastReflection_UserIncomingApproval UserIncomingApproval

func (x *UserIncomingApproval) ProtoReflect() protoreflect.Message {
	return (*fastReflection_UserIncomingApproval)(x)
}

func (x *UserIncomingApproval) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_UserIncomingApproval_messageType fastReflection_UserIncomingApproval_messageType
var _ protoreflect.MessageType = fastReflection_UserIncomingApproval_messageType{}

type fastReflection_UserIncomingApproval_messageType struct{}

func (x fastReflection_UserIncomingApproval_messageType) Zero() protoreflect.Message {
	return (*fastReflection_UserIncomingApproval)(nil)
}
func (x fastReflection_UserIncomingApproval_messageType) New() protoreflect.Message {
	return new(fastReflection_UserIncomingApproval)
}
func (x fastReflection_UserIncomingApproval_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_UserIncomingApproval
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_UserIncomingApproval) Descriptor() protoreflect.MessageDescriptor {
	return md_UserIncomingApproval
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_UserIncomingApproval) Type() protoreflect.MessageType {
	return _fastReflection_UserIncomingApproval_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_UserIncomingApproval) New() protoreflect.Message {
	return new(fastReflection_UserIncomingApproval)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_UserIncomingApproval) Interface() protoreflect.ProtoMessage {
	return (*UserIncomingApproval)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_UserIncomingApproval) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.FromListId != "" {
		value := protoreflect.ValueOfString(x.FromListId)
		if !f(fd_UserIncomingApproval_fromListId, value) {
			return
		}
	}
	if x.InitiatedByListId != "" {
		value := protoreflect.ValueOfString(x.InitiatedByListId)
		if !f(fd_UserIncomingApproval_initiatedByListId, value) {
			return
		}
	}
	if len(x.TransferTimes) != 0 {
		value := protoreflect.ValueOfList(&_UserIncomingApproval_3_list{list: &x.TransferTimes})
		if !f(fd_UserIncomingApproval_transferTimes, value) {
			return
		}
	}
	if len(x.BadgeIds) != 0 {
		value := protoreflect.ValueOfList(&_UserIncomingApproval_4_list{list: &x.BadgeIds})
		if !f(fd_UserIncomingApproval_badgeIds, value) {
			return
		}
	}
	if len(x.OwnershipTimes) != 0 {
		value := protoreflect.ValueOfList(&_UserIncomingApproval_5_list{list: &x.OwnershipTimes})
		if !f(fd_UserIncomingApproval_ownershipTimes, value) {
			return
		}
	}
	if x.Uri != "" {
		value := protoreflect.ValueOfString(x.Uri)
		if !f(fd_UserIncomingApproval_uri, value) {
			return
		}
	}
	if x.CustomData != "" {
		value := protoreflect.ValueOfString(x.CustomData)
		if !f(fd_UserIncomingApproval_customData, value) {
			return
		}
	}
	if x.ApprovalId != "" {
		value := protoreflect.ValueOfString(x.ApprovalId)
		if !f(fd_UserIncomingApproval_approvalId, value) {
			return
		}
	}
	if x.ApprovalCriteria != nil {
		value := protoreflect.ValueOfMessage(x.ApprovalCriteria.ProtoReflect())
		if !f(fd_UserIncomingApproval_approvalCriteria, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_UserIncomingApproval) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.UserIncomingApproval.fromListId":
		return x.FromListId != ""
	case "badges.UserIncomingApproval.initiatedByListId":
		return x.InitiatedByListId != ""
	case "badges.UserIncomingApproval.transferTimes":
		return len(x.TransferTimes) != 0
	case "badges.UserIncomingApproval.badgeIds":
		return len(x.BadgeIds) != 0
	case "badges.UserIncomingApproval.ownershipTimes":
		return len(x.OwnershipTimes) != 0
	case "badges.UserIncomingApproval.uri":
		return x.Uri != ""
	case "badges.UserIncomingApproval.customData":
		return x.CustomData != ""
	case "badges.UserIncomingApproval.approvalId":
		return x.ApprovalId != ""
	case "badges.UserIncomingApproval.approvalCriteria":
		return x.ApprovalCriteria != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserIncomingApproval"))
		}
		panic(fmt.Errorf("message badges.UserIncomingApproval does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserIncomingApproval) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.UserIncomingApproval.fromListId":
		x.FromListId = ""
	case "badges.UserIncomingApproval.initiatedByListId":
		x.InitiatedByListId = ""
	case "badges.UserIncomingApproval.transferTimes":
		x.TransferTimes = nil
	case "badges.UserIncomingApproval.badgeIds":
		x.BadgeIds = nil
	case "badges.UserIncomingApproval.ownershipTimes":
		x.OwnershipTimes = nil
	case "badges.UserIncomingApproval.uri":
		x.Uri = ""
	case "badges.UserIncomingApproval.customData":
		x.CustomData = ""
	case "badges.UserIncomingApproval.approvalId":
		x.ApprovalId = ""
	case "badges.UserIncomingApproval.approvalCriteria":
		x.ApprovalCriteria = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserIncomingApproval"))
		}
		panic(fmt.Errorf("message badges.UserIncomingApproval does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_UserIncomingApproval) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.UserIncomingApproval.fromListId":
		value := x.FromListId
		return protoreflect.ValueOfString(value)
	case "badges.UserIncomingApproval.initiatedByListId":
		value := x.InitiatedByListId
		return protoreflect.ValueOfString(value)
	case "badges.UserIncomingApproval.transferTimes":
		if len(x.TransferTimes) == 0 {
			return protoreflect.ValueOfList(&_UserIncomingApproval_3_list{})
		}
		listValue := &_UserIncomingApproval_3_list{list: &x.TransferTimes}
		return protoreflect.ValueOfList(listValue)
	case "badges.UserIncomingApproval.badgeIds":
		if len(x.BadgeIds) == 0 {
			return protoreflect.ValueOfList(&_UserIncomingApproval_4_list{})
		}
		listValue := &_UserIncomingApproval_4_list{list: &x.BadgeIds}
		return protoreflect.ValueOfList(listValue)
	case "badges.UserIncomingApproval.ownershipTimes":
		if len(x.OwnershipTimes) == 0 {
			return protoreflect.ValueOfList(&_UserIncomingApproval_5_list{})
		}
		listValue := &_UserIncomingApproval_5_list{list: &x.OwnershipTimes}
		return protoreflect.ValueOfList(listValue)
	case "badges.UserIncomingApproval.uri":
		value := x.Uri
		return protoreflect.ValueOfString(value)
	case "badges.UserIncomingApproval.customData":
		value := x.CustomData
		return protoreflect.ValueOfString(value)
	case "badges.UserIncomingApproval.approvalId":
		value := x.ApprovalId
		return protoreflect.ValueOfString(value)
	case "badges.UserIncomingApproval.approvalCriteria":
		value := x.ApprovalCriteria
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserIncomingApproval"))
		}
		panic(fmt.Errorf("message badges.UserIncomingApproval does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserIncomingApproval) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.UserIncomingApproval.fromListId":
		x.FromListId = value.Interface().(string)
	case "badges.UserIncomingApproval.initiatedByListId":
		x.InitiatedByListId = value.Interface().(string)
	case "badges.UserIncomingApproval.transferTimes":
		lv := value.List()
		clv := lv.(*_UserIncomingApproval_3_list)
		x.TransferTimes = *clv.list
	case "badges.UserIncomingApproval.badgeIds":
		lv := value.List()
		clv := lv.(*_UserIncomingApproval_4_list)
		x.BadgeIds = *clv.list
	case "badges.UserIncomingApproval.ownershipTimes":
		lv := value.List()
		clv := lv.(*_UserIncomingApproval_5_list)
		x.OwnershipTimes = *clv.list
	case "badges.UserIncomingApproval.uri":
		x.Uri = value.Interface().(string)
	case "badges.UserIncomingApproval.customData":
		x.CustomData = value.Interface().(string)
	case "badges.UserIncomingApproval.approvalId":
		x.ApprovalId = value.Interface().(string)
	case "badges.UserIncomingApproval.approvalCriteria":
		x.ApprovalCriteria = value.Message().Interface().(*IncomingApprovalCriteria)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserIncomingApproval"))
		}
		panic(fmt.Errorf("message badges.UserIncomingApproval does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserIncomingApproval) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.UserIncomingApproval.transferTimes":
		if x.TransferTimes == nil {
			x.TransferTimes = []*UintRange{}
		}
		value := &_UserIncomingApproval_3_list{list: &x.TransferTimes}
		return protoreflect.ValueOfList(value)
	case "badges.UserIncomingApproval.badgeIds":
		if x.BadgeIds == nil {
			x.BadgeIds = []*UintRange{}
		}
		value := &_UserIncomingApproval_4_list{list: &x.BadgeIds}
		return protoreflect.ValueOfList(value)
	case "badges.UserIncomingApproval.ownershipTimes":
		if x.OwnershipTimes == nil {
			x.OwnershipTimes = []*UintRange{}
		}
		value := &_UserIncomingApproval_5_list{list: &x.OwnershipTimes}
		return protoreflect.ValueOfList(value)
	case "badges.UserIncomingApproval.approvalCriteria":
		if x.ApprovalCriteria == nil {
			x.ApprovalCriteria = new(IncomingApprovalCriteria)
		}
		return protoreflect.ValueOfMessage(x.ApprovalCriteria.ProtoReflect())
	case "badges.UserIncomingApproval.fromListId":
		panic(fmt.Errorf("field fromListId of message badges.UserIncomingApproval is not mutable"))
	case "badges.UserIncomingApproval.initiatedByListId":
		panic(fmt.Errorf("field initiatedByListId of message badges.UserIncomingApproval is not mutable"))
	case "badges.UserIncomingApproval.uri":
		panic(fmt.Errorf("field uri of message badges.UserIncomingApproval is not mutable"))
	case "badges.UserIncomingApproval.customData":
		panic(fmt.Errorf("field customData of message badges.UserIncomingApproval is not mutable"))
	case "badges.UserIncomingApproval.approvalId":
		panic(fmt.Errorf("field approvalId of message badges.UserIncomingApproval is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserIncomingApproval"))
		}
		panic(fmt.Errorf("message badges.UserIncomingApproval does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_UserIncomingApproval) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.UserIncomingApproval.fromListId":
		return protoreflect.ValueOfString("")
	case "badges.UserIncomingApproval.initiatedByListId":
		return protoreflect.ValueOfString("")
	case "badges.UserIncomingApproval.transferTimes":
		list := []*UintRange{}
		return protoreflect.ValueOfList(&_UserIncomingApproval_3_list{list: &list})
	case "badges.UserIncomingApproval.badgeIds":
		list := []*UintRange{}
		return protoreflect.ValueOfList(&_UserIncomingApproval_4_list{list: &list})
	case "badges.UserIncomingApproval.ownershipTimes":
		list := []*UintRange{}
		return protoreflect.ValueOfList(&_UserIncomingApproval_5_list{list: &list})
	case "badges.UserIncomingApproval.uri":
		return protoreflect.ValueOfString("")
	case "badges.UserIncomingApproval.customData":
		return protoreflect.ValueOfString("")
	case "badges.UserIncomingApproval.approvalId":
		return protoreflect.ValueOfString("")
	case "badges.UserIncomingApproval.approvalCriteria":
		m := new(IncomingApprovalCriteria)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.UserIncomingApproval"))
		}
		panic(fmt.Errorf("message badges.UserIncomingApproval does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_UserIncomingApproval) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.UserIncomingApproval", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_UserIncomingApproval) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_UserIncomingApproval) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_UserIncomingApproval) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_UserIncomingApproval) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*UserIncomingApproval)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.FromListId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.InitiatedByListId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.TransferTimes) > 0 {
			for _, e := range x.TransferTimes {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.BadgeIds) > 0 {
			for _, e := range x.BadgeIds {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.OwnershipTimes) > 0 {
			for _, e := range x.OwnershipTimes {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.Uri)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CustomData)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ApprovalId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ApprovalCriteria != nil {
			l = options.Size(x.ApprovalCriteria)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*UserIncomingApproval)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ApprovalCriteria != nil {
			encoded, err := options.Marshal(x.ApprovalCriteria)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x5a
		}
		if len(x.ApprovalId) > 0 {
			i -= len(x.ApprovalId)
			copy(dAtA[i:], x.ApprovalId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ApprovalId)))
			i--
			dAtA[i] = 0x52
		}
		if len(x.CustomData) > 0 {
			i -= len(x.CustomData)
			copy(dAtA[i:], x.CustomData)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CustomData)))
			i--
			dAtA[i] = 0x4a
		}
		if len(x.Uri) > 0 {
			i -= len(x.Uri)
			copy(dAtA[i:], x.Uri)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Uri)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.OwnershipTimes) > 0 {
			for iNdEx := len(x.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.OwnershipTimes[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x2a
			}
		}
		if len(x.BadgeIds) > 0 {
			for iNdEx := len(x.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.BadgeIds[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if len(x.TransferTimes) > 0 {
			for iNdEx := len(x.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.TransferTimes[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x1a
			}
		}
		if len(x.InitiatedByListId) > 0 {
			i -= len(x.InitiatedByListId)
			copy(dAtA[i:], x.InitiatedByListId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.InitiatedByListId)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.FromListId) > 0 {
			i -= len(x.FromListId)
			copy(dAtA[i:], x.FromListId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FromListId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*UserIncomingApproval)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: UserIncomingApproval: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: UserIncomingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FromListId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FromListId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.InitiatedByListId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TransferTimes = append(x.TransferTimes, &UintRange{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.TransferTimes[len(x.TransferTimes)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BadgeIds = append(x.BadgeIds, &UintRange{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.BadgeIds[len(x.BadgeIds)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OwnershipTimes = append(x.OwnershipTimes, &UintRange{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.OwnershipTimes[len(x.OwnershipTimes)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Uri = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CustomData = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ApprovalId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ApprovalCriteria == nil {
					x.ApprovalCriteria = &IncomingApprovalCriteria{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ApprovalCriteria); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_ManualBalances_1_list)(nil)

type _ManualBalances_1_list struct {
	list *[]*Balance
}

func (x *_ManualBalances_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ManualBalances_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_ManualBalances_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Balance)
	(*x.list)[i] = concreteValue
}

func (x *_ManualBalances_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Balance)
	*x.list = append(*x.list, concreteValue)
}

func (x *_ManualBalances_1_list) AppendMutable() protoreflect.Value {
	v := new(Balance)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ManualBalances_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_ManualBalances_1_list) NewElement() protoreflect.Value {
	v := new(Balance)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ManualBalances_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_ManualBalances          protoreflect.MessageDescriptor
	fd_ManualBalances_balances protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_ManualBalances = File_badges_transfers_proto.Messages().ByName("ManualBalances")
	fd_ManualBalances_balances = md_ManualBalances.Fields().ByName("balances")
}

var _ protoreflect.Message = (*fastReflection_ManualBalances)(nil)

type fastReflection_ManualBalances ManualBalances

func (x *ManualBalances) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ManualBalances)(x)
}

func (x *ManualBalances) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ManualBalances_messageType fastReflection_ManualBalances_messageType
var _ protoreflect.MessageType = fastReflection_ManualBalances_messageType{}

type fastReflection_ManualBalances_messageType struct{}

func (x fastReflection_ManualBalances_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ManualBalances)(nil)
}
func (x fastReflection_ManualBalances_messageType) New() protoreflect.Message {
	return new(fastReflection_ManualBalances)
}
func (x fastReflection_ManualBalances_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ManualBalances
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ManualBalances) Descriptor() protoreflect.MessageDescriptor {
	return md_ManualBalances
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ManualBalances) Type() protoreflect.MessageType {
	return _fastReflection_ManualBalances_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ManualBalances) New() protoreflect.Message {
	return new(fastReflection_ManualBalances)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ManualBalances) Interface() protoreflect.ProtoMessage {
	return (*ManualBalances)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ManualBalances) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Balances) != 0 {
		value := protoreflect.ValueOfList(&_ManualBalances_1_list{list: &x.Balances})
		if !f(fd_ManualBalances_balances, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ManualBalances) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.ManualBalances.balances":
		return len(x.Balances) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ManualBalances"))
		}
		panic(fmt.Errorf("message badges.ManualBalances does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ManualBalances) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.ManualBalances.balances":
		x.Balances = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ManualBalances"))
		}
		panic(fmt.Errorf("message badges.ManualBalances does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ManualBalances) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.ManualBalances.balances":
		if len(x.Balances) == 0 {
			return protoreflect.ValueOfList(&_ManualBalances_1_list{})
		}
		listValue := &_ManualBalances_1_list{list: &x.Balances}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ManualBalances"))
		}
		panic(fmt.Errorf("message badges.ManualBalances does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ManualBalances) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.ManualBalances.balances":
		lv := value.List()
		clv := lv.(*_ManualBalances_1_list)
		x.Balances = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ManualBalances"))
		}
		panic(fmt.Errorf("message badges.ManualBalances does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ManualBalances) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ManualBalances.balances":
		if x.Balances == nil {
			x.Balances = []*Balance{}
		}
		value := &_ManualBalances_1_list{list: &x.Balances}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ManualBalances"))
		}
		panic(fmt.Errorf("message badges.ManualBalances does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ManualBalances) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ManualBalances.balances":
		list := []*Balance{}
		return protoreflect.ValueOfList(&_ManualBalances_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ManualBalances"))
		}
		panic(fmt.Errorf("message badges.ManualBalances does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ManualBalances) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.ManualBalances", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ManualBalances) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ManualBalances) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ManualBalances) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ManualBalances) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ManualBalances)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.Balances) > 0 {
			for _, e := range x.Balances {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ManualBalances)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Balances) > 0 {
			for iNdEx := len(x.Balances) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Balances[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ManualBalances)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ManualBalances: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ManualBalances: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Balances = append(x.Balances, &Balance{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Balances[len(x.Balances)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_IncrementedBalances_1_list)(nil)

type _IncrementedBalances_1_list struct {
	list *[]*Balance
}

func (x *_IncrementedBalances_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_IncrementedBalances_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_IncrementedBalances_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Balance)
	(*x.list)[i] = concreteValue
}

func (x *_IncrementedBalances_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Balance)
	*x.list = append(*x.list, concreteValue)
}

func (x *_IncrementedBalances_1_list) AppendMutable() protoreflect.Value {
	v := new(Balance)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_IncrementedBalances_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_IncrementedBalances_1_list) NewElement() protoreflect.Value {
	v := new(Balance)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_IncrementedBalances_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_IncrementedBalances                           protoreflect.MessageDescriptor
	fd_IncrementedBalances_startBalances             protoreflect.FieldDescriptor
	fd_IncrementedBalances_incrementBadgeIdsBy       protoreflect.FieldDescriptor
	fd_IncrementedBalances_incrementOwnershipTimesBy protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_IncrementedBalances = File_badges_transfers_proto.Messages().ByName("IncrementedBalances")
	fd_IncrementedBalances_startBalances = md_IncrementedBalances.Fields().ByName("startBalances")
	fd_IncrementedBalances_incrementBadgeIdsBy = md_IncrementedBalances.Fields().ByName("incrementBadgeIdsBy")
	fd_IncrementedBalances_incrementOwnershipTimesBy = md_IncrementedBalances.Fields().ByName("incrementOwnershipTimesBy")
}

var _ protoreflect.Message = (*fastReflection_IncrementedBalances)(nil)

type fastReflection_IncrementedBalances IncrementedBalances

func (x *IncrementedBalances) ProtoReflect() protoreflect.Message {
	return (*fastReflection_IncrementedBalances)(x)
}

func (x *IncrementedBalances) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_IncrementedBalances_messageType fastReflection_IncrementedBalances_messageType
var _ protoreflect.MessageType = fastReflection_IncrementedBalances_messageType{}

type fastReflection_IncrementedBalances_messageType struct{}

func (x fastReflection_IncrementedBalances_messageType) Zero() protoreflect.Message {
	return (*fastReflection_IncrementedBalances)(nil)
}
func (x fastReflection_IncrementedBalances_messageType) New() protoreflect.Message {
	return new(fastReflection_IncrementedBalances)
}
func (x fastReflection_IncrementedBalances_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_IncrementedBalances
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_IncrementedBalances) Descriptor() protoreflect.MessageDescriptor {
	return md_IncrementedBalances
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_IncrementedBalances) Type() protoreflect.MessageType {
	return _fastReflection_IncrementedBalances_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_IncrementedBalances) New() protoreflect.Message {
	return new(fastReflection_IncrementedBalances)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_IncrementedBalances) Interface() protoreflect.ProtoMessage {
	return (*IncrementedBalances)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_IncrementedBalances) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.StartBalances) != 0 {
		value := protoreflect.ValueOfList(&_IncrementedBalances_1_list{list: &x.StartBalances})
		if !f(fd_IncrementedBalances_startBalances, value) {
			return
		}
	}
	if x.IncrementBadgeIdsBy != "" {
		value := protoreflect.ValueOfString(x.IncrementBadgeIdsBy)
		if !f(fd_IncrementedBalances_incrementBadgeIdsBy, value) {
			return
		}
	}
	if x.IncrementOwnershipTimesBy != "" {
		value := protoreflect.ValueOfString(x.IncrementOwnershipTimesBy)
		if !f(fd_IncrementedBalances_incrementOwnershipTimesBy, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_IncrementedBalances) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.IncrementedBalances.startBalances":
		return len(x.StartBalances) != 0
	case "badges.IncrementedBalances.incrementBadgeIdsBy":
		return x.IncrementBadgeIdsBy != ""
	case "badges.IncrementedBalances.incrementOwnershipTimesBy":
		return x.IncrementOwnershipTimesBy != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncrementedBalances"))
		}
		panic(fmt.Errorf("message badges.IncrementedBalances does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_IncrementedBalances) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.IncrementedBalances.startBalances":
		x.StartBalances = nil
	case "badges.IncrementedBalances.incrementBadgeIdsBy":
		x.IncrementBadgeIdsBy = ""
	case "badges.IncrementedBalances.incrementOwnershipTimesBy":
		x.IncrementOwnershipTimesBy = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncrementedBalances"))
		}
		panic(fmt.Errorf("message badges.IncrementedBalances does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_IncrementedBalances) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.IncrementedBalances.startBalances":
		if len(x.StartBalances) == 0 {
			return protoreflect.ValueOfList(&_IncrementedBalances_1_list{})
		}
		listValue := &_IncrementedBalances_1_list{list: &x.StartBalances}
		return protoreflect.ValueOfList(listValue)
	case "badges.IncrementedBalances.incrementBadgeIdsBy":
		value := x.IncrementBadgeIdsBy
		return protoreflect.ValueOfString(value)
	case "badges.IncrementedBalances.incrementOwnershipTimesBy":
		value := x.IncrementOwnershipTimesBy
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncrementedBalances"))
		}
		panic(fmt.Errorf("message badges.IncrementedBalances does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_IncrementedBalances) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.IncrementedBalances.startBalances":
		lv := value.List()
		clv := lv.(*_IncrementedBalances_1_list)
		x.StartBalances = *clv.list
	case "badges.IncrementedBalances.incrementBadgeIdsBy":
		x.IncrementBadgeIdsBy = value.Interface().(string)
	case "badges.IncrementedBalances.incrementOwnershipTimesBy":
		x.IncrementOwnershipTimesBy = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncrementedBalances"))
		}
		panic(fmt.Errorf("message badges.IncrementedBalances does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_IncrementedBalances) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.IncrementedBalances.startBalances":
		if x.StartBalances == nil {
			x.StartBalances = []*Balance{}
		}
		value := &_IncrementedBalances_1_list{list: &x.StartBalances}
		return protoreflect.ValueOfList(value)
	case "badges.IncrementedBalances.incrementBadgeIdsBy":
		panic(fmt.Errorf("field incrementBadgeIdsBy of message badges.IncrementedBalances is not mutable"))
	case "badges.IncrementedBalances.incrementOwnershipTimesBy":
		panic(fmt.Errorf("field incrementOwnershipTimesBy of message badges.IncrementedBalances is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncrementedBalances"))
		}
		panic(fmt.Errorf("message badges.IncrementedBalances does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_IncrementedBalances) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.IncrementedBalances.startBalances":
		list := []*Balance{}
		return protoreflect.ValueOfList(&_IncrementedBalances_1_list{list: &list})
	case "badges.IncrementedBalances.incrementBadgeIdsBy":
		return protoreflect.ValueOfString("")
	case "badges.IncrementedBalances.incrementOwnershipTimesBy":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncrementedBalances"))
		}
		panic(fmt.Errorf("message badges.IncrementedBalances does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_IncrementedBalances) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.IncrementedBalances", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_IncrementedBalances) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_IncrementedBalances) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_IncrementedBalances) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_IncrementedBalances) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*IncrementedBalances)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.StartBalances) > 0 {
			for _, e := range x.StartBalances {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.IncrementBadgeIdsBy)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.IncrementOwnershipTimesBy)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*IncrementedBalances)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.IncrementOwnershipTimesBy) > 0 {
			i -= len(x.IncrementOwnershipTimesBy)
			copy(dAtA[i:], x.IncrementOwnershipTimesBy)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.IncrementOwnershipTimesBy)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.IncrementBadgeIdsBy) > 0 {
			i -= len(x.IncrementBadgeIdsBy)
			copy(dAtA[i:], x.IncrementBadgeIdsBy)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.IncrementBadgeIdsBy)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.StartBalances) > 0 {
			for iNdEx := len(x.StartBalances) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.StartBalances[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*IncrementedBalances)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: IncrementedBalances: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: IncrementedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StartBalances", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.StartBalances = append(x.StartBalances, &Balance{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.StartBalances[len(x.StartBalances)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IncrementBadgeIdsBy", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.IncrementBadgeIdsBy = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IncrementOwnershipTimesBy", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.IncrementOwnershipTimesBy = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_PredeterminedOrderCalculationMethod                                      protoreflect.MessageDescriptor
	fd_PredeterminedOrderCalculationMethod_useOverallNumTransfers               protoreflect.FieldDescriptor
	fd_PredeterminedOrderCalculationMethod_usePerToAddressNumTransfers          protoreflect.FieldDescriptor
	fd_PredeterminedOrderCalculationMethod_usePerFromAddressNumTransfers        protoreflect.FieldDescriptor
	fd_PredeterminedOrderCalculationMethod_usePerInitiatedByAddressNumTransfers protoreflect.FieldDescriptor
	fd_PredeterminedOrderCalculationMethod_useMerkleChallengeLeafIndex          protoreflect.FieldDescriptor
	fd_PredeterminedOrderCalculationMethod_challengeTrackerId                   protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_PredeterminedOrderCalculationMethod = File_badges_transfers_proto.Messages().ByName("PredeterminedOrderCalculationMethod")
	fd_PredeterminedOrderCalculationMethod_useOverallNumTransfers = md_PredeterminedOrderCalculationMethod.Fields().ByName("useOverallNumTransfers")
	fd_PredeterminedOrderCalculationMethod_usePerToAddressNumTransfers = md_PredeterminedOrderCalculationMethod.Fields().ByName("usePerToAddressNumTransfers")
	fd_PredeterminedOrderCalculationMethod_usePerFromAddressNumTransfers = md_PredeterminedOrderCalculationMethod.Fields().ByName("usePerFromAddressNumTransfers")
	fd_PredeterminedOrderCalculationMethod_usePerInitiatedByAddressNumTransfers = md_PredeterminedOrderCalculationMethod.Fields().ByName("usePerInitiatedByAddressNumTransfers")
	fd_PredeterminedOrderCalculationMethod_useMerkleChallengeLeafIndex = md_PredeterminedOrderCalculationMethod.Fields().ByName("useMerkleChallengeLeafIndex")
	fd_PredeterminedOrderCalculationMethod_challengeTrackerId = md_PredeterminedOrderCalculationMethod.Fields().ByName("challengeTrackerId")
}

var _ protoreflect.Message = (*fastReflection_PredeterminedOrderCalculationMethod)(nil)

type fastReflection_PredeterminedOrderCalculationMethod PredeterminedOrderCalculationMethod

func (x *PredeterminedOrderCalculationMethod) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PredeterminedOrderCalculationMethod)(x)
}

func (x *PredeterminedOrderCalculationMethod) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PredeterminedOrderCalculationMethod_messageType fastReflection_PredeterminedOrderCalculationMethod_messageType
var _ protoreflect.MessageType = fastReflection_PredeterminedOrderCalculationMethod_messageType{}

type fastReflection_PredeterminedOrderCalculationMethod_messageType struct{}

func (x fastReflection_PredeterminedOrderCalculationMethod_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PredeterminedOrderCalculationMethod)(nil)
}
func (x fastReflection_PredeterminedOrderCalculationMethod_messageType) New() protoreflect.Message {
	return new(fastReflection_PredeterminedOrderCalculationMethod)
}
func (x fastReflection_PredeterminedOrderCalculationMethod_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PredeterminedOrderCalculationMethod
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PredeterminedOrderCalculationMethod) Descriptor() protoreflect.MessageDescriptor {
	return md_PredeterminedOrderCalculationMethod
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PredeterminedOrderCalculationMethod) Type() protoreflect.MessageType {
	return _fastReflection_PredeterminedOrderCalculationMethod_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PredeterminedOrderCalculationMethod) New() protoreflect.Message {
	return new(fastReflection_PredeterminedOrderCalculationMethod)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PredeterminedOrderCalculationMethod) Interface() protoreflect.ProtoMessage {
	return (*PredeterminedOrderCalculationMethod)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PredeterminedOrderCalculationMethod) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.UseOverallNumTransfers != false {
		value := protoreflect.ValueOfBool(x.UseOverallNumTransfers)
		if !f(fd_PredeterminedOrderCalculationMethod_useOverallNumTransfers, value) {
			return
		}
	}
	if x.UsePerToAddressNumTransfers != false {
		value := protoreflect.ValueOfBool(x.UsePerToAddressNumTransfers)
		if !f(fd_PredeterminedOrderCalculationMethod_usePerToAddressNumTransfers, value) {
			return
		}
	}
	if x.UsePerFromAddressNumTransfers != false {
		value := protoreflect.ValueOfBool(x.UsePerFromAddressNumTransfers)
		if !f(fd_PredeterminedOrderCalculationMethod_usePerFromAddressNumTransfers, value) {
			return
		}
	}
	if x.UsePerInitiatedByAddressNumTransfers != false {
		value := protoreflect.ValueOfBool(x.UsePerInitiatedByAddressNumTransfers)
		if !f(fd_PredeterminedOrderCalculationMethod_usePerInitiatedByAddressNumTransfers, value) {
			return
		}
	}
	if x.UseMerkleChallengeLeafIndex != false {
		value := protoreflect.ValueOfBool(x.UseMerkleChallengeLeafIndex)
		if !f(fd_PredeterminedOrderCalculationMethod_useMerkleChallengeLeafIndex, value) {
			return
		}
	}
	if x.ChallengeTrackerId != "" {
		value := protoreflect.ValueOfString(x.ChallengeTrackerId)
		if !f(fd_PredeterminedOrderCalculationMethod_challengeTrackerId, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PredeterminedOrderCalculationMethod) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.PredeterminedOrderCalculationMethod.useOverallNumTransfers":
		return x.UseOverallNumTransfers != false
	case "badges.PredeterminedOrderCalculationMethod.usePerToAddressNumTransfers":
		return x.UsePerToAddressNumTransfers != false
	case "badges.PredeterminedOrderCalculationMethod.usePerFromAddressNumTransfers":
		return x.UsePerFromAddressNumTransfers != false
	case "badges.PredeterminedOrderCalculationMethod.usePerInitiatedByAddressNumTransfers":
		return x.UsePerInitiatedByAddressNumTransfers != false
	case "badges.PredeterminedOrderCalculationMethod.useMerkleChallengeLeafIndex":
		return x.UseMerkleChallengeLeafIndex != false
	case "badges.PredeterminedOrderCalculationMethod.challengeTrackerId":
		return x.ChallengeTrackerId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedOrderCalculationMethod"))
		}
		panic(fmt.Errorf("message badges.PredeterminedOrderCalculationMethod does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PredeterminedOrderCalculationMethod) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.PredeterminedOrderCalculationMethod.useOverallNumTransfers":
		x.UseOverallNumTransfers = false
	case "badges.PredeterminedOrderCalculationMethod.usePerToAddressNumTransfers":
		x.UsePerToAddressNumTransfers = false
	case "badges.PredeterminedOrderCalculationMethod.usePerFromAddressNumTransfers":
		x.UsePerFromAddressNumTransfers = false
	case "badges.PredeterminedOrderCalculationMethod.usePerInitiatedByAddressNumTransfers":
		x.UsePerInitiatedByAddressNumTransfers = false
	case "badges.PredeterminedOrderCalculationMethod.useMerkleChallengeLeafIndex":
		x.UseMerkleChallengeLeafIndex = false
	case "badges.PredeterminedOrderCalculationMethod.challengeTrackerId":
		x.ChallengeTrackerId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedOrderCalculationMethod"))
		}
		panic(fmt.Errorf("message badges.PredeterminedOrderCalculationMethod does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PredeterminedOrderCalculationMethod) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.PredeterminedOrderCalculationMethod.useOverallNumTransfers":
		value := x.UseOverallNumTransfers
		return protoreflect.ValueOfBool(value)
	case "badges.PredeterminedOrderCalculationMethod.usePerToAddressNumTransfers":
		value := x.UsePerToAddressNumTransfers
		return protoreflect.ValueOfBool(value)
	case "badges.PredeterminedOrderCalculationMethod.usePerFromAddressNumTransfers":
		value := x.UsePerFromAddressNumTransfers
		return protoreflect.ValueOfBool(value)
	case "badges.PredeterminedOrderCalculationMethod.usePerInitiatedByAddressNumTransfers":
		value := x.UsePerInitiatedByAddressNumTransfers
		return protoreflect.ValueOfBool(value)
	case "badges.PredeterminedOrderCalculationMethod.useMerkleChallengeLeafIndex":
		value := x.UseMerkleChallengeLeafIndex
		return protoreflect.ValueOfBool(value)
	case "badges.PredeterminedOrderCalculationMethod.challengeTrackerId":
		value := x.ChallengeTrackerId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedOrderCalculationMethod"))
		}
		panic(fmt.Errorf("message badges.PredeterminedOrderCalculationMethod does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PredeterminedOrderCalculationMethod) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.PredeterminedOrderCalculationMethod.useOverallNumTransfers":
		x.UseOverallNumTransfers = value.Bool()
	case "badges.PredeterminedOrderCalculationMethod.usePerToAddressNumTransfers":
		x.UsePerToAddressNumTransfers = value.Bool()
	case "badges.PredeterminedOrderCalculationMethod.usePerFromAddressNumTransfers":
		x.UsePerFromAddressNumTransfers = value.Bool()
	case "badges.PredeterminedOrderCalculationMethod.usePerInitiatedByAddressNumTransfers":
		x.UsePerInitiatedByAddressNumTransfers = value.Bool()
	case "badges.PredeterminedOrderCalculationMethod.useMerkleChallengeLeafIndex":
		x.UseMerkleChallengeLeafIndex = value.Bool()
	case "badges.PredeterminedOrderCalculationMethod.challengeTrackerId":
		x.ChallengeTrackerId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedOrderCalculationMethod"))
		}
		panic(fmt.Errorf("message badges.PredeterminedOrderCalculationMethod does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PredeterminedOrderCalculationMethod) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.PredeterminedOrderCalculationMethod.useOverallNumTransfers":
		panic(fmt.Errorf("field useOverallNumTransfers of message badges.PredeterminedOrderCalculationMethod is not mutable"))
	case "badges.PredeterminedOrderCalculationMethod.usePerToAddressNumTransfers":
		panic(fmt.Errorf("field usePerToAddressNumTransfers of message badges.PredeterminedOrderCalculationMethod is not mutable"))
	case "badges.PredeterminedOrderCalculationMethod.usePerFromAddressNumTransfers":
		panic(fmt.Errorf("field usePerFromAddressNumTransfers of message badges.PredeterminedOrderCalculationMethod is not mutable"))
	case "badges.PredeterminedOrderCalculationMethod.usePerInitiatedByAddressNumTransfers":
		panic(fmt.Errorf("field usePerInitiatedByAddressNumTransfers of message badges.PredeterminedOrderCalculationMethod is not mutable"))
	case "badges.PredeterminedOrderCalculationMethod.useMerkleChallengeLeafIndex":
		panic(fmt.Errorf("field useMerkleChallengeLeafIndex of message badges.PredeterminedOrderCalculationMethod is not mutable"))
	case "badges.PredeterminedOrderCalculationMethod.challengeTrackerId":
		panic(fmt.Errorf("field challengeTrackerId of message badges.PredeterminedOrderCalculationMethod is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedOrderCalculationMethod"))
		}
		panic(fmt.Errorf("message badges.PredeterminedOrderCalculationMethod does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PredeterminedOrderCalculationMethod) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.PredeterminedOrderCalculationMethod.useOverallNumTransfers":
		return protoreflect.ValueOfBool(false)
	case "badges.PredeterminedOrderCalculationMethod.usePerToAddressNumTransfers":
		return protoreflect.ValueOfBool(false)
	case "badges.PredeterminedOrderCalculationMethod.usePerFromAddressNumTransfers":
		return protoreflect.ValueOfBool(false)
	case "badges.PredeterminedOrderCalculationMethod.usePerInitiatedByAddressNumTransfers":
		return protoreflect.ValueOfBool(false)
	case "badges.PredeterminedOrderCalculationMethod.useMerkleChallengeLeafIndex":
		return protoreflect.ValueOfBool(false)
	case "badges.PredeterminedOrderCalculationMethod.challengeTrackerId":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedOrderCalculationMethod"))
		}
		panic(fmt.Errorf("message badges.PredeterminedOrderCalculationMethod does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PredeterminedOrderCalculationMethod) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.PredeterminedOrderCalculationMethod", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PredeterminedOrderCalculationMethod) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PredeterminedOrderCalculationMethod) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PredeterminedOrderCalculationMethod) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PredeterminedOrderCalculationMethod) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PredeterminedOrderCalculationMethod)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.UseOverallNumTransfers {
			n += 2
		}
		if x.UsePerToAddressNumTransfers {
			n += 2
		}
		if x.UsePerFromAddressNumTransfers {
			n += 2
		}
		if x.UsePerInitiatedByAddressNumTransfers {
			n += 2
		}
		if x.UseMerkleChallengeLeafIndex {
			n += 2
		}
		l = len(x.ChallengeTrackerId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PredeterminedOrderCalculationMethod)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ChallengeTrackerId) > 0 {
			i -= len(x.ChallengeTrackerId)
			copy(dAtA[i:], x.ChallengeTrackerId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ChallengeTrackerId)))
			i--
			dAtA[i] = 0x32
		}
		if x.UseMerkleChallengeLeafIndex {
			i--
			if x.UseMerkleChallengeLeafIndex {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if x.UsePerInitiatedByAddressNumTransfers {
			i--
			if x.UsePerInitiatedByAddressNumTransfers {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x20
		}
		if x.UsePerFromAddressNumTransfers {
			i--
			if x.UsePerFromAddressNumTransfers {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x18
		}
		if x.UsePerToAddressNumTransfers {
			i--
			if x.UsePerToAddressNumTransfers {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
		}
		if x.UseOverallNumTransfers {
			i--
			if x.UseOverallNumTransfers {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PredeterminedOrderCalculationMethod)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PredeterminedOrderCalculationMethod: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PredeterminedOrderCalculationMethod: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UseOverallNumTransfers", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UseOverallNumTransfers = bool(v != 0)
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UsePerToAddressNumTransfers", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UsePerToAddressNumTransfers = bool(v != 0)
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UsePerFromAddressNumTransfers", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UsePerFromAddressNumTransfers = bool(v != 0)
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UsePerInitiatedByAddressNumTransfers", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UsePerInitiatedByAddressNumTransfers = bool(v != 0)
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UseMerkleChallengeLeafIndex", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.UseMerkleChallengeLeafIndex = bool(v != 0)
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_PredeterminedBalances_1_list)(nil)

type _PredeterminedBalances_1_list struct {
	list *[]*ManualBalances
}

func (x *_PredeterminedBalances_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_PredeterminedBalances_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_PredeterminedBalances_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ManualBalances)
	(*x.list)[i] = concreteValue
}

func (x *_PredeterminedBalances_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ManualBalances)
	*x.list = append(*x.list, concreteValue)
}

func (x *_PredeterminedBalances_1_list) AppendMutable() protoreflect.Value {
	v := new(ManualBalances)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_PredeterminedBalances_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_PredeterminedBalances_1_list) NewElement() protoreflect.Value {
	v := new(ManualBalances)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_PredeterminedBalances_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_PredeterminedBalances                        protoreflect.MessageDescriptor
	fd_PredeterminedBalances_manualBalances         protoreflect.FieldDescriptor
	fd_PredeterminedBalances_incrementedBalances    protoreflect.FieldDescriptor
	fd_PredeterminedBalances_orderCalculationMethod protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_PredeterminedBalances = File_badges_transfers_proto.Messages().ByName("PredeterminedBalances")
	fd_PredeterminedBalances_manualBalances = md_PredeterminedBalances.Fields().ByName("manualBalances")
	fd_PredeterminedBalances_incrementedBalances = md_PredeterminedBalances.Fields().ByName("incrementedBalances")
	fd_PredeterminedBalances_orderCalculationMethod = md_PredeterminedBalances.Fields().ByName("orderCalculationMethod")
}

var _ protoreflect.Message = (*fastReflection_PredeterminedBalances)(nil)

type fastReflection_PredeterminedBalances PredeterminedBalances

func (x *PredeterminedBalances) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PredeterminedBalances)(x)
}

func (x *PredeterminedBalances) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PredeterminedBalances_messageType fastReflection_PredeterminedBalances_messageType
var _ protoreflect.MessageType = fastReflection_PredeterminedBalances_messageType{}

type fastReflection_PredeterminedBalances_messageType struct{}

func (x fastReflection_PredeterminedBalances_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PredeterminedBalances)(nil)
}
func (x fastReflection_PredeterminedBalances_messageType) New() protoreflect.Message {
	return new(fastReflection_PredeterminedBalances)
}
func (x fastReflection_PredeterminedBalances_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PredeterminedBalances
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PredeterminedBalances) Descriptor() protoreflect.MessageDescriptor {
	return md_PredeterminedBalances
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PredeterminedBalances) Type() protoreflect.MessageType {
	return _fastReflection_PredeterminedBalances_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PredeterminedBalances) New() protoreflect.Message {
	return new(fastReflection_PredeterminedBalances)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PredeterminedBalances) Interface() protoreflect.ProtoMessage {
	return (*PredeterminedBalances)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PredeterminedBalances) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.ManualBalances) != 0 {
		value := protoreflect.ValueOfList(&_PredeterminedBalances_1_list{list: &x.ManualBalances})
		if !f(fd_PredeterminedBalances_manualBalances, value) {
			return
		}
	}
	if x.IncrementedBalances != nil {
		value := protoreflect.ValueOfMessage(x.IncrementedBalances.ProtoReflect())
		if !f(fd_PredeterminedBalances_incrementedBalances, value) {
			return
		}
	}
	if x.OrderCalculationMethod != nil {
		value := protoreflect.ValueOfMessage(x.OrderCalculationMethod.ProtoReflect())
		if !f(fd_PredeterminedBalances_orderCalculationMethod, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PredeterminedBalances) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.PredeterminedBalances.manualBalances":
		return len(x.ManualBalances) != 0
	case "badges.PredeterminedBalances.incrementedBalances":
		return x.IncrementedBalances != nil
	case "badges.PredeterminedBalances.orderCalculationMethod":
		return x.OrderCalculationMethod != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedBalances"))
		}
		panic(fmt.Errorf("message badges.PredeterminedBalances does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PredeterminedBalances) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.PredeterminedBalances.manualBalances":
		x.ManualBalances = nil
	case "badges.PredeterminedBalances.incrementedBalances":
		x.IncrementedBalances = nil
	case "badges.PredeterminedBalances.orderCalculationMethod":
		x.OrderCalculationMethod = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedBalances"))
		}
		panic(fmt.Errorf("message badges.PredeterminedBalances does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PredeterminedBalances) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.PredeterminedBalances.manualBalances":
		if len(x.ManualBalances) == 0 {
			return protoreflect.ValueOfList(&_PredeterminedBalances_1_list{})
		}
		listValue := &_PredeterminedBalances_1_list{list: &x.ManualBalances}
		return protoreflect.ValueOfList(listValue)
	case "badges.PredeterminedBalances.incrementedBalances":
		value := x.IncrementedBalances
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "badges.PredeterminedBalances.orderCalculationMethod":
		value := x.OrderCalculationMethod
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedBalances"))
		}
		panic(fmt.Errorf("message badges.PredeterminedBalances does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PredeterminedBalances) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.PredeterminedBalances.manualBalances":
		lv := value.List()
		clv := lv.(*_PredeterminedBalances_1_list)
		x.ManualBalances = *clv.list
	case "badges.PredeterminedBalances.incrementedBalances":
		x.IncrementedBalances = value.Message().Interface().(*IncrementedBalances)
	case "badges.PredeterminedBalances.orderCalculationMethod":
		x.OrderCalculationMethod = value.Message().Interface().(*PredeterminedOrderCalculationMethod)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedBalances"))
		}
		panic(fmt.Errorf("message badges.PredeterminedBalances does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PredeterminedBalances) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.PredeterminedBalances.manualBalances":
		if x.ManualBalances == nil {
			x.ManualBalances = []*ManualBalances{}
		}
		value := &_PredeterminedBalances_1_list{list: &x.ManualBalances}
		return protoreflect.ValueOfList(value)
	case "badges.PredeterminedBalances.incrementedBalances":
		if x.IncrementedBalances == nil {
			x.IncrementedBalances = new(IncrementedBalances)
		}
		return protoreflect.ValueOfMessage(x.IncrementedBalances.ProtoReflect())
	case "badges.PredeterminedBalances.orderCalculationMethod":
		if x.OrderCalculationMethod == nil {
			x.OrderCalculationMethod = new(PredeterminedOrderCalculationMethod)
		}
		return protoreflect.ValueOfMessage(x.OrderCalculationMethod.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedBalances"))
		}
		panic(fmt.Errorf("message badges.PredeterminedBalances does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PredeterminedBalances) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.PredeterminedBalances.manualBalances":
		list := []*ManualBalances{}
		return protoreflect.ValueOfList(&_PredeterminedBalances_1_list{list: &list})
	case "badges.PredeterminedBalances.incrementedBalances":
		m := new(IncrementedBalances)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "badges.PredeterminedBalances.orderCalculationMethod":
		m := new(PredeterminedOrderCalculationMethod)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.PredeterminedBalances"))
		}
		panic(fmt.Errorf("message badges.PredeterminedBalances does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PredeterminedBalances) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.PredeterminedBalances", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PredeterminedBalances) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PredeterminedBalances) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PredeterminedBalances) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PredeterminedBalances) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PredeterminedBalances)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.ManualBalances) > 0 {
			for _, e := range x.ManualBalances {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.IncrementedBalances != nil {
			l = options.Size(x.IncrementedBalances)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.OrderCalculationMethod != nil {
			l = options.Size(x.OrderCalculationMethod)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PredeterminedBalances)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.OrderCalculationMethod != nil {
			encoded, err := options.Marshal(x.OrderCalculationMethod)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if x.IncrementedBalances != nil {
			encoded, err := options.Marshal(x.IncrementedBalances)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.ManualBalances) > 0 {
			for iNdEx := len(x.ManualBalances) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.ManualBalances[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PredeterminedBalances)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PredeterminedBalances: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PredeterminedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ManualBalances", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ManualBalances = append(x.ManualBalances, &ManualBalances{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ManualBalances[len(x.ManualBalances)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IncrementedBalances", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.IncrementedBalances == nil {
					x.IncrementedBalances = &IncrementedBalances{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.IncrementedBalances); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OrderCalculationMethod", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.OrderCalculationMethod == nil {
					x.OrderCalculationMethod = &PredeterminedOrderCalculationMethod{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.OrderCalculationMethod); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ApprovalAmounts                                     protoreflect.MessageDescriptor
	fd_ApprovalAmounts_overallApprovalAmount               protoreflect.FieldDescriptor
	fd_ApprovalAmounts_perToAddressApprovalAmount          protoreflect.FieldDescriptor
	fd_ApprovalAmounts_perFromAddressApprovalAmount        protoreflect.FieldDescriptor
	fd_ApprovalAmounts_perInitiatedByAddressApprovalAmount protoreflect.FieldDescriptor
	fd_ApprovalAmounts_amountTrackerId                     protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_ApprovalAmounts = File_badges_transfers_proto.Messages().ByName("ApprovalAmounts")
	fd_ApprovalAmounts_overallApprovalAmount = md_ApprovalAmounts.Fields().ByName("overallApprovalAmount")
	fd_ApprovalAmounts_perToAddressApprovalAmount = md_ApprovalAmounts.Fields().ByName("perToAddressApprovalAmount")
	fd_ApprovalAmounts_perFromAddressApprovalAmount = md_ApprovalAmounts.Fields().ByName("perFromAddressApprovalAmount")
	fd_ApprovalAmounts_perInitiatedByAddressApprovalAmount = md_ApprovalAmounts.Fields().ByName("perInitiatedByAddressApprovalAmount")
	fd_ApprovalAmounts_amountTrackerId = md_ApprovalAmounts.Fields().ByName("amountTrackerId")
}

var _ protoreflect.Message = (*fastReflection_ApprovalAmounts)(nil)

type fastReflection_ApprovalAmounts ApprovalAmounts

func (x *ApprovalAmounts) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ApprovalAmounts)(x)
}

func (x *ApprovalAmounts) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ApprovalAmounts_messageType fastReflection_ApprovalAmounts_messageType
var _ protoreflect.MessageType = fastReflection_ApprovalAmounts_messageType{}

type fastReflection_ApprovalAmounts_messageType struct{}

func (x fastReflection_ApprovalAmounts_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ApprovalAmounts)(nil)
}
func (x fastReflection_ApprovalAmounts_messageType) New() protoreflect.Message {
	return new(fastReflection_ApprovalAmounts)
}
func (x fastReflection_ApprovalAmounts_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ApprovalAmounts
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ApprovalAmounts) Descriptor() protoreflect.MessageDescriptor {
	return md_ApprovalAmounts
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ApprovalAmounts) Type() protoreflect.MessageType {
	return _fastReflection_ApprovalAmounts_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ApprovalAmounts) New() protoreflect.Message {
	return new(fastReflection_ApprovalAmounts)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ApprovalAmounts) Interface() protoreflect.ProtoMessage {
	return (*ApprovalAmounts)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ApprovalAmounts) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.OverallApprovalAmount != "" {
		value := protoreflect.ValueOfString(x.OverallApprovalAmount)
		if !f(fd_ApprovalAmounts_overallApprovalAmount, value) {
			return
		}
	}
	if x.PerToAddressApprovalAmount != "" {
		value := protoreflect.ValueOfString(x.PerToAddressApprovalAmount)
		if !f(fd_ApprovalAmounts_perToAddressApprovalAmount, value) {
			return
		}
	}
	if x.PerFromAddressApprovalAmount != "" {
		value := protoreflect.ValueOfString(x.PerFromAddressApprovalAmount)
		if !f(fd_ApprovalAmounts_perFromAddressApprovalAmount, value) {
			return
		}
	}
	if x.PerInitiatedByAddressApprovalAmount != "" {
		value := protoreflect.ValueOfString(x.PerInitiatedByAddressApprovalAmount)
		if !f(fd_ApprovalAmounts_perInitiatedByAddressApprovalAmount, value) {
			return
		}
	}
	if x.AmountTrackerId != "" {
		value := protoreflect.ValueOfString(x.AmountTrackerId)
		if !f(fd_ApprovalAmounts_amountTrackerId, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ApprovalAmounts) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.ApprovalAmounts.overallApprovalAmount":
		return x.OverallApprovalAmount != ""
	case "badges.ApprovalAmounts.perToAddressApprovalAmount":
		return x.PerToAddressApprovalAmount != ""
	case "badges.ApprovalAmounts.perFromAddressApprovalAmount":
		return x.PerFromAddressApprovalAmount != ""
	case "badges.ApprovalAmounts.perInitiatedByAddressApprovalAmount":
		return x.PerInitiatedByAddressApprovalAmount != ""
	case "badges.ApprovalAmounts.amountTrackerId":
		return x.AmountTrackerId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalAmounts"))
		}
		panic(fmt.Errorf("message badges.ApprovalAmounts does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalAmounts) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.ApprovalAmounts.overallApprovalAmount":
		x.OverallApprovalAmount = ""
	case "badges.ApprovalAmounts.perToAddressApprovalAmount":
		x.PerToAddressApprovalAmount = ""
	case "badges.ApprovalAmounts.perFromAddressApprovalAmount":
		x.PerFromAddressApprovalAmount = ""
	case "badges.ApprovalAmounts.perInitiatedByAddressApprovalAmount":
		x.PerInitiatedByAddressApprovalAmount = ""
	case "badges.ApprovalAmounts.amountTrackerId":
		x.AmountTrackerId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalAmounts"))
		}
		panic(fmt.Errorf("message badges.ApprovalAmounts does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ApprovalAmounts) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.ApprovalAmounts.overallApprovalAmount":
		value := x.OverallApprovalAmount
		return protoreflect.ValueOfString(value)
	case "badges.ApprovalAmounts.perToAddressApprovalAmount":
		value := x.PerToAddressApprovalAmount
		return protoreflect.ValueOfString(value)
	case "badges.ApprovalAmounts.perFromAddressApprovalAmount":
		value := x.PerFromAddressApprovalAmount
		return protoreflect.ValueOfString(value)
	case "badges.ApprovalAmounts.perInitiatedByAddressApprovalAmount":
		value := x.PerInitiatedByAddressApprovalAmount
		return protoreflect.ValueOfString(value)
	case "badges.ApprovalAmounts.amountTrackerId":
		value := x.AmountTrackerId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalAmounts"))
		}
		panic(fmt.Errorf("message badges.ApprovalAmounts does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalAmounts) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.ApprovalAmounts.overallApprovalAmount":
		x.OverallApprovalAmount = value.Interface().(string)
	case "badges.ApprovalAmounts.perToAddressApprovalAmount":
		x.PerToAddressApprovalAmount = value.Interface().(string)
	case "badges.ApprovalAmounts.perFromAddressApprovalAmount":
		x.PerFromAddressApprovalAmount = value.Interface().(string)
	case "badges.ApprovalAmounts.perInitiatedByAddressApprovalAmount":
		x.PerInitiatedByAddressApprovalAmount = value.Interface().(string)
	case "badges.ApprovalAmounts.amountTrackerId":
		x.AmountTrackerId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalAmounts"))
		}
		panic(fmt.Errorf("message badges.ApprovalAmounts does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalAmounts) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ApprovalAmounts.overallApprovalAmount":
		panic(fmt.Errorf("field overallApprovalAmount of message badges.ApprovalAmounts is not mutable"))
	case "badges.ApprovalAmounts.perToAddressApprovalAmount":
		panic(fmt.Errorf("field perToAddressApprovalAmount of message badges.ApprovalAmounts is not mutable"))
	case "badges.ApprovalAmounts.perFromAddressApprovalAmount":
		panic(fmt.Errorf("field perFromAddressApprovalAmount of message badges.ApprovalAmounts is not mutable"))
	case "badges.ApprovalAmounts.perInitiatedByAddressApprovalAmount":
		panic(fmt.Errorf("field perInitiatedByAddressApprovalAmount of message badges.ApprovalAmounts is not mutable"))
	case "badges.ApprovalAmounts.amountTrackerId":
		panic(fmt.Errorf("field amountTrackerId of message badges.ApprovalAmounts is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalAmounts"))
		}
		panic(fmt.Errorf("message badges.ApprovalAmounts does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ApprovalAmounts) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ApprovalAmounts.overallApprovalAmount":
		return protoreflect.ValueOfString("")
	case "badges.ApprovalAmounts.perToAddressApprovalAmount":
		return protoreflect.ValueOfString("")
	case "badges.ApprovalAmounts.perFromAddressApprovalAmount":
		return protoreflect.ValueOfString("")
	case "badges.ApprovalAmounts.perInitiatedByAddressApprovalAmount":
		return protoreflect.ValueOfString("")
	case "badges.ApprovalAmounts.amountTrackerId":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalAmounts"))
		}
		panic(fmt.Errorf("message badges.ApprovalAmounts does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ApprovalAmounts) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.ApprovalAmounts", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ApprovalAmounts) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalAmounts) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ApprovalAmounts) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ApprovalAmounts) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ApprovalAmounts)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.OverallApprovalAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PerToAddressApprovalAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PerFromAddressApprovalAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PerInitiatedByAddressApprovalAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AmountTrackerId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ApprovalAmounts)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.AmountTrackerId) > 0 {
			i -= len(x.AmountTrackerId)
			copy(dAtA[i:], x.AmountTrackerId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AmountTrackerId)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.PerInitiatedByAddressApprovalAmount) > 0 {
			i -= len(x.PerInitiatedByAddressApprovalAmount)
			copy(dAtA[i:], x.PerInitiatedByAddressApprovalAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PerInitiatedByAddressApprovalAmount)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.PerFromAddressApprovalAmount) > 0 {
			i -= len(x.PerFromAddressApprovalAmount)
			copy(dAtA[i:], x.PerFromAddressApprovalAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PerFromAddressApprovalAmount)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PerToAddressApprovalAmount) > 0 {
			i -= len(x.PerToAddressApprovalAmount)
			copy(dAtA[i:], x.PerToAddressApprovalAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PerToAddressApprovalAmount)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.OverallApprovalAmount) > 0 {
			i -= len(x.OverallApprovalAmount)
			copy(dAtA[i:], x.OverallApprovalAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.OverallApprovalAmount)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ApprovalAmounts)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ApprovalAmounts: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ApprovalAmounts: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OverallApprovalAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OverallApprovalAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PerToAddressApprovalAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PerToAddressApprovalAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PerFromAddressApprovalAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PerFromAddressApprovalAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PerInitiatedByAddressApprovalAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PerInitiatedByAddressApprovalAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AmountTrackerId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AmountTrackerId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MaxNumTransfers                                      protoreflect.MessageDescriptor
	fd_MaxNumTransfers_overallMaxNumTransfers               protoreflect.FieldDescriptor
	fd_MaxNumTransfers_perToAddressMaxNumTransfers          protoreflect.FieldDescriptor
	fd_MaxNumTransfers_perFromAddressMaxNumTransfers        protoreflect.FieldDescriptor
	fd_MaxNumTransfers_perInitiatedByAddressMaxNumTransfers protoreflect.FieldDescriptor
	fd_MaxNumTransfers_amountTrackerId                      protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_MaxNumTransfers = File_badges_transfers_proto.Messages().ByName("MaxNumTransfers")
	fd_MaxNumTransfers_overallMaxNumTransfers = md_MaxNumTransfers.Fields().ByName("overallMaxNumTransfers")
	fd_MaxNumTransfers_perToAddressMaxNumTransfers = md_MaxNumTransfers.Fields().ByName("perToAddressMaxNumTransfers")
	fd_MaxNumTransfers_perFromAddressMaxNumTransfers = md_MaxNumTransfers.Fields().ByName("perFromAddressMaxNumTransfers")
	fd_MaxNumTransfers_perInitiatedByAddressMaxNumTransfers = md_MaxNumTransfers.Fields().ByName("perInitiatedByAddressMaxNumTransfers")
	fd_MaxNumTransfers_amountTrackerId = md_MaxNumTransfers.Fields().ByName("amountTrackerId")
}

var _ protoreflect.Message = (*fastReflection_MaxNumTransfers)(nil)

type fastReflection_MaxNumTransfers MaxNumTransfers

func (x *MaxNumTransfers) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MaxNumTransfers)(x)
}

func (x *MaxNumTransfers) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MaxNumTransfers_messageType fastReflection_MaxNumTransfers_messageType
var _ protoreflect.MessageType = fastReflection_MaxNumTransfers_messageType{}

type fastReflection_MaxNumTransfers_messageType struct{}

func (x fastReflection_MaxNumTransfers_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MaxNumTransfers)(nil)
}
func (x fastReflection_MaxNumTransfers_messageType) New() protoreflect.Message {
	return new(fastReflection_MaxNumTransfers)
}
func (x fastReflection_MaxNumTransfers_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MaxNumTransfers
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MaxNumTransfers) Descriptor() protoreflect.MessageDescriptor {
	return md_MaxNumTransfers
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MaxNumTransfers) Type() protoreflect.MessageType {
	return _fastReflection_MaxNumTransfers_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MaxNumTransfers) New() protoreflect.Message {
	return new(fastReflection_MaxNumTransfers)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MaxNumTransfers) Interface() protoreflect.ProtoMessage {
	return (*MaxNumTransfers)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MaxNumTransfers) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.OverallMaxNumTransfers != "" {
		value := protoreflect.ValueOfString(x.OverallMaxNumTransfers)
		if !f(fd_MaxNumTransfers_overallMaxNumTransfers, value) {
			return
		}
	}
	if x.PerToAddressMaxNumTransfers != "" {
		value := protoreflect.ValueOfString(x.PerToAddressMaxNumTransfers)
		if !f(fd_MaxNumTransfers_perToAddressMaxNumTransfers, value) {
			return
		}
	}
	if x.PerFromAddressMaxNumTransfers != "" {
		value := protoreflect.ValueOfString(x.PerFromAddressMaxNumTransfers)
		if !f(fd_MaxNumTransfers_perFromAddressMaxNumTransfers, value) {
			return
		}
	}
	if x.PerInitiatedByAddressMaxNumTransfers != "" {
		value := protoreflect.ValueOfString(x.PerInitiatedByAddressMaxNumTransfers)
		if !f(fd_MaxNumTransfers_perInitiatedByAddressMaxNumTransfers, value) {
			return
		}
	}
	if x.AmountTrackerId != "" {
		value := protoreflect.ValueOfString(x.AmountTrackerId)
		if !f(fd_MaxNumTransfers_amountTrackerId, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MaxNumTransfers) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.MaxNumTransfers.overallMaxNumTransfers":
		return x.OverallMaxNumTransfers != ""
	case "badges.MaxNumTransfers.perToAddressMaxNumTransfers":
		return x.PerToAddressMaxNumTransfers != ""
	case "badges.MaxNumTransfers.perFromAddressMaxNumTransfers":
		return x.PerFromAddressMaxNumTransfers != ""
	case "badges.MaxNumTransfers.perInitiatedByAddressMaxNumTransfers":
		return x.PerInitiatedByAddressMaxNumTransfers != ""
	case "badges.MaxNumTransfers.amountTrackerId":
		return x.AmountTrackerId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MaxNumTransfers"))
		}
		panic(fmt.Errorf("message badges.MaxNumTransfers does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MaxNumTransfers) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.MaxNumTransfers.overallMaxNumTransfers":
		x.OverallMaxNumTransfers = ""
	case "badges.MaxNumTransfers.perToAddressMaxNumTransfers":
		x.PerToAddressMaxNumTransfers = ""
	case "badges.MaxNumTransfers.perFromAddressMaxNumTransfers":
		x.PerFromAddressMaxNumTransfers = ""
	case "badges.MaxNumTransfers.perInitiatedByAddressMaxNumTransfers":
		x.PerInitiatedByAddressMaxNumTransfers = ""
	case "badges.MaxNumTransfers.amountTrackerId":
		x.AmountTrackerId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MaxNumTransfers"))
		}
		panic(fmt.Errorf("message badges.MaxNumTransfers does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MaxNumTransfers) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.MaxNumTransfers.overallMaxNumTransfers":
		value := x.OverallMaxNumTransfers
		return protoreflect.ValueOfString(value)
	case "badges.MaxNumTransfers.perToAddressMaxNumTransfers":
		value := x.PerToAddressMaxNumTransfers
		return protoreflect.ValueOfString(value)
	case "badges.MaxNumTransfers.perFromAddressMaxNumTransfers":
		value := x.PerFromAddressMaxNumTransfers
		return protoreflect.ValueOfString(value)
	case "badges.MaxNumTransfers.perInitiatedByAddressMaxNumTransfers":
		value := x.PerInitiatedByAddressMaxNumTransfers
		return protoreflect.ValueOfString(value)
	case "badges.MaxNumTransfers.amountTrackerId":
		value := x.AmountTrackerId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MaxNumTransfers"))
		}
		panic(fmt.Errorf("message badges.MaxNumTransfers does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MaxNumTransfers) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.MaxNumTransfers.overallMaxNumTransfers":
		x.OverallMaxNumTransfers = value.Interface().(string)
	case "badges.MaxNumTransfers.perToAddressMaxNumTransfers":
		x.PerToAddressMaxNumTransfers = value.Interface().(string)
	case "badges.MaxNumTransfers.perFromAddressMaxNumTransfers":
		x.PerFromAddressMaxNumTransfers = value.Interface().(string)
	case "badges.MaxNumTransfers.perInitiatedByAddressMaxNumTransfers":
		x.PerInitiatedByAddressMaxNumTransfers = value.Interface().(string)
	case "badges.MaxNumTransfers.amountTrackerId":
		x.AmountTrackerId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MaxNumTransfers"))
		}
		panic(fmt.Errorf("message badges.MaxNumTransfers does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MaxNumTransfers) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.MaxNumTransfers.overallMaxNumTransfers":
		panic(fmt.Errorf("field overallMaxNumTransfers of message badges.MaxNumTransfers is not mutable"))
	case "badges.MaxNumTransfers.perToAddressMaxNumTransfers":
		panic(fmt.Errorf("field perToAddressMaxNumTransfers of message badges.MaxNumTransfers is not mutable"))
	case "badges.MaxNumTransfers.perFromAddressMaxNumTransfers":
		panic(fmt.Errorf("field perFromAddressMaxNumTransfers of message badges.MaxNumTransfers is not mutable"))
	case "badges.MaxNumTransfers.perInitiatedByAddressMaxNumTransfers":
		panic(fmt.Errorf("field perInitiatedByAddressMaxNumTransfers of message badges.MaxNumTransfers is not mutable"))
	case "badges.MaxNumTransfers.amountTrackerId":
		panic(fmt.Errorf("field amountTrackerId of message badges.MaxNumTransfers is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MaxNumTransfers"))
		}
		panic(fmt.Errorf("message badges.MaxNumTransfers does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MaxNumTransfers) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.MaxNumTransfers.overallMaxNumTransfers":
		return protoreflect.ValueOfString("")
	case "badges.MaxNumTransfers.perToAddressMaxNumTransfers":
		return protoreflect.ValueOfString("")
	case "badges.MaxNumTransfers.perFromAddressMaxNumTransfers":
		return protoreflect.ValueOfString("")
	case "badges.MaxNumTransfers.perInitiatedByAddressMaxNumTransfers":
		return protoreflect.ValueOfString("")
	case "badges.MaxNumTransfers.amountTrackerId":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MaxNumTransfers"))
		}
		panic(fmt.Errorf("message badges.MaxNumTransfers does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MaxNumTransfers) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.MaxNumTransfers", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MaxNumTransfers) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MaxNumTransfers) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MaxNumTransfers) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MaxNumTransfers) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MaxNumTransfers)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.OverallMaxNumTransfers)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PerToAddressMaxNumTransfers)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PerFromAddressMaxNumTransfers)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PerInitiatedByAddressMaxNumTransfers)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AmountTrackerId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MaxNumTransfers)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.AmountTrackerId) > 0 {
			i -= len(x.AmountTrackerId)
			copy(dAtA[i:], x.AmountTrackerId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AmountTrackerId)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.PerInitiatedByAddressMaxNumTransfers) > 0 {
			i -= len(x.PerInitiatedByAddressMaxNumTransfers)
			copy(dAtA[i:], x.PerInitiatedByAddressMaxNumTransfers)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PerInitiatedByAddressMaxNumTransfers)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.PerFromAddressMaxNumTransfers) > 0 {
			i -= len(x.PerFromAddressMaxNumTransfers)
			copy(dAtA[i:], x.PerFromAddressMaxNumTransfers)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PerFromAddressMaxNumTransfers)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PerToAddressMaxNumTransfers) > 0 {
			i -= len(x.PerToAddressMaxNumTransfers)
			copy(dAtA[i:], x.PerToAddressMaxNumTransfers)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PerToAddressMaxNumTransfers)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.OverallMaxNumTransfers) > 0 {
			i -= len(x.OverallMaxNumTransfers)
			copy(dAtA[i:], x.OverallMaxNumTransfers)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.OverallMaxNumTransfers)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MaxNumTransfers)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MaxNumTransfers: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MaxNumTransfers: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OverallMaxNumTransfers", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OverallMaxNumTransfers = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PerToAddressMaxNumTransfers", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PerToAddressMaxNumTransfers = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PerFromAddressMaxNumTransfers", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PerFromAddressMaxNumTransfers = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PerInitiatedByAddressMaxNumTransfers", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PerInitiatedByAddressMaxNumTransfers = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AmountTrackerId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AmountTrackerId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_ApprovalTracker_2_list)(nil)

type _ApprovalTracker_2_list struct {
	list *[]*Balance
}

func (x *_ApprovalTracker_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ApprovalTracker_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_ApprovalTracker_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Balance)
	(*x.list)[i] = concreteValue
}

func (x *_ApprovalTracker_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Balance)
	*x.list = append(*x.list, concreteValue)
}

func (x *_ApprovalTracker_2_list) AppendMutable() protoreflect.Value {
	v := new(Balance)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ApprovalTracker_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_ApprovalTracker_2_list) NewElement() protoreflect.Value {
	v := new(Balance)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ApprovalTracker_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_ApprovalTracker              protoreflect.MessageDescriptor
	fd_ApprovalTracker_numTransfers protoreflect.FieldDescriptor
	fd_ApprovalTracker_amounts      protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_ApprovalTracker = File_badges_transfers_proto.Messages().ByName("ApprovalTracker")
	fd_ApprovalTracker_numTransfers = md_ApprovalTracker.Fields().ByName("numTransfers")
	fd_ApprovalTracker_amounts = md_ApprovalTracker.Fields().ByName("amounts")
}

var _ protoreflect.Message = (*fastReflection_ApprovalTracker)(nil)

type fastReflection_ApprovalTracker ApprovalTracker

func (x *ApprovalTracker) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ApprovalTracker)(x)
}

func (x *ApprovalTracker) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ApprovalTracker_messageType fastReflection_ApprovalTracker_messageType
var _ protoreflect.MessageType = fastReflection_ApprovalTracker_messageType{}

type fastReflection_ApprovalTracker_messageType struct{}

func (x fastReflection_ApprovalTracker_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ApprovalTracker)(nil)
}
func (x fastReflection_ApprovalTracker_messageType) New() protoreflect.Message {
	return new(fastReflection_ApprovalTracker)
}
func (x fastReflection_ApprovalTracker_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ApprovalTracker
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ApprovalTracker) Descriptor() protoreflect.MessageDescriptor {
	return md_ApprovalTracker
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ApprovalTracker) Type() protoreflect.MessageType {
	return _fastReflection_ApprovalTracker_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ApprovalTracker) New() protoreflect.Message {
	return new(fastReflection_ApprovalTracker)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ApprovalTracker) Interface() protoreflect.ProtoMessage {
	return (*ApprovalTracker)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ApprovalTracker) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.NumTransfers != "" {
		value := protoreflect.ValueOfString(x.NumTransfers)
		if !f(fd_ApprovalTracker_numTransfers, value) {
			return
		}
	}
	if len(x.Amounts) != 0 {
		value := protoreflect.ValueOfList(&_ApprovalTracker_2_list{list: &x.Amounts})
		if !f(fd_ApprovalTracker_amounts, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ApprovalTracker) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.ApprovalTracker.numTransfers":
		return x.NumTransfers != ""
	case "badges.ApprovalTracker.amounts":
		return len(x.Amounts) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalTracker"))
		}
		panic(fmt.Errorf("message badges.ApprovalTracker does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalTracker) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.ApprovalTracker.numTransfers":
		x.NumTransfers = ""
	case "badges.ApprovalTracker.amounts":
		x.Amounts = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalTracker"))
		}
		panic(fmt.Errorf("message badges.ApprovalTracker does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ApprovalTracker) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.ApprovalTracker.numTransfers":
		value := x.NumTransfers
		return protoreflect.ValueOfString(value)
	case "badges.ApprovalTracker.amounts":
		if len(x.Amounts) == 0 {
			return protoreflect.ValueOfList(&_ApprovalTracker_2_list{})
		}
		listValue := &_ApprovalTracker_2_list{list: &x.Amounts}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalTracker"))
		}
		panic(fmt.Errorf("message badges.ApprovalTracker does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalTracker) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.ApprovalTracker.numTransfers":
		x.NumTransfers = value.Interface().(string)
	case "badges.ApprovalTracker.amounts":
		lv := value.List()
		clv := lv.(*_ApprovalTracker_2_list)
		x.Amounts = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalTracker"))
		}
		panic(fmt.Errorf("message badges.ApprovalTracker does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalTracker) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ApprovalTracker.amounts":
		if x.Amounts == nil {
			x.Amounts = []*Balance{}
		}
		value := &_ApprovalTracker_2_list{list: &x.Amounts}
		return protoreflect.ValueOfList(value)
	case "badges.ApprovalTracker.numTransfers":
		panic(fmt.Errorf("field numTransfers of message badges.ApprovalTracker is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalTracker"))
		}
		panic(fmt.Errorf("message badges.ApprovalTracker does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ApprovalTracker) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ApprovalTracker.numTransfers":
		return protoreflect.ValueOfString("")
	case "badges.ApprovalTracker.amounts":
		list := []*Balance{}
		return protoreflect.ValueOfList(&_ApprovalTracker_2_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalTracker"))
		}
		panic(fmt.Errorf("message badges.ApprovalTracker does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ApprovalTracker) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.ApprovalTracker", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ApprovalTracker) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalTracker) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ApprovalTracker) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ApprovalTracker) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ApprovalTracker)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.NumTransfers)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Amounts) > 0 {
			for _, e := range x.Amounts {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ApprovalTracker)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Amounts) > 0 {
			for iNdEx := len(x.Amounts) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Amounts[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.NumTransfers) > 0 {
			i -= len(x.NumTransfers)
			copy(dAtA[i:], x.NumTransfers)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NumTransfers)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ApprovalTracker)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ApprovalTracker: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ApprovalTracker: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NumTransfers", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NumTransfers = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amounts", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amounts = append(x.Amounts, &Balance{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Amounts[len(x.Amounts)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ZkProof                 protoreflect.MessageDescriptor
	fd_ZkProof_verificationKey protoreflect.FieldDescriptor
	fd_ZkProof_uri             protoreflect.FieldDescriptor
	fd_ZkProof_customData      protoreflect.FieldDescriptor
	fd_ZkProof_zkpTrackerId    protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_ZkProof = File_badges_transfers_proto.Messages().ByName("ZkProof")
	fd_ZkProof_verificationKey = md_ZkProof.Fields().ByName("verificationKey")
	fd_ZkProof_uri = md_ZkProof.Fields().ByName("uri")
	fd_ZkProof_customData = md_ZkProof.Fields().ByName("customData")
	fd_ZkProof_zkpTrackerId = md_ZkProof.Fields().ByName("zkpTrackerId")
}

var _ protoreflect.Message = (*fastReflection_ZkProof)(nil)

type fastReflection_ZkProof ZkProof

func (x *ZkProof) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ZkProof)(x)
}

func (x *ZkProof) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ZkProof_messageType fastReflection_ZkProof_messageType
var _ protoreflect.MessageType = fastReflection_ZkProof_messageType{}

type fastReflection_ZkProof_messageType struct{}

func (x fastReflection_ZkProof_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ZkProof)(nil)
}
func (x fastReflection_ZkProof_messageType) New() protoreflect.Message {
	return new(fastReflection_ZkProof)
}
func (x fastReflection_ZkProof_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ZkProof
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ZkProof) Descriptor() protoreflect.MessageDescriptor {
	return md_ZkProof
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ZkProof) Type() protoreflect.MessageType {
	return _fastReflection_ZkProof_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ZkProof) New() protoreflect.Message {
	return new(fastReflection_ZkProof)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ZkProof) Interface() protoreflect.ProtoMessage {
	return (*ZkProof)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ZkProof) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.VerificationKey != "" {
		value := protoreflect.ValueOfString(x.VerificationKey)
		if !f(fd_ZkProof_verificationKey, value) {
			return
		}
	}
	if x.Uri != "" {
		value := protoreflect.ValueOfString(x.Uri)
		if !f(fd_ZkProof_uri, value) {
			return
		}
	}
	if x.CustomData != "" {
		value := protoreflect.ValueOfString(x.CustomData)
		if !f(fd_ZkProof_customData, value) {
			return
		}
	}
	if x.ZkpTrackerId != "" {
		value := protoreflect.ValueOfString(x.ZkpTrackerId)
		if !f(fd_ZkProof_zkpTrackerId, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ZkProof) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.ZkProof.verificationKey":
		return x.VerificationKey != ""
	case "badges.ZkProof.uri":
		return x.Uri != ""
	case "badges.ZkProof.customData":
		return x.CustomData != ""
	case "badges.ZkProof.zkpTrackerId":
		return x.ZkpTrackerId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProof"))
		}
		panic(fmt.Errorf("message badges.ZkProof does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ZkProof) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.ZkProof.verificationKey":
		x.VerificationKey = ""
	case "badges.ZkProof.uri":
		x.Uri = ""
	case "badges.ZkProof.customData":
		x.CustomData = ""
	case "badges.ZkProof.zkpTrackerId":
		x.ZkpTrackerId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProof"))
		}
		panic(fmt.Errorf("message badges.ZkProof does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ZkProof) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.ZkProof.verificationKey":
		value := x.VerificationKey
		return protoreflect.ValueOfString(value)
	case "badges.ZkProof.uri":
		value := x.Uri
		return protoreflect.ValueOfString(value)
	case "badges.ZkProof.customData":
		value := x.CustomData
		return protoreflect.ValueOfString(value)
	case "badges.ZkProof.zkpTrackerId":
		value := x.ZkpTrackerId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProof"))
		}
		panic(fmt.Errorf("message badges.ZkProof does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ZkProof) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.ZkProof.verificationKey":
		x.VerificationKey = value.Interface().(string)
	case "badges.ZkProof.uri":
		x.Uri = value.Interface().(string)
	case "badges.ZkProof.customData":
		x.CustomData = value.Interface().(string)
	case "badges.ZkProof.zkpTrackerId":
		x.ZkpTrackerId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProof"))
		}
		panic(fmt.Errorf("message badges.ZkProof does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ZkProof) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ZkProof.verificationKey":
		panic(fmt.Errorf("field verificationKey of message badges.ZkProof is not mutable"))
	case "badges.ZkProof.uri":
		panic(fmt.Errorf("field uri of message badges.ZkProof is not mutable"))
	case "badges.ZkProof.customData":
		panic(fmt.Errorf("field customData of message badges.ZkProof is not mutable"))
	case "badges.ZkProof.zkpTrackerId":
		panic(fmt.Errorf("field zkpTrackerId of message badges.ZkProof is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProof"))
		}
		panic(fmt.Errorf("message badges.ZkProof does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ZkProof) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ZkProof.verificationKey":
		return protoreflect.ValueOfString("")
	case "badges.ZkProof.uri":
		return protoreflect.ValueOfString("")
	case "badges.ZkProof.customData":
		return protoreflect.ValueOfString("")
	case "badges.ZkProof.zkpTrackerId":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProof"))
		}
		panic(fmt.Errorf("message badges.ZkProof does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ZkProof) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.ZkProof", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ZkProof) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ZkProof) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ZkProof) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ZkProof) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ZkProof)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.VerificationKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Uri)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CustomData)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ZkpTrackerId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ZkProof)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ZkpTrackerId) > 0 {
			i -= len(x.ZkpTrackerId)
			copy(dAtA[i:], x.ZkpTrackerId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ZkpTrackerId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CustomData) > 0 {
			i -= len(x.CustomData)
			copy(dAtA[i:], x.CustomData)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CustomData)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Uri) > 0 {
			i -= len(x.Uri)
			copy(dAtA[i:], x.Uri)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Uri)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.VerificationKey) > 0 {
			i -= len(x.VerificationKey)
			copy(dAtA[i:], x.VerificationKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.VerificationKey)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ZkProof)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ZkProof: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ZkProof: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field VerificationKey", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.VerificationKey = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Uri = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CustomData = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ZkpTrackerId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ZkpTrackerId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ZkProofSolution              protoreflect.MessageDescriptor
	fd_ZkProofSolution_publicInputs protoreflect.FieldDescriptor
	fd_ZkProofSolution_proof        protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_ZkProofSolution = File_badges_transfers_proto.Messages().ByName("ZkProofSolution")
	fd_ZkProofSolution_publicInputs = md_ZkProofSolution.Fields().ByName("publicInputs")
	fd_ZkProofSolution_proof = md_ZkProofSolution.Fields().ByName("proof")
}

var _ protoreflect.Message = (*fastReflection_ZkProofSolution)(nil)

type fastReflection_ZkProofSolution ZkProofSolution

func (x *ZkProofSolution) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ZkProofSolution)(x)
}

func (x *ZkProofSolution) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ZkProofSolution_messageType fastReflection_ZkProofSolution_messageType
var _ protoreflect.MessageType = fastReflection_ZkProofSolution_messageType{}

type fastReflection_ZkProofSolution_messageType struct{}

func (x fastReflection_ZkProofSolution_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ZkProofSolution)(nil)
}
func (x fastReflection_ZkProofSolution_messageType) New() protoreflect.Message {
	return new(fastReflection_ZkProofSolution)
}
func (x fastReflection_ZkProofSolution_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ZkProofSolution
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ZkProofSolution) Descriptor() protoreflect.MessageDescriptor {
	return md_ZkProofSolution
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ZkProofSolution) Type() protoreflect.MessageType {
	return _fastReflection_ZkProofSolution_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ZkProofSolution) New() protoreflect.Message {
	return new(fastReflection_ZkProofSolution)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ZkProofSolution) Interface() protoreflect.ProtoMessage {
	return (*ZkProofSolution)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ZkProofSolution) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PublicInputs != "" {
		value := protoreflect.ValueOfString(x.PublicInputs)
		if !f(fd_ZkProofSolution_publicInputs, value) {
			return
		}
	}
	if x.Proof != "" {
		value := protoreflect.ValueOfString(x.Proof)
		if !f(fd_ZkProofSolution_proof, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ZkProofSolution) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.ZkProofSolution.publicInputs":
		return x.PublicInputs != ""
	case "badges.ZkProofSolution.proof":
		return x.Proof != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProofSolution"))
		}
		panic(fmt.Errorf("message badges.ZkProofSolution does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ZkProofSolution) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.ZkProofSolution.publicInputs":
		x.PublicInputs = ""
	case "badges.ZkProofSolution.proof":
		x.Proof = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProofSolution"))
		}
		panic(fmt.Errorf("message badges.ZkProofSolution does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ZkProofSolution) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.ZkProofSolution.publicInputs":
		value := x.PublicInputs
		return protoreflect.ValueOfString(value)
	case "badges.ZkProofSolution.proof":
		value := x.Proof
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProofSolution"))
		}
		panic(fmt.Errorf("message badges.ZkProofSolution does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ZkProofSolution) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.ZkProofSolution.publicInputs":
		x.PublicInputs = value.Interface().(string)
	case "badges.ZkProofSolution.proof":
		x.Proof = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProofSolution"))
		}
		panic(fmt.Errorf("message badges.ZkProofSolution does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ZkProofSolution) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ZkProofSolution.publicInputs":
		panic(fmt.Errorf("field publicInputs of message badges.ZkProofSolution is not mutable"))
	case "badges.ZkProofSolution.proof":
		panic(fmt.Errorf("field proof of message badges.ZkProofSolution is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProofSolution"))
		}
		panic(fmt.Errorf("message badges.ZkProofSolution does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ZkProofSolution) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ZkProofSolution.publicInputs":
		return protoreflect.ValueOfString("")
	case "badges.ZkProofSolution.proof":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ZkProofSolution"))
		}
		panic(fmt.Errorf("message badges.ZkProofSolution does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ZkProofSolution) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.ZkProofSolution", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ZkProofSolution) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ZkProofSolution) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ZkProofSolution) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ZkProofSolution) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ZkProofSolution)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PublicInputs)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Proof)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ZkProofSolution)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Proof) > 0 {
			i -= len(x.Proof)
			copy(dAtA[i:], x.Proof)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Proof)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.PublicInputs) > 0 {
			i -= len(x.PublicInputs)
			copy(dAtA[i:], x.PublicInputs)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PublicInputs)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ZkProofSolution)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ZkProofSolution: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ZkProofSolution: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PublicInputs", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PublicInputs = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Proof = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_CoinTransfer_2_list)(nil)

type _CoinTransfer_2_list struct {
	list *[]*v1beta1.Coin
}

func (x *_CoinTransfer_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_CoinTransfer_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_CoinTransfer_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*v1beta1.Coin)
	(*x.list)[i] = concreteValue
}

func (x *_CoinTransfer_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*v1beta1.Coin)
	*x.list = append(*x.list, concreteValue)
}

func (x *_CoinTransfer_2_list) AppendMutable() protoreflect.Value {
	v := new(v1beta1.Coin)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CoinTransfer_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_CoinTransfer_2_list) NewElement() protoreflect.Value {
	v := new(v1beta1.Coin)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CoinTransfer_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_CoinTransfer       protoreflect.MessageDescriptor
	fd_CoinTransfer_to    protoreflect.FieldDescriptor
	fd_CoinTransfer_coins protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_CoinTransfer = File_badges_transfers_proto.Messages().ByName("CoinTransfer")
	fd_CoinTransfer_to = md_CoinTransfer.Fields().ByName("to")
	fd_CoinTransfer_coins = md_CoinTransfer.Fields().ByName("coins")
}

var _ protoreflect.Message = (*fastReflection_CoinTransfer)(nil)

type fastReflection_CoinTransfer CoinTransfer

func (x *CoinTransfer) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CoinTransfer)(x)
}

func (x *CoinTransfer) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CoinTransfer_messageType fastReflection_CoinTransfer_messageType
var _ protoreflect.MessageType = fastReflection_CoinTransfer_messageType{}

type fastReflection_CoinTransfer_messageType struct{}

func (x fastReflection_CoinTransfer_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CoinTransfer)(nil)
}
func (x fastReflection_CoinTransfer_messageType) New() protoreflect.Message {
	return new(fastReflection_CoinTransfer)
}
func (x fastReflection_CoinTransfer_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CoinTransfer
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CoinTransfer) Descriptor() protoreflect.MessageDescriptor {
	return md_CoinTransfer
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CoinTransfer) Type() protoreflect.MessageType {
	return _fastReflection_CoinTransfer_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CoinTransfer) New() protoreflect.Message {
	return new(fastReflection_CoinTransfer)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CoinTransfer) Interface() protoreflect.ProtoMessage {
	return (*CoinTransfer)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CoinTransfer) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.To != "" {
		value := protoreflect.ValueOfString(x.To)
		if !f(fd_CoinTransfer_to, value) {
			return
		}
	}
	if len(x.Coins) != 0 {
		value := protoreflect.ValueOfList(&_CoinTransfer_2_list{list: &x.Coins})
		if !f(fd_CoinTransfer_coins, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CoinTransfer) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.CoinTransfer.to":
		return x.To != ""
	case "badges.CoinTransfer.coins":
		return len(x.Coins) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CoinTransfer"))
		}
		panic(fmt.Errorf("message badges.CoinTransfer does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CoinTransfer) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.CoinTransfer.to":
		x.To = ""
	case "badges.CoinTransfer.coins":
		x.Coins = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CoinTransfer"))
		}
		panic(fmt.Errorf("message badges.CoinTransfer does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CoinTransfer) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.CoinTransfer.to":
		value := x.To
		return protoreflect.ValueOfString(value)
	case "badges.CoinTransfer.coins":
		if len(x.Coins) == 0 {
			return protoreflect.ValueOfList(&_CoinTransfer_2_list{})
		}
		listValue := &_CoinTransfer_2_list{list: &x.Coins}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CoinTransfer"))
		}
		panic(fmt.Errorf("message badges.CoinTransfer does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CoinTransfer) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.CoinTransfer.to":
		x.To = value.Interface().(string)
	case "badges.CoinTransfer.coins":
		lv := value.List()
		clv := lv.(*_CoinTransfer_2_list)
		x.Coins = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CoinTransfer"))
		}
		panic(fmt.Errorf("message badges.CoinTransfer does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CoinTransfer) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.CoinTransfer.coins":
		if x.Coins == nil {
			x.Coins = []*v1beta1.Coin{}
		}
		value := &_CoinTransfer_2_list{list: &x.Coins}
		return protoreflect.ValueOfList(value)
	case "badges.CoinTransfer.to":
		panic(fmt.Errorf("field to of message badges.CoinTransfer is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CoinTransfer"))
		}
		panic(fmt.Errorf("message badges.CoinTransfer does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CoinTransfer) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.CoinTransfer.to":
		return protoreflect.ValueOfString("")
	case "badges.CoinTransfer.coins":
		list := []*v1beta1.Coin{}
		return protoreflect.ValueOfList(&_CoinTransfer_2_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CoinTransfer"))
		}
		panic(fmt.Errorf("message badges.CoinTransfer does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CoinTransfer) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.CoinTransfer", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CoinTransfer) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CoinTransfer) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CoinTransfer) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CoinTransfer) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CoinTransfer)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.To)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Coins) > 0 {
			for _, e := range x.Coins {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CoinTransfer)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Coins) > 0 {
			for iNdEx := len(x.Coins) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Coins[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.To) > 0 {
			i -= len(x.To)
			copy(dAtA[i:], x.To)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.To)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CoinTransfer)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CoinTransfer: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CoinTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.To = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Coins = append(x.Coins, &v1beta1.Coin{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Coins[len(x.Coins)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_ApprovalCriteria_1_list)(nil)

type _ApprovalCriteria_1_list struct {
	list *[]*MustOwnBadges
}

func (x *_ApprovalCriteria_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ApprovalCriteria_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_ApprovalCriteria_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MustOwnBadges)
	(*x.list)[i] = concreteValue
}

func (x *_ApprovalCriteria_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MustOwnBadges)
	*x.list = append(*x.list, concreteValue)
}

func (x *_ApprovalCriteria_1_list) AppendMutable() protoreflect.Value {
	v := new(MustOwnBadges)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ApprovalCriteria_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_ApprovalCriteria_1_list) NewElement() protoreflect.Value {
	v := new(MustOwnBadges)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ApprovalCriteria_1_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_ApprovalCriteria_2_list)(nil)

type _ApprovalCriteria_2_list struct {
	list *[]*MerkleChallenge
}

func (x *_ApprovalCriteria_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ApprovalCriteria_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_ApprovalCriteria_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MerkleChallenge)
	(*x.list)[i] = concreteValue
}

func (x *_ApprovalCriteria_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MerkleChallenge)
	*x.list = append(*x.list, concreteValue)
}

func (x *_ApprovalCriteria_2_list) AppendMutable() protoreflect.Value {
	v := new(MerkleChallenge)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ApprovalCriteria_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_ApprovalCriteria_2_list) NewElement() protoreflect.Value {
	v := new(MerkleChallenge)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ApprovalCriteria_2_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_ApprovalCriteria_6_list)(nil)

type _ApprovalCriteria_6_list struct {
	list *[]*ZkProof
}

func (x *_ApprovalCriteria_6_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ApprovalCriteria_6_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_ApprovalCriteria_6_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ZkProof)
	(*x.list)[i] = concreteValue
}

func (x *_ApprovalCriteria_6_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ZkProof)
	*x.list = append(*x.list, concreteValue)
}

func (x *_ApprovalCriteria_6_list) AppendMutable() protoreflect.Value {
	v := new(ZkProof)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ApprovalCriteria_6_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_ApprovalCriteria_6_list) NewElement() protoreflect.Value {
	v := new(ZkProof)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ApprovalCriteria_6_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_ApprovalCriteria_7_list)(nil)

type _ApprovalCriteria_7_list struct {
	list *[]*CoinTransfer
}

func (x *_ApprovalCriteria_7_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_ApprovalCriteria_7_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_ApprovalCriteria_7_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*CoinTransfer)
	(*x.list)[i] = concreteValue
}

func (x *_ApprovalCriteria_7_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*CoinTransfer)
	*x.list = append(*x.list, concreteValue)
}

func (x *_ApprovalCriteria_7_list) AppendMutable() protoreflect.Value {
	v := new(CoinTransfer)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ApprovalCriteria_7_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_ApprovalCriteria_7_list) NewElement() protoreflect.Value {
	v := new(CoinTransfer)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_ApprovalCriteria_7_list) IsValid() bool {
	return x.list != nil
}

var (
	md_ApprovalCriteria                                    protoreflect.MessageDescriptor
	fd_ApprovalCriteria_mustOwnBadges                      protoreflect.FieldDescriptor
	fd_ApprovalCriteria_merkleChallenges                   protoreflect.FieldDescriptor
	fd_ApprovalCriteria_predeterminedBalances              protoreflect.FieldDescriptor
	fd_ApprovalCriteria_approvalAmounts                    protoreflect.FieldDescriptor
	fd_ApprovalCriteria_maxNumTransfers                    protoreflect.FieldDescriptor
	fd_ApprovalCriteria_zkProofs                           protoreflect.FieldDescriptor
	fd_ApprovalCriteria_coinTransfers                      protoreflect.FieldDescriptor
	fd_ApprovalCriteria_requireToEqualsInitiatedBy         protoreflect.FieldDescriptor
	fd_ApprovalCriteria_requireFromEqualsInitiatedBy       protoreflect.FieldDescriptor
	fd_ApprovalCriteria_requireToDoesNotEqualInitiatedBy   protoreflect.FieldDescriptor
	fd_ApprovalCriteria_requireFromDoesNotEqualInitiatedBy protoreflect.FieldDescriptor
	fd_ApprovalCriteria_overridesFromOutgoingApprovals     protoreflect.FieldDescriptor
	fd_ApprovalCriteria_overridesToIncomingApprovals       protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_ApprovalCriteria = File_badges_transfers_proto.Messages().ByName("ApprovalCriteria")
	fd_ApprovalCriteria_mustOwnBadges = md_ApprovalCriteria.Fields().ByName("mustOwnBadges")
	fd_ApprovalCriteria_merkleChallenges = md_ApprovalCriteria.Fields().ByName("merkleChallenges")
	fd_ApprovalCriteria_predeterminedBalances = md_ApprovalCriteria.Fields().ByName("predeterminedBalances")
	fd_ApprovalCriteria_approvalAmounts = md_ApprovalCriteria.Fields().ByName("approvalAmounts")
	fd_ApprovalCriteria_maxNumTransfers = md_ApprovalCriteria.Fields().ByName("maxNumTransfers")
	fd_ApprovalCriteria_zkProofs = md_ApprovalCriteria.Fields().ByName("zkProofs")
	fd_ApprovalCriteria_coinTransfers = md_ApprovalCriteria.Fields().ByName("coinTransfers")
	fd_ApprovalCriteria_requireToEqualsInitiatedBy = md_ApprovalCriteria.Fields().ByName("requireToEqualsInitiatedBy")
	fd_ApprovalCriteria_requireFromEqualsInitiatedBy = md_ApprovalCriteria.Fields().ByName("requireFromEqualsInitiatedBy")
	fd_ApprovalCriteria_requireToDoesNotEqualInitiatedBy = md_ApprovalCriteria.Fields().ByName("requireToDoesNotEqualInitiatedBy")
	fd_ApprovalCriteria_requireFromDoesNotEqualInitiatedBy = md_ApprovalCriteria.Fields().ByName("requireFromDoesNotEqualInitiatedBy")
	fd_ApprovalCriteria_overridesFromOutgoingApprovals = md_ApprovalCriteria.Fields().ByName("overridesFromOutgoingApprovals")
	fd_ApprovalCriteria_overridesToIncomingApprovals = md_ApprovalCriteria.Fields().ByName("overridesToIncomingApprovals")
}

var _ protoreflect.Message = (*fastReflection_ApprovalCriteria)(nil)

type fastReflection_ApprovalCriteria ApprovalCriteria

func (x *ApprovalCriteria) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ApprovalCriteria)(x)
}

func (x *ApprovalCriteria) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ApprovalCriteria_messageType fastReflection_ApprovalCriteria_messageType
var _ protoreflect.MessageType = fastReflection_ApprovalCriteria_messageType{}

type fastReflection_ApprovalCriteria_messageType struct{}

func (x fastReflection_ApprovalCriteria_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ApprovalCriteria)(nil)
}
func (x fastReflection_ApprovalCriteria_messageType) New() protoreflect.Message {
	return new(fastReflection_ApprovalCriteria)
}
func (x fastReflection_ApprovalCriteria_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ApprovalCriteria
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ApprovalCriteria) Descriptor() protoreflect.MessageDescriptor {
	return md_ApprovalCriteria
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ApprovalCriteria) Type() protoreflect.MessageType {
	return _fastReflection_ApprovalCriteria_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ApprovalCriteria) New() protoreflect.Message {
	return new(fastReflection_ApprovalCriteria)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ApprovalCriteria) Interface() protoreflect.ProtoMessage {
	return (*ApprovalCriteria)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ApprovalCriteria) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.MustOwnBadges) != 0 {
		value := protoreflect.ValueOfList(&_ApprovalCriteria_1_list{list: &x.MustOwnBadges})
		if !f(fd_ApprovalCriteria_mustOwnBadges, value) {
			return
		}
	}
	if len(x.MerkleChallenges) != 0 {
		value := protoreflect.ValueOfList(&_ApprovalCriteria_2_list{list: &x.MerkleChallenges})
		if !f(fd_ApprovalCriteria_merkleChallenges, value) {
			return
		}
	}
	if x.PredeterminedBalances != nil {
		value := protoreflect.ValueOfMessage(x.PredeterminedBalances.ProtoReflect())
		if !f(fd_ApprovalCriteria_predeterminedBalances, value) {
			return
		}
	}
	if x.ApprovalAmounts != nil {
		value := protoreflect.ValueOfMessage(x.ApprovalAmounts.ProtoReflect())
		if !f(fd_ApprovalCriteria_approvalAmounts, value) {
			return
		}
	}
	if x.MaxNumTransfers != nil {
		value := protoreflect.ValueOfMessage(x.MaxNumTransfers.ProtoReflect())
		if !f(fd_ApprovalCriteria_maxNumTransfers, value) {
			return
		}
	}
	if len(x.ZkProofs) != 0 {
		value := protoreflect.ValueOfList(&_ApprovalCriteria_6_list{list: &x.ZkProofs})
		if !f(fd_ApprovalCriteria_zkProofs, value) {
			return
		}
	}
	if len(x.CoinTransfers) != 0 {
		value := protoreflect.ValueOfList(&_ApprovalCriteria_7_list{list: &x.CoinTransfers})
		if !f(fd_ApprovalCriteria_coinTransfers, value) {
			return
		}
	}
	if x.RequireToEqualsInitiatedBy != false {
		value := protoreflect.ValueOfBool(x.RequireToEqualsInitiatedBy)
		if !f(fd_ApprovalCriteria_requireToEqualsInitiatedBy, value) {
			return
		}
	}
	if x.RequireFromEqualsInitiatedBy != false {
		value := protoreflect.ValueOfBool(x.RequireFromEqualsInitiatedBy)
		if !f(fd_ApprovalCriteria_requireFromEqualsInitiatedBy, value) {
			return
		}
	}
	if x.RequireToDoesNotEqualInitiatedBy != false {
		value := protoreflect.ValueOfBool(x.RequireToDoesNotEqualInitiatedBy)
		if !f(fd_ApprovalCriteria_requireToDoesNotEqualInitiatedBy, value) {
			return
		}
	}
	if x.RequireFromDoesNotEqualInitiatedBy != false {
		value := protoreflect.ValueOfBool(x.RequireFromDoesNotEqualInitiatedBy)
		if !f(fd_ApprovalCriteria_requireFromDoesNotEqualInitiatedBy, value) {
			return
		}
	}
	if x.OverridesFromOutgoingApprovals != false {
		value := protoreflect.ValueOfBool(x.OverridesFromOutgoingApprovals)
		if !f(fd_ApprovalCriteria_overridesFromOutgoingApprovals, value) {
			return
		}
	}
	if x.OverridesToIncomingApprovals != false {
		value := protoreflect.ValueOfBool(x.OverridesToIncomingApprovals)
		if !f(fd_ApprovalCriteria_overridesToIncomingApprovals, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ApprovalCriteria) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.ApprovalCriteria.mustOwnBadges":
		return len(x.MustOwnBadges) != 0
	case "badges.ApprovalCriteria.merkleChallenges":
		return len(x.MerkleChallenges) != 0
	case "badges.ApprovalCriteria.predeterminedBalances":
		return x.PredeterminedBalances != nil
	case "badges.ApprovalCriteria.approvalAmounts":
		return x.ApprovalAmounts != nil
	case "badges.ApprovalCriteria.maxNumTransfers":
		return x.MaxNumTransfers != nil
	case "badges.ApprovalCriteria.zkProofs":
		return len(x.ZkProofs) != 0
	case "badges.ApprovalCriteria.coinTransfers":
		return len(x.CoinTransfers) != 0
	case "badges.ApprovalCriteria.requireToEqualsInitiatedBy":
		return x.RequireToEqualsInitiatedBy != false
	case "badges.ApprovalCriteria.requireFromEqualsInitiatedBy":
		return x.RequireFromEqualsInitiatedBy != false
	case "badges.ApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		return x.RequireToDoesNotEqualInitiatedBy != false
	case "badges.ApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		return x.RequireFromDoesNotEqualInitiatedBy != false
	case "badges.ApprovalCriteria.overridesFromOutgoingApprovals":
		return x.OverridesFromOutgoingApprovals != false
	case "badges.ApprovalCriteria.overridesToIncomingApprovals":
		return x.OverridesToIncomingApprovals != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.ApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalCriteria) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.ApprovalCriteria.mustOwnBadges":
		x.MustOwnBadges = nil
	case "badges.ApprovalCriteria.merkleChallenges":
		x.MerkleChallenges = nil
	case "badges.ApprovalCriteria.predeterminedBalances":
		x.PredeterminedBalances = nil
	case "badges.ApprovalCriteria.approvalAmounts":
		x.ApprovalAmounts = nil
	case "badges.ApprovalCriteria.maxNumTransfers":
		x.MaxNumTransfers = nil
	case "badges.ApprovalCriteria.zkProofs":
		x.ZkProofs = nil
	case "badges.ApprovalCriteria.coinTransfers":
		x.CoinTransfers = nil
	case "badges.ApprovalCriteria.requireToEqualsInitiatedBy":
		x.RequireToEqualsInitiatedBy = false
	case "badges.ApprovalCriteria.requireFromEqualsInitiatedBy":
		x.RequireFromEqualsInitiatedBy = false
	case "badges.ApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		x.RequireToDoesNotEqualInitiatedBy = false
	case "badges.ApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		x.RequireFromDoesNotEqualInitiatedBy = false
	case "badges.ApprovalCriteria.overridesFromOutgoingApprovals":
		x.OverridesFromOutgoingApprovals = false
	case "badges.ApprovalCriteria.overridesToIncomingApprovals":
		x.OverridesToIncomingApprovals = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.ApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ApprovalCriteria) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.ApprovalCriteria.mustOwnBadges":
		if len(x.MustOwnBadges) == 0 {
			return protoreflect.ValueOfList(&_ApprovalCriteria_1_list{})
		}
		listValue := &_ApprovalCriteria_1_list{list: &x.MustOwnBadges}
		return protoreflect.ValueOfList(listValue)
	case "badges.ApprovalCriteria.merkleChallenges":
		if len(x.MerkleChallenges) == 0 {
			return protoreflect.ValueOfList(&_ApprovalCriteria_2_list{})
		}
		listValue := &_ApprovalCriteria_2_list{list: &x.MerkleChallenges}
		return protoreflect.ValueOfList(listValue)
	case "badges.ApprovalCriteria.predeterminedBalances":
		value := x.PredeterminedBalances
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "badges.ApprovalCriteria.approvalAmounts":
		value := x.ApprovalAmounts
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "badges.ApprovalCriteria.maxNumTransfers":
		value := x.MaxNumTransfers
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "badges.ApprovalCriteria.zkProofs":
		if len(x.ZkProofs) == 0 {
			return protoreflect.ValueOfList(&_ApprovalCriteria_6_list{})
		}
		listValue := &_ApprovalCriteria_6_list{list: &x.ZkProofs}
		return protoreflect.ValueOfList(listValue)
	case "badges.ApprovalCriteria.coinTransfers":
		if len(x.CoinTransfers) == 0 {
			return protoreflect.ValueOfList(&_ApprovalCriteria_7_list{})
		}
		listValue := &_ApprovalCriteria_7_list{list: &x.CoinTransfers}
		return protoreflect.ValueOfList(listValue)
	case "badges.ApprovalCriteria.requireToEqualsInitiatedBy":
		value := x.RequireToEqualsInitiatedBy
		return protoreflect.ValueOfBool(value)
	case "badges.ApprovalCriteria.requireFromEqualsInitiatedBy":
		value := x.RequireFromEqualsInitiatedBy
		return protoreflect.ValueOfBool(value)
	case "badges.ApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		value := x.RequireToDoesNotEqualInitiatedBy
		return protoreflect.ValueOfBool(value)
	case "badges.ApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		value := x.RequireFromDoesNotEqualInitiatedBy
		return protoreflect.ValueOfBool(value)
	case "badges.ApprovalCriteria.overridesFromOutgoingApprovals":
		value := x.OverridesFromOutgoingApprovals
		return protoreflect.ValueOfBool(value)
	case "badges.ApprovalCriteria.overridesToIncomingApprovals":
		value := x.OverridesToIncomingApprovals
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.ApprovalCriteria does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalCriteria) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.ApprovalCriteria.mustOwnBadges":
		lv := value.List()
		clv := lv.(*_ApprovalCriteria_1_list)
		x.MustOwnBadges = *clv.list
	case "badges.ApprovalCriteria.merkleChallenges":
		lv := value.List()
		clv := lv.(*_ApprovalCriteria_2_list)
		x.MerkleChallenges = *clv.list
	case "badges.ApprovalCriteria.predeterminedBalances":
		x.PredeterminedBalances = value.Message().Interface().(*PredeterminedBalances)
	case "badges.ApprovalCriteria.approvalAmounts":
		x.ApprovalAmounts = value.Message().Interface().(*ApprovalAmounts)
	case "badges.ApprovalCriteria.maxNumTransfers":
		x.MaxNumTransfers = value.Message().Interface().(*MaxNumTransfers)
	case "badges.ApprovalCriteria.zkProofs":
		lv := value.List()
		clv := lv.(*_ApprovalCriteria_6_list)
		x.ZkProofs = *clv.list
	case "badges.ApprovalCriteria.coinTransfers":
		lv := value.List()
		clv := lv.(*_ApprovalCriteria_7_list)
		x.CoinTransfers = *clv.list
	case "badges.ApprovalCriteria.requireToEqualsInitiatedBy":
		x.RequireToEqualsInitiatedBy = value.Bool()
	case "badges.ApprovalCriteria.requireFromEqualsInitiatedBy":
		x.RequireFromEqualsInitiatedBy = value.Bool()
	case "badges.ApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		x.RequireToDoesNotEqualInitiatedBy = value.Bool()
	case "badges.ApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		x.RequireFromDoesNotEqualInitiatedBy = value.Bool()
	case "badges.ApprovalCriteria.overridesFromOutgoingApprovals":
		x.OverridesFromOutgoingApprovals = value.Bool()
	case "badges.ApprovalCriteria.overridesToIncomingApprovals":
		x.OverridesToIncomingApprovals = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.ApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalCriteria) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ApprovalCriteria.mustOwnBadges":
		if x.MustOwnBadges == nil {
			x.MustOwnBadges = []*MustOwnBadges{}
		}
		value := &_ApprovalCriteria_1_list{list: &x.MustOwnBadges}
		return protoreflect.ValueOfList(value)
	case "badges.ApprovalCriteria.merkleChallenges":
		if x.MerkleChallenges == nil {
			x.MerkleChallenges = []*MerkleChallenge{}
		}
		value := &_ApprovalCriteria_2_list{list: &x.MerkleChallenges}
		return protoreflect.ValueOfList(value)
	case "badges.ApprovalCriteria.predeterminedBalances":
		if x.PredeterminedBalances == nil {
			x.PredeterminedBalances = new(PredeterminedBalances)
		}
		return protoreflect.ValueOfMessage(x.PredeterminedBalances.ProtoReflect())
	case "badges.ApprovalCriteria.approvalAmounts":
		if x.ApprovalAmounts == nil {
			x.ApprovalAmounts = new(ApprovalAmounts)
		}
		return protoreflect.ValueOfMessage(x.ApprovalAmounts.ProtoReflect())
	case "badges.ApprovalCriteria.maxNumTransfers":
		if x.MaxNumTransfers == nil {
			x.MaxNumTransfers = new(MaxNumTransfers)
		}
		return protoreflect.ValueOfMessage(x.MaxNumTransfers.ProtoReflect())
	case "badges.ApprovalCriteria.zkProofs":
		if x.ZkProofs == nil {
			x.ZkProofs = []*ZkProof{}
		}
		value := &_ApprovalCriteria_6_list{list: &x.ZkProofs}
		return protoreflect.ValueOfList(value)
	case "badges.ApprovalCriteria.coinTransfers":
		if x.CoinTransfers == nil {
			x.CoinTransfers = []*CoinTransfer{}
		}
		value := &_ApprovalCriteria_7_list{list: &x.CoinTransfers}
		return protoreflect.ValueOfList(value)
	case "badges.ApprovalCriteria.requireToEqualsInitiatedBy":
		panic(fmt.Errorf("field requireToEqualsInitiatedBy of message badges.ApprovalCriteria is not mutable"))
	case "badges.ApprovalCriteria.requireFromEqualsInitiatedBy":
		panic(fmt.Errorf("field requireFromEqualsInitiatedBy of message badges.ApprovalCriteria is not mutable"))
	case "badges.ApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		panic(fmt.Errorf("field requireToDoesNotEqualInitiatedBy of message badges.ApprovalCriteria is not mutable"))
	case "badges.ApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		panic(fmt.Errorf("field requireFromDoesNotEqualInitiatedBy of message badges.ApprovalCriteria is not mutable"))
	case "badges.ApprovalCriteria.overridesFromOutgoingApprovals":
		panic(fmt.Errorf("field overridesFromOutgoingApprovals of message badges.ApprovalCriteria is not mutable"))
	case "badges.ApprovalCriteria.overridesToIncomingApprovals":
		panic(fmt.Errorf("field overridesToIncomingApprovals of message badges.ApprovalCriteria is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.ApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ApprovalCriteria) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ApprovalCriteria.mustOwnBadges":
		list := []*MustOwnBadges{}
		return protoreflect.ValueOfList(&_ApprovalCriteria_1_list{list: &list})
	case "badges.ApprovalCriteria.merkleChallenges":
		list := []*MerkleChallenge{}
		return protoreflect.ValueOfList(&_ApprovalCriteria_2_list{list: &list})
	case "badges.ApprovalCriteria.predeterminedBalances":
		m := new(PredeterminedBalances)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "badges.ApprovalCriteria.approvalAmounts":
		m := new(ApprovalAmounts)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "badges.ApprovalCriteria.maxNumTransfers":
		m := new(MaxNumTransfers)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "badges.ApprovalCriteria.zkProofs":
		list := []*ZkProof{}
		return protoreflect.ValueOfList(&_ApprovalCriteria_6_list{list: &list})
	case "badges.ApprovalCriteria.coinTransfers":
		list := []*CoinTransfer{}
		return protoreflect.ValueOfList(&_ApprovalCriteria_7_list{list: &list})
	case "badges.ApprovalCriteria.requireToEqualsInitiatedBy":
		return protoreflect.ValueOfBool(false)
	case "badges.ApprovalCriteria.requireFromEqualsInitiatedBy":
		return protoreflect.ValueOfBool(false)
	case "badges.ApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		return protoreflect.ValueOfBool(false)
	case "badges.ApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		return protoreflect.ValueOfBool(false)
	case "badges.ApprovalCriteria.overridesFromOutgoingApprovals":
		return protoreflect.ValueOfBool(false)
	case "badges.ApprovalCriteria.overridesToIncomingApprovals":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.ApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ApprovalCriteria) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.ApprovalCriteria", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ApprovalCriteria) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalCriteria) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ApprovalCriteria) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ApprovalCriteria) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ApprovalCriteria)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.MustOwnBadges) > 0 {
			for _, e := range x.MustOwnBadges {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.MerkleChallenges) > 0 {
			for _, e := range x.MerkleChallenges {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.PredeterminedBalances != nil {
			l = options.Size(x.PredeterminedBalances)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ApprovalAmounts != nil {
			l = options.Size(x.ApprovalAmounts)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.MaxNumTransfers != nil {
			l = options.Size(x.MaxNumTransfers)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.ZkProofs) > 0 {
			for _, e := range x.ZkProofs {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.CoinTransfers) > 0 {
			for _, e := range x.CoinTransfers {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.RequireToEqualsInitiatedBy {
			n += 2
		}
		if x.RequireFromEqualsInitiatedBy {
			n += 2
		}
		if x.RequireToDoesNotEqualInitiatedBy {
			n += 2
		}
		if x.RequireFromDoesNotEqualInitiatedBy {
			n += 2
		}
		if x.OverridesFromOutgoingApprovals {
			n += 2
		}
		if x.OverridesToIncomingApprovals {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ApprovalCriteria)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.OverridesToIncomingApprovals {
			i--
			if x.OverridesToIncomingApprovals {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x70
		}
		if x.OverridesFromOutgoingApprovals {
			i--
			if x.OverridesFromOutgoingApprovals {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x68
		}
		if x.RequireFromDoesNotEqualInitiatedBy {
			i--
			if x.RequireFromDoesNotEqualInitiatedBy {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x60
		}
		if x.RequireToDoesNotEqualInitiatedBy {
			i--
			if x.RequireToDoesNotEqualInitiatedBy {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x58
		}
		if x.RequireFromEqualsInitiatedBy {
			i--
			if x.RequireFromEqualsInitiatedBy {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x50
		}
		if x.RequireToEqualsInitiatedBy {
			i--
			if x.RequireToEqualsInitiatedBy {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x48
		}
		if len(x.CoinTransfers) > 0 {
			for iNdEx := len(x.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.CoinTransfers[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x3a
			}
		}
		if len(x.ZkProofs) > 0 {
			for iNdEx := len(x.ZkProofs) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.ZkProofs[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x32
			}
		}
		if x.MaxNumTransfers != nil {
			encoded, err := options.Marshal(x.MaxNumTransfers)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if x.ApprovalAmounts != nil {
			encoded, err := options.Marshal(x.ApprovalAmounts)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if x.PredeterminedBalances != nil {
			encoded, err := options.Marshal(x.PredeterminedBalances)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.MerkleChallenges) > 0 {
			for iNdEx := len(x.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.MerkleChallenges[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.MustOwnBadges) > 0 {
			for iNdEx := len(x.MustOwnBadges) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.MustOwnBadges[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ApprovalCriteria)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ApprovalCriteria: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MustOwnBadges", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MustOwnBadges = append(x.MustOwnBadges, &MustOwnBadges{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MustOwnBadges[len(x.MustOwnBadges)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MerkleChallenges = append(x.MerkleChallenges, &MerkleChallenge{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MerkleChallenges[len(x.MerkleChallenges)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.PredeterminedBalances == nil {
					x.PredeterminedBalances = &PredeterminedBalances{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.PredeterminedBalances); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ApprovalAmounts == nil {
					x.ApprovalAmounts = &ApprovalAmounts{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ApprovalAmounts); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.MaxNumTransfers == nil {
					x.MaxNumTransfers = &MaxNumTransfers{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MaxNumTransfers); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ZkProofs", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ZkProofs = append(x.ZkProofs, &ZkProof{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ZkProofs[len(x.ZkProofs)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CoinTransfers = append(x.CoinTransfers, &CoinTransfer{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CoinTransfers[len(x.CoinTransfers)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.RequireToEqualsInitiatedBy = bool(v != 0)
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.RequireFromEqualsInitiatedBy = bool(v != 0)
			case 11:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
			case 12:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
			case 13:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OverridesFromOutgoingApprovals", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.OverridesFromOutgoingApprovals = bool(v != 0)
			case 14:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OverridesToIncomingApprovals", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.OverridesToIncomingApprovals = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_OutgoingApprovalCriteria_1_list)(nil)

type _OutgoingApprovalCriteria_1_list struct {
	list *[]*MustOwnBadges
}

func (x *_OutgoingApprovalCriteria_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_OutgoingApprovalCriteria_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MustOwnBadges)
	(*x.list)[i] = concreteValue
}

func (x *_OutgoingApprovalCriteria_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MustOwnBadges)
	*x.list = append(*x.list, concreteValue)
}

func (x *_OutgoingApprovalCriteria_1_list) AppendMutable() protoreflect.Value {
	v := new(MustOwnBadges)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_OutgoingApprovalCriteria_1_list) NewElement() protoreflect.Value {
	v := new(MustOwnBadges)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_1_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_OutgoingApprovalCriteria_2_list)(nil)

type _OutgoingApprovalCriteria_2_list struct {
	list *[]*MerkleChallenge
}

func (x *_OutgoingApprovalCriteria_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_OutgoingApprovalCriteria_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MerkleChallenge)
	(*x.list)[i] = concreteValue
}

func (x *_OutgoingApprovalCriteria_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MerkleChallenge)
	*x.list = append(*x.list, concreteValue)
}

func (x *_OutgoingApprovalCriteria_2_list) AppendMutable() protoreflect.Value {
	v := new(MerkleChallenge)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_OutgoingApprovalCriteria_2_list) NewElement() protoreflect.Value {
	v := new(MerkleChallenge)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_2_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_OutgoingApprovalCriteria_6_list)(nil)

type _OutgoingApprovalCriteria_6_list struct {
	list *[]*ZkProof
}

func (x *_OutgoingApprovalCriteria_6_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_OutgoingApprovalCriteria_6_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_6_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ZkProof)
	(*x.list)[i] = concreteValue
}

func (x *_OutgoingApprovalCriteria_6_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ZkProof)
	*x.list = append(*x.list, concreteValue)
}

func (x *_OutgoingApprovalCriteria_6_list) AppendMutable() protoreflect.Value {
	v := new(ZkProof)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_6_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_OutgoingApprovalCriteria_6_list) NewElement() protoreflect.Value {
	v := new(ZkProof)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_6_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_OutgoingApprovalCriteria_7_list)(nil)

type _OutgoingApprovalCriteria_7_list struct {
	list *[]*CoinTransfer
}

func (x *_OutgoingApprovalCriteria_7_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_OutgoingApprovalCriteria_7_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_7_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*CoinTransfer)
	(*x.list)[i] = concreteValue
}

func (x *_OutgoingApprovalCriteria_7_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*CoinTransfer)
	*x.list = append(*x.list, concreteValue)
}

func (x *_OutgoingApprovalCriteria_7_list) AppendMutable() protoreflect.Value {
	v := new(CoinTransfer)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_7_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_OutgoingApprovalCriteria_7_list) NewElement() protoreflect.Value {
	v := new(CoinTransfer)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_OutgoingApprovalCriteria_7_list) IsValid() bool {
	return x.list != nil
}

var (
	md_OutgoingApprovalCriteria                                  protoreflect.MessageDescriptor
	fd_OutgoingApprovalCriteria_mustOwnBadges                    protoreflect.FieldDescriptor
	fd_OutgoingApprovalCriteria_merkleChallenges                 protoreflect.FieldDescriptor
	fd_OutgoingApprovalCriteria_predeterminedBalances            protoreflect.FieldDescriptor
	fd_OutgoingApprovalCriteria_approvalAmounts                  protoreflect.FieldDescriptor
	fd_OutgoingApprovalCriteria_maxNumTransfers                  protoreflect.FieldDescriptor
	fd_OutgoingApprovalCriteria_zkProofs                         protoreflect.FieldDescriptor
	fd_OutgoingApprovalCriteria_coinTransfers                    protoreflect.FieldDescriptor
	fd_OutgoingApprovalCriteria_requireToEqualsInitiatedBy       protoreflect.FieldDescriptor
	fd_OutgoingApprovalCriteria_requireToDoesNotEqualInitiatedBy protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_OutgoingApprovalCriteria = File_badges_transfers_proto.Messages().ByName("OutgoingApprovalCriteria")
	fd_OutgoingApprovalCriteria_mustOwnBadges = md_OutgoingApprovalCriteria.Fields().ByName("mustOwnBadges")
	fd_OutgoingApprovalCriteria_merkleChallenges = md_OutgoingApprovalCriteria.Fields().ByName("merkleChallenges")
	fd_OutgoingApprovalCriteria_predeterminedBalances = md_OutgoingApprovalCriteria.Fields().ByName("predeterminedBalances")
	fd_OutgoingApprovalCriteria_approvalAmounts = md_OutgoingApprovalCriteria.Fields().ByName("approvalAmounts")
	fd_OutgoingApprovalCriteria_maxNumTransfers = md_OutgoingApprovalCriteria.Fields().ByName("maxNumTransfers")
	fd_OutgoingApprovalCriteria_zkProofs = md_OutgoingApprovalCriteria.Fields().ByName("zkProofs")
	fd_OutgoingApprovalCriteria_coinTransfers = md_OutgoingApprovalCriteria.Fields().ByName("coinTransfers")
	fd_OutgoingApprovalCriteria_requireToEqualsInitiatedBy = md_OutgoingApprovalCriteria.Fields().ByName("requireToEqualsInitiatedBy")
	fd_OutgoingApprovalCriteria_requireToDoesNotEqualInitiatedBy = md_OutgoingApprovalCriteria.Fields().ByName("requireToDoesNotEqualInitiatedBy")
}

var _ protoreflect.Message = (*fastReflection_OutgoingApprovalCriteria)(nil)

type fastReflection_OutgoingApprovalCriteria OutgoingApprovalCriteria

func (x *OutgoingApprovalCriteria) ProtoReflect() protoreflect.Message {
	return (*fastReflection_OutgoingApprovalCriteria)(x)
}

func (x *OutgoingApprovalCriteria) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_OutgoingApprovalCriteria_messageType fastReflection_OutgoingApprovalCriteria_messageType
var _ protoreflect.MessageType = fastReflection_OutgoingApprovalCriteria_messageType{}

type fastReflection_OutgoingApprovalCriteria_messageType struct{}

func (x fastReflection_OutgoingApprovalCriteria_messageType) Zero() protoreflect.Message {
	return (*fastReflection_OutgoingApprovalCriteria)(nil)
}
func (x fastReflection_OutgoingApprovalCriteria_messageType) New() protoreflect.Message {
	return new(fastReflection_OutgoingApprovalCriteria)
}
func (x fastReflection_OutgoingApprovalCriteria_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_OutgoingApprovalCriteria
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_OutgoingApprovalCriteria) Descriptor() protoreflect.MessageDescriptor {
	return md_OutgoingApprovalCriteria
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_OutgoingApprovalCriteria) Type() protoreflect.MessageType {
	return _fastReflection_OutgoingApprovalCriteria_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_OutgoingApprovalCriteria) New() protoreflect.Message {
	return new(fastReflection_OutgoingApprovalCriteria)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_OutgoingApprovalCriteria) Interface() protoreflect.ProtoMessage {
	return (*OutgoingApprovalCriteria)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_OutgoingApprovalCriteria) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.MustOwnBadges) != 0 {
		value := protoreflect.ValueOfList(&_OutgoingApprovalCriteria_1_list{list: &x.MustOwnBadges})
		if !f(fd_OutgoingApprovalCriteria_mustOwnBadges, value) {
			return
		}
	}
	if len(x.MerkleChallenges) != 0 {
		value := protoreflect.ValueOfList(&_OutgoingApprovalCriteria_2_list{list: &x.MerkleChallenges})
		if !f(fd_OutgoingApprovalCriteria_merkleChallenges, value) {
			return
		}
	}
	if x.PredeterminedBalances != nil {
		value := protoreflect.ValueOfMessage(x.PredeterminedBalances.ProtoReflect())
		if !f(fd_OutgoingApprovalCriteria_predeterminedBalances, value) {
			return
		}
	}
	if x.ApprovalAmounts != nil {
		value := protoreflect.ValueOfMessage(x.ApprovalAmounts.ProtoReflect())
		if !f(fd_OutgoingApprovalCriteria_approvalAmounts, value) {
			return
		}
	}
	if x.MaxNumTransfers != nil {
		value := protoreflect.ValueOfMessage(x.MaxNumTransfers.ProtoReflect())
		if !f(fd_OutgoingApprovalCriteria_maxNumTransfers, value) {
			return
		}
	}
	if len(x.ZkProofs) != 0 {
		value := protoreflect.ValueOfList(&_OutgoingApprovalCriteria_6_list{list: &x.ZkProofs})
		if !f(fd_OutgoingApprovalCriteria_zkProofs, value) {
			return
		}
	}
	if len(x.CoinTransfers) != 0 {
		value := protoreflect.ValueOfList(&_OutgoingApprovalCriteria_7_list{list: &x.CoinTransfers})
		if !f(fd_OutgoingApprovalCriteria_coinTransfers, value) {
			return
		}
	}
	if x.RequireToEqualsInitiatedBy != false {
		value := protoreflect.ValueOfBool(x.RequireToEqualsInitiatedBy)
		if !f(fd_OutgoingApprovalCriteria_requireToEqualsInitiatedBy, value) {
			return
		}
	}
	if x.RequireToDoesNotEqualInitiatedBy != false {
		value := protoreflect.ValueOfBool(x.RequireToDoesNotEqualInitiatedBy)
		if !f(fd_OutgoingApprovalCriteria_requireToDoesNotEqualInitiatedBy, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_OutgoingApprovalCriteria) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.OutgoingApprovalCriteria.mustOwnBadges":
		return len(x.MustOwnBadges) != 0
	case "badges.OutgoingApprovalCriteria.merkleChallenges":
		return len(x.MerkleChallenges) != 0
	case "badges.OutgoingApprovalCriteria.predeterminedBalances":
		return x.PredeterminedBalances != nil
	case "badges.OutgoingApprovalCriteria.approvalAmounts":
		return x.ApprovalAmounts != nil
	case "badges.OutgoingApprovalCriteria.maxNumTransfers":
		return x.MaxNumTransfers != nil
	case "badges.OutgoingApprovalCriteria.zkProofs":
		return len(x.ZkProofs) != 0
	case "badges.OutgoingApprovalCriteria.coinTransfers":
		return len(x.CoinTransfers) != 0
	case "badges.OutgoingApprovalCriteria.requireToEqualsInitiatedBy":
		return x.RequireToEqualsInitiatedBy != false
	case "badges.OutgoingApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		return x.RequireToDoesNotEqualInitiatedBy != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.OutgoingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.OutgoingApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OutgoingApprovalCriteria) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.OutgoingApprovalCriteria.mustOwnBadges":
		x.MustOwnBadges = nil
	case "badges.OutgoingApprovalCriteria.merkleChallenges":
		x.MerkleChallenges = nil
	case "badges.OutgoingApprovalCriteria.predeterminedBalances":
		x.PredeterminedBalances = nil
	case "badges.OutgoingApprovalCriteria.approvalAmounts":
		x.ApprovalAmounts = nil
	case "badges.OutgoingApprovalCriteria.maxNumTransfers":
		x.MaxNumTransfers = nil
	case "badges.OutgoingApprovalCriteria.zkProofs":
		x.ZkProofs = nil
	case "badges.OutgoingApprovalCriteria.coinTransfers":
		x.CoinTransfers = nil
	case "badges.OutgoingApprovalCriteria.requireToEqualsInitiatedBy":
		x.RequireToEqualsInitiatedBy = false
	case "badges.OutgoingApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		x.RequireToDoesNotEqualInitiatedBy = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.OutgoingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.OutgoingApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_OutgoingApprovalCriteria) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.OutgoingApprovalCriteria.mustOwnBadges":
		if len(x.MustOwnBadges) == 0 {
			return protoreflect.ValueOfList(&_OutgoingApprovalCriteria_1_list{})
		}
		listValue := &_OutgoingApprovalCriteria_1_list{list: &x.MustOwnBadges}
		return protoreflect.ValueOfList(listValue)
	case "badges.OutgoingApprovalCriteria.merkleChallenges":
		if len(x.MerkleChallenges) == 0 {
			return protoreflect.ValueOfList(&_OutgoingApprovalCriteria_2_list{})
		}
		listValue := &_OutgoingApprovalCriteria_2_list{list: &x.MerkleChallenges}
		return protoreflect.ValueOfList(listValue)
	case "badges.OutgoingApprovalCriteria.predeterminedBalances":
		value := x.PredeterminedBalances
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "badges.OutgoingApprovalCriteria.approvalAmounts":
		value := x.ApprovalAmounts
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "badges.OutgoingApprovalCriteria.maxNumTransfers":
		value := x.MaxNumTransfers
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "badges.OutgoingApprovalCriteria.zkProofs":
		if len(x.ZkProofs) == 0 {
			return protoreflect.ValueOfList(&_OutgoingApprovalCriteria_6_list{})
		}
		listValue := &_OutgoingApprovalCriteria_6_list{list: &x.ZkProofs}
		return protoreflect.ValueOfList(listValue)
	case "badges.OutgoingApprovalCriteria.coinTransfers":
		if len(x.CoinTransfers) == 0 {
			return protoreflect.ValueOfList(&_OutgoingApprovalCriteria_7_list{})
		}
		listValue := &_OutgoingApprovalCriteria_7_list{list: &x.CoinTransfers}
		return protoreflect.ValueOfList(listValue)
	case "badges.OutgoingApprovalCriteria.requireToEqualsInitiatedBy":
		value := x.RequireToEqualsInitiatedBy
		return protoreflect.ValueOfBool(value)
	case "badges.OutgoingApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		value := x.RequireToDoesNotEqualInitiatedBy
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.OutgoingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.OutgoingApprovalCriteria does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OutgoingApprovalCriteria) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.OutgoingApprovalCriteria.mustOwnBadges":
		lv := value.List()
		clv := lv.(*_OutgoingApprovalCriteria_1_list)
		x.MustOwnBadges = *clv.list
	case "badges.OutgoingApprovalCriteria.merkleChallenges":
		lv := value.List()
		clv := lv.(*_OutgoingApprovalCriteria_2_list)
		x.MerkleChallenges = *clv.list
	case "badges.OutgoingApprovalCriteria.predeterminedBalances":
		x.PredeterminedBalances = value.Message().Interface().(*PredeterminedBalances)
	case "badges.OutgoingApprovalCriteria.approvalAmounts":
		x.ApprovalAmounts = value.Message().Interface().(*ApprovalAmounts)
	case "badges.OutgoingApprovalCriteria.maxNumTransfers":
		x.MaxNumTransfers = value.Message().Interface().(*MaxNumTransfers)
	case "badges.OutgoingApprovalCriteria.zkProofs":
		lv := value.List()
		clv := lv.(*_OutgoingApprovalCriteria_6_list)
		x.ZkProofs = *clv.list
	case "badges.OutgoingApprovalCriteria.coinTransfers":
		lv := value.List()
		clv := lv.(*_OutgoingApprovalCriteria_7_list)
		x.CoinTransfers = *clv.list
	case "badges.OutgoingApprovalCriteria.requireToEqualsInitiatedBy":
		x.RequireToEqualsInitiatedBy = value.Bool()
	case "badges.OutgoingApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		x.RequireToDoesNotEqualInitiatedBy = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.OutgoingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.OutgoingApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OutgoingApprovalCriteria) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.OutgoingApprovalCriteria.mustOwnBadges":
		if x.MustOwnBadges == nil {
			x.MustOwnBadges = []*MustOwnBadges{}
		}
		value := &_OutgoingApprovalCriteria_1_list{list: &x.MustOwnBadges}
		return protoreflect.ValueOfList(value)
	case "badges.OutgoingApprovalCriteria.merkleChallenges":
		if x.MerkleChallenges == nil {
			x.MerkleChallenges = []*MerkleChallenge{}
		}
		value := &_OutgoingApprovalCriteria_2_list{list: &x.MerkleChallenges}
		return protoreflect.ValueOfList(value)
	case "badges.OutgoingApprovalCriteria.predeterminedBalances":
		if x.PredeterminedBalances == nil {
			x.PredeterminedBalances = new(PredeterminedBalances)
		}
		return protoreflect.ValueOfMessage(x.PredeterminedBalances.ProtoReflect())
	case "badges.OutgoingApprovalCriteria.approvalAmounts":
		if x.ApprovalAmounts == nil {
			x.ApprovalAmounts = new(ApprovalAmounts)
		}
		return protoreflect.ValueOfMessage(x.ApprovalAmounts.ProtoReflect())
	case "badges.OutgoingApprovalCriteria.maxNumTransfers":
		if x.MaxNumTransfers == nil {
			x.MaxNumTransfers = new(MaxNumTransfers)
		}
		return protoreflect.ValueOfMessage(x.MaxNumTransfers.ProtoReflect())
	case "badges.OutgoingApprovalCriteria.zkProofs":
		if x.ZkProofs == nil {
			x.ZkProofs = []*ZkProof{}
		}
		value := &_OutgoingApprovalCriteria_6_list{list: &x.ZkProofs}
		return protoreflect.ValueOfList(value)
	case "badges.OutgoingApprovalCriteria.coinTransfers":
		if x.CoinTransfers == nil {
			x.CoinTransfers = []*CoinTransfer{}
		}
		value := &_OutgoingApprovalCriteria_7_list{list: &x.CoinTransfers}
		return protoreflect.ValueOfList(value)
	case "badges.OutgoingApprovalCriteria.requireToEqualsInitiatedBy":
		panic(fmt.Errorf("field requireToEqualsInitiatedBy of message badges.OutgoingApprovalCriteria is not mutable"))
	case "badges.OutgoingApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		panic(fmt.Errorf("field requireToDoesNotEqualInitiatedBy of message badges.OutgoingApprovalCriteria is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.OutgoingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.OutgoingApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_OutgoingApprovalCriteria) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.OutgoingApprovalCriteria.mustOwnBadges":
		list := []*MustOwnBadges{}
		return protoreflect.ValueOfList(&_OutgoingApprovalCriteria_1_list{list: &list})
	case "badges.OutgoingApprovalCriteria.merkleChallenges":
		list := []*MerkleChallenge{}
		return protoreflect.ValueOfList(&_OutgoingApprovalCriteria_2_list{list: &list})
	case "badges.OutgoingApprovalCriteria.predeterminedBalances":
		m := new(PredeterminedBalances)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "badges.OutgoingApprovalCriteria.approvalAmounts":
		m := new(ApprovalAmounts)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "badges.OutgoingApprovalCriteria.maxNumTransfers":
		m := new(MaxNumTransfers)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "badges.OutgoingApprovalCriteria.zkProofs":
		list := []*ZkProof{}
		return protoreflect.ValueOfList(&_OutgoingApprovalCriteria_6_list{list: &list})
	case "badges.OutgoingApprovalCriteria.coinTransfers":
		list := []*CoinTransfer{}
		return protoreflect.ValueOfList(&_OutgoingApprovalCriteria_7_list{list: &list})
	case "badges.OutgoingApprovalCriteria.requireToEqualsInitiatedBy":
		return protoreflect.ValueOfBool(false)
	case "badges.OutgoingApprovalCriteria.requireToDoesNotEqualInitiatedBy":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.OutgoingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.OutgoingApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_OutgoingApprovalCriteria) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.OutgoingApprovalCriteria", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_OutgoingApprovalCriteria) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OutgoingApprovalCriteria) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_OutgoingApprovalCriteria) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_OutgoingApprovalCriteria) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*OutgoingApprovalCriteria)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.MustOwnBadges) > 0 {
			for _, e := range x.MustOwnBadges {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.MerkleChallenges) > 0 {
			for _, e := range x.MerkleChallenges {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.PredeterminedBalances != nil {
			l = options.Size(x.PredeterminedBalances)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ApprovalAmounts != nil {
			l = options.Size(x.ApprovalAmounts)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.MaxNumTransfers != nil {
			l = options.Size(x.MaxNumTransfers)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.ZkProofs) > 0 {
			for _, e := range x.ZkProofs {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.CoinTransfers) > 0 {
			for _, e := range x.CoinTransfers {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.RequireToEqualsInitiatedBy {
			n += 2
		}
		if x.RequireToDoesNotEqualInitiatedBy {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*OutgoingApprovalCriteria)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.RequireToDoesNotEqualInitiatedBy {
			i--
			if x.RequireToDoesNotEqualInitiatedBy {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x58
		}
		if x.RequireToEqualsInitiatedBy {
			i--
			if x.RequireToEqualsInitiatedBy {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x48
		}
		if len(x.CoinTransfers) > 0 {
			for iNdEx := len(x.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.CoinTransfers[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x3a
			}
		}
		if len(x.ZkProofs) > 0 {
			for iNdEx := len(x.ZkProofs) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.ZkProofs[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x32
			}
		}
		if x.MaxNumTransfers != nil {
			encoded, err := options.Marshal(x.MaxNumTransfers)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if x.ApprovalAmounts != nil {
			encoded, err := options.Marshal(x.ApprovalAmounts)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if x.PredeterminedBalances != nil {
			encoded, err := options.Marshal(x.PredeterminedBalances)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.MerkleChallenges) > 0 {
			for iNdEx := len(x.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.MerkleChallenges[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.MustOwnBadges) > 0 {
			for iNdEx := len(x.MustOwnBadges) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.MustOwnBadges[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*OutgoingApprovalCriteria)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: OutgoingApprovalCriteria: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: OutgoingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MustOwnBadges", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MustOwnBadges = append(x.MustOwnBadges, &MustOwnBadges{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MustOwnBadges[len(x.MustOwnBadges)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MerkleChallenges = append(x.MerkleChallenges, &MerkleChallenge{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MerkleChallenges[len(x.MerkleChallenges)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.PredeterminedBalances == nil {
					x.PredeterminedBalances = &PredeterminedBalances{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.PredeterminedBalances); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ApprovalAmounts == nil {
					x.ApprovalAmounts = &ApprovalAmounts{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ApprovalAmounts); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.MaxNumTransfers == nil {
					x.MaxNumTransfers = &MaxNumTransfers{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MaxNumTransfers); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ZkProofs", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ZkProofs = append(x.ZkProofs, &ZkProof{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ZkProofs[len(x.ZkProofs)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CoinTransfers = append(x.CoinTransfers, &CoinTransfer{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CoinTransfers[len(x.CoinTransfers)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.RequireToEqualsInitiatedBy = bool(v != 0)
			case 11:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_IncomingApprovalCriteria_1_list)(nil)

type _IncomingApprovalCriteria_1_list struct {
	list *[]*MustOwnBadges
}

func (x *_IncomingApprovalCriteria_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_IncomingApprovalCriteria_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_IncomingApprovalCriteria_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MustOwnBadges)
	(*x.list)[i] = concreteValue
}

func (x *_IncomingApprovalCriteria_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MustOwnBadges)
	*x.list = append(*x.list, concreteValue)
}

func (x *_IncomingApprovalCriteria_1_list) AppendMutable() protoreflect.Value {
	v := new(MustOwnBadges)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_IncomingApprovalCriteria_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_IncomingApprovalCriteria_1_list) NewElement() protoreflect.Value {
	v := new(MustOwnBadges)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_IncomingApprovalCriteria_1_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_IncomingApprovalCriteria_2_list)(nil)

type _IncomingApprovalCriteria_2_list struct {
	list *[]*MerkleChallenge
}

func (x *_IncomingApprovalCriteria_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_IncomingApprovalCriteria_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_IncomingApprovalCriteria_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MerkleChallenge)
	(*x.list)[i] = concreteValue
}

func (x *_IncomingApprovalCriteria_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MerkleChallenge)
	*x.list = append(*x.list, concreteValue)
}

func (x *_IncomingApprovalCriteria_2_list) AppendMutable() protoreflect.Value {
	v := new(MerkleChallenge)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_IncomingApprovalCriteria_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_IncomingApprovalCriteria_2_list) NewElement() protoreflect.Value {
	v := new(MerkleChallenge)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_IncomingApprovalCriteria_2_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_IncomingApprovalCriteria_6_list)(nil)

type _IncomingApprovalCriteria_6_list struct {
	list *[]*ZkProof
}

func (x *_IncomingApprovalCriteria_6_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_IncomingApprovalCriteria_6_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_IncomingApprovalCriteria_6_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ZkProof)
	(*x.list)[i] = concreteValue
}

func (x *_IncomingApprovalCriteria_6_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ZkProof)
	*x.list = append(*x.list, concreteValue)
}

func (x *_IncomingApprovalCriteria_6_list) AppendMutable() protoreflect.Value {
	v := new(ZkProof)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_IncomingApprovalCriteria_6_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_IncomingApprovalCriteria_6_list) NewElement() protoreflect.Value {
	v := new(ZkProof)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_IncomingApprovalCriteria_6_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_IncomingApprovalCriteria_7_list)(nil)

type _IncomingApprovalCriteria_7_list struct {
	list *[]*CoinTransfer
}

func (x *_IncomingApprovalCriteria_7_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_IncomingApprovalCriteria_7_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_IncomingApprovalCriteria_7_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*CoinTransfer)
	(*x.list)[i] = concreteValue
}

func (x *_IncomingApprovalCriteria_7_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*CoinTransfer)
	*x.list = append(*x.list, concreteValue)
}

func (x *_IncomingApprovalCriteria_7_list) AppendMutable() protoreflect.Value {
	v := new(CoinTransfer)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_IncomingApprovalCriteria_7_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_IncomingApprovalCriteria_7_list) NewElement() protoreflect.Value {
	v := new(CoinTransfer)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_IncomingApprovalCriteria_7_list) IsValid() bool {
	return x.list != nil
}

var (
	md_IncomingApprovalCriteria                                    protoreflect.MessageDescriptor
	fd_IncomingApprovalCriteria_mustOwnBadges                      protoreflect.FieldDescriptor
	fd_IncomingApprovalCriteria_merkleChallenges                   protoreflect.FieldDescriptor
	fd_IncomingApprovalCriteria_predeterminedBalances              protoreflect.FieldDescriptor
	fd_IncomingApprovalCriteria_approvalAmounts                    protoreflect.FieldDescriptor
	fd_IncomingApprovalCriteria_maxNumTransfers                    protoreflect.FieldDescriptor
	fd_IncomingApprovalCriteria_zkProofs                           protoreflect.FieldDescriptor
	fd_IncomingApprovalCriteria_coinTransfers                      protoreflect.FieldDescriptor
	fd_IncomingApprovalCriteria_requireFromEqualsInitiatedBy       protoreflect.FieldDescriptor
	fd_IncomingApprovalCriteria_requireFromDoesNotEqualInitiatedBy protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_IncomingApprovalCriteria = File_badges_transfers_proto.Messages().ByName("IncomingApprovalCriteria")
	fd_IncomingApprovalCriteria_mustOwnBadges = md_IncomingApprovalCriteria.Fields().ByName("mustOwnBadges")
	fd_IncomingApprovalCriteria_merkleChallenges = md_IncomingApprovalCriteria.Fields().ByName("merkleChallenges")
	fd_IncomingApprovalCriteria_predeterminedBalances = md_IncomingApprovalCriteria.Fields().ByName("predeterminedBalances")
	fd_IncomingApprovalCriteria_approvalAmounts = md_IncomingApprovalCriteria.Fields().ByName("approvalAmounts")
	fd_IncomingApprovalCriteria_maxNumTransfers = md_IncomingApprovalCriteria.Fields().ByName("maxNumTransfers")
	fd_IncomingApprovalCriteria_zkProofs = md_IncomingApprovalCriteria.Fields().ByName("zkProofs")
	fd_IncomingApprovalCriteria_coinTransfers = md_IncomingApprovalCriteria.Fields().ByName("coinTransfers")
	fd_IncomingApprovalCriteria_requireFromEqualsInitiatedBy = md_IncomingApprovalCriteria.Fields().ByName("requireFromEqualsInitiatedBy")
	fd_IncomingApprovalCriteria_requireFromDoesNotEqualInitiatedBy = md_IncomingApprovalCriteria.Fields().ByName("requireFromDoesNotEqualInitiatedBy")
}

var _ protoreflect.Message = (*fastReflection_IncomingApprovalCriteria)(nil)

type fastReflection_IncomingApprovalCriteria IncomingApprovalCriteria

func (x *IncomingApprovalCriteria) ProtoReflect() protoreflect.Message {
	return (*fastReflection_IncomingApprovalCriteria)(x)
}

func (x *IncomingApprovalCriteria) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_IncomingApprovalCriteria_messageType fastReflection_IncomingApprovalCriteria_messageType
var _ protoreflect.MessageType = fastReflection_IncomingApprovalCriteria_messageType{}

type fastReflection_IncomingApprovalCriteria_messageType struct{}

func (x fastReflection_IncomingApprovalCriteria_messageType) Zero() protoreflect.Message {
	return (*fastReflection_IncomingApprovalCriteria)(nil)
}
func (x fastReflection_IncomingApprovalCriteria_messageType) New() protoreflect.Message {
	return new(fastReflection_IncomingApprovalCriteria)
}
func (x fastReflection_IncomingApprovalCriteria_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_IncomingApprovalCriteria
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_IncomingApprovalCriteria) Descriptor() protoreflect.MessageDescriptor {
	return md_IncomingApprovalCriteria
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_IncomingApprovalCriteria) Type() protoreflect.MessageType {
	return _fastReflection_IncomingApprovalCriteria_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_IncomingApprovalCriteria) New() protoreflect.Message {
	return new(fastReflection_IncomingApprovalCriteria)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_IncomingApprovalCriteria) Interface() protoreflect.ProtoMessage {
	return (*IncomingApprovalCriteria)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_IncomingApprovalCriteria) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.MustOwnBadges) != 0 {
		value := protoreflect.ValueOfList(&_IncomingApprovalCriteria_1_list{list: &x.MustOwnBadges})
		if !f(fd_IncomingApprovalCriteria_mustOwnBadges, value) {
			return
		}
	}
	if len(x.MerkleChallenges) != 0 {
		value := protoreflect.ValueOfList(&_IncomingApprovalCriteria_2_list{list: &x.MerkleChallenges})
		if !f(fd_IncomingApprovalCriteria_merkleChallenges, value) {
			return
		}
	}
	if x.PredeterminedBalances != nil {
		value := protoreflect.ValueOfMessage(x.PredeterminedBalances.ProtoReflect())
		if !f(fd_IncomingApprovalCriteria_predeterminedBalances, value) {
			return
		}
	}
	if x.ApprovalAmounts != nil {
		value := protoreflect.ValueOfMessage(x.ApprovalAmounts.ProtoReflect())
		if !f(fd_IncomingApprovalCriteria_approvalAmounts, value) {
			return
		}
	}
	if x.MaxNumTransfers != nil {
		value := protoreflect.ValueOfMessage(x.MaxNumTransfers.ProtoReflect())
		if !f(fd_IncomingApprovalCriteria_maxNumTransfers, value) {
			return
		}
	}
	if len(x.ZkProofs) != 0 {
		value := protoreflect.ValueOfList(&_IncomingApprovalCriteria_6_list{list: &x.ZkProofs})
		if !f(fd_IncomingApprovalCriteria_zkProofs, value) {
			return
		}
	}
	if len(x.CoinTransfers) != 0 {
		value := protoreflect.ValueOfList(&_IncomingApprovalCriteria_7_list{list: &x.CoinTransfers})
		if !f(fd_IncomingApprovalCriteria_coinTransfers, value) {
			return
		}
	}
	if x.RequireFromEqualsInitiatedBy != false {
		value := protoreflect.ValueOfBool(x.RequireFromEqualsInitiatedBy)
		if !f(fd_IncomingApprovalCriteria_requireFromEqualsInitiatedBy, value) {
			return
		}
	}
	if x.RequireFromDoesNotEqualInitiatedBy != false {
		value := protoreflect.ValueOfBool(x.RequireFromDoesNotEqualInitiatedBy)
		if !f(fd_IncomingApprovalCriteria_requireFromDoesNotEqualInitiatedBy, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_IncomingApprovalCriteria) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.IncomingApprovalCriteria.mustOwnBadges":
		return len(x.MustOwnBadges) != 0
	case "badges.IncomingApprovalCriteria.merkleChallenges":
		return len(x.MerkleChallenges) != 0
	case "badges.IncomingApprovalCriteria.predeterminedBalances":
		return x.PredeterminedBalances != nil
	case "badges.IncomingApprovalCriteria.approvalAmounts":
		return x.ApprovalAmounts != nil
	case "badges.IncomingApprovalCriteria.maxNumTransfers":
		return x.MaxNumTransfers != nil
	case "badges.IncomingApprovalCriteria.zkProofs":
		return len(x.ZkProofs) != 0
	case "badges.IncomingApprovalCriteria.coinTransfers":
		return len(x.CoinTransfers) != 0
	case "badges.IncomingApprovalCriteria.requireFromEqualsInitiatedBy":
		return x.RequireFromEqualsInitiatedBy != false
	case "badges.IncomingApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		return x.RequireFromDoesNotEqualInitiatedBy != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncomingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.IncomingApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_IncomingApprovalCriteria) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.IncomingApprovalCriteria.mustOwnBadges":
		x.MustOwnBadges = nil
	case "badges.IncomingApprovalCriteria.merkleChallenges":
		x.MerkleChallenges = nil
	case "badges.IncomingApprovalCriteria.predeterminedBalances":
		x.PredeterminedBalances = nil
	case "badges.IncomingApprovalCriteria.approvalAmounts":
		x.ApprovalAmounts = nil
	case "badges.IncomingApprovalCriteria.maxNumTransfers":
		x.MaxNumTransfers = nil
	case "badges.IncomingApprovalCriteria.zkProofs":
		x.ZkProofs = nil
	case "badges.IncomingApprovalCriteria.coinTransfers":
		x.CoinTransfers = nil
	case "badges.IncomingApprovalCriteria.requireFromEqualsInitiatedBy":
		x.RequireFromEqualsInitiatedBy = false
	case "badges.IncomingApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		x.RequireFromDoesNotEqualInitiatedBy = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncomingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.IncomingApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_IncomingApprovalCriteria) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.IncomingApprovalCriteria.mustOwnBadges":
		if len(x.MustOwnBadges) == 0 {
			return protoreflect.ValueOfList(&_IncomingApprovalCriteria_1_list{})
		}
		listValue := &_IncomingApprovalCriteria_1_list{list: &x.MustOwnBadges}
		return protoreflect.ValueOfList(listValue)
	case "badges.IncomingApprovalCriteria.merkleChallenges":
		if len(x.MerkleChallenges) == 0 {
			return protoreflect.ValueOfList(&_IncomingApprovalCriteria_2_list{})
		}
		listValue := &_IncomingApprovalCriteria_2_list{list: &x.MerkleChallenges}
		return protoreflect.ValueOfList(listValue)
	case "badges.IncomingApprovalCriteria.predeterminedBalances":
		value := x.PredeterminedBalances
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "badges.IncomingApprovalCriteria.approvalAmounts":
		value := x.ApprovalAmounts
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "badges.IncomingApprovalCriteria.maxNumTransfers":
		value := x.MaxNumTransfers
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "badges.IncomingApprovalCriteria.zkProofs":
		if len(x.ZkProofs) == 0 {
			return protoreflect.ValueOfList(&_IncomingApprovalCriteria_6_list{})
		}
		listValue := &_IncomingApprovalCriteria_6_list{list: &x.ZkProofs}
		return protoreflect.ValueOfList(listValue)
	case "badges.IncomingApprovalCriteria.coinTransfers":
		if len(x.CoinTransfers) == 0 {
			return protoreflect.ValueOfList(&_IncomingApprovalCriteria_7_list{})
		}
		listValue := &_IncomingApprovalCriteria_7_list{list: &x.CoinTransfers}
		return protoreflect.ValueOfList(listValue)
	case "badges.IncomingApprovalCriteria.requireFromEqualsInitiatedBy":
		value := x.RequireFromEqualsInitiatedBy
		return protoreflect.ValueOfBool(value)
	case "badges.IncomingApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		value := x.RequireFromDoesNotEqualInitiatedBy
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncomingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.IncomingApprovalCriteria does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_IncomingApprovalCriteria) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.IncomingApprovalCriteria.mustOwnBadges":
		lv := value.List()
		clv := lv.(*_IncomingApprovalCriteria_1_list)
		x.MustOwnBadges = *clv.list
	case "badges.IncomingApprovalCriteria.merkleChallenges":
		lv := value.List()
		clv := lv.(*_IncomingApprovalCriteria_2_list)
		x.MerkleChallenges = *clv.list
	case "badges.IncomingApprovalCriteria.predeterminedBalances":
		x.PredeterminedBalances = value.Message().Interface().(*PredeterminedBalances)
	case "badges.IncomingApprovalCriteria.approvalAmounts":
		x.ApprovalAmounts = value.Message().Interface().(*ApprovalAmounts)
	case "badges.IncomingApprovalCriteria.maxNumTransfers":
		x.MaxNumTransfers = value.Message().Interface().(*MaxNumTransfers)
	case "badges.IncomingApprovalCriteria.zkProofs":
		lv := value.List()
		clv := lv.(*_IncomingApprovalCriteria_6_list)
		x.ZkProofs = *clv.list
	case "badges.IncomingApprovalCriteria.coinTransfers":
		lv := value.List()
		clv := lv.(*_IncomingApprovalCriteria_7_list)
		x.CoinTransfers = *clv.list
	case "badges.IncomingApprovalCriteria.requireFromEqualsInitiatedBy":
		x.RequireFromEqualsInitiatedBy = value.Bool()
	case "badges.IncomingApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		x.RequireFromDoesNotEqualInitiatedBy = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncomingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.IncomingApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_IncomingApprovalCriteria) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.IncomingApprovalCriteria.mustOwnBadges":
		if x.MustOwnBadges == nil {
			x.MustOwnBadges = []*MustOwnBadges{}
		}
		value := &_IncomingApprovalCriteria_1_list{list: &x.MustOwnBadges}
		return protoreflect.ValueOfList(value)
	case "badges.IncomingApprovalCriteria.merkleChallenges":
		if x.MerkleChallenges == nil {
			x.MerkleChallenges = []*MerkleChallenge{}
		}
		value := &_IncomingApprovalCriteria_2_list{list: &x.MerkleChallenges}
		return protoreflect.ValueOfList(value)
	case "badges.IncomingApprovalCriteria.predeterminedBalances":
		if x.PredeterminedBalances == nil {
			x.PredeterminedBalances = new(PredeterminedBalances)
		}
		return protoreflect.ValueOfMessage(x.PredeterminedBalances.ProtoReflect())
	case "badges.IncomingApprovalCriteria.approvalAmounts":
		if x.ApprovalAmounts == nil {
			x.ApprovalAmounts = new(ApprovalAmounts)
		}
		return protoreflect.ValueOfMessage(x.ApprovalAmounts.ProtoReflect())
	case "badges.IncomingApprovalCriteria.maxNumTransfers":
		if x.MaxNumTransfers == nil {
			x.MaxNumTransfers = new(MaxNumTransfers)
		}
		return protoreflect.ValueOfMessage(x.MaxNumTransfers.ProtoReflect())
	case "badges.IncomingApprovalCriteria.zkProofs":
		if x.ZkProofs == nil {
			x.ZkProofs = []*ZkProof{}
		}
		value := &_IncomingApprovalCriteria_6_list{list: &x.ZkProofs}
		return protoreflect.ValueOfList(value)
	case "badges.IncomingApprovalCriteria.coinTransfers":
		if x.CoinTransfers == nil {
			x.CoinTransfers = []*CoinTransfer{}
		}
		value := &_IncomingApprovalCriteria_7_list{list: &x.CoinTransfers}
		return protoreflect.ValueOfList(value)
	case "badges.IncomingApprovalCriteria.requireFromEqualsInitiatedBy":
		panic(fmt.Errorf("field requireFromEqualsInitiatedBy of message badges.IncomingApprovalCriteria is not mutable"))
	case "badges.IncomingApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		panic(fmt.Errorf("field requireFromDoesNotEqualInitiatedBy of message badges.IncomingApprovalCriteria is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncomingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.IncomingApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_IncomingApprovalCriteria) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.IncomingApprovalCriteria.mustOwnBadges":
		list := []*MustOwnBadges{}
		return protoreflect.ValueOfList(&_IncomingApprovalCriteria_1_list{list: &list})
	case "badges.IncomingApprovalCriteria.merkleChallenges":
		list := []*MerkleChallenge{}
		return protoreflect.ValueOfList(&_IncomingApprovalCriteria_2_list{list: &list})
	case "badges.IncomingApprovalCriteria.predeterminedBalances":
		m := new(PredeterminedBalances)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "badges.IncomingApprovalCriteria.approvalAmounts":
		m := new(ApprovalAmounts)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "badges.IncomingApprovalCriteria.maxNumTransfers":
		m := new(MaxNumTransfers)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "badges.IncomingApprovalCriteria.zkProofs":
		list := []*ZkProof{}
		return protoreflect.ValueOfList(&_IncomingApprovalCriteria_6_list{list: &list})
	case "badges.IncomingApprovalCriteria.coinTransfers":
		list := []*CoinTransfer{}
		return protoreflect.ValueOfList(&_IncomingApprovalCriteria_7_list{list: &list})
	case "badges.IncomingApprovalCriteria.requireFromEqualsInitiatedBy":
		return protoreflect.ValueOfBool(false)
	case "badges.IncomingApprovalCriteria.requireFromDoesNotEqualInitiatedBy":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.IncomingApprovalCriteria"))
		}
		panic(fmt.Errorf("message badges.IncomingApprovalCriteria does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_IncomingApprovalCriteria) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.IncomingApprovalCriteria", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_IncomingApprovalCriteria) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_IncomingApprovalCriteria) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_IncomingApprovalCriteria) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_IncomingApprovalCriteria) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*IncomingApprovalCriteria)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.MustOwnBadges) > 0 {
			for _, e := range x.MustOwnBadges {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.MerkleChallenges) > 0 {
			for _, e := range x.MerkleChallenges {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.PredeterminedBalances != nil {
			l = options.Size(x.PredeterminedBalances)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ApprovalAmounts != nil {
			l = options.Size(x.ApprovalAmounts)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.MaxNumTransfers != nil {
			l = options.Size(x.MaxNumTransfers)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.ZkProofs) > 0 {
			for _, e := range x.ZkProofs {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.CoinTransfers) > 0 {
			for _, e := range x.CoinTransfers {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.RequireFromEqualsInitiatedBy {
			n += 2
		}
		if x.RequireFromDoesNotEqualInitiatedBy {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*IncomingApprovalCriteria)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.RequireFromDoesNotEqualInitiatedBy {
			i--
			if x.RequireFromDoesNotEqualInitiatedBy {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x60
		}
		if x.RequireFromEqualsInitiatedBy {
			i--
			if x.RequireFromEqualsInitiatedBy {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x50
		}
		if len(x.CoinTransfers) > 0 {
			for iNdEx := len(x.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.CoinTransfers[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x3a
			}
		}
		if len(x.ZkProofs) > 0 {
			for iNdEx := len(x.ZkProofs) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.ZkProofs[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x32
			}
		}
		if x.MaxNumTransfers != nil {
			encoded, err := options.Marshal(x.MaxNumTransfers)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if x.ApprovalAmounts != nil {
			encoded, err := options.Marshal(x.ApprovalAmounts)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if x.PredeterminedBalances != nil {
			encoded, err := options.Marshal(x.PredeterminedBalances)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.MerkleChallenges) > 0 {
			for iNdEx := len(x.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.MerkleChallenges[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.MustOwnBadges) > 0 {
			for iNdEx := len(x.MustOwnBadges) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.MustOwnBadges[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*IncomingApprovalCriteria)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: IncomingApprovalCriteria: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: IncomingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MustOwnBadges", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MustOwnBadges = append(x.MustOwnBadges, &MustOwnBadges{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MustOwnBadges[len(x.MustOwnBadges)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MerkleChallenges = append(x.MerkleChallenges, &MerkleChallenge{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MerkleChallenges[len(x.MerkleChallenges)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.PredeterminedBalances == nil {
					x.PredeterminedBalances = &PredeterminedBalances{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.PredeterminedBalances); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ApprovalAmounts == nil {
					x.ApprovalAmounts = &ApprovalAmounts{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ApprovalAmounts); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.MaxNumTransfers == nil {
					x.MaxNumTransfers = &MaxNumTransfers{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MaxNumTransfers); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ZkProofs", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ZkProofs = append(x.ZkProofs, &ZkProof{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ZkProofs[len(x.ZkProofs)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CoinTransfers = append(x.CoinTransfers, &CoinTransfer{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CoinTransfers[len(x.CoinTransfers)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.RequireFromEqualsInitiatedBy = bool(v != 0)
			case 12:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_CollectionApproval_4_list)(nil)

type _CollectionApproval_4_list struct {
	list *[]*UintRange
}

func (x *_CollectionApproval_4_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_CollectionApproval_4_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_CollectionApproval_4_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	(*x.list)[i] = concreteValue
}

func (x *_CollectionApproval_4_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	*x.list = append(*x.list, concreteValue)
}

func (x *_CollectionApproval_4_list) AppendMutable() protoreflect.Value {
	v := new(UintRange)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CollectionApproval_4_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_CollectionApproval_4_list) NewElement() protoreflect.Value {
	v := new(UintRange)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CollectionApproval_4_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_CollectionApproval_5_list)(nil)

type _CollectionApproval_5_list struct {
	list *[]*UintRange
}

func (x *_CollectionApproval_5_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_CollectionApproval_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_CollectionApproval_5_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	(*x.list)[i] = concreteValue
}

func (x *_CollectionApproval_5_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	*x.list = append(*x.list, concreteValue)
}

func (x *_CollectionApproval_5_list) AppendMutable() protoreflect.Value {
	v := new(UintRange)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CollectionApproval_5_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_CollectionApproval_5_list) NewElement() protoreflect.Value {
	v := new(UintRange)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CollectionApproval_5_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_CollectionApproval_6_list)(nil)

type _CollectionApproval_6_list struct {
	list *[]*UintRange
}

func (x *_CollectionApproval_6_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_CollectionApproval_6_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_CollectionApproval_6_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	(*x.list)[i] = concreteValue
}

func (x *_CollectionApproval_6_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*UintRange)
	*x.list = append(*x.list, concreteValue)
}

func (x *_CollectionApproval_6_list) AppendMutable() protoreflect.Value {
	v := new(UintRange)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CollectionApproval_6_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_CollectionApproval_6_list) NewElement() protoreflect.Value {
	v := new(UintRange)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_CollectionApproval_6_list) IsValid() bool {
	return x.list != nil
}

var (
	md_CollectionApproval                   protoreflect.MessageDescriptor
	fd_CollectionApproval_fromListId        protoreflect.FieldDescriptor
	fd_CollectionApproval_toListId          protoreflect.FieldDescriptor
	fd_CollectionApproval_initiatedByListId protoreflect.FieldDescriptor
	fd_CollectionApproval_transferTimes     protoreflect.FieldDescriptor
	fd_CollectionApproval_badgeIds          protoreflect.FieldDescriptor
	fd_CollectionApproval_ownershipTimes    protoreflect.FieldDescriptor
	fd_CollectionApproval_uri               protoreflect.FieldDescriptor
	fd_CollectionApproval_customData        protoreflect.FieldDescriptor
	fd_CollectionApproval_approvalId        protoreflect.FieldDescriptor
	fd_CollectionApproval_approvalCriteria  protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_CollectionApproval = File_badges_transfers_proto.Messages().ByName("CollectionApproval")
	fd_CollectionApproval_fromListId = md_CollectionApproval.Fields().ByName("fromListId")
	fd_CollectionApproval_toListId = md_CollectionApproval.Fields().ByName("toListId")
	fd_CollectionApproval_initiatedByListId = md_CollectionApproval.Fields().ByName("initiatedByListId")
	fd_CollectionApproval_transferTimes = md_CollectionApproval.Fields().ByName("transferTimes")
	fd_CollectionApproval_badgeIds = md_CollectionApproval.Fields().ByName("badgeIds")
	fd_CollectionApproval_ownershipTimes = md_CollectionApproval.Fields().ByName("ownershipTimes")
	fd_CollectionApproval_uri = md_CollectionApproval.Fields().ByName("uri")
	fd_CollectionApproval_customData = md_CollectionApproval.Fields().ByName("customData")
	fd_CollectionApproval_approvalId = md_CollectionApproval.Fields().ByName("approvalId")
	fd_CollectionApproval_approvalCriteria = md_CollectionApproval.Fields().ByName("approvalCriteria")
}

var _ protoreflect.Message = (*fastReflection_CollectionApproval)(nil)

type fastReflection_CollectionApproval CollectionApproval

func (x *CollectionApproval) ProtoReflect() protoreflect.Message {
	return (*fastReflection_CollectionApproval)(x)
}

func (x *CollectionApproval) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_CollectionApproval_messageType fastReflection_CollectionApproval_messageType
var _ protoreflect.MessageType = fastReflection_CollectionApproval_messageType{}

type fastReflection_CollectionApproval_messageType struct{}

func (x fastReflection_CollectionApproval_messageType) Zero() protoreflect.Message {
	return (*fastReflection_CollectionApproval)(nil)
}
func (x fastReflection_CollectionApproval_messageType) New() protoreflect.Message {
	return new(fastReflection_CollectionApproval)
}
func (x fastReflection_CollectionApproval_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_CollectionApproval
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_CollectionApproval) Descriptor() protoreflect.MessageDescriptor {
	return md_CollectionApproval
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_CollectionApproval) Type() protoreflect.MessageType {
	return _fastReflection_CollectionApproval_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_CollectionApproval) New() protoreflect.Message {
	return new(fastReflection_CollectionApproval)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_CollectionApproval) Interface() protoreflect.ProtoMessage {
	return (*CollectionApproval)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_CollectionApproval) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.FromListId != "" {
		value := protoreflect.ValueOfString(x.FromListId)
		if !f(fd_CollectionApproval_fromListId, value) {
			return
		}
	}
	if x.ToListId != "" {
		value := protoreflect.ValueOfString(x.ToListId)
		if !f(fd_CollectionApproval_toListId, value) {
			return
		}
	}
	if x.InitiatedByListId != "" {
		value := protoreflect.ValueOfString(x.InitiatedByListId)
		if !f(fd_CollectionApproval_initiatedByListId, value) {
			return
		}
	}
	if len(x.TransferTimes) != 0 {
		value := protoreflect.ValueOfList(&_CollectionApproval_4_list{list: &x.TransferTimes})
		if !f(fd_CollectionApproval_transferTimes, value) {
			return
		}
	}
	if len(x.BadgeIds) != 0 {
		value := protoreflect.ValueOfList(&_CollectionApproval_5_list{list: &x.BadgeIds})
		if !f(fd_CollectionApproval_badgeIds, value) {
			return
		}
	}
	if len(x.OwnershipTimes) != 0 {
		value := protoreflect.ValueOfList(&_CollectionApproval_6_list{list: &x.OwnershipTimes})
		if !f(fd_CollectionApproval_ownershipTimes, value) {
			return
		}
	}
	if x.Uri != "" {
		value := protoreflect.ValueOfString(x.Uri)
		if !f(fd_CollectionApproval_uri, value) {
			return
		}
	}
	if x.CustomData != "" {
		value := protoreflect.ValueOfString(x.CustomData)
		if !f(fd_CollectionApproval_customData, value) {
			return
		}
	}
	if x.ApprovalId != "" {
		value := protoreflect.ValueOfString(x.ApprovalId)
		if !f(fd_CollectionApproval_approvalId, value) {
			return
		}
	}
	if x.ApprovalCriteria != nil {
		value := protoreflect.ValueOfMessage(x.ApprovalCriteria.ProtoReflect())
		if !f(fd_CollectionApproval_approvalCriteria, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_CollectionApproval) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.CollectionApproval.fromListId":
		return x.FromListId != ""
	case "badges.CollectionApproval.toListId":
		return x.ToListId != ""
	case "badges.CollectionApproval.initiatedByListId":
		return x.InitiatedByListId != ""
	case "badges.CollectionApproval.transferTimes":
		return len(x.TransferTimes) != 0
	case "badges.CollectionApproval.badgeIds":
		return len(x.BadgeIds) != 0
	case "badges.CollectionApproval.ownershipTimes":
		return len(x.OwnershipTimes) != 0
	case "badges.CollectionApproval.uri":
		return x.Uri != ""
	case "badges.CollectionApproval.customData":
		return x.CustomData != ""
	case "badges.CollectionApproval.approvalId":
		return x.ApprovalId != ""
	case "badges.CollectionApproval.approvalCriteria":
		return x.ApprovalCriteria != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CollectionApproval"))
		}
		panic(fmt.Errorf("message badges.CollectionApproval does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CollectionApproval) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.CollectionApproval.fromListId":
		x.FromListId = ""
	case "badges.CollectionApproval.toListId":
		x.ToListId = ""
	case "badges.CollectionApproval.initiatedByListId":
		x.InitiatedByListId = ""
	case "badges.CollectionApproval.transferTimes":
		x.TransferTimes = nil
	case "badges.CollectionApproval.badgeIds":
		x.BadgeIds = nil
	case "badges.CollectionApproval.ownershipTimes":
		x.OwnershipTimes = nil
	case "badges.CollectionApproval.uri":
		x.Uri = ""
	case "badges.CollectionApproval.customData":
		x.CustomData = ""
	case "badges.CollectionApproval.approvalId":
		x.ApprovalId = ""
	case "badges.CollectionApproval.approvalCriteria":
		x.ApprovalCriteria = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CollectionApproval"))
		}
		panic(fmt.Errorf("message badges.CollectionApproval does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_CollectionApproval) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.CollectionApproval.fromListId":
		value := x.FromListId
		return protoreflect.ValueOfString(value)
	case "badges.CollectionApproval.toListId":
		value := x.ToListId
		return protoreflect.ValueOfString(value)
	case "badges.CollectionApproval.initiatedByListId":
		value := x.InitiatedByListId
		return protoreflect.ValueOfString(value)
	case "badges.CollectionApproval.transferTimes":
		if len(x.TransferTimes) == 0 {
			return protoreflect.ValueOfList(&_CollectionApproval_4_list{})
		}
		listValue := &_CollectionApproval_4_list{list: &x.TransferTimes}
		return protoreflect.ValueOfList(listValue)
	case "badges.CollectionApproval.badgeIds":
		if len(x.BadgeIds) == 0 {
			return protoreflect.ValueOfList(&_CollectionApproval_5_list{})
		}
		listValue := &_CollectionApproval_5_list{list: &x.BadgeIds}
		return protoreflect.ValueOfList(listValue)
	case "badges.CollectionApproval.ownershipTimes":
		if len(x.OwnershipTimes) == 0 {
			return protoreflect.ValueOfList(&_CollectionApproval_6_list{})
		}
		listValue := &_CollectionApproval_6_list{list: &x.OwnershipTimes}
		return protoreflect.ValueOfList(listValue)
	case "badges.CollectionApproval.uri":
		value := x.Uri
		return protoreflect.ValueOfString(value)
	case "badges.CollectionApproval.customData":
		value := x.CustomData
		return protoreflect.ValueOfString(value)
	case "badges.CollectionApproval.approvalId":
		value := x.ApprovalId
		return protoreflect.ValueOfString(value)
	case "badges.CollectionApproval.approvalCriteria":
		value := x.ApprovalCriteria
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CollectionApproval"))
		}
		panic(fmt.Errorf("message badges.CollectionApproval does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CollectionApproval) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.CollectionApproval.fromListId":
		x.FromListId = value.Interface().(string)
	case "badges.CollectionApproval.toListId":
		x.ToListId = value.Interface().(string)
	case "badges.CollectionApproval.initiatedByListId":
		x.InitiatedByListId = value.Interface().(string)
	case "badges.CollectionApproval.transferTimes":
		lv := value.List()
		clv := lv.(*_CollectionApproval_4_list)
		x.TransferTimes = *clv.list
	case "badges.CollectionApproval.badgeIds":
		lv := value.List()
		clv := lv.(*_CollectionApproval_5_list)
		x.BadgeIds = *clv.list
	case "badges.CollectionApproval.ownershipTimes":
		lv := value.List()
		clv := lv.(*_CollectionApproval_6_list)
		x.OwnershipTimes = *clv.list
	case "badges.CollectionApproval.uri":
		x.Uri = value.Interface().(string)
	case "badges.CollectionApproval.customData":
		x.CustomData = value.Interface().(string)
	case "badges.CollectionApproval.approvalId":
		x.ApprovalId = value.Interface().(string)
	case "badges.CollectionApproval.approvalCriteria":
		x.ApprovalCriteria = value.Message().Interface().(*ApprovalCriteria)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CollectionApproval"))
		}
		panic(fmt.Errorf("message badges.CollectionApproval does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CollectionApproval) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.CollectionApproval.transferTimes":
		if x.TransferTimes == nil {
			x.TransferTimes = []*UintRange{}
		}
		value := &_CollectionApproval_4_list{list: &x.TransferTimes}
		return protoreflect.ValueOfList(value)
	case "badges.CollectionApproval.badgeIds":
		if x.BadgeIds == nil {
			x.BadgeIds = []*UintRange{}
		}
		value := &_CollectionApproval_5_list{list: &x.BadgeIds}
		return protoreflect.ValueOfList(value)
	case "badges.CollectionApproval.ownershipTimes":
		if x.OwnershipTimes == nil {
			x.OwnershipTimes = []*UintRange{}
		}
		value := &_CollectionApproval_6_list{list: &x.OwnershipTimes}
		return protoreflect.ValueOfList(value)
	case "badges.CollectionApproval.approvalCriteria":
		if x.ApprovalCriteria == nil {
			x.ApprovalCriteria = new(ApprovalCriteria)
		}
		return protoreflect.ValueOfMessage(x.ApprovalCriteria.ProtoReflect())
	case "badges.CollectionApproval.fromListId":
		panic(fmt.Errorf("field fromListId of message badges.CollectionApproval is not mutable"))
	case "badges.CollectionApproval.toListId":
		panic(fmt.Errorf("field toListId of message badges.CollectionApproval is not mutable"))
	case "badges.CollectionApproval.initiatedByListId":
		panic(fmt.Errorf("field initiatedByListId of message badges.CollectionApproval is not mutable"))
	case "badges.CollectionApproval.uri":
		panic(fmt.Errorf("field uri of message badges.CollectionApproval is not mutable"))
	case "badges.CollectionApproval.customData":
		panic(fmt.Errorf("field customData of message badges.CollectionApproval is not mutable"))
	case "badges.CollectionApproval.approvalId":
		panic(fmt.Errorf("field approvalId of message badges.CollectionApproval is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CollectionApproval"))
		}
		panic(fmt.Errorf("message badges.CollectionApproval does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_CollectionApproval) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.CollectionApproval.fromListId":
		return protoreflect.ValueOfString("")
	case "badges.CollectionApproval.toListId":
		return protoreflect.ValueOfString("")
	case "badges.CollectionApproval.initiatedByListId":
		return protoreflect.ValueOfString("")
	case "badges.CollectionApproval.transferTimes":
		list := []*UintRange{}
		return protoreflect.ValueOfList(&_CollectionApproval_4_list{list: &list})
	case "badges.CollectionApproval.badgeIds":
		list := []*UintRange{}
		return protoreflect.ValueOfList(&_CollectionApproval_5_list{list: &list})
	case "badges.CollectionApproval.ownershipTimes":
		list := []*UintRange{}
		return protoreflect.ValueOfList(&_CollectionApproval_6_list{list: &list})
	case "badges.CollectionApproval.uri":
		return protoreflect.ValueOfString("")
	case "badges.CollectionApproval.customData":
		return protoreflect.ValueOfString("")
	case "badges.CollectionApproval.approvalId":
		return protoreflect.ValueOfString("")
	case "badges.CollectionApproval.approvalCriteria":
		m := new(ApprovalCriteria)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.CollectionApproval"))
		}
		panic(fmt.Errorf("message badges.CollectionApproval does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_CollectionApproval) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.CollectionApproval", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_CollectionApproval) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_CollectionApproval) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_CollectionApproval) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_CollectionApproval) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*CollectionApproval)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.FromListId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ToListId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.InitiatedByListId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.TransferTimes) > 0 {
			for _, e := range x.TransferTimes {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.BadgeIds) > 0 {
			for _, e := range x.BadgeIds {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.OwnershipTimes) > 0 {
			for _, e := range x.OwnershipTimes {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.Uri)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CustomData)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ApprovalId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ApprovalCriteria != nil {
			l = options.Size(x.ApprovalCriteria)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*CollectionApproval)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ApprovalCriteria != nil {
			encoded, err := options.Marshal(x.ApprovalCriteria)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x62
		}
		if len(x.ApprovalId) > 0 {
			i -= len(x.ApprovalId)
			copy(dAtA[i:], x.ApprovalId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ApprovalId)))
			i--
			dAtA[i] = 0x5a
		}
		if len(x.CustomData) > 0 {
			i -= len(x.CustomData)
			copy(dAtA[i:], x.CustomData)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CustomData)))
			i--
			dAtA[i] = 0x52
		}
		if len(x.Uri) > 0 {
			i -= len(x.Uri)
			copy(dAtA[i:], x.Uri)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Uri)))
			i--
			dAtA[i] = 0x4a
		}
		if len(x.OwnershipTimes) > 0 {
			for iNdEx := len(x.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.OwnershipTimes[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x32
			}
		}
		if len(x.BadgeIds) > 0 {
			for iNdEx := len(x.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.BadgeIds[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x2a
			}
		}
		if len(x.TransferTimes) > 0 {
			for iNdEx := len(x.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.TransferTimes[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x22
			}
		}
		if len(x.InitiatedByListId) > 0 {
			i -= len(x.InitiatedByListId)
			copy(dAtA[i:], x.InitiatedByListId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.InitiatedByListId)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.ToListId) > 0 {
			i -= len(x.ToListId)
			copy(dAtA[i:], x.ToListId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ToListId)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.FromListId) > 0 {
			i -= len(x.FromListId)
			copy(dAtA[i:], x.FromListId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FromListId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*CollectionApproval)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CollectionApproval: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: CollectionApproval: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FromListId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FromListId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ToListId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ToListId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.InitiatedByListId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TransferTimes = append(x.TransferTimes, &UintRange{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.TransferTimes[len(x.TransferTimes)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BadgeIds = append(x.BadgeIds, &UintRange{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.BadgeIds[len(x.BadgeIds)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OwnershipTimes = append(x.OwnershipTimes, &UintRange{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.OwnershipTimes[len(x.OwnershipTimes)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Uri = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CustomData = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ApprovalId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ApprovalCriteria == nil {
					x.ApprovalCriteria = &ApprovalCriteria{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ApprovalCriteria); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_ApprovalIdentifierDetails                 protoreflect.MessageDescriptor
	fd_ApprovalIdentifierDetails_approvalId      protoreflect.FieldDescriptor
	fd_ApprovalIdentifierDetails_approvalLevel   protoreflect.FieldDescriptor
	fd_ApprovalIdentifierDetails_approverAddress protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_ApprovalIdentifierDetails = File_badges_transfers_proto.Messages().ByName("ApprovalIdentifierDetails")
	fd_ApprovalIdentifierDetails_approvalId = md_ApprovalIdentifierDetails.Fields().ByName("approvalId")
	fd_ApprovalIdentifierDetails_approvalLevel = md_ApprovalIdentifierDetails.Fields().ByName("approvalLevel")
	fd_ApprovalIdentifierDetails_approverAddress = md_ApprovalIdentifierDetails.Fields().ByName("approverAddress")
}

var _ protoreflect.Message = (*fastReflection_ApprovalIdentifierDetails)(nil)

type fastReflection_ApprovalIdentifierDetails ApprovalIdentifierDetails

func (x *ApprovalIdentifierDetails) ProtoReflect() protoreflect.Message {
	return (*fastReflection_ApprovalIdentifierDetails)(x)
}

func (x *ApprovalIdentifierDetails) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_ApprovalIdentifierDetails_messageType fastReflection_ApprovalIdentifierDetails_messageType
var _ protoreflect.MessageType = fastReflection_ApprovalIdentifierDetails_messageType{}

type fastReflection_ApprovalIdentifierDetails_messageType struct{}

func (x fastReflection_ApprovalIdentifierDetails_messageType) Zero() protoreflect.Message {
	return (*fastReflection_ApprovalIdentifierDetails)(nil)
}
func (x fastReflection_ApprovalIdentifierDetails_messageType) New() protoreflect.Message {
	return new(fastReflection_ApprovalIdentifierDetails)
}
func (x fastReflection_ApprovalIdentifierDetails_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_ApprovalIdentifierDetails
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_ApprovalIdentifierDetails) Descriptor() protoreflect.MessageDescriptor {
	return md_ApprovalIdentifierDetails
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_ApprovalIdentifierDetails) Type() protoreflect.MessageType {
	return _fastReflection_ApprovalIdentifierDetails_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_ApprovalIdentifierDetails) New() protoreflect.Message {
	return new(fastReflection_ApprovalIdentifierDetails)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_ApprovalIdentifierDetails) Interface() protoreflect.ProtoMessage {
	return (*ApprovalIdentifierDetails)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_ApprovalIdentifierDetails) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.ApprovalId != "" {
		value := protoreflect.ValueOfString(x.ApprovalId)
		if !f(fd_ApprovalIdentifierDetails_approvalId, value) {
			return
		}
	}
	if x.ApprovalLevel != "" {
		value := protoreflect.ValueOfString(x.ApprovalLevel)
		if !f(fd_ApprovalIdentifierDetails_approvalLevel, value) {
			return
		}
	}
	if x.ApproverAddress != "" {
		value := protoreflect.ValueOfString(x.ApproverAddress)
		if !f(fd_ApprovalIdentifierDetails_approverAddress, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_ApprovalIdentifierDetails) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.ApprovalIdentifierDetails.approvalId":
		return x.ApprovalId != ""
	case "badges.ApprovalIdentifierDetails.approvalLevel":
		return x.ApprovalLevel != ""
	case "badges.ApprovalIdentifierDetails.approverAddress":
		return x.ApproverAddress != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalIdentifierDetails"))
		}
		panic(fmt.Errorf("message badges.ApprovalIdentifierDetails does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalIdentifierDetails) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.ApprovalIdentifierDetails.approvalId":
		x.ApprovalId = ""
	case "badges.ApprovalIdentifierDetails.approvalLevel":
		x.ApprovalLevel = ""
	case "badges.ApprovalIdentifierDetails.approverAddress":
		x.ApproverAddress = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalIdentifierDetails"))
		}
		panic(fmt.Errorf("message badges.ApprovalIdentifierDetails does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_ApprovalIdentifierDetails) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.ApprovalIdentifierDetails.approvalId":
		value := x.ApprovalId
		return protoreflect.ValueOfString(value)
	case "badges.ApprovalIdentifierDetails.approvalLevel":
		value := x.ApprovalLevel
		return protoreflect.ValueOfString(value)
	case "badges.ApprovalIdentifierDetails.approverAddress":
		value := x.ApproverAddress
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalIdentifierDetails"))
		}
		panic(fmt.Errorf("message badges.ApprovalIdentifierDetails does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalIdentifierDetails) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.ApprovalIdentifierDetails.approvalId":
		x.ApprovalId = value.Interface().(string)
	case "badges.ApprovalIdentifierDetails.approvalLevel":
		x.ApprovalLevel = value.Interface().(string)
	case "badges.ApprovalIdentifierDetails.approverAddress":
		x.ApproverAddress = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalIdentifierDetails"))
		}
		panic(fmt.Errorf("message badges.ApprovalIdentifierDetails does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalIdentifierDetails) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ApprovalIdentifierDetails.approvalId":
		panic(fmt.Errorf("field approvalId of message badges.ApprovalIdentifierDetails is not mutable"))
	case "badges.ApprovalIdentifierDetails.approvalLevel":
		panic(fmt.Errorf("field approvalLevel of message badges.ApprovalIdentifierDetails is not mutable"))
	case "badges.ApprovalIdentifierDetails.approverAddress":
		panic(fmt.Errorf("field approverAddress of message badges.ApprovalIdentifierDetails is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalIdentifierDetails"))
		}
		panic(fmt.Errorf("message badges.ApprovalIdentifierDetails does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_ApprovalIdentifierDetails) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.ApprovalIdentifierDetails.approvalId":
		return protoreflect.ValueOfString("")
	case "badges.ApprovalIdentifierDetails.approvalLevel":
		return protoreflect.ValueOfString("")
	case "badges.ApprovalIdentifierDetails.approverAddress":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.ApprovalIdentifierDetails"))
		}
		panic(fmt.Errorf("message badges.ApprovalIdentifierDetails does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_ApprovalIdentifierDetails) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.ApprovalIdentifierDetails", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_ApprovalIdentifierDetails) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_ApprovalIdentifierDetails) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_ApprovalIdentifierDetails) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_ApprovalIdentifierDetails) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*ApprovalIdentifierDetails)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.ApprovalId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ApprovalLevel)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ApproverAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*ApprovalIdentifierDetails)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ApproverAddress) > 0 {
			i -= len(x.ApproverAddress)
			copy(dAtA[i:], x.ApproverAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ApproverAddress)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.ApprovalLevel) > 0 {
			i -= len(x.ApprovalLevel)
			copy(dAtA[i:], x.ApprovalLevel)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ApprovalLevel)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.ApprovalId) > 0 {
			i -= len(x.ApprovalId)
			copy(dAtA[i:], x.ApprovalId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ApprovalId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*ApprovalIdentifierDetails)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ApprovalIdentifierDetails: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: ApprovalIdentifierDetails: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ApprovalId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApprovalLevel", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ApprovalLevel = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ApproverAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ApproverAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_Transfer_2_list)(nil)

type _Transfer_2_list struct {
	list *[]string
}

func (x *_Transfer_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Transfer_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_Transfer_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_Transfer_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_Transfer_2_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message Transfer at list field ToAddresses as it is not of Message kind"))
}

func (x *_Transfer_2_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_Transfer_2_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_Transfer_2_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_Transfer_3_list)(nil)

type _Transfer_3_list struct {
	list *[]*Balance
}

func (x *_Transfer_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Transfer_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_Transfer_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Balance)
	(*x.list)[i] = concreteValue
}

func (x *_Transfer_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*Balance)
	*x.list = append(*x.list, concreteValue)
}

func (x *_Transfer_3_list) AppendMutable() protoreflect.Value {
	v := new(Balance)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Transfer_3_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_Transfer_3_list) NewElement() protoreflect.Value {
	v := new(Balance)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Transfer_3_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_Transfer_5_list)(nil)

type _Transfer_5_list struct {
	list *[]*MerkleProof
}

func (x *_Transfer_5_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Transfer_5_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_Transfer_5_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MerkleProof)
	(*x.list)[i] = concreteValue
}

func (x *_Transfer_5_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MerkleProof)
	*x.list = append(*x.list, concreteValue)
}

func (x *_Transfer_5_list) AppendMutable() protoreflect.Value {
	v := new(MerkleProof)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Transfer_5_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_Transfer_5_list) NewElement() protoreflect.Value {
	v := new(MerkleProof)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Transfer_5_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_Transfer_7_list)(nil)

type _Transfer_7_list struct {
	list *[]*ApprovalIdentifierDetails
}

func (x *_Transfer_7_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Transfer_7_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_Transfer_7_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ApprovalIdentifierDetails)
	(*x.list)[i] = concreteValue
}

func (x *_Transfer_7_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ApprovalIdentifierDetails)
	*x.list = append(*x.list, concreteValue)
}

func (x *_Transfer_7_list) AppendMutable() protoreflect.Value {
	v := new(ApprovalIdentifierDetails)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Transfer_7_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_Transfer_7_list) NewElement() protoreflect.Value {
	v := new(ApprovalIdentifierDetails)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Transfer_7_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_Transfer_11_list)(nil)

type _Transfer_11_list struct {
	list *[]*ZkProofSolution
}

func (x *_Transfer_11_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_Transfer_11_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_Transfer_11_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ZkProofSolution)
	(*x.list)[i] = concreteValue
}

func (x *_Transfer_11_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*ZkProofSolution)
	*x.list = append(*x.list, concreteValue)
}

func (x *_Transfer_11_list) AppendMutable() protoreflect.Value {
	v := new(ZkProofSolution)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Transfer_11_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_Transfer_11_list) NewElement() protoreflect.Value {
	v := new(ZkProofSolution)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_Transfer_11_list) IsValid() bool {
	return x.list != nil
}

var (
	md_Transfer                                         protoreflect.MessageDescriptor
	fd_Transfer_from                                    protoreflect.FieldDescriptor
	fd_Transfer_toAddresses                             protoreflect.FieldDescriptor
	fd_Transfer_balances                                protoreflect.FieldDescriptor
	fd_Transfer_precalculateBalancesFromApproval        protoreflect.FieldDescriptor
	fd_Transfer_merkleProofs                            protoreflect.FieldDescriptor
	fd_Transfer_memo                                    protoreflect.FieldDescriptor
	fd_Transfer_prioritizedApprovals                    protoreflect.FieldDescriptor
	fd_Transfer_onlyCheckPrioritizedCollectionApprovals protoreflect.FieldDescriptor
	fd_Transfer_onlyCheckPrioritizedIncomingApprovals   protoreflect.FieldDescriptor
	fd_Transfer_onlyCheckPrioritizedOutgoingApprovals   protoreflect.FieldDescriptor
	fd_Transfer_zkProofSolutions                        protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_Transfer = File_badges_transfers_proto.Messages().ByName("Transfer")
	fd_Transfer_from = md_Transfer.Fields().ByName("from")
	fd_Transfer_toAddresses = md_Transfer.Fields().ByName("toAddresses")
	fd_Transfer_balances = md_Transfer.Fields().ByName("balances")
	fd_Transfer_precalculateBalancesFromApproval = md_Transfer.Fields().ByName("precalculateBalancesFromApproval")
	fd_Transfer_merkleProofs = md_Transfer.Fields().ByName("merkleProofs")
	fd_Transfer_memo = md_Transfer.Fields().ByName("memo")
	fd_Transfer_prioritizedApprovals = md_Transfer.Fields().ByName("prioritizedApprovals")
	fd_Transfer_onlyCheckPrioritizedCollectionApprovals = md_Transfer.Fields().ByName("onlyCheckPrioritizedCollectionApprovals")
	fd_Transfer_onlyCheckPrioritizedIncomingApprovals = md_Transfer.Fields().ByName("onlyCheckPrioritizedIncomingApprovals")
	fd_Transfer_onlyCheckPrioritizedOutgoingApprovals = md_Transfer.Fields().ByName("onlyCheckPrioritizedOutgoingApprovals")
	fd_Transfer_zkProofSolutions = md_Transfer.Fields().ByName("zkProofSolutions")
}

var _ protoreflect.Message = (*fastReflection_Transfer)(nil)

type fastReflection_Transfer Transfer

func (x *Transfer) ProtoReflect() protoreflect.Message {
	return (*fastReflection_Transfer)(x)
}

func (x *Transfer) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_Transfer_messageType fastReflection_Transfer_messageType
var _ protoreflect.MessageType = fastReflection_Transfer_messageType{}

type fastReflection_Transfer_messageType struct{}

func (x fastReflection_Transfer_messageType) Zero() protoreflect.Message {
	return (*fastReflection_Transfer)(nil)
}
func (x fastReflection_Transfer_messageType) New() protoreflect.Message {
	return new(fastReflection_Transfer)
}
func (x fastReflection_Transfer_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_Transfer
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_Transfer) Descriptor() protoreflect.MessageDescriptor {
	return md_Transfer
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_Transfer) Type() protoreflect.MessageType {
	return _fastReflection_Transfer_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_Transfer) New() protoreflect.Message {
	return new(fastReflection_Transfer)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_Transfer) Interface() protoreflect.ProtoMessage {
	return (*Transfer)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_Transfer) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.From != "" {
		value := protoreflect.ValueOfString(x.From)
		if !f(fd_Transfer_from, value) {
			return
		}
	}
	if len(x.ToAddresses) != 0 {
		value := protoreflect.ValueOfList(&_Transfer_2_list{list: &x.ToAddresses})
		if !f(fd_Transfer_toAddresses, value) {
			return
		}
	}
	if len(x.Balances) != 0 {
		value := protoreflect.ValueOfList(&_Transfer_3_list{list: &x.Balances})
		if !f(fd_Transfer_balances, value) {
			return
		}
	}
	if x.PrecalculateBalancesFromApproval != nil {
		value := protoreflect.ValueOfMessage(x.PrecalculateBalancesFromApproval.ProtoReflect())
		if !f(fd_Transfer_precalculateBalancesFromApproval, value) {
			return
		}
	}
	if len(x.MerkleProofs) != 0 {
		value := protoreflect.ValueOfList(&_Transfer_5_list{list: &x.MerkleProofs})
		if !f(fd_Transfer_merkleProofs, value) {
			return
		}
	}
	if x.Memo != "" {
		value := protoreflect.ValueOfString(x.Memo)
		if !f(fd_Transfer_memo, value) {
			return
		}
	}
	if len(x.PrioritizedApprovals) != 0 {
		value := protoreflect.ValueOfList(&_Transfer_7_list{list: &x.PrioritizedApprovals})
		if !f(fd_Transfer_prioritizedApprovals, value) {
			return
		}
	}
	if x.OnlyCheckPrioritizedCollectionApprovals != false {
		value := protoreflect.ValueOfBool(x.OnlyCheckPrioritizedCollectionApprovals)
		if !f(fd_Transfer_onlyCheckPrioritizedCollectionApprovals, value) {
			return
		}
	}
	if x.OnlyCheckPrioritizedIncomingApprovals != false {
		value := protoreflect.ValueOfBool(x.OnlyCheckPrioritizedIncomingApprovals)
		if !f(fd_Transfer_onlyCheckPrioritizedIncomingApprovals, value) {
			return
		}
	}
	if x.OnlyCheckPrioritizedOutgoingApprovals != false {
		value := protoreflect.ValueOfBool(x.OnlyCheckPrioritizedOutgoingApprovals)
		if !f(fd_Transfer_onlyCheckPrioritizedOutgoingApprovals, value) {
			return
		}
	}
	if len(x.ZkProofSolutions) != 0 {
		value := protoreflect.ValueOfList(&_Transfer_11_list{list: &x.ZkProofSolutions})
		if !f(fd_Transfer_zkProofSolutions, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_Transfer) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.Transfer.from":
		return x.From != ""
	case "badges.Transfer.toAddresses":
		return len(x.ToAddresses) != 0
	case "badges.Transfer.balances":
		return len(x.Balances) != 0
	case "badges.Transfer.precalculateBalancesFromApproval":
		return x.PrecalculateBalancesFromApproval != nil
	case "badges.Transfer.merkleProofs":
		return len(x.MerkleProofs) != 0
	case "badges.Transfer.memo":
		return x.Memo != ""
	case "badges.Transfer.prioritizedApprovals":
		return len(x.PrioritizedApprovals) != 0
	case "badges.Transfer.onlyCheckPrioritizedCollectionApprovals":
		return x.OnlyCheckPrioritizedCollectionApprovals != false
	case "badges.Transfer.onlyCheckPrioritizedIncomingApprovals":
		return x.OnlyCheckPrioritizedIncomingApprovals != false
	case "badges.Transfer.onlyCheckPrioritizedOutgoingApprovals":
		return x.OnlyCheckPrioritizedOutgoingApprovals != false
	case "badges.Transfer.zkProofSolutions":
		return len(x.ZkProofSolutions) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.Transfer"))
		}
		panic(fmt.Errorf("message badges.Transfer does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Transfer) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.Transfer.from":
		x.From = ""
	case "badges.Transfer.toAddresses":
		x.ToAddresses = nil
	case "badges.Transfer.balances":
		x.Balances = nil
	case "badges.Transfer.precalculateBalancesFromApproval":
		x.PrecalculateBalancesFromApproval = nil
	case "badges.Transfer.merkleProofs":
		x.MerkleProofs = nil
	case "badges.Transfer.memo":
		x.Memo = ""
	case "badges.Transfer.prioritizedApprovals":
		x.PrioritizedApprovals = nil
	case "badges.Transfer.onlyCheckPrioritizedCollectionApprovals":
		x.OnlyCheckPrioritizedCollectionApprovals = false
	case "badges.Transfer.onlyCheckPrioritizedIncomingApprovals":
		x.OnlyCheckPrioritizedIncomingApprovals = false
	case "badges.Transfer.onlyCheckPrioritizedOutgoingApprovals":
		x.OnlyCheckPrioritizedOutgoingApprovals = false
	case "badges.Transfer.zkProofSolutions":
		x.ZkProofSolutions = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.Transfer"))
		}
		panic(fmt.Errorf("message badges.Transfer does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_Transfer) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.Transfer.from":
		value := x.From
		return protoreflect.ValueOfString(value)
	case "badges.Transfer.toAddresses":
		if len(x.ToAddresses) == 0 {
			return protoreflect.ValueOfList(&_Transfer_2_list{})
		}
		listValue := &_Transfer_2_list{list: &x.ToAddresses}
		return protoreflect.ValueOfList(listValue)
	case "badges.Transfer.balances":
		if len(x.Balances) == 0 {
			return protoreflect.ValueOfList(&_Transfer_3_list{})
		}
		listValue := &_Transfer_3_list{list: &x.Balances}
		return protoreflect.ValueOfList(listValue)
	case "badges.Transfer.precalculateBalancesFromApproval":
		value := x.PrecalculateBalancesFromApproval
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "badges.Transfer.merkleProofs":
		if len(x.MerkleProofs) == 0 {
			return protoreflect.ValueOfList(&_Transfer_5_list{})
		}
		listValue := &_Transfer_5_list{list: &x.MerkleProofs}
		return protoreflect.ValueOfList(listValue)
	case "badges.Transfer.memo":
		value := x.Memo
		return protoreflect.ValueOfString(value)
	case "badges.Transfer.prioritizedApprovals":
		if len(x.PrioritizedApprovals) == 0 {
			return protoreflect.ValueOfList(&_Transfer_7_list{})
		}
		listValue := &_Transfer_7_list{list: &x.PrioritizedApprovals}
		return protoreflect.ValueOfList(listValue)
	case "badges.Transfer.onlyCheckPrioritizedCollectionApprovals":
		value := x.OnlyCheckPrioritizedCollectionApprovals
		return protoreflect.ValueOfBool(value)
	case "badges.Transfer.onlyCheckPrioritizedIncomingApprovals":
		value := x.OnlyCheckPrioritizedIncomingApprovals
		return protoreflect.ValueOfBool(value)
	case "badges.Transfer.onlyCheckPrioritizedOutgoingApprovals":
		value := x.OnlyCheckPrioritizedOutgoingApprovals
		return protoreflect.ValueOfBool(value)
	case "badges.Transfer.zkProofSolutions":
		if len(x.ZkProofSolutions) == 0 {
			return protoreflect.ValueOfList(&_Transfer_11_list{})
		}
		listValue := &_Transfer_11_list{list: &x.ZkProofSolutions}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.Transfer"))
		}
		panic(fmt.Errorf("message badges.Transfer does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Transfer) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.Transfer.from":
		x.From = value.Interface().(string)
	case "badges.Transfer.toAddresses":
		lv := value.List()
		clv := lv.(*_Transfer_2_list)
		x.ToAddresses = *clv.list
	case "badges.Transfer.balances":
		lv := value.List()
		clv := lv.(*_Transfer_3_list)
		x.Balances = *clv.list
	case "badges.Transfer.precalculateBalancesFromApproval":
		x.PrecalculateBalancesFromApproval = value.Message().Interface().(*ApprovalIdentifierDetails)
	case "badges.Transfer.merkleProofs":
		lv := value.List()
		clv := lv.(*_Transfer_5_list)
		x.MerkleProofs = *clv.list
	case "badges.Transfer.memo":
		x.Memo = value.Interface().(string)
	case "badges.Transfer.prioritizedApprovals":
		lv := value.List()
		clv := lv.(*_Transfer_7_list)
		x.PrioritizedApprovals = *clv.list
	case "badges.Transfer.onlyCheckPrioritizedCollectionApprovals":
		x.OnlyCheckPrioritizedCollectionApprovals = value.Bool()
	case "badges.Transfer.onlyCheckPrioritizedIncomingApprovals":
		x.OnlyCheckPrioritizedIncomingApprovals = value.Bool()
	case "badges.Transfer.onlyCheckPrioritizedOutgoingApprovals":
		x.OnlyCheckPrioritizedOutgoingApprovals = value.Bool()
	case "badges.Transfer.zkProofSolutions":
		lv := value.List()
		clv := lv.(*_Transfer_11_list)
		x.ZkProofSolutions = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.Transfer"))
		}
		panic(fmt.Errorf("message badges.Transfer does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Transfer) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.Transfer.toAddresses":
		if x.ToAddresses == nil {
			x.ToAddresses = []string{}
		}
		value := &_Transfer_2_list{list: &x.ToAddresses}
		return protoreflect.ValueOfList(value)
	case "badges.Transfer.balances":
		if x.Balances == nil {
			x.Balances = []*Balance{}
		}
		value := &_Transfer_3_list{list: &x.Balances}
		return protoreflect.ValueOfList(value)
	case "badges.Transfer.precalculateBalancesFromApproval":
		if x.PrecalculateBalancesFromApproval == nil {
			x.PrecalculateBalancesFromApproval = new(ApprovalIdentifierDetails)
		}
		return protoreflect.ValueOfMessage(x.PrecalculateBalancesFromApproval.ProtoReflect())
	case "badges.Transfer.merkleProofs":
		if x.MerkleProofs == nil {
			x.MerkleProofs = []*MerkleProof{}
		}
		value := &_Transfer_5_list{list: &x.MerkleProofs}
		return protoreflect.ValueOfList(value)
	case "badges.Transfer.prioritizedApprovals":
		if x.PrioritizedApprovals == nil {
			x.PrioritizedApprovals = []*ApprovalIdentifierDetails{}
		}
		value := &_Transfer_7_list{list: &x.PrioritizedApprovals}
		return protoreflect.ValueOfList(value)
	case "badges.Transfer.zkProofSolutions":
		if x.ZkProofSolutions == nil {
			x.ZkProofSolutions = []*ZkProofSolution{}
		}
		value := &_Transfer_11_list{list: &x.ZkProofSolutions}
		return protoreflect.ValueOfList(value)
	case "badges.Transfer.from":
		panic(fmt.Errorf("field from of message badges.Transfer is not mutable"))
	case "badges.Transfer.memo":
		panic(fmt.Errorf("field memo of message badges.Transfer is not mutable"))
	case "badges.Transfer.onlyCheckPrioritizedCollectionApprovals":
		panic(fmt.Errorf("field onlyCheckPrioritizedCollectionApprovals of message badges.Transfer is not mutable"))
	case "badges.Transfer.onlyCheckPrioritizedIncomingApprovals":
		panic(fmt.Errorf("field onlyCheckPrioritizedIncomingApprovals of message badges.Transfer is not mutable"))
	case "badges.Transfer.onlyCheckPrioritizedOutgoingApprovals":
		panic(fmt.Errorf("field onlyCheckPrioritizedOutgoingApprovals of message badges.Transfer is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.Transfer"))
		}
		panic(fmt.Errorf("message badges.Transfer does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_Transfer) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.Transfer.from":
		return protoreflect.ValueOfString("")
	case "badges.Transfer.toAddresses":
		list := []string{}
		return protoreflect.ValueOfList(&_Transfer_2_list{list: &list})
	case "badges.Transfer.balances":
		list := []*Balance{}
		return protoreflect.ValueOfList(&_Transfer_3_list{list: &list})
	case "badges.Transfer.precalculateBalancesFromApproval":
		m := new(ApprovalIdentifierDetails)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "badges.Transfer.merkleProofs":
		list := []*MerkleProof{}
		return protoreflect.ValueOfList(&_Transfer_5_list{list: &list})
	case "badges.Transfer.memo":
		return protoreflect.ValueOfString("")
	case "badges.Transfer.prioritizedApprovals":
		list := []*ApprovalIdentifierDetails{}
		return protoreflect.ValueOfList(&_Transfer_7_list{list: &list})
	case "badges.Transfer.onlyCheckPrioritizedCollectionApprovals":
		return protoreflect.ValueOfBool(false)
	case "badges.Transfer.onlyCheckPrioritizedIncomingApprovals":
		return protoreflect.ValueOfBool(false)
	case "badges.Transfer.onlyCheckPrioritizedOutgoingApprovals":
		return protoreflect.ValueOfBool(false)
	case "badges.Transfer.zkProofSolutions":
		list := []*ZkProofSolution{}
		return protoreflect.ValueOfList(&_Transfer_11_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.Transfer"))
		}
		panic(fmt.Errorf("message badges.Transfer does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_Transfer) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.Transfer", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_Transfer) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_Transfer) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_Transfer) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_Transfer) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*Transfer)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.From)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.ToAddresses) > 0 {
			for _, s := range x.ToAddresses {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if len(x.Balances) > 0 {
			for _, e := range x.Balances {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.PrecalculateBalancesFromApproval != nil {
			l = options.Size(x.PrecalculateBalancesFromApproval)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.MerkleProofs) > 0 {
			for _, e := range x.MerkleProofs {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.Memo)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.PrioritizedApprovals) > 0 {
			for _, e := range x.PrioritizedApprovals {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.OnlyCheckPrioritizedCollectionApprovals {
			n += 2
		}
		if x.OnlyCheckPrioritizedIncomingApprovals {
			n += 2
		}
		if x.OnlyCheckPrioritizedOutgoingApprovals {
			n += 2
		}
		if len(x.ZkProofSolutions) > 0 {
			for _, e := range x.ZkProofSolutions {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*Transfer)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.ZkProofSolutions) > 0 {
			for iNdEx := len(x.ZkProofSolutions) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.ZkProofSolutions[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x5a
			}
		}
		if x.OnlyCheckPrioritizedOutgoingApprovals {
			i--
			if x.OnlyCheckPrioritizedOutgoingApprovals {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x50
		}
		if x.OnlyCheckPrioritizedIncomingApprovals {
			i--
			if x.OnlyCheckPrioritizedIncomingApprovals {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x48
		}
		if x.OnlyCheckPrioritizedCollectionApprovals {
			i--
			if x.OnlyCheckPrioritizedCollectionApprovals {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x40
		}
		if len(x.PrioritizedApprovals) > 0 {
			for iNdEx := len(x.PrioritizedApprovals) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.PrioritizedApprovals[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x3a
			}
		}
		if len(x.Memo) > 0 {
			i -= len(x.Memo)
			copy(dAtA[i:], x.Memo)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Memo)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.MerkleProofs) > 0 {
			for iNdEx := len(x.MerkleProofs) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.MerkleProofs[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x2a
			}
		}
		if x.PrecalculateBalancesFromApproval != nil {
			encoded, err := options.Marshal(x.PrecalculateBalancesFromApproval)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Balances) > 0 {
			for iNdEx := len(x.Balances) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Balances[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x1a
			}
		}
		if len(x.ToAddresses) > 0 {
			for iNdEx := len(x.ToAddresses) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.ToAddresses[iNdEx])
				copy(dAtA[i:], x.ToAddresses[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ToAddresses[iNdEx])))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.From) > 0 {
			i -= len(x.From)
			copy(dAtA[i:], x.From)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.From)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*Transfer)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Transfer: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: Transfer: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.From = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ToAddresses", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ToAddresses = append(x.ToAddresses, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Balances = append(x.Balances, &Balance{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Balances[len(x.Balances)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrecalculateBalancesFromApproval", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.PrecalculateBalancesFromApproval == nil {
					x.PrecalculateBalancesFromApproval = &ApprovalIdentifierDetails{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.PrecalculateBalancesFromApproval); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MerkleProofs", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MerkleProofs = append(x.MerkleProofs, &MerkleProof{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.MerkleProofs[len(x.MerkleProofs)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Memo = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrioritizedApprovals", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrioritizedApprovals = append(x.PrioritizedApprovals, &ApprovalIdentifierDetails{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.PrioritizedApprovals[len(x.PrioritizedApprovals)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedCollectionApprovals", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.OnlyCheckPrioritizedCollectionApprovals = bool(v != 0)
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedIncomingApprovals", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.OnlyCheckPrioritizedIncomingApprovals = bool(v != 0)
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedOutgoingApprovals", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.OnlyCheckPrioritizedOutgoingApprovals = bool(v != 0)
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ZkProofSolutions", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ZkProofSolutions = append(x.ZkProofSolutions, &ZkProofSolution{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ZkProofSolutions[len(x.ZkProofSolutions)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MerklePathItem         protoreflect.MessageDescriptor
	fd_MerklePathItem_aunt    protoreflect.FieldDescriptor
	fd_MerklePathItem_onRight protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_MerklePathItem = File_badges_transfers_proto.Messages().ByName("MerklePathItem")
	fd_MerklePathItem_aunt = md_MerklePathItem.Fields().ByName("aunt")
	fd_MerklePathItem_onRight = md_MerklePathItem.Fields().ByName("onRight")
}

var _ protoreflect.Message = (*fastReflection_MerklePathItem)(nil)

type fastReflection_MerklePathItem MerklePathItem

func (x *MerklePathItem) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MerklePathItem)(x)
}

func (x *MerklePathItem) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MerklePathItem_messageType fastReflection_MerklePathItem_messageType
var _ protoreflect.MessageType = fastReflection_MerklePathItem_messageType{}

type fastReflection_MerklePathItem_messageType struct{}

func (x fastReflection_MerklePathItem_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MerklePathItem)(nil)
}
func (x fastReflection_MerklePathItem_messageType) New() protoreflect.Message {
	return new(fastReflection_MerklePathItem)
}
func (x fastReflection_MerklePathItem_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MerklePathItem
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MerklePathItem) Descriptor() protoreflect.MessageDescriptor {
	return md_MerklePathItem
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MerklePathItem) Type() protoreflect.MessageType {
	return _fastReflection_MerklePathItem_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MerklePathItem) New() protoreflect.Message {
	return new(fastReflection_MerklePathItem)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MerklePathItem) Interface() protoreflect.ProtoMessage {
	return (*MerklePathItem)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MerklePathItem) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Aunt != "" {
		value := protoreflect.ValueOfString(x.Aunt)
		if !f(fd_MerklePathItem_aunt, value) {
			return
		}
	}
	if x.OnRight != false {
		value := protoreflect.ValueOfBool(x.OnRight)
		if !f(fd_MerklePathItem_onRight, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MerklePathItem) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.MerklePathItem.aunt":
		return x.Aunt != ""
	case "badges.MerklePathItem.onRight":
		return x.OnRight != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerklePathItem"))
		}
		panic(fmt.Errorf("message badges.MerklePathItem does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerklePathItem) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.MerklePathItem.aunt":
		x.Aunt = ""
	case "badges.MerklePathItem.onRight":
		x.OnRight = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerklePathItem"))
		}
		panic(fmt.Errorf("message badges.MerklePathItem does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MerklePathItem) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.MerklePathItem.aunt":
		value := x.Aunt
		return protoreflect.ValueOfString(value)
	case "badges.MerklePathItem.onRight":
		value := x.OnRight
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerklePathItem"))
		}
		panic(fmt.Errorf("message badges.MerklePathItem does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerklePathItem) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.MerklePathItem.aunt":
		x.Aunt = value.Interface().(string)
	case "badges.MerklePathItem.onRight":
		x.OnRight = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerklePathItem"))
		}
		panic(fmt.Errorf("message badges.MerklePathItem does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerklePathItem) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.MerklePathItem.aunt":
		panic(fmt.Errorf("field aunt of message badges.MerklePathItem is not mutable"))
	case "badges.MerklePathItem.onRight":
		panic(fmt.Errorf("field onRight of message badges.MerklePathItem is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerklePathItem"))
		}
		panic(fmt.Errorf("message badges.MerklePathItem does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MerklePathItem) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.MerklePathItem.aunt":
		return protoreflect.ValueOfString("")
	case "badges.MerklePathItem.onRight":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerklePathItem"))
		}
		panic(fmt.Errorf("message badges.MerklePathItem does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MerklePathItem) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.MerklePathItem", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MerklePathItem) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerklePathItem) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MerklePathItem) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MerklePathItem) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MerklePathItem)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Aunt)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.OnRight {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MerklePathItem)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.OnRight {
			i--
			if x.OnRight {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
		}
		if len(x.Aunt) > 0 {
			i -= len(x.Aunt)
			copy(dAtA[i:], x.Aunt)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Aunt)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MerklePathItem)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MerklePathItem: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MerklePathItem: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Aunt", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Aunt = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OnRight", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.OnRight = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_MerkleProof_2_list)(nil)

type _MerkleProof_2_list struct {
	list *[]*MerklePathItem
}

func (x *_MerkleProof_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MerkleProof_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_MerkleProof_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MerklePathItem)
	(*x.list)[i] = concreteValue
}

func (x *_MerkleProof_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*MerklePathItem)
	*x.list = append(*x.list, concreteValue)
}

func (x *_MerkleProof_2_list) AppendMutable() protoreflect.Value {
	v := new(MerklePathItem)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MerkleProof_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_MerkleProof_2_list) NewElement() protoreflect.Value {
	v := new(MerklePathItem)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_MerkleProof_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_MerkleProof       protoreflect.MessageDescriptor
	fd_MerkleProof_leaf  protoreflect.FieldDescriptor
	fd_MerkleProof_aunts protoreflect.FieldDescriptor
)

func init() {
	file_badges_transfers_proto_init()
	md_MerkleProof = File_badges_transfers_proto.Messages().ByName("MerkleProof")
	fd_MerkleProof_leaf = md_MerkleProof.Fields().ByName("leaf")
	fd_MerkleProof_aunts = md_MerkleProof.Fields().ByName("aunts")
}

var _ protoreflect.Message = (*fastReflection_MerkleProof)(nil)

type fastReflection_MerkleProof MerkleProof

func (x *MerkleProof) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MerkleProof)(x)
}

func (x *MerkleProof) slowProtoReflect() protoreflect.Message {
	mi := &file_badges_transfers_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MerkleProof_messageType fastReflection_MerkleProof_messageType
var _ protoreflect.MessageType = fastReflection_MerkleProof_messageType{}

type fastReflection_MerkleProof_messageType struct{}

func (x fastReflection_MerkleProof_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MerkleProof)(nil)
}
func (x fastReflection_MerkleProof_messageType) New() protoreflect.Message {
	return new(fastReflection_MerkleProof)
}
func (x fastReflection_MerkleProof_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MerkleProof
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MerkleProof) Descriptor() protoreflect.MessageDescriptor {
	return md_MerkleProof
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MerkleProof) Type() protoreflect.MessageType {
	return _fastReflection_MerkleProof_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MerkleProof) New() protoreflect.Message {
	return new(fastReflection_MerkleProof)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MerkleProof) Interface() protoreflect.ProtoMessage {
	return (*MerkleProof)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MerkleProof) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Leaf != "" {
		value := protoreflect.ValueOfString(x.Leaf)
		if !f(fd_MerkleProof_leaf, value) {
			return
		}
	}
	if len(x.Aunts) != 0 {
		value := protoreflect.ValueOfList(&_MerkleProof_2_list{list: &x.Aunts})
		if !f(fd_MerkleProof_aunts, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MerkleProof) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "badges.MerkleProof.leaf":
		return x.Leaf != ""
	case "badges.MerkleProof.aunts":
		return len(x.Aunts) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleProof"))
		}
		panic(fmt.Errorf("message badges.MerkleProof does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerkleProof) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "badges.MerkleProof.leaf":
		x.Leaf = ""
	case "badges.MerkleProof.aunts":
		x.Aunts = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleProof"))
		}
		panic(fmt.Errorf("message badges.MerkleProof does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MerkleProof) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "badges.MerkleProof.leaf":
		value := x.Leaf
		return protoreflect.ValueOfString(value)
	case "badges.MerkleProof.aunts":
		if len(x.Aunts) == 0 {
			return protoreflect.ValueOfList(&_MerkleProof_2_list{})
		}
		listValue := &_MerkleProof_2_list{list: &x.Aunts}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleProof"))
		}
		panic(fmt.Errorf("message badges.MerkleProof does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerkleProof) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "badges.MerkleProof.leaf":
		x.Leaf = value.Interface().(string)
	case "badges.MerkleProof.aunts":
		lv := value.List()
		clv := lv.(*_MerkleProof_2_list)
		x.Aunts = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleProof"))
		}
		panic(fmt.Errorf("message badges.MerkleProof does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerkleProof) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.MerkleProof.aunts":
		if x.Aunts == nil {
			x.Aunts = []*MerklePathItem{}
		}
		value := &_MerkleProof_2_list{list: &x.Aunts}
		return protoreflect.ValueOfList(value)
	case "badges.MerkleProof.leaf":
		panic(fmt.Errorf("field leaf of message badges.MerkleProof is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleProof"))
		}
		panic(fmt.Errorf("message badges.MerkleProof does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MerkleProof) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "badges.MerkleProof.leaf":
		return protoreflect.ValueOfString("")
	case "badges.MerkleProof.aunts":
		list := []*MerklePathItem{}
		return protoreflect.ValueOfList(&_MerkleProof_2_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: badges.MerkleProof"))
		}
		panic(fmt.Errorf("message badges.MerkleProof does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MerkleProof) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in badges.MerkleProof", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MerkleProof) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MerkleProof) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MerkleProof) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MerkleProof) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MerkleProof)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Leaf)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Aunts) > 0 {
			for _, e := range x.Aunts {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MerkleProof)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Aunts) > 0 {
			for iNdEx := len(x.Aunts) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Aunts[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.Leaf) > 0 {
			i -= len(x.Leaf)
			copy(dAtA[i:], x.Leaf)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Leaf)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MerkleProof)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MerkleProof: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MerkleProof: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Leaf = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Aunts", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Aunts = append(x.Aunts, &MerklePathItem{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Aunts[len(x.Aunts)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: badges/transfers.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// UserBalanceStore is the store for the user balances for a collection.
//
// It consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,
// as well as the permissions for updating the approved incoming/outgoing transfers.
//
// Upon initialization, all fields (minus the balances) are set to the defaults specified by the collection.
//
// The outgoing transfers can be used to allow / disallow transfers which are sent from this user.
// If a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)
// and autoApproveSelfInitiatedOutgoingTransfers is set to true.
//
// The incoming transfers can be used to allow / disallow transfers which are sent to this user.
// If a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)
// and autoApproveSelfInitiatedIncomingTransfers is set to true.
//
// Note that the user approved transfers are only checked if the collection approved transfers do not specify to override
// the user approved transfers.
//
// The permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.
type UserBalanceStore struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list of balances associated with this user.
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
	// The list of approved outgoing transfers for this user.
	OutgoingApprovals []*UserOutgoingApproval `protobuf:"bytes,2,rep,name=outgoingApprovals,proto3" json:"outgoingApprovals,omitempty"`
	// The list of approved incoming transfers for this user.
	IncomingApprovals []*UserIncomingApproval `protobuf:"bytes,3,rep,name=incomingApprovals,proto3" json:"incomingApprovals,omitempty"`
	// Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).
	AutoApproveSelfInitiatedOutgoingTransfers bool `protobuf:"varint,4,opt,name=autoApproveSelfInitiatedOutgoingTransfers,proto3" json:"autoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).
	AutoApproveSelfInitiatedIncomingTransfers bool `protobuf:"varint,5,opt,name=autoApproveSelfInitiatedIncomingTransfers,proto3" json:"autoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// The permissions for this user's actions and transfers.
	UserPermissions *UserPermissions `protobuf:"bytes,6,opt,name=userPermissions,proto3" json:"userPermissions,omitempty"`
}

func (x *UserBalanceStore) Reset() {
	*x = UserBalanceStore{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserBalanceStore) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserBalanceStore) ProtoMessage() {}

// Deprecated: Use UserBalanceStore.ProtoReflect.Descriptor instead.
func (*UserBalanceStore) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{0}
}

func (x *UserBalanceStore) GetBalances() []*Balance {
	if x != nil {
		return x.Balances
	}
	return nil
}

func (x *UserBalanceStore) GetOutgoingApprovals() []*UserOutgoingApproval {
	if x != nil {
		return x.OutgoingApprovals
	}
	return nil
}

func (x *UserBalanceStore) GetIncomingApprovals() []*UserIncomingApproval {
	if x != nil {
		return x.IncomingApprovals
	}
	return nil
}

func (x *UserBalanceStore) GetAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if x != nil {
		return x.AutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (x *UserBalanceStore) GetAutoApproveSelfInitiatedIncomingTransfers() bool {
	if x != nil {
		return x.AutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (x *UserBalanceStore) GetUserPermissions() *UserPermissions {
	if x != nil {
		return x.UserPermissions
	}
	return nil
}

// Challenges define a rule for the approval in the form of a Merkle challenge.
//
// A Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,
// then the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.
//
// IMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.
//
// IMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.
// If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
// We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
type MerkleChallenge struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The root hash of the Merkle tree to which the Merkle path must lead for verification.
	Root string `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty"`
	// The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.
	ExpectedProofLength string `protobuf:"bytes,2,opt,name=expectedProofLength,proto3" json:"expectedProofLength,omitempty"`
	// If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.
	UseCreatorAddressAsLeaf bool `protobuf:"varint,3,opt,name=useCreatorAddressAsLeaf,proto3" json:"useCreatorAddressAsLeaf,omitempty"`
	// The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.
	MaxUsesPerLeaf string `protobuf:"bytes,4,opt,name=maxUsesPerLeaf,proto3" json:"maxUsesPerLeaf,omitempty"`
	// The URI associated with this Merkle challenge, optionally providing metadata about the challenge.
	Uri string `protobuf:"bytes,5,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this Merkle challenge.
	CustomData string `protobuf:"bytes,6,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this Merkle challenge for tracking the number of uses per leaf.
	ChallengeTrackerId string `protobuf:"bytes,7,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
}

func (x *MerkleChallenge) Reset() {
	*x = MerkleChallenge{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MerkleChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MerkleChallenge) ProtoMessage() {}

// Deprecated: Use MerkleChallenge.ProtoReflect.Descriptor instead.
func (*MerkleChallenge) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{1}
}

func (x *MerkleChallenge) GetRoot() string {
	if x != nil {
		return x.Root
	}
	return ""
}

func (x *MerkleChallenge) GetExpectedProofLength() string {
	if x != nil {
		return x.ExpectedProofLength
	}
	return ""
}

func (x *MerkleChallenge) GetUseCreatorAddressAsLeaf() bool {
	if x != nil {
		return x.UseCreatorAddressAsLeaf
	}
	return false
}

func (x *MerkleChallenge) GetMaxUsesPerLeaf() string {
	if x != nil {
		return x.MaxUsesPerLeaf
	}
	return ""
}

func (x *MerkleChallenge) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

func (x *MerkleChallenge) GetCustomData() string {
	if x != nil {
		return x.CustomData
	}
	return ""
}

func (x *MerkleChallenge) GetChallengeTrackerId() string {
	if x != nil {
		return x.ChallengeTrackerId
	}
	return ""
}

// UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.
type UserOutgoingApproval struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list ID for the recipient of the transfer.
	ToListId string `protobuf:"bytes,1,opt,name=toListId,proto3" json:"toListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,2,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of badge IDs for approval.
	BadgeIds []*UintRange `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,8,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,9,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,10,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *OutgoingApprovalCriteria `protobuf:"bytes,11,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
}

func (x *UserOutgoingApproval) Reset() {
	*x = UserOutgoingApproval{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserOutgoingApproval) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserOutgoingApproval) ProtoMessage() {}

// Deprecated: Use UserOutgoingApproval.ProtoReflect.Descriptor instead.
func (*UserOutgoingApproval) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{2}
}

func (x *UserOutgoingApproval) GetToListId() string {
	if x != nil {
		return x.ToListId
	}
	return ""
}

func (x *UserOutgoingApproval) GetInitiatedByListId() string {
	if x != nil {
		return x.InitiatedByListId
	}
	return ""
}

func (x *UserOutgoingApproval) GetTransferTimes() []*UintRange {
	if x != nil {
		return x.TransferTimes
	}
	return nil
}

func (x *UserOutgoingApproval) GetBadgeIds() []*UintRange {
	if x != nil {
		return x.BadgeIds
	}
	return nil
}

func (x *UserOutgoingApproval) GetOwnershipTimes() []*UintRange {
	if x != nil {
		return x.OwnershipTimes
	}
	return nil
}

func (x *UserOutgoingApproval) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

func (x *UserOutgoingApproval) GetCustomData() string {
	if x != nil {
		return x.CustomData
	}
	return ""
}

func (x *UserOutgoingApproval) GetApprovalId() string {
	if x != nil {
		return x.ApprovalId
	}
	return ""
}

func (x *UserOutgoingApproval) GetApprovalCriteria() *OutgoingApprovalCriteria {
	if x != nil {
		return x.ApprovalCriteria
	}
	return nil
}

// UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.
type UserIncomingApproval struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list ID for the sender of the transfer.
	FromListId string `protobuf:"bytes,1,opt,name=fromListId,proto3" json:"fromListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,2,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of badge IDs for approval.
	BadgeIds []*UintRange `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,8,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,9,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,10,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *IncomingApprovalCriteria `protobuf:"bytes,11,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
}

func (x *UserIncomingApproval) Reset() {
	*x = UserIncomingApproval{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserIncomingApproval) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserIncomingApproval) ProtoMessage() {}

// Deprecated: Use UserIncomingApproval.ProtoReflect.Descriptor instead.
func (*UserIncomingApproval) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{3}
}

func (x *UserIncomingApproval) GetFromListId() string {
	if x != nil {
		return x.FromListId
	}
	return ""
}

func (x *UserIncomingApproval) GetInitiatedByListId() string {
	if x != nil {
		return x.InitiatedByListId
	}
	return ""
}

func (x *UserIncomingApproval) GetTransferTimes() []*UintRange {
	if x != nil {
		return x.TransferTimes
	}
	return nil
}

func (x *UserIncomingApproval) GetBadgeIds() []*UintRange {
	if x != nil {
		return x.BadgeIds
	}
	return nil
}

func (x *UserIncomingApproval) GetOwnershipTimes() []*UintRange {
	if x != nil {
		return x.OwnershipTimes
	}
	return nil
}

func (x *UserIncomingApproval) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

func (x *UserIncomingApproval) GetCustomData() string {
	if x != nil {
		return x.CustomData
	}
	return ""
}

func (x *UserIncomingApproval) GetApprovalId() string {
	if x != nil {
		return x.ApprovalId
	}
	return ""
}

func (x *UserIncomingApproval) GetApprovalCriteria() *IncomingApprovalCriteria {
	if x != nil {
		return x.ApprovalCriteria
	}
	return nil
}

// ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.
type ManualBalances struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Balances []*Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
}

func (x *ManualBalances) Reset() {
	*x = ManualBalances{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ManualBalances) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ManualBalances) ProtoMessage() {}

// Deprecated: Use ManualBalances.ProtoReflect.Descriptor instead.
func (*ManualBalances) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{4}
}

func (x *ManualBalances) GetBalances() []*Balance {
	if x != nil {
		return x.Balances
	}
	return nil
}

// IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.
type IncrementedBalances struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	StartBalances []*Balance `protobuf:"bytes,1,rep,name=startBalances,proto3" json:"startBalances,omitempty"`
	// The amount by which to increment badge IDs.
	IncrementBadgeIdsBy string `protobuf:"bytes,2,opt,name=incrementBadgeIdsBy,proto3" json:"incrementBadgeIdsBy,omitempty"`
	// The amount by which to increment ownership times.
	IncrementOwnershipTimesBy string `protobuf:"bytes,3,opt,name=incrementOwnershipTimesBy,proto3" json:"incrementOwnershipTimesBy,omitempty"`
}

func (x *IncrementedBalances) Reset() {
	*x = IncrementedBalances{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IncrementedBalances) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementedBalances) ProtoMessage() {}

// Deprecated: Use IncrementedBalances.ProtoReflect.Descriptor instead.
func (*IncrementedBalances) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{5}
}

func (x *IncrementedBalances) GetStartBalances() []*Balance {
	if x != nil {
		return x.StartBalances
	}
	return nil
}

func (x *IncrementedBalances) GetIncrementBadgeIdsBy() string {
	if x != nil {
		return x.IncrementBadgeIdsBy
	}
	return ""
}

func (x *IncrementedBalances) GetIncrementOwnershipTimesBy() string {
	if x != nil {
		return x.IncrementOwnershipTimesBy
	}
	return ""
}

// PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.
type PredeterminedOrderCalculationMethod struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.
	UseOverallNumTransfers bool `protobuf:"varint,1,opt,name=useOverallNumTransfers,proto3" json:"useOverallNumTransfers,omitempty"`
	// Use the number of transfers per "to" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.
	UsePerToAddressNumTransfers bool `protobuf:"varint,2,opt,name=usePerToAddressNumTransfers,proto3" json:"usePerToAddressNumTransfers,omitempty"`
	// Use the number of transfers per "from" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.
	UsePerFromAddressNumTransfers bool `protobuf:"varint,3,opt,name=usePerFromAddressNumTransfers,proto3" json:"usePerFromAddressNumTransfers,omitempty"`
	// Use the number of transfers per "initiated by" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.
	UsePerInitiatedByAddressNumTransfers bool `protobuf:"varint,4,opt,name=usePerInitiatedByAddressNumTransfers,proto3" json:"usePerInitiatedByAddressNumTransfers,omitempty"`
	// Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.
	UseMerkleChallengeLeafIndex bool `protobuf:"varint,5,opt,name=useMerkleChallengeLeafIndex,proto3" json:"useMerkleChallengeLeafIndex,omitempty"`
	// If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.
	ChallengeTrackerId string `protobuf:"bytes,6,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
}

func (x *PredeterminedOrderCalculationMethod) Reset() {
	*x = PredeterminedOrderCalculationMethod{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PredeterminedOrderCalculationMethod) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PredeterminedOrderCalculationMethod) ProtoMessage() {}

// Deprecated: Use PredeterminedOrderCalculationMethod.ProtoReflect.Descriptor instead.
func (*PredeterminedOrderCalculationMethod) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{6}
}

func (x *PredeterminedOrderCalculationMethod) GetUseOverallNumTransfers() bool {
	if x != nil {
		return x.UseOverallNumTransfers
	}
	return false
}

func (x *PredeterminedOrderCalculationMethod) GetUsePerToAddressNumTransfers() bool {
	if x != nil {
		return x.UsePerToAddressNumTransfers
	}
	return false
}

func (x *PredeterminedOrderCalculationMethod) GetUsePerFromAddressNumTransfers() bool {
	if x != nil {
		return x.UsePerFromAddressNumTransfers
	}
	return false
}

func (x *PredeterminedOrderCalculationMethod) GetUsePerInitiatedByAddressNumTransfers() bool {
	if x != nil {
		return x.UsePerInitiatedByAddressNumTransfers
	}
	return false
}

func (x *PredeterminedOrderCalculationMethod) GetUseMerkleChallengeLeafIndex() bool {
	if x != nil {
		return x.UseMerkleChallengeLeafIndex
	}
	return false
}

func (x *PredeterminedOrderCalculationMethod) GetChallengeTrackerId() string {
	if x != nil {
		return x.ChallengeTrackerId
	}
	return ""
}

// PredeterminedBalances represents balances with predetermined order calculation.
type PredeterminedBalances struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Manual balances that can be entered. If this is nil, then we use the incremented balances.
	ManualBalances []*ManualBalances `protobuf:"bytes,1,rep,name=manualBalances,proto3" json:"manualBalances,omitempty"`
	// Balances that have a starting amount and increment. If this is nil, then we use the manual balances.
	IncrementedBalances *IncrementedBalances `protobuf:"bytes,2,opt,name=incrementedBalances,proto3" json:"incrementedBalances,omitempty"`
	// The method to calculate the order of predetermined balances.
	OrderCalculationMethod *PredeterminedOrderCalculationMethod `protobuf:"bytes,3,opt,name=orderCalculationMethod,proto3" json:"orderCalculationMethod,omitempty"`
}

func (x *PredeterminedBalances) Reset() {
	*x = PredeterminedBalances{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PredeterminedBalances) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PredeterminedBalances) ProtoMessage() {}

// Deprecated: Use PredeterminedBalances.ProtoReflect.Descriptor instead.
func (*PredeterminedBalances) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{7}
}

func (x *PredeterminedBalances) GetManualBalances() []*ManualBalances {
	if x != nil {
		return x.ManualBalances
	}
	return nil
}

func (x *PredeterminedBalances) GetIncrementedBalances() *IncrementedBalances {
	if x != nil {
		return x.IncrementedBalances
	}
	return nil
}

func (x *PredeterminedBalances) GetOrderCalculationMethod() *PredeterminedOrderCalculationMethod {
	if x != nil {
		return x.OrderCalculationMethod
	}
	return nil
}

// ApprovalAmounts defines approval amounts per unique "from," "to," and/or "initiated by" address.
// If any of these are nil or "0", we assume unlimited approvals.
// If they are set to a value, then the running tally of the amounts transferred for the specified badge IDs and ownership times
// must not exceed the corresponding value.
type ApprovalAmounts struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Overall approval amount.
	OverallApprovalAmount string `protobuf:"bytes,1,opt,name=overallApprovalAmount,proto3" json:"overallApprovalAmount,omitempty"`
	// Approval amount per "to" address.
	PerToAddressApprovalAmount string `protobuf:"bytes,2,opt,name=perToAddressApprovalAmount,proto3" json:"perToAddressApprovalAmount,omitempty"`
	// Approval amount per "from" address.
	PerFromAddressApprovalAmount string `protobuf:"bytes,3,opt,name=perFromAddressApprovalAmount,proto3" json:"perFromAddressApprovalAmount,omitempty"`
	// Approval amount per "initiated by" address.
	PerInitiatedByAddressApprovalAmount string `protobuf:"bytes,4,opt,name=perInitiatedByAddressApprovalAmount,proto3" json:"perInitiatedByAddressApprovalAmount,omitempty"`
	// The ID of the amount tracker associated with this approval.
	// We use this ID to track the number of transfers and amounts transferred.
	AmountTrackerId string `protobuf:"bytes,6,opt,name=amountTrackerId,proto3" json:"amountTrackerId,omitempty"`
}

func (x *ApprovalAmounts) Reset() {
	*x = ApprovalAmounts{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ApprovalAmounts) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApprovalAmounts) ProtoMessage() {}

// Deprecated: Use ApprovalAmounts.ProtoReflect.Descriptor instead.
func (*ApprovalAmounts) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{8}
}

func (x *ApprovalAmounts) GetOverallApprovalAmount() string {
	if x != nil {
		return x.OverallApprovalAmount
	}
	return ""
}

func (x *ApprovalAmounts) GetPerToAddressApprovalAmount() string {
	if x != nil {
		return x.PerToAddressApprovalAmount
	}
	return ""
}

func (x *ApprovalAmounts) GetPerFromAddressApprovalAmount() string {
	if x != nil {
		return x.PerFromAddressApprovalAmount
	}
	return ""
}

func (x *ApprovalAmounts) GetPerInitiatedByAddressApprovalAmount() string {
	if x != nil {
		return x.PerInitiatedByAddressApprovalAmount
	}
	return ""
}

func (x *ApprovalAmounts) GetAmountTrackerId() string {
	if x != nil {
		return x.AmountTrackerId
	}
	return ""
}

// MaxNumTransfers defines the maximum number of transfers per unique "from," "to," and/or "initiated by" address.
// If any of these are nil or "0", we assume unlimited approvals.
// If they are set to a value, then the running tally of the number of transfers for the specified badge IDs and ownership times
// must not exceed the corresponding value.
type MaxNumTransfers struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Overall maximum number of transfers.
	OverallMaxNumTransfers string `protobuf:"bytes,1,opt,name=overallMaxNumTransfers,proto3" json:"overallMaxNumTransfers,omitempty"`
	// Maximum number of transfers per "to" address.
	PerToAddressMaxNumTransfers string `protobuf:"bytes,2,opt,name=perToAddressMaxNumTransfers,proto3" json:"perToAddressMaxNumTransfers,omitempty"`
	// Maximum number of transfers per "from" address.
	PerFromAddressMaxNumTransfers string `protobuf:"bytes,3,opt,name=perFromAddressMaxNumTransfers,proto3" json:"perFromAddressMaxNumTransfers,omitempty"`
	// Maximum number of transfers per "initiated by" address.
	PerInitiatedByAddressMaxNumTransfers string `protobuf:"bytes,4,opt,name=perInitiatedByAddressMaxNumTransfers,proto3" json:"perInitiatedByAddressMaxNumTransfers,omitempty"`
	// The ID of the amount tracker associated with this approval.
	// We use this ID to track the number of transfers and amounts transferred.
	AmountTrackerId string `protobuf:"bytes,6,opt,name=amountTrackerId,proto3" json:"amountTrackerId,omitempty"`
}

func (x *MaxNumTransfers) Reset() {
	*x = MaxNumTransfers{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MaxNumTransfers) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MaxNumTransfers) ProtoMessage() {}

// Deprecated: Use MaxNumTransfers.ProtoReflect.Descriptor instead.
func (*MaxNumTransfers) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{9}
}

func (x *MaxNumTransfers) GetOverallMaxNumTransfers() string {
	if x != nil {
		return x.OverallMaxNumTransfers
	}
	return ""
}

func (x *MaxNumTransfers) GetPerToAddressMaxNumTransfers() string {
	if x != nil {
		return x.PerToAddressMaxNumTransfers
	}
	return ""
}

func (x *MaxNumTransfers) GetPerFromAddressMaxNumTransfers() string {
	if x != nil {
		return x.PerFromAddressMaxNumTransfers
	}
	return ""
}

func (x *MaxNumTransfers) GetPerInitiatedByAddressMaxNumTransfers() string {
	if x != nil {
		return x.PerInitiatedByAddressMaxNumTransfers
	}
	return ""
}

func (x *MaxNumTransfers) GetAmountTrackerId() string {
	if x != nil {
		return x.AmountTrackerId
	}
	return ""
}

// ApprovalTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.
type ApprovalTracker struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The number of transfers that have been processed.
	NumTransfers string `protobuf:"bytes,1,opt,name=numTransfers,proto3" json:"numTransfers,omitempty"`
	// Cumulative balances associated with the transfers that have been processed.
	Amounts []*Balance `protobuf:"bytes,2,rep,name=amounts,proto3" json:"amounts,omitempty"`
}

func (x *ApprovalTracker) Reset() {
	*x = ApprovalTracker{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ApprovalTracker) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApprovalTracker) ProtoMessage() {}

// Deprecated: Use ApprovalTracker.ProtoReflect.Descriptor instead.
func (*ApprovalTracker) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{10}
}

func (x *ApprovalTracker) GetNumTransfers() string {
	if x != nil {
		return x.NumTransfers
	}
	return ""
}

func (x *ApprovalTracker) GetAmounts() []*Balance {
	if x != nil {
		return x.Amounts
	}
	return nil
}

type ZkProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The verification key for the proof.
	VerificationKey string `protobuf:"bytes,1,opt,name=verificationKey,proto3" json:"verificationKey,omitempty"`
	// The URI associated with this proof, optionally providing metadata about the proof.
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this proof.
	CustomData string `protobuf:"bytes,3,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this proof
	ZkpTrackerId string `protobuf:"bytes,4,opt,name=zkpTrackerId,proto3" json:"zkpTrackerId,omitempty"`
}

func (x *ZkProof) Reset() {
	*x = ZkProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ZkProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZkProof) ProtoMessage() {}

// Deprecated: Use ZkProof.ProtoReflect.Descriptor instead.
func (*ZkProof) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{11}
}

func (x *ZkProof) GetVerificationKey() string {
	if x != nil {
		return x.VerificationKey
	}
	return ""
}

func (x *ZkProof) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

func (x *ZkProof) GetCustomData() string {
	if x != nil {
		return x.CustomData
	}
	return ""
}

func (x *ZkProof) GetZkpTrackerId() string {
	if x != nil {
		return x.ZkpTrackerId
	}
	return ""
}

type ZkProofSolution struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The public inputs
	PublicInputs string `protobuf:"bytes,1,opt,name=publicInputs,proto3" json:"publicInputs,omitempty"`
	// The proof
	Proof string `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (x *ZkProofSolution) Reset() {
	*x = ZkProofSolution{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ZkProofSolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZkProofSolution) ProtoMessage() {}

// Deprecated: Use ZkProofSolution.ProtoReflect.Descriptor instead.
func (*ZkProofSolution) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{12}
}

func (x *ZkProofSolution) GetPublicInputs() string {
	if x != nil {
		return x.PublicInputs
	}
	return ""
}

func (x *ZkProofSolution) GetProof() string {
	if x != nil {
		return x.Proof
	}
	return ""
}

type CoinTransfer struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The address of the recipient of the transfer.
	To string `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	// The sdk.Coins to be transferred.
	Coins []*v1beta1.Coin `protobuf:"bytes,2,rep,name=coins,proto3" json:"coins,omitempty"`
}

func (x *CoinTransfer) Reset() {
	*x = CoinTransfer{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CoinTransfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CoinTransfer) ProtoMessage() {}

// Deprecated: Use CoinTransfer.ProtoReflect.Descriptor instead.
func (*CoinTransfer) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{13}
}

func (x *CoinTransfer) GetTo() string {
	if x != nil {
		return x.To
	}
	return ""
}

func (x *CoinTransfer) GetCoins() []*v1beta1.Coin {
	if x != nil {
		return x.Coins
	}
	return nil
}

// ApprovalCriteria defines the criteria for approving transfers.
type ApprovalCriteria struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of badges that the user must own for approval.
	MustOwnBadges []*MustOwnBadges `protobuf:"bytes,1,rep,name=mustOwnBadges,proto3" json:"mustOwnBadges,omitempty"`
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,2,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,3,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,4,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,5,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The ZKPs that need to be solved for approval.
	ZkProofs []*ZkProof `protobuf:"bytes,6,rep,name=zkProofs,proto3" json:"zkProofs,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,7,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,9,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,10,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,11,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,12,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
	// Overrides the user's outgoing approvals for approval.
	OverridesFromOutgoingApprovals bool `protobuf:"varint,13,opt,name=overridesFromOutgoingApprovals,proto3" json:"overridesFromOutgoingApprovals,omitempty"`
	// Overrides the user's incoming approvals for approval.
	OverridesToIncomingApprovals bool `protobuf:"varint,14,opt,name=overridesToIncomingApprovals,proto3" json:"overridesToIncomingApprovals,omitempty"`
}

func (x *ApprovalCriteria) Reset() {
	*x = ApprovalCriteria{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ApprovalCriteria) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApprovalCriteria) ProtoMessage() {}

// Deprecated: Use ApprovalCriteria.ProtoReflect.Descriptor instead.
func (*ApprovalCriteria) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{14}
}

func (x *ApprovalCriteria) GetMustOwnBadges() []*MustOwnBadges {
	if x != nil {
		return x.MustOwnBadges
	}
	return nil
}

func (x *ApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if x != nil {
		return x.MerkleChallenges
	}
	return nil
}

func (x *ApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if x != nil {
		return x.PredeterminedBalances
	}
	return nil
}

func (x *ApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if x != nil {
		return x.ApprovalAmounts
	}
	return nil
}

func (x *ApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if x != nil {
		return x.MaxNumTransfers
	}
	return nil
}

func (x *ApprovalCriteria) GetZkProofs() []*ZkProof {
	if x != nil {
		return x.ZkProofs
	}
	return nil
}

func (x *ApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if x != nil {
		return x.CoinTransfers
	}
	return nil
}

func (x *ApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if x != nil {
		return x.RequireToEqualsInitiatedBy
	}
	return false
}

func (x *ApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if x != nil {
		return x.RequireFromEqualsInitiatedBy
	}
	return false
}

func (x *ApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if x != nil {
		return x.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

func (x *ApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if x != nil {
		return x.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

func (x *ApprovalCriteria) GetOverridesFromOutgoingApprovals() bool {
	if x != nil {
		return x.OverridesFromOutgoingApprovals
	}
	return false
}

func (x *ApprovalCriteria) GetOverridesToIncomingApprovals() bool {
	if x != nil {
		return x.OverridesToIncomingApprovals
	}
	return false
}

// OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.
type OutgoingApprovalCriteria struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of badges that the user must own for approval.
	MustOwnBadges []*MustOwnBadges `protobuf:"bytes,1,rep,name=mustOwnBadges,proto3" json:"mustOwnBadges,omitempty"`
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,2,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,3,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,4,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,5,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The ZKPs that need to be solved for approval.
	ZkProofs []*ZkProof `protobuf:"bytes,6,rep,name=zkProofs,proto3" json:"zkProofs,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,7,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,9,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,11,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
}

func (x *OutgoingApprovalCriteria) Reset() {
	*x = OutgoingApprovalCriteria{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OutgoingApprovalCriteria) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutgoingApprovalCriteria) ProtoMessage() {}

// Deprecated: Use OutgoingApprovalCriteria.ProtoReflect.Descriptor instead.
func (*OutgoingApprovalCriteria) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{15}
}

func (x *OutgoingApprovalCriteria) GetMustOwnBadges() []*MustOwnBadges {
	if x != nil {
		return x.MustOwnBadges
	}
	return nil
}

func (x *OutgoingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if x != nil {
		return x.MerkleChallenges
	}
	return nil
}

func (x *OutgoingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if x != nil {
		return x.PredeterminedBalances
	}
	return nil
}

func (x *OutgoingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if x != nil {
		return x.ApprovalAmounts
	}
	return nil
}

func (x *OutgoingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if x != nil {
		return x.MaxNumTransfers
	}
	return nil
}

func (x *OutgoingApprovalCriteria) GetZkProofs() []*ZkProof {
	if x != nil {
		return x.ZkProofs
	}
	return nil
}

func (x *OutgoingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if x != nil {
		return x.CoinTransfers
	}
	return nil
}

func (x *OutgoingApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if x != nil {
		return x.RequireToEqualsInitiatedBy
	}
	return false
}

func (x *OutgoingApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if x != nil {
		return x.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

// IncomingApprovalCriteria defines the criteria for approving incoming transfers.
type IncomingApprovalCriteria struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of badges that the user must own for approval.
	MustOwnBadges []*MustOwnBadges `protobuf:"bytes,1,rep,name=mustOwnBadges,proto3" json:"mustOwnBadges,omitempty"`
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,2,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,3,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,4,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,5,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The ZKPs that need to be solved for approval.
	ZkProofs []*ZkProof `protobuf:"bytes,6,rep,name=zkProofs,proto3" json:"zkProofs,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,7,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,10,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,12,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
}

func (x *IncomingApprovalCriteria) Reset() {
	*x = IncomingApprovalCriteria{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IncomingApprovalCriteria) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncomingApprovalCriteria) ProtoMessage() {}

// Deprecated: Use IncomingApprovalCriteria.ProtoReflect.Descriptor instead.
func (*IncomingApprovalCriteria) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{16}
}

func (x *IncomingApprovalCriteria) GetMustOwnBadges() []*MustOwnBadges {
	if x != nil {
		return x.MustOwnBadges
	}
	return nil
}

func (x *IncomingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if x != nil {
		return x.MerkleChallenges
	}
	return nil
}

func (x *IncomingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if x != nil {
		return x.PredeterminedBalances
	}
	return nil
}

func (x *IncomingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if x != nil {
		return x.ApprovalAmounts
	}
	return nil
}

func (x *IncomingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if x != nil {
		return x.MaxNumTransfers
	}
	return nil
}

func (x *IncomingApprovalCriteria) GetZkProofs() []*ZkProof {
	if x != nil {
		return x.ZkProofs
	}
	return nil
}

func (x *IncomingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if x != nil {
		return x.CoinTransfers
	}
	return nil
}

func (x *IncomingApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if x != nil {
		return x.RequireFromEqualsInitiatedBy
	}
	return false
}

func (x *IncomingApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if x != nil {
		return x.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

// CollectionApproval defines the rules for the approval of a transfer on the collection level
type CollectionApproval struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list ID for the sender of the transfer.
	FromListId string `protobuf:"bytes,1,opt,name=fromListId,proto3" json:"fromListId,omitempty"`
	// The list ID for the recipient of the transfer.
	ToListId string `protobuf:"bytes,2,opt,name=toListId,proto3" json:"toListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,3,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,4,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of badge IDs for approval.
	BadgeIds []*UintRange `protobuf:"bytes,5,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,6,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,9,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,10,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,11,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *ApprovalCriteria `protobuf:"bytes,12,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
}

func (x *CollectionApproval) Reset() {
	*x = CollectionApproval{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CollectionApproval) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CollectionApproval) ProtoMessage() {}

// Deprecated: Use CollectionApproval.ProtoReflect.Descriptor instead.
func (*CollectionApproval) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{17}
}

func (x *CollectionApproval) GetFromListId() string {
	if x != nil {
		return x.FromListId
	}
	return ""
}

func (x *CollectionApproval) GetToListId() string {
	if x != nil {
		return x.ToListId
	}
	return ""
}

func (x *CollectionApproval) GetInitiatedByListId() string {
	if x != nil {
		return x.InitiatedByListId
	}
	return ""
}

func (x *CollectionApproval) GetTransferTimes() []*UintRange {
	if x != nil {
		return x.TransferTimes
	}
	return nil
}

func (x *CollectionApproval) GetBadgeIds() []*UintRange {
	if x != nil {
		return x.BadgeIds
	}
	return nil
}

func (x *CollectionApproval) GetOwnershipTimes() []*UintRange {
	if x != nil {
		return x.OwnershipTimes
	}
	return nil
}

func (x *CollectionApproval) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

func (x *CollectionApproval) GetCustomData() string {
	if x != nil {
		return x.CustomData
	}
	return ""
}

func (x *CollectionApproval) GetApprovalId() string {
	if x != nil {
		return x.ApprovalId
	}
	return ""
}

func (x *CollectionApproval) GetApprovalCriteria() *ApprovalCriteria {
	if x != nil {
		return x.ApprovalCriteria
	}
	return nil
}

// ApprovalIdentifierDetails defines the details to identify a specific approval.
type ApprovalIdentifierDetails struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The ID of the approval.
	ApprovalId string `protobuf:"bytes,1,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The level of the approval. Can be "collection", "incoming", or "outgoing".
	ApprovalLevel string `protobuf:"bytes,2,opt,name=approvalLevel,proto3" json:"approvalLevel,omitempty"`
	// The address of the approver. Leave blank "" if approvalLevel == "collection".
	ApproverAddress string `protobuf:"bytes,3,opt,name=approverAddress,proto3" json:"approverAddress,omitempty"`
}

func (x *ApprovalIdentifierDetails) Reset() {
	*x = ApprovalIdentifierDetails{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ApprovalIdentifierDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApprovalIdentifierDetails) ProtoMessage() {}

// Deprecated: Use ApprovalIdentifierDetails.ProtoReflect.Descriptor instead.
func (*ApprovalIdentifierDetails) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{18}
}

func (x *ApprovalIdentifierDetails) GetApprovalId() string {
	if x != nil {
		return x.ApprovalId
	}
	return ""
}

func (x *ApprovalIdentifierDetails) GetApprovalLevel() string {
	if x != nil {
		return x.ApprovalLevel
	}
	return ""
}

func (x *ApprovalIdentifierDetails) GetApproverAddress() string {
	if x != nil {
		return x.ApproverAddress
	}
	return ""
}

// Transfer defines the details of a transfer of badges.
type Transfer struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The address of the sender of the transfer.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// The addresses of the recipients of the transfer.
	ToAddresses []string `protobuf:"bytes,2,rep,name=toAddresses,proto3" json:"toAddresses,omitempty"`
	// The balances to be transferred.
	Balances []*Balance `protobuf:"bytes,3,rep,name=balances,proto3" json:"balances,omitempty"`
	// If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.
	// We will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.
	PrecalculateBalancesFromApproval *ApprovalIdentifierDetails `protobuf:"bytes,4,opt,name=precalculateBalancesFromApproval,proto3" json:"precalculateBalancesFromApproval,omitempty"`
	// The Merkle proofs / solutions for all Merkle challenges required for the transfer.
	MerkleProofs []*MerkleProof `protobuf:"bytes,5,rep,name=merkleProofs,proto3" json:"merkleProofs,omitempty"`
	// The memo for the transfer.
	Memo string `protobuf:"bytes,6,opt,name=memo,proto3" json:"memo,omitempty"`
	// The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.
	// This field can be used to prioritize specific approvals and scan through them first.
	PrioritizedApprovals []*ApprovalIdentifierDetails `protobuf:"bytes,7,rep,name=prioritizedApprovals,proto3" json:"prioritizedApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedCollectionApprovals bool `protobuf:"varint,8,opt,name=onlyCheckPrioritizedCollectionApprovals,proto3" json:"onlyCheckPrioritizedCollectionApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedIncomingApprovals bool `protobuf:"varint,9,opt,name=onlyCheckPrioritizedIncomingApprovals,proto3" json:"onlyCheckPrioritizedIncomingApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedOutgoingApprovals bool `protobuf:"varint,10,opt,name=onlyCheckPrioritizedOutgoingApprovals,proto3" json:"onlyCheckPrioritizedOutgoingApprovals,omitempty"`
	// The ZKPs that need to be solved for approval.
	ZkProofSolutions []*ZkProofSolution `protobuf:"bytes,11,rep,name=zkProofSolutions,proto3" json:"zkProofSolutions,omitempty"`
}

func (x *Transfer) Reset() {
	*x = Transfer{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Transfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transfer) ProtoMessage() {}

// Deprecated: Use Transfer.ProtoReflect.Descriptor instead.
func (*Transfer) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{19}
}

func (x *Transfer) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *Transfer) GetToAddresses() []string {
	if x != nil {
		return x.ToAddresses
	}
	return nil
}

func (x *Transfer) GetBalances() []*Balance {
	if x != nil {
		return x.Balances
	}
	return nil
}

func (x *Transfer) GetPrecalculateBalancesFromApproval() *ApprovalIdentifierDetails {
	if x != nil {
		return x.PrecalculateBalancesFromApproval
	}
	return nil
}

func (x *Transfer) GetMerkleProofs() []*MerkleProof {
	if x != nil {
		return x.MerkleProofs
	}
	return nil
}

func (x *Transfer) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

func (x *Transfer) GetPrioritizedApprovals() []*ApprovalIdentifierDetails {
	if x != nil {
		return x.PrioritizedApprovals
	}
	return nil
}

func (x *Transfer) GetOnlyCheckPrioritizedCollectionApprovals() bool {
	if x != nil {
		return x.OnlyCheckPrioritizedCollectionApprovals
	}
	return false
}

func (x *Transfer) GetOnlyCheckPrioritizedIncomingApprovals() bool {
	if x != nil {
		return x.OnlyCheckPrioritizedIncomingApprovals
	}
	return false
}

func (x *Transfer) GetOnlyCheckPrioritizedOutgoingApprovals() bool {
	if x != nil {
		return x.OnlyCheckPrioritizedOutgoingApprovals
	}
	return false
}

func (x *Transfer) GetZkProofSolutions() []*ZkProofSolution {
	if x != nil {
		return x.ZkProofSolutions
	}
	return nil
}

// MerklePathItem represents an item in a Merkle path.
type MerklePathItem struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The hash of the sibling node (aunt) in the Merkle path.
	Aunt string `protobuf:"bytes,1,opt,name=aunt,proto3" json:"aunt,omitempty"`
	// Indicates whether the aunt node is on the right side of the path.
	OnRight bool `protobuf:"varint,2,opt,name=onRight,proto3" json:"onRight,omitempty"`
}

func (x *MerklePathItem) Reset() {
	*x = MerklePathItem{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MerklePathItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MerklePathItem) ProtoMessage() {}

// Deprecated: Use MerklePathItem.ProtoReflect.Descriptor instead.
func (*MerklePathItem) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{20}
}

func (x *MerklePathItem) GetAunt() string {
	if x != nil {
		return x.Aunt
	}
	return ""
}

func (x *MerklePathItem) GetOnRight() bool {
	if x != nil {
		return x.OnRight
	}
	return false
}

// MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.
type MerkleProof struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The hash of the leaf node for which the proof is generated.
	Leaf string `protobuf:"bytes,1,opt,name=leaf,proto3" json:"leaf,omitempty"`
	// List of Merkle path items (aunts) that make up the proof.
	Aunts []*MerklePathItem `protobuf:"bytes,2,rep,name=aunts,proto3" json:"aunts,omitempty"`
}

func (x *MerkleProof) Reset() {
	*x = MerkleProof{}
	if protoimpl.UnsafeEnabled {
		mi := &file_badges_transfers_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MerkleProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MerkleProof) ProtoMessage() {}

// Deprecated: Use MerkleProof.ProtoReflect.Descriptor instead.
func (*MerkleProof) Descriptor() ([]byte, []int) {
	return file_badges_transfers_proto_rawDescGZIP(), []int{21}
}

func (x *MerkleProof) GetLeaf() string {
	if x != nil {
		return x.Leaf
	}
	return ""
}

func (x *MerkleProof) GetAunts() []*MerklePathItem {
	if x != nil {
		return x.Aunts
	}
	return nil
}

var File_badges_transfers_proto protoreflect.FileDescriptor

var file_badges_transfers_proto_rawDesc = []byte{
	0x0a, 0x16, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x06, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73,
	0x1a, 0x14, 0x67, 0x6f, 0x67, 0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x18, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2f, 0x70,
	0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x1a, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x5f, 0x6c, 0x69, 0x73, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x15, 0x62, 0x61,
	0x64, 0x67, 0x65, 0x73, 0x2f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x62, 0x61, 0x73, 0x65,
	0x2f, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2f, 0x63, 0x6f, 0x69, 0x6e, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x22, 0xd6, 0x03, 0x0a, 0x10, 0x55, 0x73, 0x65, 0x72, 0x42, 0x61, 0x6c, 0x61,
	0x6e, 0x63, 0x65, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x12, 0x2b, 0x0a, 0x08, 0x62, 0x61, 0x6c, 0x61,
	0x6e, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x62, 0x61, 0x64,
	0x67, 0x65, 0x73, 0x2e, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x08, 0x62, 0x61, 0x6c,
	0x61, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x4a, 0x0a, 0x11, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e,
	0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x1c, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x4f, 0x75,
	0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x52, 0x11,
	0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c,
	0x73, 0x12, 0x4a, 0x0a, 0x11, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70,
	0x72, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x62,
	0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x63, 0x6f, 0x6d, 0x69,
	0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x52, 0x11, 0x69, 0x6e, 0x63, 0x6f,
	0x6d, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x12, 0x5c, 0x0a,
	0x29, 0x61, 0x75, 0x74, 0x6f, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x53, 0x65, 0x6c, 0x66,
	0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x4f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e,
	0x67, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x29, 0x61, 0x75, 0x74, 0x6f, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x53, 0x65, 0x6c,
	0x66, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x4f, 0x75, 0x74, 0x67, 0x6f, 0x69,
	0x6e, 0x67, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x5c, 0x0a, 0x29, 0x61,
	0x75, 0x74, 0x6f, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x53, 0x65, 0x6c, 0x66, 0x49, 0x6e,
	0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x49, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x54,
	0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x29,
	0x61, 0x75, 0x74, 0x6f, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x53, 0x65, 0x6c, 0x66, 0x49,
	0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x49, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67,
	0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x41, 0x0a, 0x0f, 0x75, 0x73, 0x65,
	0x72, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x55, 0x73, 0x65, 0x72,
	0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x0f, 0x75, 0x73, 0x65,
	0x72, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0xb7, 0x02, 0x0a,
	0x0f, 0x4d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65,
	0x12, 0x12, 0x0a, 0x04, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x72, 0x6f, 0x6f, 0x74, 0x12, 0x3e, 0x0a, 0x13, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64,
	0x50, 0x72, 0x6f, 0x6f, 0x66, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74, 0x52,
	0x13, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x4c, 0x65,
	0x6e, 0x67, 0x74, 0x68, 0x12, 0x38, 0x0a, 0x17, 0x75, 0x73, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74,
	0x6f, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x41, 0x73, 0x4c, 0x65, 0x61, 0x66, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x17, 0x75, 0x73, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6f,
	0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x41, 0x73, 0x4c, 0x65, 0x61, 0x66, 0x12, 0x34,
	0x0a, 0x0e, 0x6d, 0x61, 0x78, 0x55, 0x73, 0x65, 0x73, 0x50, 0x65, 0x72, 0x4c, 0x65, 0x61, 0x66,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x04,
	0x55, 0x69, 0x6e, 0x74, 0x52, 0x0e, 0x6d, 0x61, 0x78, 0x55, 0x73, 0x65, 0x73, 0x50, 0x65, 0x72,
	0x4c, 0x65, 0x61, 0x66, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x69, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x75, 0x72, 0x69, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d,
	0x44, 0x61, 0x74, 0x61, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x63, 0x75, 0x73, 0x74,
	0x6f, 0x6d, 0x44, 0x61, 0x74, 0x61, 0x12, 0x2e, 0x0a, 0x12, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65,
	0x6e, 0x67, 0x65, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x49, 0x64, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x12, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x54, 0x72, 0x61,
	0x63, 0x6b, 0x65, 0x72, 0x49, 0x64, 0x22, 0xa3, 0x03, 0x0a, 0x14, 0x55, 0x73, 0x65, 0x72, 0x4f,
	0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x12,
	0x1a, 0x0a, 0x08, 0x74, 0x6f, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x08, 0x74, 0x6f, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x64, 0x12, 0x2c, 0x0a, 0x11, 0x69,
	0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x11, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65,
	0x64, 0x42, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x64, 0x12, 0x37, 0x0a, 0x0d, 0x74, 0x72, 0x61,
	0x6e, 0x73, 0x66, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x11, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x61,
	0x6e, 0x67, 0x65, 0x52, 0x0d, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x54, 0x69, 0x6d,
	0x65, 0x73, 0x12, 0x2d, 0x0a, 0x08, 0x62, 0x61, 0x64, 0x67, 0x65, 0x49, 0x64, 0x73, 0x18, 0x04,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x55, 0x69,
	0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x08, 0x62, 0x61, 0x64, 0x67, 0x65, 0x49, 0x64,
	0x73, 0x12, 0x39, 0x0a, 0x0e, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x54, 0x69,
	0x6d, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62, 0x61, 0x64, 0x67,
	0x65, 0x73, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0e, 0x6f, 0x77,
	0x6e, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x12, 0x10, 0x0a, 0x03,
	0x75, 0x72, 0x69, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x69, 0x12, 0x1e,
	0x0a, 0x0a, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44, 0x61, 0x74, 0x61, 0x18, 0x09, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0a, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44, 0x61, 0x74, 0x61, 0x12, 0x1e,
	0x0a, 0x0a, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x49, 0x64, 0x18, 0x0a, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0a, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x49, 0x64, 0x12, 0x4c,
	0x0a, 0x10, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72,
	0x69, 0x61, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65,
	0x73, 0x2e, 0x4f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76,
	0x61, 0x6c, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x52, 0x10, 0x61, 0x70, 0x70, 0x72,
	0x6f, 0x76, 0x61, 0x6c, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x22, 0xa7, 0x03, 0x0a,
	0x14, 0x55, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70,
	0x72, 0x6f, 0x76, 0x61, 0x6c, 0x12, 0x1e, 0x0a, 0x0a, 0x66, 0x72, 0x6f, 0x6d, 0x4c, 0x69, 0x73,
	0x74, 0x49, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x66, 0x72, 0x6f, 0x6d, 0x4c,
	0x69, 0x73, 0x74, 0x49, 0x64, 0x12, 0x2c, 0x0a, 0x11, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74,
	0x65, 0x64, 0x42, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x11, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x4c, 0x69, 0x73,
	0x74, 0x49, 0x64, 0x12, 0x37, 0x0a, 0x0d, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x54,
	0x69, 0x6d, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62, 0x61, 0x64,
	0x67, 0x65, 0x73, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0d, 0x74,
	0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x12, 0x2d, 0x0a, 0x08,
	0x62, 0x61, 0x64, 0x67, 0x65, 0x49, 0x64, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11,
	0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67,
	0x65, 0x52, 0x08, 0x62, 0x61, 0x64, 0x67, 0x65, 0x49, 0x64, 0x73, 0x12, 0x39, 0x0a, 0x0e, 0x6f,
	0x77, 0x6e, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x18, 0x05, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x55, 0x69, 0x6e,
	0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0e, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x73, 0x68, 0x69,
	0x70, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x69, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x69, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x75, 0x73, 0x74,
	0x6f, 0x6d, 0x44, 0x61, 0x74, 0x61, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x63, 0x75,
	0x73, 0x74, 0x6f, 0x6d, 0x44, 0x61, 0x74, 0x61, 0x12, 0x1e, 0x0a, 0x0a, 0x61, 0x70, 0x70, 0x72,
	0x6f, 0x76, 0x61, 0x6c, 0x49, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x70,
	0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x49, 0x64, 0x12, 0x4c, 0x0a, 0x10, 0x61, 0x70, 0x70, 0x72,
	0x6f, 0x76, 0x61, 0x6c, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x18, 0x0b, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x20, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x49, 0x6e, 0x63, 0x6f,
	0x6d, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x43, 0x72, 0x69, 0x74,
	0x65, 0x72, 0x69, 0x61, 0x52, 0x10, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x43, 0x72,
	0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x22, 0x3d, 0x0a, 0x0e, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c,
	0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x2b, 0x0a, 0x08, 0x62, 0x61, 0x6c, 0x61,
	0x6e, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x62, 0x61, 0x64,
	0x67, 0x65, 0x73, 0x2e, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x08, 0x62, 0x61, 0x6c,
	0x61, 0x6e, 0x63, 0x65, 0x73, 0x22, 0xd8, 0x01, 0x0a, 0x13, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x6d,
	0x65, 0x6e, 0x74, 0x65, 0x64, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x35, 0x0a,
	0x0d, 0x73, 0x74, 0x61, 0x72, 0x74, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x42, 0x61,
	0x6c, 0x61, 0x6e, 0x63, 0x65, 0x52, 0x0d, 0x73, 0x74, 0x61, 0x72, 0x74, 0x42, 0x61, 0x6c, 0x61,
	0x6e, 0x63, 0x65, 0x73, 0x12, 0x3e, 0x0a, 0x13, 0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e,
	0x74, 0x42, 0x61, 0x64, 0x67, 0x65, 0x49, 0x64, 0x73, 0x42, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74, 0x52,
	0x13, 0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x42, 0x61, 0x64, 0x67, 0x65, 0x49,
	0x64, 0x73, 0x42, 0x79, 0x12, 0x4a, 0x0a, 0x19, 0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e,
	0x74, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x42,
	0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f,
	0x04, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x19, 0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74,
	0x4f, 0x77, 0x6e, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x42, 0x79,
	0x22, 0xab, 0x03, 0x0a, 0x23, 0x50, 0x72, 0x65, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e,
	0x65, 0x64, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x43, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x12, 0x36, 0x0a, 0x16, 0x75, 0x73, 0x65, 0x4f,
	0x76, 0x65, 0x72, 0x61, 0x6c, 0x6c, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x16, 0x75, 0x73, 0x65, 0x4f, 0x76, 0x65,
	0x72, 0x61, 0x6c, 0x6c, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73,
	0x12, 0x40, 0x0a, 0x1b, 0x75, 0x73, 0x65, 0x50, 0x65, 0x72, 0x54, 0x6f, 0x41, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1b, 0x75, 0x73, 0x65, 0x50, 0x65, 0x72, 0x54, 0x6f, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x73, 0x12, 0x44, 0x0a, 0x1d, 0x75, 0x73, 0x65, 0x50, 0x65, 0x72, 0x46, 0x72, 0x6f, 0x6d,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66,
	0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1d, 0x75, 0x73, 0x65, 0x50, 0x65,
	0x72, 0x46, 0x72, 0x6f, 0x6d, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x4e, 0x75, 0x6d, 0x54,
	0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x52, 0x0a, 0x24, 0x75, 0x73, 0x65, 0x50,
	0x65, 0x72, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x24, 0x75, 0x73, 0x65, 0x50, 0x65, 0x72, 0x49, 0x6e,
	0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x40, 0x0a, 0x1b,
	0x75, 0x73, 0x65, 0x4d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e,
	0x67, 0x65, 0x4c, 0x65, 0x61, 0x66, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x1b, 0x75, 0x73, 0x65, 0x4d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43, 0x68, 0x61, 0x6c,
	0x6c, 0x65, 0x6e, 0x67, 0x65, 0x4c, 0x65, 0x61, 0x66, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x2e,
	0x0a, 0x12, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x54, 0x72, 0x61, 0x63, 0x6b,
	0x65, 0x72, 0x49, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x63, 0x68, 0x61, 0x6c,
	0x6c, 0x65, 0x6e, 0x67, 0x65, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x49, 0x64, 0x22, 0x8b,
	0x02, 0x0a, 0x15, 0x50, 0x72, 0x65, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x64,
	0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x3e, 0x0a, 0x0e, 0x6d, 0x61, 0x6e, 0x75,
	0x61, 0x6c, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x16, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c,
	0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x0e, 0x6d, 0x61, 0x6e, 0x75, 0x61, 0x6c,
	0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x4d, 0x0a, 0x13, 0x69, 0x6e, 0x63, 0x72,
	0x65, 0x6d, 0x65, 0x6e, 0x74, 0x65, 0x64, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x49,
	0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x65, 0x64, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63,
	0x65, 0x73, 0x52, 0x13, 0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x65, 0x64, 0x42,
	0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x63, 0x0a, 0x16, 0x6f, 0x72, 0x64, 0x65, 0x72,
	0x43, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x68, 0x6f,
	0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73,
	0x2e, 0x50, 0x72, 0x65, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x64, 0x4f, 0x72,
	0x64, 0x65, 0x72, 0x43, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x65,
	0x74, 0x68, 0x6f, 0x64, 0x52, 0x16, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x43, 0x61, 0x6c, 0x63, 0x75,
	0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x22, 0xff, 0x02, 0x0a,
	0x0f, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73,
	0x12, 0x42, 0x0a, 0x15, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x6c, 0x6c, 0x41, 0x70, 0x70, 0x72, 0x6f,
	0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x15, 0x6f,
	0x76, 0x65, 0x72, 0x61, 0x6c, 0x6c, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x12, 0x4c, 0x0a, 0x1a, 0x70, 0x65, 0x72, 0x54, 0x6f, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde,
	0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x1a, 0x70, 0x65, 0x72, 0x54, 0x6f, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x12, 0x50, 0x0a, 0x1c, 0x70, 0x65, 0x72, 0x46, 0x72, 0x6f, 0x6d, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde,
	0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x1c, 0x70, 0x65, 0x72, 0x46, 0x72, 0x6f, 0x6d, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x12, 0x5e, 0x0a, 0x23, 0x70, 0x65, 0x72, 0x49, 0x6e, 0x69, 0x74, 0x69,
	0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x41, 0x70, 0x70,
	0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74, 0x52,
	0x23, 0x70, 0x65, 0x72, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x12, 0x28, 0x0a, 0x0f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x54, 0x72,
	0x61, 0x63, 0x6b, 0x65, 0x72, 0x49, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x61,
	0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x49, 0x64, 0x22, 0x87,
	0x03, 0x0a, 0x0f, 0x4d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x73, 0x12, 0x44, 0x0a, 0x16, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x6c, 0x6c, 0x4d, 0x61, 0x78,
	0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74,
	0x52, 0x16, 0x6f, 0x76, 0x65, 0x72, 0x61, 0x6c, 0x6c, 0x4d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54,
	0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x4e, 0x0a, 0x1b, 0x70, 0x65, 0x72, 0x54,
	0x6f, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x4d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72,
	0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x0c, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x1b, 0x70, 0x65, 0x72,
	0x54, 0x6f, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x4d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54,
	0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x52, 0x0a, 0x1d, 0x70, 0x65, 0x72, 0x46,
	0x72, 0x6f, 0x6d, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x4d, 0x61, 0x78, 0x4e, 0x75, 0x6d,
	0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x1d, 0x70,
	0x65, 0x72, 0x46, 0x72, 0x6f, 0x6d, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x4d, 0x61, 0x78,
	0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x60, 0x0a, 0x24,
	0x70, 0x65, 0x72, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x41, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x4d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73,
	0x66, 0x65, 0x72, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x24, 0x70, 0x65, 0x72, 0x49, 0x6e, 0x69,
	0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x4d,
	0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x28,
	0x0a, 0x0f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x49,
	0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x54,
	0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x49, 0x64, 0x22, 0x6e, 0x0a, 0x0f, 0x41, 0x70, 0x70, 0x72,
	0x6f, 0x76, 0x61, 0x6c, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x12, 0x30, 0x0a, 0x0c, 0x6e,
	0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x0c, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x04, 0x55, 0x69, 0x6e, 0x74, 0x52,
	0x0c, 0x6e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x29, 0x0a,
	0x07, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f,
	0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x52,
	0x07, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x22, 0x89, 0x01, 0x0a, 0x07, 0x5a, 0x6b, 0x50,
	0x72, 0x6f, 0x6f, 0x66, 0x12, 0x28, 0x0a, 0x0f, 0x76, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x76,
	0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0x12, 0x10,
	0x0a, 0x03, 0x75, 0x72, 0x69, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x69,
	0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44, 0x61, 0x74, 0x61, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44, 0x61, 0x74, 0x61,
	0x12, 0x22, 0x0a, 0x0c, 0x7a, 0x6b, 0x70, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x49, 0x64,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x7a, 0x6b, 0x70, 0x54, 0x72, 0x61, 0x63, 0x6b,
	0x65, 0x72, 0x49, 0x64, 0x22, 0x4b, 0x0a, 0x0f, 0x5a, 0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x53,
	0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x22, 0x0a, 0x0c, 0x70, 0x75, 0x62, 0x6c, 0x69,
	0x63, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x70,
	0x75, 0x62, 0x6c, 0x69, 0x63, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x70,
	0x72, 0x6f, 0x6f, 0x66, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x70, 0x72, 0x6f, 0x6f,
	0x66, 0x22, 0x4f, 0x0a, 0x0c, 0x43, 0x6f, 0x69, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x12, 0x0e, 0x0a, 0x02, 0x74, 0x6f, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x74,
	0x6f, 0x12, 0x2f, 0x0a, 0x05, 0x63, 0x6f, 0x69, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x19, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x2e, 0x76,
	0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x52, 0x05, 0x63, 0x6f, 0x69,
	0x6e, 0x73, 0x22, 0x84, 0x07, 0x0a, 0x10, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x43,
	0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x12, 0x3b, 0x0a, 0x0d, 0x6d, 0x75, 0x73, 0x74, 0x4f,
	0x77, 0x6e, 0x42, 0x61, 0x64, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x15,
	0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x4d, 0x75, 0x73, 0x74, 0x4f, 0x77, 0x6e, 0x42,
	0x61, 0x64, 0x67, 0x65, 0x73, 0x52, 0x0d, 0x6d, 0x75, 0x73, 0x74, 0x4f, 0x77, 0x6e, 0x42, 0x61,
	0x64, 0x67, 0x65, 0x73, 0x12, 0x43, 0x0a, 0x10, 0x6d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43, 0x68,
	0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17,
	0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x4d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43, 0x68,
	0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x52, 0x10, 0x6d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43,
	0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x53, 0x0a, 0x15, 0x70, 0x72, 0x65,
	0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x64, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63,
	0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65,
	0x73, 0x2e, 0x50, 0x72, 0x65, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x64, 0x42,
	0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x15, 0x70, 0x72, 0x65, 0x64, 0x65, 0x74, 0x65,
	0x72, 0x6d, 0x69, 0x6e, 0x65, 0x64, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x41,
	0x0a, 0x0f, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73,
	0x2e, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73,
	0x52, 0x0f, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x73, 0x12, 0x41, 0x0a, 0x0f, 0x6d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73,
	0x66, 0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62, 0x61, 0x64,
	0x67, 0x65, 0x73, 0x2e, 0x4d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66,
	0x65, 0x72, 0x73, 0x52, 0x0f, 0x6d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73,
	0x66, 0x65, 0x72, 0x73, 0x12, 0x2b, 0x0a, 0x08, 0x7a, 0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x73,
	0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e,
	0x5a, 0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x52, 0x08, 0x7a, 0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66,
	0x73, 0x12, 0x3a, 0x0a, 0x0d, 0x63, 0x6f, 0x69, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65,
	0x73, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x52, 0x0d,
	0x63, 0x6f, 0x69, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x3e, 0x0a,
	0x1a, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x54, 0x6f, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x73,
	0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x1a, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x54, 0x6f, 0x45, 0x71, 0x75, 0x61,
	0x6c, 0x73, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x12, 0x42, 0x0a,
	0x1c, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x45, 0x71, 0x75, 0x61,
	0x6c, 0x73, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x18, 0x0a, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x1c, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x46, 0x72, 0x6f, 0x6d,
	0x45, 0x71, 0x75, 0x61, 0x6c, 0x73, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42,
	0x79, 0x12, 0x4a, 0x0a, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x54, 0x6f, 0x44, 0x6f,
	0x65, 0x73, 0x4e, 0x6f, 0x74, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61,
	0x74, 0x65, 0x64, 0x42, 0x79, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x20, 0x72, 0x65, 0x71,
	0x75, 0x69, 0x72, 0x65, 0x54, 0x6f, 0x44, 0x6f, 0x65, 0x73, 0x4e, 0x6f, 0x74, 0x45, 0x71, 0x75,
	0x61, 0x6c, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x12, 0x4e, 0x0a,
	0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x44, 0x6f, 0x65, 0x73,
	0x4e, 0x6f, 0x74, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65,
	0x64, 0x42, 0x79, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69,
	0x72, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x44, 0x6f, 0x65, 0x73, 0x4e, 0x6f, 0x74, 0x45, 0x71, 0x75,
	0x61, 0x6c, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x12, 0x46, 0x0a,
	0x1e, 0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x46, 0x72, 0x6f, 0x6d, 0x4f, 0x75,
	0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x18,
	0x0d, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1e, 0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73,
	0x46, 0x72, 0x6f, 0x6d, 0x4f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72,
	0x6f, 0x76, 0x61, 0x6c, 0x73, 0x12, 0x42, 0x0a, 0x1c, 0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64,
	0x65, 0x73, 0x54, 0x6f, 0x49, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72,
	0x6f, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1c, 0x6f, 0x76, 0x65,
	0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x54, 0x6f, 0x49, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67,
	0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x22, 0xec, 0x04, 0x0a, 0x18, 0x4f, 0x75,
	0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x43, 0x72,
	0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x12, 0x3b, 0x0a, 0x0d, 0x6d, 0x75, 0x73, 0x74, 0x4f, 0x77,
	0x6e, 0x42, 0x61, 0x64, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x15, 0x2e,
	0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x4d, 0x75, 0x73, 0x74, 0x4f, 0x77, 0x6e, 0x42, 0x61,
	0x64, 0x67, 0x65, 0x73, 0x52, 0x0d, 0x6d, 0x75, 0x73, 0x74, 0x4f, 0x77, 0x6e, 0x42, 0x61, 0x64,
	0x67, 0x65, 0x73, 0x12, 0x43, 0x0a, 0x10, 0x6d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43, 0x68, 0x61,
	0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e,
	0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x4d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43, 0x68, 0x61,
	0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x52, 0x10, 0x6d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43, 0x68,
	0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x53, 0x0a, 0x15, 0x70, 0x72, 0x65, 0x64,
	0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x64, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65,
	0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73,
	0x2e, 0x50, 0x72, 0x65, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x64, 0x42, 0x61,
	0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x15, 0x70, 0x72, 0x65, 0x64, 0x65, 0x74, 0x65, 0x72,
	0x6d, 0x69, 0x6e, 0x65, 0x64, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x41, 0x0a,
	0x0f, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e,
	0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x52,
	0x0f, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73,
	0x12, 0x41, 0x0a, 0x0f, 0x6d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66,
	0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62, 0x61, 0x64, 0x67,
	0x65, 0x73, 0x2e, 0x4d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x73, 0x52, 0x0f, 0x6d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66,
	0x65, 0x72, 0x73, 0x12, 0x2b, 0x0a, 0x08, 0x7a, 0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x73, 0x18,
	0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x5a,
	0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x52, 0x08, 0x7a, 0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x73,
	0x12, 0x3a, 0x0a, 0x0d, 0x63, 0x6f, 0x69, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72,
	0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73,
	0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x52, 0x0d, 0x63,
	0x6f, 0x69, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x3e, 0x0a, 0x1a,
	0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x54, 0x6f, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x73, 0x49,
	0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x1a, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x54, 0x6f, 0x45, 0x71, 0x75, 0x61, 0x6c,
	0x73, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x12, 0x4a, 0x0a, 0x20,
	0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x54, 0x6f, 0x44, 0x6f, 0x65, 0x73, 0x4e, 0x6f, 0x74,
	0x45, 0x71, 0x75, 0x61, 0x6c, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79,
	0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x54,
	0x6f, 0x44, 0x6f, 0x65, 0x73, 0x4e, 0x6f, 0x74, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x49, 0x6e, 0x69,
	0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x22, 0xf4, 0x04, 0x0a, 0x18, 0x49, 0x6e, 0x63,
	0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x43, 0x72, 0x69,
	0x74, 0x65, 0x72, 0x69, 0x61, 0x12, 0x3b, 0x0a, 0x0d, 0x6d, 0x75, 0x73, 0x74, 0x4f, 0x77, 0x6e,
	0x42, 0x61, 0x64, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x62,
	0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x4d, 0x75, 0x73, 0x74, 0x4f, 0x77, 0x6e, 0x42, 0x61, 0x64,
	0x67, 0x65, 0x73, 0x52, 0x0d, 0x6d, 0x75, 0x73, 0x74, 0x4f, 0x77, 0x6e, 0x42, 0x61, 0x64, 0x67,
	0x65, 0x73, 0x12, 0x43, 0x0a, 0x10, 0x6d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43, 0x68, 0x61, 0x6c,
	0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62,
	0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x4d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43, 0x68, 0x61, 0x6c,
	0x6c, 0x65, 0x6e, 0x67, 0x65, 0x52, 0x10, 0x6d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x43, 0x68, 0x61,
	0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x53, 0x0a, 0x15, 0x70, 0x72, 0x65, 0x64, 0x65,
	0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x64, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e,
	0x50, 0x72, 0x65, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x64, 0x42, 0x61, 0x6c,
	0x61, 0x6e, 0x63, 0x65, 0x73, 0x52, 0x15, 0x70, 0x72, 0x65, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d,
	0x69, 0x6e, 0x65, 0x64, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x41, 0x0a, 0x0f,
	0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x41,
	0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x52, 0x0f,
	0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x12,
	0x41, 0x0a, 0x0f, 0x6d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65,
	0x73, 0x2e, 0x4d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72,
	0x73, 0x52, 0x0f, 0x6d, 0x61, 0x78, 0x4e, 0x75, 0x6d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x73, 0x12, 0x2b, 0x0a, 0x08, 0x7a, 0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x73, 0x18, 0x06,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x5a, 0x6b,
	0x50, 0x72, 0x6f, 0x6f, 0x66, 0x52, 0x08, 0x7a, 0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x73, 0x12,
	0x3a, 0x0a, 0x0d, 0x63, 0x6f, 0x69, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73,
	0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e,
	0x43, 0x6f, 0x69, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x52, 0x0d, 0x63, 0x6f,
	0x69, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x73, 0x12, 0x42, 0x0a, 0x1c, 0x72,
	0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x73,
	0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x1c, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x45, 0x71,
	0x75, 0x61, 0x6c, 0x73, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x12,
	0x4e, 0x0a, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x44, 0x6f,
	0x65, 0x73, 0x4e, 0x6f, 0x74, 0x45, 0x71, 0x75, 0x61, 0x6c, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61,
	0x74, 0x65, 0x64, 0x42, 0x79, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x22, 0x72, 0x65, 0x71,
	0x75, 0x69, 0x72, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x44, 0x6f, 0x65, 0x73, 0x4e, 0x6f, 0x74, 0x45,
	0x71, 0x75, 0x61, 0x6c, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x22,
	0xb9, 0x03, 0x0a, 0x12, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x70,
	0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x12, 0x1e, 0x0a, 0x0a, 0x66, 0x72, 0x6f, 0x6d, 0x4c, 0x69,
	0x73, 0x74, 0x49, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x66, 0x72, 0x6f, 0x6d,
	0x4c, 0x69, 0x73, 0x74, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x74, 0x6f, 0x4c, 0x69, 0x73, 0x74,
	0x49, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x6f, 0x4c, 0x69, 0x73, 0x74,
	0x49, 0x64, 0x12, 0x2c, 0x0a, 0x11, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42,
	0x79, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x11, 0x69,
	0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x49, 0x64,
	0x12, 0x37, 0x0a, 0x0d, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65,
	0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73,
	0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0d, 0x74, 0x72, 0x61, 0x6e,
	0x73, 0x66, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x12, 0x2d, 0x0a, 0x08, 0x62, 0x61, 0x64,
	0x67, 0x65, 0x49, 0x64, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x62, 0x61,
	0x64, 0x67, 0x65, 0x73, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x08,
	0x62, 0x61, 0x64, 0x67, 0x65, 0x49, 0x64, 0x73, 0x12, 0x39, 0x0a, 0x0e, 0x6f, 0x77, 0x6e, 0x65,
	0x72, 0x73, 0x68, 0x69, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x11, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x61,
	0x6e, 0x67, 0x65, 0x52, 0x0e, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x54, 0x69,
	0x6d, 0x65, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x69, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x75, 0x72, 0x69, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44,
	0x61, 0x74, 0x61, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x63, 0x75, 0x73, 0x74, 0x6f,
	0x6d, 0x44, 0x61, 0x74, 0x61, 0x12, 0x1e, 0x0a, 0x0a, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61,
	0x6c, 0x49, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x70, 0x70, 0x72, 0x6f,
	0x76, 0x61, 0x6c, 0x49, 0x64, 0x12, 0x44, 0x0a, 0x10, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61,
	0x6c, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x18, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61,
	0x6c, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x52, 0x10, 0x61, 0x70, 0x70, 0x72, 0x6f,
	0x76, 0x61, 0x6c, 0x43, 0x72, 0x69, 0x74, 0x65, 0x72, 0x69, 0x61, 0x22, 0x8b, 0x01, 0x0a, 0x19,
	0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69,
	0x65, 0x72, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x12, 0x1e, 0x0a, 0x0a, 0x61, 0x70, 0x70,
	0x72, 0x6f, 0x76, 0x61, 0x6c, 0x49, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61,
	0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x49, 0x64, 0x12, 0x24, 0x0a, 0x0d, 0x61, 0x70, 0x70,
	0x72, 0x6f, 0x76, 0x61, 0x6c, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0d, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12,
	0x28, 0x0a, 0x0f, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76,
	0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0xcb, 0x05, 0x0a, 0x08, 0x54, 0x72,
	0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x20, 0x0a, 0x0b, 0x74, 0x6f,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52,
	0x0b, 0x74, 0x6f, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x2b, 0x0a, 0x08,
	0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f,
	0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x52,
	0x08, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x6d, 0x0a, 0x20, 0x70, 0x72, 0x65,
	0x63, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x65, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65,
	0x73, 0x46, 0x72, 0x6f, 0x6d, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x41, 0x70, 0x70,
	0x72, 0x6f, 0x76, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x44,
	0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x52, 0x20, 0x70, 0x72, 0x65, 0x63, 0x61, 0x6c, 0x63, 0x75,
	0x6c, 0x61, 0x74, 0x65, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x46, 0x72, 0x6f, 0x6d,
	0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x12, 0x37, 0x0a, 0x0c, 0x6d, 0x65, 0x72, 0x6b,
	0x6c, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13,
	0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x4d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x50, 0x72,
	0x6f, 0x6f, 0x66, 0x52, 0x0c, 0x6d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66,
	0x73, 0x12, 0x12, 0x0a, 0x04, 0x6d, 0x65, 0x6d, 0x6f, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x6d, 0x65, 0x6d, 0x6f, 0x12, 0x55, 0x0a, 0x14, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74,
	0x69, 0x7a, 0x65, 0x64, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x07, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x41, 0x70, 0x70,
	0x72, 0x6f, 0x76, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x44,
	0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x52, 0x14, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x69,
	0x7a, 0x65, 0x64, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x12, 0x58, 0x0a, 0x27,
	0x6f, 0x6e, 0x6c, 0x79, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74,
	0x69, 0x7a, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x70,
	0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x27, 0x6f,
	0x6e, 0x6c, 0x79, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x69,
	0x7a, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x70, 0x70,
	0x72, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x12, 0x54, 0x0a, 0x25, 0x6f, 0x6e, 0x6c, 0x79, 0x43, 0x68,
	0x65, 0x63, 0x6b, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x69, 0x7a, 0x65, 0x64, 0x49, 0x6e,
	0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x18,
	0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x25, 0x6f, 0x6e, 0x6c, 0x79, 0x43, 0x68, 0x65, 0x63, 0x6b,
	0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x69, 0x7a, 0x65, 0x64, 0x49, 0x6e, 0x63, 0x6f, 0x6d,
	0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x12, 0x54, 0x0a, 0x25,
	0x6f, 0x6e, 0x6c, 0x79, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74,
	0x69, 0x7a, 0x65, 0x64, 0x4f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72,
	0x6f, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x25, 0x6f, 0x6e, 0x6c,
	0x79, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x69, 0x7a, 0x65,
	0x64, 0x4f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x61,
	0x6c, 0x73, 0x12, 0x43, 0x0a, 0x10, 0x7a, 0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x53, 0x6f, 0x6c,
	0x75, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0b, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x62,
	0x61, 0x64, 0x67, 0x65, 0x73, 0x2e, 0x5a, 0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x53, 0x6f, 0x6c,
	0x75, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x10, 0x7a, 0x6b, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x53, 0x6f,
	0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0x3e, 0x0a, 0x0e, 0x4d, 0x65, 0x72, 0x6b, 0x6c,
	0x65, 0x50, 0x61, 0x74, 0x68, 0x49, 0x74, 0x65, 0x6d, 0x12, 0x12, 0x0a, 0x04, 0x61, 0x75, 0x6e,
	0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x61, 0x75, 0x6e, 0x74, 0x12, 0x18, 0x0a,
	0x07, 0x6f, 0x6e, 0x52, 0x69, 0x67, 0x68, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07,
	0x6f, 0x6e, 0x52, 0x69, 0x67, 0x68, 0x74, 0x22, 0x4f, 0x0a, 0x0b, 0x4d, 0x65, 0x72, 0x6b, 0x6c,
	0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x12, 0x12, 0x0a, 0x04, 0x6c, 0x65, 0x61, 0x66, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6c, 0x65, 0x61, 0x66, 0x12, 0x2c, 0x0a, 0x05, 0x61, 0x75,
	0x6e, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x62, 0x61, 0x64, 0x67,
	0x65, 0x73, 0x2e, 0x4d, 0x65, 0x72, 0x6b, 0x6c, 0x65, 0x50, 0x61, 0x74, 0x68, 0x49, 0x74, 0x65,
	0x6d, 0x52, 0x05, 0x61, 0x75, 0x6e, 0x74, 0x73, 0x42, 0x6f, 0x0a, 0x0a, 0x63, 0x6f, 0x6d, 0x2e,
	0x62, 0x61, 0x64, 0x67, 0x65, 0x73, 0x42, 0x0e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72,
	0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x19, 0x62, 0x69, 0x74, 0x62, 0x61, 0x64,
	0x67, 0x65, 0x73, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x61, 0x64,
	0x67, 0x65, 0x73, 0xa2, 0x02, 0x03, 0x42, 0x58, 0x58, 0xaa, 0x02, 0x06, 0x42, 0x61, 0x64, 0x67,
	0x65, 0x73, 0xca, 0x02, 0x06, 0x42, 0x61, 0x64, 0x67, 0x65, 0x73, 0xe2, 0x02, 0x12, 0x42, 0x61,
	0x64, 0x67, 0x65, 0x73, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
	0xea, 0x02, 0x06, 0x42, 0x61, 0x64, 0x67, 0x65, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x33,
}

var (
	file_badges_transfers_proto_rawDescOnce sync.Once
	file_badges_transfers_proto_rawDescData = file_badges_transfers_proto_rawDesc
)

func file_badges_transfers_proto_rawDescGZIP() []byte {
	file_badges_transfers_proto_rawDescOnce.Do(func() {
		file_badges_transfers_proto_rawDescData = protoimpl.X.CompressGZIP(file_badges_transfers_proto_rawDescData)
	})
	return file_badges_transfers_proto_rawDescData
}

var file_badges_transfers_proto_msgTypes = make([]protoimpl.MessageInfo, 22)
var file_badges_transfers_proto_goTypes = []interface{}{
	(*UserBalanceStore)(nil),                    // 0: badges.UserBalanceStore
	(*MerkleChallenge)(nil),                     // 1: badges.MerkleChallenge
	(*UserOutgoingApproval)(nil),                // 2: badges.UserOutgoingApproval
	(*UserIncomingApproval)(nil),                // 3: badges.UserIncomingApproval
	(*ManualBalances)(nil),                      // 4: badges.ManualBalances
	(*IncrementedBalances)(nil),                 // 5: badges.IncrementedBalances
	(*PredeterminedOrderCalculationMethod)(nil), // 6: badges.PredeterminedOrderCalculationMethod
	(*PredeterminedBalances)(nil),               // 7: badges.PredeterminedBalances
	(*ApprovalAmounts)(nil),                     // 8: badges.ApprovalAmounts
	(*MaxNumTransfers)(nil),                     // 9: badges.MaxNumTransfers
	(*ApprovalTracker)(nil),                     // 10: badges.ApprovalTracker
	(*ZkProof)(nil),                             // 11: badges.ZkProof
	(*ZkProofSolution)(nil),                     // 12: badges.ZkProofSolution
	(*CoinTransfer)(nil),                        // 13: badges.CoinTransfer
	(*ApprovalCriteria)(nil),                    // 14: badges.ApprovalCriteria
	(*OutgoingApprovalCriteria)(nil),            // 15: badges.OutgoingApprovalCriteria
	(*IncomingApprovalCriteria)(nil),            // 16: badges.IncomingApprovalCriteria
	(*CollectionApproval)(nil),                  // 17: badges.CollectionApproval
	(*ApprovalIdentifierDetails)(nil),           // 18: badges.ApprovalIdentifierDetails
	(*Transfer)(nil),                            // 19: badges.Transfer
	(*MerklePathItem)(nil),                      // 20: badges.MerklePathItem
	(*MerkleProof)(nil),                         // 21: badges.MerkleProof
	(*Balance)(nil),                             // 22: badges.Balance
	(*UserPermissions)(nil),                     // 23: badges.UserPermissions
	(*UintRange)(nil),                           // 24: badges.UintRange
	(*v1beta1.Coin)(nil),                        // 25: cosmos.base.v1beta1.Coin
	(*MustOwnBadges)(nil),                       // 26: badges.MustOwnBadges
}
var file_badges_transfers_proto_depIdxs = []int32{
	22, // 0: badges.UserBalanceStore.balances:type_name -> badges.Balance
	2,  // 1: badges.UserBalanceStore.outgoingApprovals:type_name -> badges.UserOutgoingApproval
	3,  // 2: badges.UserBalanceStore.incomingApprovals:type_name -> badges.UserIncomingApproval
	23, // 3: badges.UserBalanceStore.userPermissions:type_name -> badges.UserPermissions
	24, // 4: badges.UserOutgoingApproval.transferTimes:type_name -> badges.UintRange
	24, // 5: badges.UserOutgoingApproval.badgeIds:type_name -> badges.UintRange
	24, // 6: badges.UserOutgoingApproval.ownershipTimes:type_name -> badges.UintRange
	15, // 7: badges.UserOutgoingApproval.approvalCriteria:type_name -> badges.OutgoingApprovalCriteria
	24, // 8: badges.UserIncomingApproval.transferTimes:type_name -> badges.UintRange
	24, // 9: badges.UserIncomingApproval.badgeIds:type_name -> badges.UintRange
	24, // 10: badges.UserIncomingApproval.ownershipTimes:type_name -> badges.UintRange
	16, // 11: badges.UserIncomingApproval.approvalCriteria:type_name -> badges.IncomingApprovalCriteria
	22, // 12: badges.ManualBalances.balances:type_name -> badges.Balance
	22, // 13: badges.IncrementedBalances.startBalances:type_name -> badges.Balance
	4,  // 14: badges.PredeterminedBalances.manualBalances:type_name -> badges.ManualBalances
	5,  // 15: badges.PredeterminedBalances.incrementedBalances:type_name -> badges.IncrementedBalances
	6,  // 16: badges.PredeterminedBalances.orderCalculationMethod:type_name -> badges.PredeterminedOrderCalculationMethod
	22, // 17: badges.ApprovalTracker.amounts:type_name -> badges.Balance
	25, // 18: badges.CoinTransfer.coins:type_name -> cosmos.base.v1beta1.Coin
	26, // 19: badges.ApprovalCriteria.mustOwnBadges:type_name -> badges.MustOwnBadges
	1,  // 20: badges.ApprovalCriteria.merkleChallenges:type_name -> badges.MerkleChallenge
	7,  // 21: badges.ApprovalCriteria.predeterminedBalances:type_name -> badges.PredeterminedBalances
	8,  // 22: badges.ApprovalCriteria.approvalAmounts:type_name -> badges.ApprovalAmounts
	9,  // 23: badges.ApprovalCriteria.maxNumTransfers:type_name -> badges.MaxNumTransfers
	11, // 24: badges.ApprovalCriteria.zkProofs:type_name -> badges.ZkProof
	13, // 25: badges.ApprovalCriteria.coinTransfers:type_name -> badges.CoinTransfer
	26, // 26: badges.OutgoingApprovalCriteria.mustOwnBadges:type_name -> badges.MustOwnBadges
	1,  // 27: badges.OutgoingApprovalCriteria.merkleChallenges:type_name -> badges.MerkleChallenge
	7,  // 28: badges.OutgoingApprovalCriteria.predeterminedBalances:type_name -> badges.PredeterminedBalances
	8,  // 29: badges.OutgoingApprovalCriteria.approvalAmounts:type_name -> badges.ApprovalAmounts
	9,  // 30: badges.OutgoingApprovalCriteria.maxNumTransfers:type_name -> badges.MaxNumTransfers
	11, // 31: badges.OutgoingApprovalCriteria.zkProofs:type_name -> badges.ZkProof
	13, // 32: badges.OutgoingApprovalCriteria.coinTransfers:type_name -> badges.CoinTransfer
	26, // 33: badges.IncomingApprovalCriteria.mustOwnBadges:type_name -> badges.MustOwnBadges
	1,  // 34: badges.IncomingApprovalCriteria.merkleChallenges:type_name -> badges.MerkleChallenge
	7,  // 35: badges.IncomingApprovalCriteria.predeterminedBalances:type_name -> badges.PredeterminedBalances
	8,  // 36: badges.IncomingApprovalCriteria.approvalAmounts:type_name -> badges.ApprovalAmounts
	9,  // 37: badges.IncomingApprovalCriteria.maxNumTransfers:type_name -> badges.MaxNumTransfers
	11, // 38: badges.IncomingApprovalCriteria.zkProofs:type_name -> badges.ZkProof
	13, // 39: badges.IncomingApprovalCriteria.coinTransfers:type_name -> badges.CoinTransfer
	24, // 40: badges.CollectionApproval.transferTimes:type_name -> badges.UintRange
	24, // 41: badges.CollectionApproval.badgeIds:type_name -> badges.UintRange
	24, // 42: badges.CollectionApproval.ownershipTimes:type_name -> badges.UintRange
	14, // 43: badges.CollectionApproval.approvalCriteria:type_name -> badges.ApprovalCriteria
	22, // 44: badges.Transfer.balances:type_name -> badges.Balance
	18, // 45: badges.Transfer.precalculateBalancesFromApproval:type_name -> badges.ApprovalIdentifierDetails
	21, // 46: badges.Transfer.merkleProofs:type_name -> badges.MerkleProof
	18, // 47: badges.Transfer.prioritizedApprovals:type_name -> badges.ApprovalIdentifierDetails
	12, // 48: badges.Transfer.zkProofSolutions:type_name -> badges.ZkProofSolution
	20, // 49: badges.MerkleProof.aunts:type_name -> badges.MerklePathItem
	50, // [50:50] is the sub-list for method output_type
	50, // [50:50] is the sub-list for method input_type
	50, // [50:50] is the sub-list for extension type_name
	50, // [50:50] is the sub-list for extension extendee
	0,  // [0:50] is the sub-list for field type_name
}

func init() { file_badges_transfers_proto_init() }
func file_badges_transfers_proto_init() {
	if File_badges_transfers_proto != nil {
		return
	}
	file_badges_permissions_proto_init()
	file_badges_address_lists_proto_init()
	file_badges_balances_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_badges_transfers_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserBalanceStore); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MerkleChallenge); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserOutgoingApproval); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserIncomingApproval); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ManualBalances); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IncrementedBalances); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PredeterminedOrderCalculationMethod); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PredeterminedBalances); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ApprovalAmounts); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MaxNumTransfers); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ApprovalTracker); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ZkProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ZkProofSolution); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CoinTransfer); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ApprovalCriteria); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OutgoingApprovalCriteria); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IncomingApprovalCriteria); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CollectionApproval); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ApprovalIdentifierDetails); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Transfer); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MerklePathItem); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_badges_transfers_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MerkleProof); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_badges_transfers_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   22,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_badges_transfers_proto_goTypes,
		DependencyIndexes: file_badges_transfers_proto_depIdxs,
		MessageInfos:      file_badges_transfers_proto_msgTypes,
	}.Build()
	File_badges_transfers_proto = out.File
	file_badges_transfers_proto_rawDesc = nil
	file_badges_transfers_proto_goTypes = nil
	file_badges_transfers_proto_depIdxs = nil
}
