// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tokenization/predetermined_balances.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.
type ManualBalances struct {
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
}

func (m *ManualBalances) Reset()         { *m = ManualBalances{} }
func (m *ManualBalances) String() string { return proto.CompactTextString(m) }
func (*ManualBalances) ProtoMessage()    {}
func (*ManualBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed7945f6a1a04eba, []int{0}
}
func (m *ManualBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ManualBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ManualBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ManualBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManualBalances.Merge(m, src)
}
func (m *ManualBalances) XXX_Size() int {
	return m.Size()
}
func (m *ManualBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_ManualBalances.DiscardUnknown(m)
}

var xxx_messageInfo_ManualBalances proto.InternalMessageInfo

func (m *ManualBalances) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

// RecurringOwnershipTimes represents a list of recurring ownership times.
type RecurringOwnershipTimes struct {
	// The original start time of the first interval.
	StartTime Uint `protobuf:"bytes,1,opt,name=startTime,proto3,customtype=Uint" json:"startTime"`
	// The interval length in unix milliseconds.
	IntervalLength Uint `protobuf:"bytes,2,opt,name=intervalLength,proto3,customtype=Uint" json:"intervalLength"`
	// Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period
	ChargePeriodLength Uint `protobuf:"bytes,3,opt,name=chargePeriodLength,proto3,customtype=Uint" json:"chargePeriodLength"`
}

func (m *RecurringOwnershipTimes) Reset()         { *m = RecurringOwnershipTimes{} }
func (m *RecurringOwnershipTimes) String() string { return proto.CompactTextString(m) }
func (*RecurringOwnershipTimes) ProtoMessage()    {}
func (*RecurringOwnershipTimes) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed7945f6a1a04eba, []int{1}
}
func (m *RecurringOwnershipTimes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecurringOwnershipTimes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecurringOwnershipTimes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecurringOwnershipTimes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecurringOwnershipTimes.Merge(m, src)
}
func (m *RecurringOwnershipTimes) XXX_Size() int {
	return m.Size()
}
func (m *RecurringOwnershipTimes) XXX_DiscardUnknown() {
	xxx_messageInfo_RecurringOwnershipTimes.DiscardUnknown(m)
}

var xxx_messageInfo_RecurringOwnershipTimes proto.InternalMessageInfo

// IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.
type IncrementedBalances struct {
	StartBalances []*Balance `protobuf:"bytes,1,rep,name=startBalances,proto3" json:"startBalances,omitempty"`
	// The amount by which to increment token IDs.
	IncrementTokenIdsBy Uint `protobuf:"bytes,2,opt,name=incrementTokenIdsBy,proto3,customtype=Uint" json:"incrementTokenIdsBy"`
	// The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.
	IncrementOwnershipTimesBy Uint `protobuf:"bytes,3,opt,name=incrementOwnershipTimesBy,proto3,customtype=Uint" json:"incrementOwnershipTimesBy"`
	// The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.
	DurationFromTimestamp Uint `protobuf:"bytes,4,opt,name=durationFromTimestamp,proto3,customtype=Uint" json:"durationFromTimestamp"`
	// Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).
	AllowOverrideTimestamp bool `protobuf:"varint,5,opt,name=allowOverrideTimestamp,proto3" json:"allowOverrideTimestamp,omitempty"`
	// Recurring ownership times.
	RecurringOwnershipTimes *RecurringOwnershipTimes `protobuf:"bytes,6,opt,name=recurringOwnershipTimes,proto3" json:"recurringOwnershipTimes,omitempty"`
	// Allow override of any valid ID
	AllowOverrideWithAnyValidToken bool `protobuf:"varint,7,opt,name=allowOverrideWithAnyValidToken,proto3" json:"allowOverrideWithAnyValidToken,omitempty"`
}

func (m *IncrementedBalances) Reset()         { *m = IncrementedBalances{} }
func (m *IncrementedBalances) String() string { return proto.CompactTextString(m) }
func (*IncrementedBalances) ProtoMessage()    {}
func (*IncrementedBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed7945f6a1a04eba, []int{2}
}
func (m *IncrementedBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrementedBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncrementedBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncrementedBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrementedBalances.Merge(m, src)
}
func (m *IncrementedBalances) XXX_Size() int {
	return m.Size()
}
func (m *IncrementedBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrementedBalances.DiscardUnknown(m)
}

var xxx_messageInfo_IncrementedBalances proto.InternalMessageInfo

func (m *IncrementedBalances) GetStartBalances() []*Balance {
	if m != nil {
		return m.StartBalances
	}
	return nil
}

func (m *IncrementedBalances) GetAllowOverrideTimestamp() bool {
	if m != nil {
		return m.AllowOverrideTimestamp
	}
	return false
}

func (m *IncrementedBalances) GetRecurringOwnershipTimes() *RecurringOwnershipTimes {
	if m != nil {
		return m.RecurringOwnershipTimes
	}
	return nil
}

func (m *IncrementedBalances) GetAllowOverrideWithAnyValidToken() bool {
	if m != nil {
		return m.AllowOverrideWithAnyValidToken
	}
	return false
}

// PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.
type PredeterminedOrderCalculationMethod struct {
	// Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.
	UseOverallNumTransfers bool `protobuf:"varint,1,opt,name=useOverallNumTransfers,proto3" json:"useOverallNumTransfers,omitempty"`
	// Use the number of transfers per "to" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.
	UsePerToAddressNumTransfers bool `protobuf:"varint,2,opt,name=usePerToAddressNumTransfers,proto3" json:"usePerToAddressNumTransfers,omitempty"`
	// Use the number of transfers per "from" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.
	UsePerFromAddressNumTransfers bool `protobuf:"varint,3,opt,name=usePerFromAddressNumTransfers,proto3" json:"usePerFromAddressNumTransfers,omitempty"`
	// Use the number of transfers per "initiated by" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.
	UsePerInitiatedByAddressNumTransfers bool `protobuf:"varint,4,opt,name=usePerInitiatedByAddressNumTransfers,proto3" json:"usePerInitiatedByAddressNumTransfers,omitempty"`
	// Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.
	UseMerkleChallengeLeafIndex bool `protobuf:"varint,5,opt,name=useMerkleChallengeLeafIndex,proto3" json:"useMerkleChallengeLeafIndex,omitempty"`
	// If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.
	ChallengeTrackerId string `protobuf:"bytes,6,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
}

func (m *PredeterminedOrderCalculationMethod) Reset()         { *m = PredeterminedOrderCalculationMethod{} }
func (m *PredeterminedOrderCalculationMethod) String() string { return proto.CompactTextString(m) }
func (*PredeterminedOrderCalculationMethod) ProtoMessage()    {}
func (*PredeterminedOrderCalculationMethod) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed7945f6a1a04eba, []int{3}
}
func (m *PredeterminedOrderCalculationMethod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredeterminedOrderCalculationMethod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredeterminedOrderCalculationMethod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredeterminedOrderCalculationMethod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredeterminedOrderCalculationMethod.Merge(m, src)
}
func (m *PredeterminedOrderCalculationMethod) XXX_Size() int {
	return m.Size()
}
func (m *PredeterminedOrderCalculationMethod) XXX_DiscardUnknown() {
	xxx_messageInfo_PredeterminedOrderCalculationMethod.DiscardUnknown(m)
}

var xxx_messageInfo_PredeterminedOrderCalculationMethod proto.InternalMessageInfo

func (m *PredeterminedOrderCalculationMethod) GetUseOverallNumTransfers() bool {
	if m != nil {
		return m.UseOverallNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerToAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerToAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerFromAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerFromAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerInitiatedByAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerInitiatedByAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUseMerkleChallengeLeafIndex() bool {
	if m != nil {
		return m.UseMerkleChallengeLeafIndex
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

// PredeterminedBalances represents balances with predetermined order calculation.
type PredeterminedBalances struct {
	// Manual balances that can be entered. If this is nil, then we use the incremented balances.
	ManualBalances []*ManualBalances `protobuf:"bytes,1,rep,name=manualBalances,proto3" json:"manualBalances,omitempty"`
	// Balances that have a starting amount and increment. If this is nil, then we use the manual balances.
	IncrementedBalances *IncrementedBalances `protobuf:"bytes,2,opt,name=incrementedBalances,proto3" json:"incrementedBalances,omitempty"`
	// The method to calculate the order of predetermined balances.
	OrderCalculationMethod *PredeterminedOrderCalculationMethod `protobuf:"bytes,3,opt,name=orderCalculationMethod,proto3" json:"orderCalculationMethod,omitempty"`
}

func (m *PredeterminedBalances) Reset()         { *m = PredeterminedBalances{} }
func (m *PredeterminedBalances) String() string { return proto.CompactTextString(m) }
func (*PredeterminedBalances) ProtoMessage()    {}
func (*PredeterminedBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_ed7945f6a1a04eba, []int{4}
}
func (m *PredeterminedBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredeterminedBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredeterminedBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredeterminedBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredeterminedBalances.Merge(m, src)
}
func (m *PredeterminedBalances) XXX_Size() int {
	return m.Size()
}
func (m *PredeterminedBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_PredeterminedBalances.DiscardUnknown(m)
}

var xxx_messageInfo_PredeterminedBalances proto.InternalMessageInfo

func (m *PredeterminedBalances) GetManualBalances() []*ManualBalances {
	if m != nil {
		return m.ManualBalances
	}
	return nil
}

func (m *PredeterminedBalances) GetIncrementedBalances() *IncrementedBalances {
	if m != nil {
		return m.IncrementedBalances
	}
	return nil
}

func (m *PredeterminedBalances) GetOrderCalculationMethod() *PredeterminedOrderCalculationMethod {
	if m != nil {
		return m.OrderCalculationMethod
	}
	return nil
}

func init() {
	proto.RegisterType((*ManualBalances)(nil), "tokenization.ManualBalances")
	proto.RegisterType((*RecurringOwnershipTimes)(nil), "tokenization.RecurringOwnershipTimes")
	proto.RegisterType((*IncrementedBalances)(nil), "tokenization.IncrementedBalances")
	proto.RegisterType((*PredeterminedOrderCalculationMethod)(nil), "tokenization.PredeterminedOrderCalculationMethod")
	proto.RegisterType((*PredeterminedBalances)(nil), "tokenization.PredeterminedBalances")
}

func init() {
	proto.RegisterFile("tokenization/predetermined_balances.proto", fileDescriptor_ed7945f6a1a04eba)
}

var fileDescriptor_ed7945f6a1a04eba = []byte{
	// 679 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x95, 0xdf, 0x4e, 0x13, 0x41,
	0x14, 0xc6, 0xbb, 0xb4, 0x22, 0x4c, 0x91, 0x8b, 0x41, 0xa0, 0x82, 0x94, 0x5a, 0x35, 0xa9, 0x5e,
	0xb4, 0xa1, 0x1a, 0x63, 0xa2, 0x31, 0xb2, 0x10, 0x92, 0x1a, 0x10, 0xb2, 0x56, 0x4d, 0xbc, 0x21,
	0xd3, 0x9d, 0xc3, 0xee, 0x84, 0xdd, 0xd9, 0x66, 0x76, 0x16, 0xa8, 0xb7, 0xbe, 0x80, 0x2f, 0xe0,
	0x13, 0xf8, 0x04, 0xbe, 0x01, 0x97, 0x5c, 0x1a, 0x2f, 0x88, 0x81, 0x17, 0x31, 0x3b, 0xfd, 0x3b,
	0x64, 0x8a, 0xdc, 0x6d, 0xe7, 0x7c, 0xe7, 0xd7, 0x99, 0x33, 0xdf, 0x39, 0x83, 0x9e, 0xc8, 0xe8,
	0x10, 0x38, 0xfb, 0x4a, 0x24, 0x8b, 0x78, 0xad, 0x2d, 0x80, 0x82, 0x04, 0x11, 0x32, 0x0e, 0x74,
	0xbf, 0x45, 0x02, 0xc2, 0x5d, 0x88, 0xab, 0x6d, 0x11, 0xc9, 0x08, 0xcf, 0x8c, 0x4a, 0x97, 0xee,
	0x7a, 0x91, 0x17, 0xa9, 0x40, 0x2d, 0xfd, 0xea, 0x6a, 0x96, 0x96, 0x35, 0x9c, 0x0e, 0x58, 0x5a,
	0xd1, 0x82, 0xae, 0x4f, 0x82, 0x00, 0xb8, 0xd7, 0x0f, 0x97, 0x37, 0xd0, 0xec, 0x0e, 0xe1, 0x09,
	0x09, 0xec, 0x5e, 0x1a, 0x5e, 0x43, 0x53, 0x7d, 0x44, 0xc1, 0x2a, 0x65, 0x2b, 0xf9, 0xfa, 0x7c,
	0x75, 0x94, 0x51, 0xed, 0x29, 0x9d, 0x81, 0xac, 0xfc, 0xcb, 0x42, 0x8b, 0x0e, 0xb8, 0x89, 0x10,
	0x8c, 0x7b, 0xbb, 0xc7, 0x1c, 0x44, 0xec, 0xb3, 0x76, 0x93, 0x85, 0x10, 0xe3, 0xa7, 0x68, 0x3a,
	0x96, 0x44, 0xc8, 0xf4, 0x57, 0xc1, 0x2a, 0x59, 0x95, 0x69, 0x7b, 0xe6, 0xf4, 0x7c, 0x35, 0xf3,
	0xe7, 0x7c, 0x35, 0xf7, 0x91, 0x71, 0xe9, 0x0c, 0xc3, 0xf8, 0x39, 0x9a, 0x65, 0x5c, 0x82, 0x38,
	0x22, 0xc1, 0x36, 0x70, 0x4f, 0xfa, 0x85, 0x09, 0x43, 0xc2, 0x15, 0x0d, 0x7e, 0x8d, 0xb0, 0xeb,
	0x13, 0xe1, 0xc1, 0x1e, 0x08, 0x16, 0xd1, 0x5e, 0x66, 0xd6, 0x90, 0x69, 0xd0, 0x95, 0xbf, 0xe5,
	0xd0, 0x5c, 0x83, 0xbb, 0x02, 0x42, 0xe0, 0x12, 0xe8, 0xa0, 0x0c, 0xaf, 0xd0, 0x1d, 0xb5, 0x31,
	0xfb, 0x46, 0xb5, 0xd0, 0xb5, 0xf8, 0x0d, 0x9a, 0x63, 0x7d, 0x66, 0x33, 0xd5, 0x37, 0x68, 0x6c,
	0x77, 0x8c, 0xa7, 0x31, 0x09, 0xf1, 0x3b, 0x74, 0x6f, 0xb0, 0xac, 0xd7, 0xd3, 0xee, 0x18, 0x4f,
	0x36, 0x5e, 0x8e, 0x6d, 0x34, 0x4f, 0x13, 0xa1, 0xb6, 0xbb, 0x25, 0xa2, 0x50, 0x2d, 0x4b, 0x12,
	0xb6, 0x0b, 0x39, 0x03, 0xc7, 0x2c, 0xc5, 0x2f, 0xd0, 0x02, 0x09, 0x82, 0xe8, 0x78, 0xf7, 0x08,
	0x84, 0x60, 0x14, 0x86, 0x90, 0x5b, 0x25, 0xab, 0x32, 0xe5, 0x8c, 0x89, 0xe2, 0x7d, 0xb4, 0x28,
	0xcc, 0xbe, 0x28, 0x4c, 0x96, 0xac, 0x4a, 0xbe, 0xfe, 0x58, 0x2f, 0xe7, 0x18, 0x13, 0x39, 0xe3,
	0x28, 0x78, 0x0b, 0x15, 0xb5, 0xbf, 0xfe, 0xcc, 0xa4, 0xbf, 0xce, 0x3b, 0x9f, 0x48, 0xc0, 0xa8,
	0xaa, 0x67, 0xe1, 0xb6, 0xda, 0xe0, 0x7f, 0x54, 0xe5, 0x9f, 0x59, 0xf4, 0x70, 0x6f, 0xb4, 0x0f,
	0x77, 0x05, 0x05, 0xb1, 0x41, 0x02, 0x37, 0x09, 0xd4, 0xd6, 0x76, 0x40, 0xfa, 0x11, 0x4d, 0x0b,
	0x91, 0xc4, 0x90, 0x72, 0x48, 0x10, 0xbc, 0x4f, 0xc2, 0xa6, 0x20, 0x3c, 0x3e, 0x00, 0x11, 0x2b,
	0x6b, 0x4f, 0x39, 0x63, 0xa2, 0xf8, 0x2d, 0x5a, 0x4e, 0xe2, 0xd4, 0x78, 0xcd, 0x68, 0x9d, 0x52,
	0x01, 0x71, 0xac, 0x25, 0x4f, 0xa8, 0xe4, 0xeb, 0x24, 0x78, 0x13, 0xad, 0x74, 0xc3, 0xe9, 0xcd,
	0x98, 0x18, 0x59, 0xc5, 0xb8, 0x5e, 0x84, 0x1d, 0xf4, 0xa8, 0x2b, 0x68, 0x70, 0x26, 0x19, 0x49,
	0x0d, 0xdf, 0x31, 0xc1, 0x72, 0x0a, 0x76, 0x23, 0x6d, 0xef, 0x6c, 0x3b, 0x20, 0x0e, 0x03, 0xd8,
	0xe8, 0xcf, 0x97, 0x6d, 0x20, 0x07, 0x0d, 0x4e, 0xe1, 0xa4, 0xe7, 0x90, 0xeb, 0x24, 0xb8, 0xaa,
	0x3a, 0xb8, 0xbb, 0xda, 0x14, 0xc4, 0x3d, 0x04, 0xd1, 0xa0, 0xca, 0x21, 0xd3, 0x8e, 0x21, 0x52,
	0xfe, 0x31, 0x81, 0xe6, 0xb5, 0xdb, 0x1a, 0x34, 0xde, 0x26, 0x9a, 0x0d, 0xb5, 0x71, 0xd6, 0x6b,
	0xdb, 0xfb, 0xba, 0xcf, 0xf4, 0x91, 0xe7, 0x5c, 0xc9, 0xc1, 0x1f, 0x46, 0xda, 0x77, 0x08, 0x57,
	0xb7, 0x94, 0xaf, 0x3f, 0xd0, 0x51, 0x86, 0xd9, 0xe1, 0x98, 0xb2, 0x31, 0x43, 0x0b, 0x91, 0xd1,
	0x54, 0xea, 0xe6, 0xf2, 0xf5, 0x35, 0x9d, 0x7b, 0x03, 0x37, 0x3a, 0x63, 0x80, 0xb6, 0x73, 0x7a,
	0x51, 0xb4, 0xce, 0x2e, 0x8a, 0xd6, 0xdf, 0x8b, 0xa2, 0xf5, 0xfd, 0xb2, 0x98, 0x39, 0xbb, 0x2c,
	0x66, 0x7e, 0x5f, 0x16, 0x33, 0x5f, 0x5e, 0x7a, 0x4c, 0xfa, 0x49, 0xab, 0xea, 0x46, 0x61, 0xad,
	0xc5, 0x64, 0x8b, 0x50, 0x0f, 0xe2, 0xe1, 0x97, 0xeb, 0x13, 0xc6, 0x6b, 0x27, 0x35, 0xed, 0xcd,
	0x90, 0x9d, 0x36, 0xc4, 0xad, 0x49, 0xf5, 0x5e, 0x3c, 0xfb, 0x17, 0x00, 0x00, 0xff, 0xff, 0xcd,
	0xc2, 0xf5, 0xb6, 0xbc, 0x06, 0x00, 0x00,
}

func (m *ManualBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManualBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ManualBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecurringOwnershipTimes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecurringOwnershipTimes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecurringOwnershipTimes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ChargePeriodLength.Size()
		i -= size
		if _, err := m.ChargePeriodLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.IntervalLength.Size()
		i -= size
		if _, err := m.IntervalLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.StartTime.Size()
		i -= size
		if _, err := m.StartTime.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IncrementedBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrementedBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrementedBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowOverrideWithAnyValidToken {
		i--
		if m.AllowOverrideWithAnyValidToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RecurringOwnershipTimes != nil {
		{
			size, err := m.RecurringOwnershipTimes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.AllowOverrideTimestamp {
		i--
		if m.AllowOverrideTimestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.DurationFromTimestamp.Size()
		i -= size
		if _, err := m.DurationFromTimestamp.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.IncrementOwnershipTimesBy.Size()
		i -= size
		if _, err := m.IncrementOwnershipTimesBy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.IncrementTokenIdsBy.Size()
		i -= size
		if _, err := m.IncrementTokenIdsBy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.StartBalances) > 0 {
		for iNdEx := len(m.StartBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StartBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PredeterminedOrderCalculationMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredeterminedOrderCalculationMethod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredeterminedOrderCalculationMethod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintPredeterminedBalances(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	if m.UseMerkleChallengeLeafIndex {
		i--
		if m.UseMerkleChallengeLeafIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.UsePerInitiatedByAddressNumTransfers {
		i--
		if m.UsePerInitiatedByAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UsePerFromAddressNumTransfers {
		i--
		if m.UsePerFromAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UsePerToAddressNumTransfers {
		i--
		if m.UsePerToAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UseOverallNumTransfers {
		i--
		if m.UseOverallNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PredeterminedBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredeterminedBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredeterminedBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderCalculationMethod != nil {
		{
			size, err := m.OrderCalculationMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IncrementedBalances != nil {
		{
			size, err := m.IncrementedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ManualBalances) > 0 {
		for iNdEx := len(m.ManualBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManualBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPredeterminedBalances(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPredeterminedBalances(dAtA []byte, offset int, v uint64) int {
	offset -= sovPredeterminedBalances(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ManualBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovPredeterminedBalances(uint64(l))
		}
	}
	return n
}

func (m *RecurringOwnershipTimes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StartTime.Size()
	n += 1 + l + sovPredeterminedBalances(uint64(l))
	l = m.IntervalLength.Size()
	n += 1 + l + sovPredeterminedBalances(uint64(l))
	l = m.ChargePeriodLength.Size()
	n += 1 + l + sovPredeterminedBalances(uint64(l))
	return n
}

func (m *IncrementedBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StartBalances) > 0 {
		for _, e := range m.StartBalances {
			l = e.Size()
			n += 1 + l + sovPredeterminedBalances(uint64(l))
		}
	}
	l = m.IncrementTokenIdsBy.Size()
	n += 1 + l + sovPredeterminedBalances(uint64(l))
	l = m.IncrementOwnershipTimesBy.Size()
	n += 1 + l + sovPredeterminedBalances(uint64(l))
	l = m.DurationFromTimestamp.Size()
	n += 1 + l + sovPredeterminedBalances(uint64(l))
	if m.AllowOverrideTimestamp {
		n += 2
	}
	if m.RecurringOwnershipTimes != nil {
		l = m.RecurringOwnershipTimes.Size()
		n += 1 + l + sovPredeterminedBalances(uint64(l))
	}
	if m.AllowOverrideWithAnyValidToken {
		n += 2
	}
	return n
}

func (m *PredeterminedOrderCalculationMethod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseOverallNumTransfers {
		n += 2
	}
	if m.UsePerToAddressNumTransfers {
		n += 2
	}
	if m.UsePerFromAddressNumTransfers {
		n += 2
	}
	if m.UsePerInitiatedByAddressNumTransfers {
		n += 2
	}
	if m.UseMerkleChallengeLeafIndex {
		n += 2
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovPredeterminedBalances(uint64(l))
	}
	return n
}

func (m *PredeterminedBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ManualBalances) > 0 {
		for _, e := range m.ManualBalances {
			l = e.Size()
			n += 1 + l + sovPredeterminedBalances(uint64(l))
		}
	}
	if m.IncrementedBalances != nil {
		l = m.IncrementedBalances.Size()
		n += 1 + l + sovPredeterminedBalances(uint64(l))
	}
	if m.OrderCalculationMethod != nil {
		l = m.OrderCalculationMethod.Size()
		n += 1 + l + sovPredeterminedBalances(uint64(l))
	}
	return n
}

func sovPredeterminedBalances(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPredeterminedBalances(x uint64) (n int) {
	return sovPredeterminedBalances(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ManualBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredeterminedBalances
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManualBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManualBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredeterminedBalances(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecurringOwnershipTimes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredeterminedBalances
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecurringOwnershipTimes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecurringOwnershipTimes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IntervalLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargePeriodLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChargePeriodLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredeterminedBalances(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrementedBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredeterminedBalances
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrementedBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrementedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartBalances = append(m.StartBalances, &Balance{})
			if err := m.StartBalances[len(m.StartBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementTokenIdsBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncrementTokenIdsBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementOwnershipTimesBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncrementOwnershipTimesBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationFromTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DurationFromTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideTimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideTimestamp = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecurringOwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecurringOwnershipTimes == nil {
				m.RecurringOwnershipTimes = &RecurringOwnershipTimes{}
			}
			if err := m.RecurringOwnershipTimes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideWithAnyValidToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideWithAnyValidToken = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPredeterminedBalances(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredeterminedOrderCalculationMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredeterminedBalances
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredeterminedOrderCalculationMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredeterminedOrderCalculationMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseOverallNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseOverallNumTransfers = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerToAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerToAddressNumTransfers = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerFromAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerFromAddressNumTransfers = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerInitiatedByAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerInitiatedByAddressNumTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMerkleChallengeLeafIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMerkleChallengeLeafIndex = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredeterminedBalances(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredeterminedBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPredeterminedBalances
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredeterminedBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredeterminedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManualBalances = append(m.ManualBalances, &ManualBalances{})
			if err := m.ManualBalances[len(m.ManualBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncrementedBalances == nil {
				m.IncrementedBalances = &IncrementedBalances{}
			}
			if err := m.IncrementedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderCalculationMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderCalculationMethod == nil {
				m.OrderCalculationMethod = &PredeterminedOrderCalculationMethod{}
			}
			if err := m.OrderCalculationMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPredeterminedBalances(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPredeterminedBalances
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPredeterminedBalances(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPredeterminedBalances
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPredeterminedBalances
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPredeterminedBalances
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPredeterminedBalances
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPredeterminedBalances
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPredeterminedBalances        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPredeterminedBalances          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPredeterminedBalances = fmt.Errorf("proto: unexpected end of group")
)
