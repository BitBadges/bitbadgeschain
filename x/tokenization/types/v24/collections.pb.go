// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tokenization/v24/collections.proto

package v24

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A TokenCollection is the top-level object for a collection of tokens.
// It defines everything about the collection, such as the manager, metadata, etc.
//
// All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).
//
// All collections can have a manager who is responsible for managing the collection and can be granted certain admin
// permissions, such as the ability to mint new tokens.
//
// Collections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.
//
// See documentation for more details.
type TokenCollection struct {
	// The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The metadata for the collection itself.
	CollectionMetadata *CollectionMetadata `protobuf:"bytes,2,opt,name=collectionMetadata,proto3" json:"collectionMetadata,omitempty"`
	// The metadata for each token in the collection.
	TokenMetadata []*TokenMetadata `protobuf:"bytes,3,rep,name=tokenMetadata,proto3" json:"tokenMetadata,omitempty"`
	// An arbitrary field that can store any data.
	CustomData string `protobuf:"bytes,4,opt,name=customData,proto3" json:"customData,omitempty"`
	// The address of the manager of this collection.
	Manager string `protobuf:"bytes,5,opt,name=manager,proto3" json:"manager,omitempty"`
	// Permissions that define what the manager of the collection can do or not do.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,6,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Transferability of the collection for collections with standard balances, subject to changes over time.
	// Overrides user approvals for a transfer if specified.
	// Transfer must satisfy both user and collection-level approvals.
	// Only applicable to on-chain balances.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,7,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Standards that define how to interpret the fields of the collection.
	Standards []string `protobuf:"bytes,8,rep,name=standards,proto3" json:"standards,omitempty"`
	// Whether the collection is archived or not.
	// When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
	IsArchived bool `protobuf:"varint,9,opt,name=isArchived,proto3" json:"isArchived,omitempty"`
	// The default store of a balance / approvals for a user, upon genesis.
	DefaultBalances *UserBalanceStore `protobuf:"bytes,10,opt,name=defaultBalances,proto3" json:"defaultBalances,omitempty"`
	// The user or entity who created the collection.
	CreatedBy string `protobuf:"bytes,11,opt,name=createdBy,proto3" json:"createdBy,omitempty"`
	// The valid token IDs for this collection.
	ValidTokenIds []*UintRange `protobuf:"bytes,12,rep,name=validTokenIds,proto3" json:"validTokenIds,omitempty"`
	//The generated address of the collection. Also used to escrow Mint balances.
	MintEscrowAddress string `protobuf:"bytes,13,opt,name=mintEscrowAddress,proto3" json:"mintEscrowAddress,omitempty"`
	// The IBC wrapper (sdk.coin) paths for the collection.
	CosmosCoinWrapperPaths []*CosmosCoinWrapperPath `protobuf:"bytes,14,rep,name=cosmosCoinWrapperPaths,proto3" json:"cosmosCoinWrapperPaths,omitempty"`
	// Collection-level invariants that cannot be broken.
	// These are set upon genesis and cannot be modified.
	Invariants *CollectionInvariants `protobuf:"bytes,15,opt,name=invariants,proto3" json:"invariants,omitempty"`
	// The alias (non-wrapping) paths for the collection.
	AliasPaths []*AliasPath `protobuf:"bytes,16,rep,name=aliasPaths,proto3" json:"aliasPaths,omitempty"`
}

func (m *TokenCollection) Reset()         { *m = TokenCollection{} }
func (m *TokenCollection) String() string { return proto.CompactTextString(m) }
func (*TokenCollection) ProtoMessage()    {}
func (*TokenCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_865993468b3af8e3, []int{0}
}
func (m *TokenCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenCollection.Merge(m, src)
}
func (m *TokenCollection) XXX_Size() int {
	return m.Size()
}
func (m *TokenCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenCollection.DiscardUnknown(m)
}

var xxx_messageInfo_TokenCollection proto.InternalMessageInfo

func (m *TokenCollection) GetCollectionMetadata() *CollectionMetadata {
	if m != nil {
		return m.CollectionMetadata
	}
	return nil
}

func (m *TokenCollection) GetTokenMetadata() []*TokenMetadata {
	if m != nil {
		return m.TokenMetadata
	}
	return nil
}

func (m *TokenCollection) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *TokenCollection) GetManager() string {
	if m != nil {
		return m.Manager
	}
	return ""
}

func (m *TokenCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *TokenCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *TokenCollection) GetStandards() []string {
	if m != nil {
		return m.Standards
	}
	return nil
}

func (m *TokenCollection) GetIsArchived() bool {
	if m != nil {
		return m.IsArchived
	}
	return false
}

func (m *TokenCollection) GetDefaultBalances() *UserBalanceStore {
	if m != nil {
		return m.DefaultBalances
	}
	return nil
}

func (m *TokenCollection) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *TokenCollection) GetValidTokenIds() []*UintRange {
	if m != nil {
		return m.ValidTokenIds
	}
	return nil
}

func (m *TokenCollection) GetMintEscrowAddress() string {
	if m != nil {
		return m.MintEscrowAddress
	}
	return ""
}

func (m *TokenCollection) GetCosmosCoinWrapperPaths() []*CosmosCoinWrapperPath {
	if m != nil {
		return m.CosmosCoinWrapperPaths
	}
	return nil
}

func (m *TokenCollection) GetInvariants() *CollectionInvariants {
	if m != nil {
		return m.Invariants
	}
	return nil
}

func (m *TokenCollection) GetAliasPaths() []*AliasPath {
	if m != nil {
		return m.AliasPaths
	}
	return nil
}

// Conversion defines a bidirectional conversion between a cosmos coin (with denom) and token balances.
type Conversion struct {
	// Side A: The cosmos coin side of the conversion (amount + denom).
	SideA *ConversionSideAWithDenom `protobuf:"bytes,1,opt,name=sideA,proto3" json:"sideA,omitempty"`
	// Side B: The token balances side of the conversion.
	SideB []*Balance `protobuf:"bytes,2,rep,name=sideB,proto3" json:"sideB,omitempty"`
}

func (m *Conversion) Reset()         { *m = Conversion{} }
func (m *Conversion) String() string { return proto.CompactTextString(m) }
func (*Conversion) ProtoMessage()    {}
func (*Conversion) Descriptor() ([]byte, []int) {
	return fileDescriptor_865993468b3af8e3, []int{1}
}
func (m *Conversion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Conversion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Conversion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Conversion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Conversion.Merge(m, src)
}
func (m *Conversion) XXX_Size() int {
	return m.Size()
}
func (m *Conversion) XXX_DiscardUnknown() {
	xxx_messageInfo_Conversion.DiscardUnknown(m)
}

var xxx_messageInfo_Conversion proto.InternalMessageInfo

func (m *Conversion) GetSideA() *ConversionSideAWithDenom {
	if m != nil {
		return m.SideA
	}
	return nil
}

func (m *Conversion) GetSideB() []*Balance {
	if m != nil {
		return m.SideB
	}
	return nil
}

// ConversionSideAWithDenom represents the cosmos coin side of a conversion with denomination.
type ConversionSideAWithDenom struct {
	// The amount of the cosmos coin (0 decimals).
	Amount Uint `protobuf:"bytes,1,opt,name=amount,proto3,customtype=Uint" json:"amount"`
	// The denomination of the cosmos coin.
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *ConversionSideAWithDenom) Reset()         { *m = ConversionSideAWithDenom{} }
func (m *ConversionSideAWithDenom) String() string { return proto.CompactTextString(m) }
func (*ConversionSideAWithDenom) ProtoMessage()    {}
func (*ConversionSideAWithDenom) Descriptor() ([]byte, []int) {
	return fileDescriptor_865993468b3af8e3, []int{2}
}
func (m *ConversionSideAWithDenom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConversionSideAWithDenom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConversionSideAWithDenom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConversionSideAWithDenom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConversionSideAWithDenom.Merge(m, src)
}
func (m *ConversionSideAWithDenom) XXX_Size() int {
	return m.Size()
}
func (m *ConversionSideAWithDenom) XXX_DiscardUnknown() {
	xxx_messageInfo_ConversionSideAWithDenom.DiscardUnknown(m)
}

var xxx_messageInfo_ConversionSideAWithDenom proto.InternalMessageInfo

func (m *ConversionSideAWithDenom) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

// ConversionWithoutDenom defines a bidirectional conversion between a cosmos coin amount (without denom) and token balances.
// The denom is stored at the base level (e.g., in AliasPath or CosmosCoinWrapperPath).
type ConversionWithoutDenom struct {
	// Side A: The cosmos coin amount side of the conversion (amount only, denom stored separately).
	SideA *ConversionSideA `protobuf:"bytes,1,opt,name=sideA,proto3" json:"sideA,omitempty"`
	// Side B: The token balances side of the conversion.
	SideB []*Balance `protobuf:"bytes,2,rep,name=sideB,proto3" json:"sideB,omitempty"`
}

func (m *ConversionWithoutDenom) Reset()         { *m = ConversionWithoutDenom{} }
func (m *ConversionWithoutDenom) String() string { return proto.CompactTextString(m) }
func (*ConversionWithoutDenom) ProtoMessage()    {}
func (*ConversionWithoutDenom) Descriptor() ([]byte, []int) {
	return fileDescriptor_865993468b3af8e3, []int{3}
}
func (m *ConversionWithoutDenom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConversionWithoutDenom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConversionWithoutDenom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConversionWithoutDenom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConversionWithoutDenom.Merge(m, src)
}
func (m *ConversionWithoutDenom) XXX_Size() int {
	return m.Size()
}
func (m *ConversionWithoutDenom) XXX_DiscardUnknown() {
	xxx_messageInfo_ConversionWithoutDenom.DiscardUnknown(m)
}

var xxx_messageInfo_ConversionWithoutDenom proto.InternalMessageInfo

func (m *ConversionWithoutDenom) GetSideA() *ConversionSideA {
	if m != nil {
		return m.SideA
	}
	return nil
}

func (m *ConversionWithoutDenom) GetSideB() []*Balance {
	if m != nil {
		return m.SideB
	}
	return nil
}

// ConversionSideA represents the cosmos coin amount side of a conversion without denomination.
type ConversionSideA struct {
	// The amount of the cosmos coin (0 decimals).
	Amount Uint `protobuf:"bytes,1,opt,name=amount,proto3,customtype=Uint" json:"amount"`
}

func (m *ConversionSideA) Reset()         { *m = ConversionSideA{} }
func (m *ConversionSideA) String() string { return proto.CompactTextString(m) }
func (*ConversionSideA) ProtoMessage()    {}
func (*ConversionSideA) Descriptor() ([]byte, []int) {
	return fileDescriptor_865993468b3af8e3, []int{4}
}
func (m *ConversionSideA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConversionSideA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConversionSideA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConversionSideA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConversionSideA.Merge(m, src)
}
func (m *ConversionSideA) XXX_Size() int {
	return m.Size()
}
func (m *ConversionSideA) XXX_DiscardUnknown() {
	xxx_messageInfo_ConversionSideA.DiscardUnknown(m)
}

var xxx_messageInfo_ConversionSideA proto.InternalMessageInfo

type CosmosCoinWrapperPath struct {
	// The BitBadges address associated with this wrapper path. Used for routing and identifying the wrapper.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The denomination (denom) to be used for the wrapped coin or the alias denom.
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	// The conversion between cosmos coin and token balances.
	Conversion *ConversionWithoutDenom `protobuf:"bytes,3,opt,name=conversion,proto3" json:"conversion,omitempty"`
	// The symbol for the wrapped coin (e.g., "BADGE", "NFT"). Used for display purposes. Note that this may not be the default.
	Symbol string `protobuf:"bytes,4,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// Denomination units for the wrapped coin. Defines how the coin can be displayed with different
	// decimal places and symbols (e.g., base unit, display unit). You can specify which is the default display unit (base level or one of these).
	DenomUnits []*DenomUnit `protobuf:"bytes,5,rep,name=denomUnits,proto3" json:"denomUnits,omitempty"`
	// If true, allows this wrapper path to be used with any valid token ID in the collection via an {id} placeholder.
	AllowOverrideWithAnyValidToken bool `protobuf:"varint,6,opt,name=allowOverrideWithAnyValidToken,proto3" json:"allowOverrideWithAnyValidToken,omitempty"`
	// The metadata for this wrapper path.
	Metadata *PathMetadata `protobuf:"bytes,7,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *CosmosCoinWrapperPath) Reset()         { *m = CosmosCoinWrapperPath{} }
func (m *CosmosCoinWrapperPath) String() string { return proto.CompactTextString(m) }
func (*CosmosCoinWrapperPath) ProtoMessage()    {}
func (*CosmosCoinWrapperPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_865993468b3af8e3, []int{5}
}
func (m *CosmosCoinWrapperPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosCoinWrapperPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosCoinWrapperPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosCoinWrapperPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosCoinWrapperPath.Merge(m, src)
}
func (m *CosmosCoinWrapperPath) XXX_Size() int {
	return m.Size()
}
func (m *CosmosCoinWrapperPath) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosCoinWrapperPath.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosCoinWrapperPath proto.InternalMessageInfo

func (m *CosmosCoinWrapperPath) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetConversion() *ConversionWithoutDenom {
	if m != nil {
		return m.Conversion
	}
	return nil
}

func (m *CosmosCoinWrapperPath) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetDenomUnits() []*DenomUnit {
	if m != nil {
		return m.DenomUnits
	}
	return nil
}

func (m *CosmosCoinWrapperPath) GetAllowOverrideWithAnyValidToken() bool {
	if m != nil {
		return m.AllowOverrideWithAnyValidToken
	}
	return false
}

func (m *CosmosCoinWrapperPath) GetMetadata() *PathMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type AliasPath struct {
	// The denomination (denom) to be used for the alias.
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	// The conversion between cosmos coin and token balances.
	Conversion *ConversionWithoutDenom `protobuf:"bytes,2,opt,name=conversion,proto3" json:"conversion,omitempty"`
	// The symbol for the alias (e.g., "BADGE", "NFT"). Used for display purposes. Note that this may not be the default.
	Symbol string `protobuf:"bytes,3,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// Denomination units for the alias. Defines how the coin can be displayed with different decimal places and symbols.
	DenomUnits []*DenomUnit `protobuf:"bytes,4,rep,name=denomUnits,proto3" json:"denomUnits,omitempty"`
	// The metadata for this alias path.
	Metadata *PathMetadata `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *AliasPath) Reset()         { *m = AliasPath{} }
func (m *AliasPath) String() string { return proto.CompactTextString(m) }
func (*AliasPath) ProtoMessage()    {}
func (*AliasPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_865993468b3af8e3, []int{6}
}
func (m *AliasPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AliasPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AliasPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AliasPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AliasPath.Merge(m, src)
}
func (m *AliasPath) XXX_Size() int {
	return m.Size()
}
func (m *AliasPath) XXX_DiscardUnknown() {
	xxx_messageInfo_AliasPath.DiscardUnknown(m)
}

var xxx_messageInfo_AliasPath proto.InternalMessageInfo

func (m *AliasPath) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *AliasPath) GetConversion() *ConversionWithoutDenom {
	if m != nil {
		return m.Conversion
	}
	return nil
}

func (m *AliasPath) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *AliasPath) GetDenomUnits() []*DenomUnit {
	if m != nil {
		return m.DenomUnits
	}
	return nil
}

func (m *AliasPath) GetMetadata() *PathMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type CosmosCoinBackedPath struct {
	// The address associated with this backed path. Used for routing and escrowing IBC tokens.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The conversion between IBC cosmos coin and token balances.
	Conversion *Conversion `protobuf:"bytes,2,opt,name=conversion,proto3" json:"conversion,omitempty"`
}

func (m *CosmosCoinBackedPath) Reset()         { *m = CosmosCoinBackedPath{} }
func (m *CosmosCoinBackedPath) String() string { return proto.CompactTextString(m) }
func (*CosmosCoinBackedPath) ProtoMessage()    {}
func (*CosmosCoinBackedPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_865993468b3af8e3, []int{7}
}
func (m *CosmosCoinBackedPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosCoinBackedPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosCoinBackedPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosCoinBackedPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosCoinBackedPath.Merge(m, src)
}
func (m *CosmosCoinBackedPath) XXX_Size() int {
	return m.Size()
}
func (m *CosmosCoinBackedPath) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosCoinBackedPath.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosCoinBackedPath proto.InternalMessageInfo

func (m *CosmosCoinBackedPath) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CosmosCoinBackedPath) GetConversion() *Conversion {
	if m != nil {
		return m.Conversion
	}
	return nil
}

type DenomUnit struct {
	// The number of decimal places for this unit. Defines the precision of the unit.
	Decimals Uint `protobuf:"bytes,1,opt,name=decimals,proto3,customtype=Uint" json:"decimals"`
	// The symbol for this unit (e.g., "BADGE", "nBADGE"). Used for display purposes.
	Symbol string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// If true, this is the default display unit. Only one unit should be marked as the default display unit.
	// This unit will be used by default when displaying the coin amount. If none are marked default, we use the base level.
	IsDefaultDisplay bool `protobuf:"varint,3,opt,name=isDefaultDisplay,proto3" json:"isDefaultDisplay,omitempty"`
	// The metadata for this denomination unit.
	Metadata *PathMetadata `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *DenomUnit) Reset()         { *m = DenomUnit{} }
func (m *DenomUnit) String() string { return proto.CompactTextString(m) }
func (*DenomUnit) ProtoMessage()    {}
func (*DenomUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_865993468b3af8e3, []int{8}
}
func (m *DenomUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenomUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenomUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenomUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenomUnit.Merge(m, src)
}
func (m *DenomUnit) XXX_Size() int {
	return m.Size()
}
func (m *DenomUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_DenomUnit.DiscardUnknown(m)
}

var xxx_messageInfo_DenomUnit proto.InternalMessageInfo

func (m *DenomUnit) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *DenomUnit) GetIsDefaultDisplay() bool {
	if m != nil {
		return m.IsDefaultDisplay
	}
	return false
}

func (m *DenomUnit) GetMetadata() *PathMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// CollectionInvariants defines the invariants that apply to a collection.
type CollectionInvariants struct {
	// If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].
	// This prevents time-based restrictions on token ownership.
	NoCustomOwnershipTimes bool `protobuf:"varint,1,opt,name=noCustomOwnershipTimes,proto3" json:"noCustomOwnershipTimes,omitempty"`
	// Maximum supply per token ID. If set, no balance can exceed this amount.
	// This prevents any single token ID from having more than the specified supply.
	MaxSupplyPerId Uint `protobuf:"bytes,2,opt,name=maxSupplyPerId,proto3,customtype=Uint" json:"maxSupplyPerId"`
	// The IBC backed (sdk.coin) path for the collection. Only one path is allowed.
	CosmosCoinBackedPath *CosmosCoinBackedPath `protobuf:"bytes,3,opt,name=cosmosCoinBackedPath,proto3" json:"cosmosCoinBackedPath,omitempty"`
	// If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.
	// This prevents forceful transfers that bypass user-level approvals.
	// This only applies to transfers where the from address does not equal "Mint".
	NoForcefulPostMintTransfers bool `protobuf:"varint,4,opt,name=noForcefulPostMintTransfers,proto3" json:"noForcefulPostMintTransfers,omitempty"`
	// If true, disallows pool creation with this collection's assets.
	// When true, any attempt to create a pool with tokenization assets from this collection will fail.
	DisablePoolCreation bool `protobuf:"varint,5,opt,name=disablePoolCreation,proto3" json:"disablePoolCreation,omitempty"`
}

func (m *CollectionInvariants) Reset()         { *m = CollectionInvariants{} }
func (m *CollectionInvariants) String() string { return proto.CompactTextString(m) }
func (*CollectionInvariants) ProtoMessage()    {}
func (*CollectionInvariants) Descriptor() ([]byte, []int) {
	return fileDescriptor_865993468b3af8e3, []int{9}
}
func (m *CollectionInvariants) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionInvariants) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionInvariants.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionInvariants) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionInvariants.Merge(m, src)
}
func (m *CollectionInvariants) XXX_Size() int {
	return m.Size()
}
func (m *CollectionInvariants) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionInvariants.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionInvariants proto.InternalMessageInfo

func (m *CollectionInvariants) GetNoCustomOwnershipTimes() bool {
	if m != nil {
		return m.NoCustomOwnershipTimes
	}
	return false
}

func (m *CollectionInvariants) GetCosmosCoinBackedPath() *CosmosCoinBackedPath {
	if m != nil {
		return m.CosmosCoinBackedPath
	}
	return nil
}

func (m *CollectionInvariants) GetNoForcefulPostMintTransfers() bool {
	if m != nil {
		return m.NoForcefulPostMintTransfers
	}
	return false
}

func (m *CollectionInvariants) GetDisablePoolCreation() bool {
	if m != nil {
		return m.DisablePoolCreation
	}
	return false
}

func init() {
	proto.RegisterType((*TokenCollection)(nil), "tokenization.v24.TokenCollection")
	proto.RegisterType((*Conversion)(nil), "tokenization.v24.Conversion")
	proto.RegisterType((*ConversionSideAWithDenom)(nil), "tokenization.v24.ConversionSideAWithDenom")
	proto.RegisterType((*ConversionWithoutDenom)(nil), "tokenization.v24.ConversionWithoutDenom")
	proto.RegisterType((*ConversionSideA)(nil), "tokenization.v24.ConversionSideA")
	proto.RegisterType((*CosmosCoinWrapperPath)(nil), "tokenization.v24.CosmosCoinWrapperPath")
	proto.RegisterType((*AliasPath)(nil), "tokenization.v24.AliasPath")
	proto.RegisterType((*CosmosCoinBackedPath)(nil), "tokenization.v24.CosmosCoinBackedPath")
	proto.RegisterType((*DenomUnit)(nil), "tokenization.v24.DenomUnit")
	proto.RegisterType((*CollectionInvariants)(nil), "tokenization.v24.CollectionInvariants")
}

func init() {
	proto.RegisterFile("tokenization/v24/collections.proto", fileDescriptor_865993468b3af8e3)
}

var fileDescriptor_865993468b3af8e3 = []byte{
	// 1077 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdd, 0x6e, 0xdb, 0x36,
	0x14, 0x8e, 0x9c, 0x38, 0xb1, 0x4f, 0xda, 0xa6, 0x63, 0xd3, 0x40, 0x4d, 0x0b, 0xc7, 0x33, 0x8a,
	0xce, 0x2b, 0x86, 0xb8, 0xc8, 0x82, 0x15, 0xd8, 0x7a, 0x51, 0xdb, 0x69, 0xb0, 0x00, 0x2b, 0x1a,
	0x28, 0x3f, 0x05, 0x0a, 0x0c, 0x01, 0x2d, 0x31, 0x36, 0x51, 0x89, 0x14, 0x48, 0xda, 0xa9, 0x77,
	0x33, 0x60, 0x4f, 0xb0, 0x97, 0xd9, 0x3b, 0xf4, 0xb2, 0x18, 0x76, 0x31, 0xec, 0xa2, 0x18, 0x92,
	0xbb, 0x3d, 0xc3, 0x2e, 0x06, 0x52, 0xb2, 0x25, 0x47, 0xb2, 0xb3, 0x0c, 0xbb, 0x13, 0xc9, 0xef,
	0x7c, 0x3a, 0xdf, 0xc7, 0xc3, 0x43, 0x42, 0x4d, 0xf1, 0xb7, 0x84, 0xd1, 0x1f, 0xb0, 0xa2, 0x9c,
	0x35, 0x06, 0x5b, 0xdb, 0x0d, 0x97, 0xfb, 0x3e, 0x71, 0xf5, 0x50, 0x6e, 0x86, 0x82, 0x2b, 0x8e,
	0x6e, 0xa7, 0x31, 0x9b, 0x83, 0xad, 0xed, 0xf5, 0x7b, 0x5d, 0xce, 0xbb, 0x3e, 0x69, 0x98, 0xf5,
	0x4e, 0xff, 0xb4, 0x81, 0xd9, 0x30, 0x02, 0xaf, 0x57, 0x33, 0x84, 0x4a, 0x60, 0x26, 0x4f, 0x89,
	0x88, 0xe9, 0xd6, 0x37, 0x32, 0x88, 0x0e, 0xf6, 0x31, 0x73, 0xc9, 0x08, 0x90, 0xcd, 0x29, 0x24,
	0x22, 0xa0, 0x52, 0x26, 0x39, 0xe5, 0x90, 0x04, 0x44, 0x61, 0x0f, 0x2b, 0x3c, 0x35, 0x0f, 0x1c,
	0x86, 0x82, 0x0f, 0xb0, 0x3f, 0xa2, 0xf8, 0x3c, 0x83, 0xe8, 0x4b, 0x22, 0x4e, 0xe2, 0x64, 0x4e,
	0xa4, 0xe2, 0x82, 0xc4, 0xd0, 0xd5, 0x2e, 0xef, 0x72, 0xf3, 0xd9, 0xd0, 0x5f, 0xd1, 0x6c, 0xed,
	0xd7, 0x25, 0x58, 0x39, 0xd4, 0x1c, 0xed, 0xb1, 0x65, 0xe8, 0x09, 0xdc, 0x48, 0x0c, 0xdc, 0xf3,
	0x6c, 0xab, 0x6a, 0xd5, 0xcb, 0xad, 0x1b, 0xef, 0x3f, 0x6e, 0xcc, 0xfd, 0xf1, 0x71, 0x63, 0xe1,
	0x88, 0x32, 0xe5, 0x4c, 0x20, 0xd0, 0x21, 0xa0, 0x64, 0xfc, 0x32, 0x16, 0x61, 0x17, 0xaa, 0x56,
	0x7d, 0x79, 0xeb, 0xe1, 0xe6, 0x65, 0xeb, 0x37, 0xdb, 0x19, 0xac, 0x93, 0x13, 0x8f, 0x5e, 0xc0,
	0x4d, 0x13, 0x3a, 0x26, 0x9c, 0xaf, 0xce, 0xd7, 0x97, 0xb7, 0x36, 0xb2, 0x84, 0x87, 0x69, 0x98,
	0x33, 0x19, 0x85, 0x2a, 0x00, 0x6e, 0x5f, 0x2a, 0x1e, 0xec, 0x68, 0x8e, 0x05, 0x2d, 0xc6, 0x49,
	0xcd, 0x20, 0x1b, 0x96, 0x02, 0xcc, 0x70, 0x97, 0x08, 0xbb, 0x68, 0x16, 0x47, 0x43, 0xf4, 0x3d,
	0xdc, 0x4d, 0xd2, 0xda, 0x4f, 0xf6, 0xcf, 0x5e, 0x34, 0xca, 0x3e, 0x9b, 0xa5, 0x2c, 0x05, 0x77,
	0xf2, 0x59, 0xd0, 0x31, 0xdc, 0x49, 0x16, 0x9a, 0xa3, 0x9d, 0xb5, 0x97, 0x8c, 0xca, 0x99, 0xb6,
	0x8d, 0xc0, 0x4e, 0x1e, 0x01, 0x7a, 0x00, 0x65, 0xa9, 0x30, 0xf3, 0xb0, 0xf0, 0xa4, 0x5d, 0xaa,
	0xce, 0xd7, 0xcb, 0x4e, 0x32, 0xa1, 0xed, 0xa0, 0xb2, 0x29, 0xdc, 0x1e, 0x1d, 0x10, 0xcf, 0x2e,
	0x57, 0xad, 0x7a, 0xc9, 0x49, 0xcd, 0xa0, 0xef, 0x60, 0xc5, 0x23, 0xa7, 0xb8, 0xef, 0xab, 0x56,
	0x5c, 0xd2, 0x36, 0x18, 0xb9, 0xb5, 0x6c, 0x46, 0x47, 0x92, 0x88, 0x18, 0x75, 0xa0, 0x4b, 0xcd,
	0xb9, 0x1c, 0xaa, 0x73, 0x71, 0x05, 0xc1, 0x8a, 0x78, 0xad, 0xa1, 0xbd, 0x6c, 0xec, 0x4d, 0x26,
	0x50, 0x13, 0x6e, 0x0e, 0xb0, 0x4f, 0x3d, 0xb3, 0x7f, 0x7b, 0x9e, 0xb4, 0x6f, 0x18, 0xed, 0xf7,
	0x73, 0xfe, 0xa4, 0x8b, 0x0e, 0xb3, 0x2e, 0x71, 0x26, 0x23, 0xd0, 0x17, 0xf0, 0x49, 0x40, 0x99,
	0x7a, 0x21, 0x5d, 0xc1, 0xcf, 0x9a, 0x9e, 0x27, 0x88, 0x94, 0xf6, 0x4d, 0xf3, 0xa3, 0xec, 0x02,
	0x3a, 0x81, 0x35, 0x97, 0xcb, 0x80, 0xcb, 0x36, 0xa7, 0xec, 0xb5, 0xc0, 0x61, 0x48, 0xc4, 0x3e,
	0x56, 0x3d, 0x69, 0xdf, 0x32, 0x7f, 0xce, 0xdd, 0xd2, 0x1c, 0xbc, 0x33, 0x85, 0x06, 0xed, 0x02,
	0x50, 0x36, 0xc0, 0x82, 0x62, 0xa6, 0xa4, 0xbd, 0x62, 0x8c, 0x7b, 0x34, 0x6b, 0x2b, 0xf7, 0xc6,
	0x68, 0x27, 0x15, 0x89, 0xbe, 0x01, 0xc0, 0x3e, 0xc5, 0x32, 0x4a, 0xee, 0xf6, 0x34, 0x5b, 0x9a,
	0x23, 0x8c, 0x93, 0x82, 0xd7, 0x7e, 0x04, 0x68, 0x73, 0x36, 0x20, 0x42, 0xd7, 0x19, 0x7a, 0x0e,
	0x45, 0x49, 0x3d, 0xd2, 0x34, 0xe7, 0x78, 0x79, 0xeb, 0x71, 0x5e, 0x36, 0x23, 0xf0, 0x81, 0x06,
	0xbe, 0xa6, 0xaa, 0xb7, 0x43, 0x18, 0x0f, 0x9c, 0x28, 0x10, 0x35, 0x22, 0x86, 0x96, 0x5d, 0x30,
	0x79, 0xdc, 0xcb, 0x32, 0xc4, 0xfb, 0x1d, 0x05, 0xb4, 0x6a, 0xc7, 0x60, 0x4f, 0xe3, 0x44, 0x0f,
	0x61, 0x11, 0x07, 0xbc, 0xcf, 0x54, 0x6e, 0x5f, 0x89, 0xd7, 0xd0, 0x2a, 0x14, 0x3d, 0x0d, 0x37,
	0x4d, 0xa4, 0xec, 0x44, 0x83, 0xda, 0x4f, 0x16, 0xac, 0x25, 0xc4, 0x9a, 0x93, 0xf7, 0x55, 0x44,
	0xfb, 0x74, 0x52, 0xe5, 0xa7, 0x57, 0xaa, 0xfc, 0xcf, 0xe2, 0x9e, 0xc2, 0xca, 0x25, 0xaa, 0x7f,
	0xa7, 0xa9, 0xf6, 0x57, 0x01, 0xee, 0xe6, 0x56, 0x93, 0x6e, 0x41, 0x38, 0x2e, 0x5d, 0x2b, 0x6a,
	0x41, 0xf1, 0x30, 0xdf, 0x07, 0xf4, 0x2d, 0x80, 0x3b, 0x4e, 0xc1, 0x9e, 0x37, 0x8a, 0xeb, 0xb3,
	0x14, 0xa7, 0xad, 0x72, 0x52, 0xb1, 0x68, 0x0d, 0x16, 0xe5, 0x30, 0xe8, 0x70, 0x3f, 0x6e, 0x8c,
	0xf1, 0x48, 0xd7, 0x9f, 0xf9, 0xd5, 0x11, 0xa3, 0x4a, 0xda, 0xc5, 0x69, 0xf5, 0xb7, 0x33, 0xc2,
	0x38, 0x29, 0x38, 0xda, 0x85, 0x0a, 0xf6, 0x7d, 0x7e, 0xf6, 0x6a, 0x40, 0x84, 0xa0, 0x1e, 0xd1,
	0x7f, 0x6f, 0xb2, 0xe1, 0xf1, 0xf8, 0xe0, 0x9a, 0x06, 0x5a, 0x72, 0xae, 0x40, 0xa1, 0xaf, 0xa1,
	0x34, 0xba, 0x11, 0xed, 0x25, 0x23, 0xb2, 0x92, 0x4d, 0x41, 0x1b, 0x38, 0x6e, 0xfd, 0x63, 0x7c,
	0xed, 0x6f, 0x0b, 0xca, 0xe3, 0xd3, 0x91, 0xd8, 0x68, 0x4d, 0xb7, 0xb1, 0xf0, 0xbf, 0xd8, 0x38,
	0x3f, 0xc3, 0xc6, 0x85, 0xeb, 0xd9, 0x98, 0x96, 0x5f, 0xbc, 0xa6, 0x7c, 0x06, 0xab, 0x49, 0xa9,
	0xb5, 0xb0, 0xfb, 0x96, 0x78, 0x57, 0x54, 0xda, 0xb3, 0x1c, 0x33, 0x1e, 0xcc, 0x32, 0x23, 0x6d,
	0x40, 0xed, 0x17, 0x0b, 0xca, 0x63, 0x15, 0xa8, 0x0e, 0x25, 0x8f, 0xb8, 0x34, 0xd0, 0xd7, 0x59,
	0xde, 0x89, 0x18, 0xaf, 0xa6, 0x8c, 0x2b, 0x4c, 0x18, 0xf7, 0x18, 0x6e, 0x53, 0xb9, 0x13, 0x5d,
	0x26, 0x3b, 0x54, 0x86, 0x3e, 0x1e, 0x1a, 0x6b, 0x4b, 0x4e, 0x66, 0x7e, 0xc2, 0xa7, 0x85, 0x6b,
	0xfa, 0xf4, 0x5b, 0x41, 0x1b, 0x95, 0x6d, 0xc6, 0xe8, 0x2b, 0x58, 0x63, 0xbc, 0x6d, 0x5e, 0x09,
	0xaf, 0xce, 0x18, 0x11, 0xb2, 0x47, 0xc3, 0x43, 0x1a, 0x90, 0x48, 0x50, 0xc9, 0x99, 0xb2, 0x8a,
	0xb6, 0xe1, 0x56, 0x80, 0xdf, 0x1d, 0xf4, 0xc3, 0xd0, 0x1f, 0xee, 0x13, 0xb1, 0xe7, 0x45, 0xc2,
	0x2e, 0x19, 0x70, 0x09, 0x83, 0xde, 0xc0, 0xaa, 0x9b, 0xb3, 0x5d, 0xf1, 0xd1, 0x7e, 0x34, 0xeb,
	0x56, 0x4a, 0xd0, 0x4e, 0x2e, 0x07, 0x7a, 0x0e, 0xf7, 0x19, 0xdf, 0xe5, 0xc2, 0x25, 0xa7, 0x7d,
	0x7f, 0x9f, 0x4b, 0xf5, 0x92, 0x32, 0x75, 0x38, 0x7a, 0xd0, 0x1a, 0xc7, 0x4a, 0xce, 0x2c, 0x08,
	0x7a, 0x02, 0x77, 0x3c, 0x2a, 0x71, 0xc7, 0x27, 0xfb, 0x9c, 0xfb, 0x6d, 0x7d, 0x7d, 0xeb, 0x1a,
	0x29, 0x9a, 0xc8, 0xbc, 0xa5, 0xd6, 0xf1, 0xfb, 0xf3, 0x8a, 0xf5, 0xe1, 0xbc, 0x62, 0xfd, 0x79,
	0x5e, 0xb1, 0x7e, 0xbe, 0xa8, 0xcc, 0x7d, 0xb8, 0xa8, 0xcc, 0xfd, 0x7e, 0x51, 0x99, 0x7b, 0xf3,
	0xac, 0x4b, 0x55, 0xaf, 0xdf, 0xd9, 0x74, 0x79, 0xd0, 0xe8, 0x50, 0xd5, 0xc1, 0x5e, 0x97, 0xc8,
	0xe4, 0xcb, 0xed, 0x61, 0xca, 0x1a, 0xef, 0x1a, 0x13, 0xef, 0x5a, 0x35, 0x0c, 0x89, 0xd4, 0xaf,
	0xdb, 0xce, 0xa2, 0x79, 0xb5, 0x7e, 0xf9, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x40, 0x2e, 0x83,
	0xe5, 0xf3, 0x0b, 0x00, 0x00,
}

func (m *TokenCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AliasPaths) > 0 {
		for iNdEx := len(m.AliasPaths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AliasPaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Invariants != nil {
		{
			size, err := m.Invariants.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.CosmosCoinWrapperPaths) > 0 {
		for iNdEx := len(m.CosmosCoinWrapperPaths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CosmosCoinWrapperPaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.MintEscrowAddress) > 0 {
		i -= len(m.MintEscrowAddress)
		copy(dAtA[i:], m.MintEscrowAddress)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.MintEscrowAddress)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ValidTokenIds) > 0 {
		for iNdEx := len(m.ValidTokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidTokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.CreatedBy) > 0 {
		i -= len(m.CreatedBy)
		copy(dAtA[i:], m.CreatedBy)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CreatedBy)))
		i--
		dAtA[i] = 0x5a
	}
	if m.DefaultBalances != nil {
		{
			size, err := m.DefaultBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.IsArchived {
		i--
		if m.IsArchived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.Standards) > 0 {
		for iNdEx := len(m.Standards) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Standards[iNdEx])
			copy(dAtA[i:], m.Standards[iNdEx])
			i = encodeVarintCollections(dAtA, i, uint64(len(m.Standards[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenMetadata) > 0 {
		for iNdEx := len(m.TokenMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CollectionMetadata != nil {
		{
			size, err := m.CollectionMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Conversion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Conversion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Conversion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SideB) > 0 {
		for iNdEx := len(m.SideB) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SideB[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.SideA != nil {
		{
			size, err := m.SideA.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConversionSideAWithDenom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConversionSideAWithDenom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConversionSideAWithDenom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConversionWithoutDenom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConversionWithoutDenom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConversionWithoutDenom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SideB) > 0 {
		for iNdEx := len(m.SideB) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SideB[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.SideA != nil {
		{
			size, err := m.SideA.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConversionSideA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConversionSideA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConversionSideA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CosmosCoinWrapperPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosCoinWrapperPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosCoinWrapperPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.AllowOverrideWithAnyValidToken {
		i--
		if m.AllowOverrideWithAnyValidToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.DenomUnits) > 0 {
		for iNdEx := len(m.DenomUnits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DenomUnits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x22
	}
	if m.Conversion != nil {
		{
			size, err := m.Conversion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AliasPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AliasPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AliasPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DenomUnits) > 0 {
		for iNdEx := len(m.DenomUnits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DenomUnits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Conversion != nil {
		{
			size, err := m.Conversion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CosmosCoinBackedPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosCoinBackedPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosCoinBackedPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Conversion != nil {
		{
			size, err := m.Conversion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DenomUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenomUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenomUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IsDefaultDisplay {
		i--
		if m.IsDefaultDisplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Decimals.Size()
		i -= size
		if _, err := m.Decimals.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CollectionInvariants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionInvariants) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionInvariants) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisablePoolCreation {
		i--
		if m.DisablePoolCreation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.NoForcefulPostMintTransfers {
		i--
		if m.NoForcefulPostMintTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CosmosCoinBackedPath != nil {
		{
			size, err := m.CosmosCoinBackedPath.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.MaxSupplyPerId.Size()
		i -= size
		if _, err := m.MaxSupplyPerId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.NoCustomOwnershipTimes {
		i--
		if m.NoCustomOwnershipTimes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCollections(dAtA []byte, offset int, v uint64) int {
	offset -= sovCollections(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TokenCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovCollections(uint64(l))
	if m.CollectionMetadata != nil {
		l = m.CollectionMetadata.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.TokenMetadata) > 0 {
		for _, e := range m.TokenMetadata {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.Standards) > 0 {
		for _, s := range m.Standards {
			l = len(s)
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.IsArchived {
		n += 2
	}
	if m.DefaultBalances != nil {
		l = m.DefaultBalances.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.CreatedBy)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.ValidTokenIds) > 0 {
		for _, e := range m.ValidTokenIds {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.MintEscrowAddress)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.CosmosCoinWrapperPaths) > 0 {
		for _, e := range m.CosmosCoinWrapperPaths {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.Invariants != nil {
		l = m.Invariants.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.AliasPaths) > 0 {
		for _, e := range m.AliasPaths {
			l = e.Size()
			n += 2 + l + sovCollections(uint64(l))
		}
	}
	return n
}

func (m *Conversion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SideA != nil {
		l = m.SideA.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.SideB) > 0 {
		for _, e := range m.SideB {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	return n
}

func (m *ConversionSideAWithDenom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovCollections(uint64(l))
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *ConversionWithoutDenom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SideA != nil {
		l = m.SideA.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.SideB) > 0 {
		for _, e := range m.SideB {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	return n
}

func (m *ConversionSideA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovCollections(uint64(l))
	return n
}

func (m *CosmosCoinWrapperPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Conversion != nil {
		l = m.Conversion.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.DenomUnits) > 0 {
		for _, e := range m.DenomUnits {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.AllowOverrideWithAnyValidToken {
		n += 2
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *AliasPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Conversion != nil {
		l = m.Conversion.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.DenomUnits) > 0 {
		for _, e := range m.DenomUnits {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *CosmosCoinBackedPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.Conversion != nil {
		l = m.Conversion.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *DenomUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Decimals.Size()
	n += 1 + l + sovCollections(uint64(l))
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.IsDefaultDisplay {
		n += 2
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *CollectionInvariants) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoCustomOwnershipTimes {
		n += 2
	}
	l = m.MaxSupplyPerId.Size()
	n += 1 + l + sovCollections(uint64(l))
	if m.CosmosCoinBackedPath != nil {
		l = m.CosmosCoinBackedPath.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.NoForcefulPostMintTransfers {
		n += 2
	}
	if m.DisablePoolCreation {
		n += 2
	}
	return n
}

func sovCollections(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCollections(x uint64) (n int) {
	return sovCollections(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TokenCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionMetadata == nil {
				m.CollectionMetadata = &CollectionMetadata{}
			}
			if err := m.CollectionMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenMetadata = append(m.TokenMetadata, &TokenMetadata{})
			if err := m.TokenMetadata[len(m.TokenMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Standards = append(m.Standards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsArchived = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBalances == nil {
				m.DefaultBalances = &UserBalanceStore{}
			}
			if err := m.DefaultBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidTokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidTokenIds = append(m.ValidTokenIds, &UintRange{})
			if err := m.ValidTokenIds[len(m.ValidTokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintEscrowAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintEscrowAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinWrapperPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosCoinWrapperPaths = append(m.CosmosCoinWrapperPaths, &CosmosCoinWrapperPath{})
			if err := m.CosmosCoinWrapperPaths[len(m.CosmosCoinWrapperPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invariants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invariants == nil {
				m.Invariants = &CollectionInvariants{}
			}
			if err := m.Invariants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasPaths = append(m.AliasPaths, &AliasPath{})
			if err := m.AliasPaths[len(m.AliasPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Conversion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Conversion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Conversion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SideA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SideA == nil {
				m.SideA = &ConversionSideAWithDenom{}
			}
			if err := m.SideA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SideB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SideB = append(m.SideB, &Balance{})
			if err := m.SideB[len(m.SideB)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConversionSideAWithDenom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConversionSideAWithDenom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConversionSideAWithDenom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConversionWithoutDenom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConversionWithoutDenom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConversionWithoutDenom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SideA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SideA == nil {
				m.SideA = &ConversionSideA{}
			}
			if err := m.SideA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SideB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SideB = append(m.SideB, &Balance{})
			if err := m.SideB[len(m.SideB)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConversionSideA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConversionSideA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConversionSideA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosCoinWrapperPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosCoinWrapperPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosCoinWrapperPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conversion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conversion == nil {
				m.Conversion = &ConversionWithoutDenom{}
			}
			if err := m.Conversion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomUnits = append(m.DenomUnits, &DenomUnit{})
			if err := m.DenomUnits[len(m.DenomUnits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideWithAnyValidToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideWithAnyValidToken = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &PathMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AliasPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AliasPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AliasPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conversion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conversion == nil {
				m.Conversion = &ConversionWithoutDenom{}
			}
			if err := m.Conversion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomUnits = append(m.DenomUnits, &DenomUnit{})
			if err := m.DenomUnits[len(m.DenomUnits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &PathMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosCoinBackedPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosCoinBackedPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosCoinBackedPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conversion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conversion == nil {
				m.Conversion = &Conversion{}
			}
			if err := m.Conversion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenomUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenomUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenomUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Decimals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDefaultDisplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDefaultDisplay = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &PathMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionInvariants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionInvariants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionInvariants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCustomOwnershipTimes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoCustomOwnershipTimes = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSupplyPerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSupplyPerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinBackedPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CosmosCoinBackedPath == nil {
				m.CosmosCoinBackedPath = &CosmosCoinBackedPath{}
			}
			if err := m.CosmosCoinBackedPath.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoForcefulPostMintTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoForcefulPostMintTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePoolCreation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePoolCreation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCollections(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCollections
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCollections
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCollections
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCollections        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCollections          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCollections = fmt.Errorf("proto: unexpected end of group")
)
