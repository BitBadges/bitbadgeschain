// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tokenization/v23/user_balance_store.proto

package v23

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UserBalanceStore is the store for the user balances for a collection.
//
// It consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,
// as well as the permissions for updating the approved incoming/outgoing transfers.
//
// Upon initialization, all fields (minus the balances) are set to the defaults specified by the collection.
//
// The outgoing transfers can be used to allow / disallow transfers which are sent from this user.
// If a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)
// and autoApproveSelfInitiatedOutgoingTransfers is set to true.
//
// The incoming transfers can be used to allow / disallow transfers which are sent to this user.
// If a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)
// and autoApproveSelfInitiatedIncomingTransfers is set to true.
//
// Note that the user approved transfers are only checked if the collection approved transfers do not specify to override
// the user approved transfers.
//
// The permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.
type UserBalanceStore struct {
	// The list of balances associated with this user.
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
	// The list of approved outgoing transfers for this user.
	OutgoingApprovals []*UserOutgoingApproval `protobuf:"bytes,2,rep,name=outgoingApprovals,proto3" json:"outgoingApprovals,omitempty"`
	// The list of approved incoming transfers for this user.
	IncomingApprovals []*UserIncomingApproval `protobuf:"bytes,3,rep,name=incomingApprovals,proto3" json:"incomingApprovals,omitempty"`
	// Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).
	AutoApproveSelfInitiatedOutgoingTransfers bool `protobuf:"varint,4,opt,name=autoApproveSelfInitiatedOutgoingTransfers,proto3" json:"autoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).
	AutoApproveSelfInitiatedIncomingTransfers bool `protobuf:"varint,5,opt,name=autoApproveSelfInitiatedIncomingTransfers,proto3" json:"autoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// Whether to auto-approve all incoming transfers by default.
	// This is just shorthand for adding an accept everything incoming approval
	// with no restrictions.
	AutoApproveAllIncomingTransfers bool `protobuf:"varint,6,opt,name=autoApproveAllIncomingTransfers,proto3" json:"autoApproveAllIncomingTransfers,omitempty"`
	// The permissions for this user's actions and transfers.
	UserPermissions *UserPermissions `protobuf:"bytes,7,opt,name=userPermissions,proto3" json:"userPermissions,omitempty"`
}

func (m *UserBalanceStore) Reset()         { *m = UserBalanceStore{} }
func (m *UserBalanceStore) String() string { return proto.CompactTextString(m) }
func (*UserBalanceStore) ProtoMessage()    {}
func (*UserBalanceStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac2020c4dfee1583, []int{0}
}
func (m *UserBalanceStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserBalanceStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserBalanceStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserBalanceStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserBalanceStore.Merge(m, src)
}
func (m *UserBalanceStore) XXX_Size() int {
	return m.Size()
}
func (m *UserBalanceStore) XXX_DiscardUnknown() {
	xxx_messageInfo_UserBalanceStore.DiscardUnknown(m)
}

var xxx_messageInfo_UserBalanceStore proto.InternalMessageInfo

func (m *UserBalanceStore) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *UserBalanceStore) GetOutgoingApprovals() []*UserOutgoingApproval {
	if m != nil {
		return m.OutgoingApprovals
	}
	return nil
}

func (m *UserBalanceStore) GetIncomingApprovals() []*UserIncomingApproval {
	if m != nil {
		return m.IncomingApprovals
	}
	return nil
}

func (m *UserBalanceStore) GetAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (m *UserBalanceStore) GetAutoApproveSelfInitiatedIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (m *UserBalanceStore) GetAutoApproveAllIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveAllIncomingTransfers
	}
	return false
}

func (m *UserBalanceStore) GetUserPermissions() *UserPermissions {
	if m != nil {
		return m.UserPermissions
	}
	return nil
}

func init() {
	proto.RegisterType((*UserBalanceStore)(nil), "tokenization.v23.UserBalanceStore")
}

func init() {
	proto.RegisterFile("tokenization/v23/user_balance_store.proto", fileDescriptor_ac2020c4dfee1583)
}

var fileDescriptor_ac2020c4dfee1583 = []byte{
	// 376 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0x31, 0x4f, 0xf2, 0x40,
	0x18, 0xc7, 0xe9, 0x0b, 0x2f, 0x92, 0x63, 0x10, 0x1b, 0x87, 0xca, 0x50, 0x2a, 0x83, 0x81, 0xa5,
	0x4d, 0x4a, 0xdc, 0x5c, 0x60, 0x92, 0x38, 0x68, 0x0a, 0x3a, 0x18, 0x13, 0x72, 0x2d, 0x47, 0xb9,
	0x58, 0xee, 0x9a, 0xbb, 0x2b, 0x51, 0x3f, 0x85, 0x1f, 0x8b, 0x91, 0xd1, 0xd1, 0xc0, 0x17, 0x31,
	0x2d, 0xad, 0x40, 0xcf, 0xa0, 0xdb, 0x93, 0xf6, 0xf7, 0xff, 0x3d, 0x4f, 0x2e, 0x7f, 0xd0, 0x16,
	0xf4, 0x19, 0x11, 0xfc, 0x06, 0x05, 0xa6, 0xc4, 0x9a, 0xdb, 0x1d, 0x2b, 0xe2, 0x88, 0x8d, 0x5c,
	0x18, 0x40, 0xe2, 0xa1, 0x11, 0x17, 0x94, 0x21, 0x33, 0x64, 0x54, 0x50, 0xb5, 0xb6, 0x8b, 0x9a,
	0x73, 0xbb, 0x53, 0x3f, 0xf5, 0xa9, 0x4f, 0x93, 0x9f, 0x56, 0x3c, 0x6d, 0xb8, 0x7a, 0x43, 0x52,
	0xa6, 0x36, 0x9e, 0x02, 0x4d, 0x09, 0x08, 0x11, 0x9b, 0x61, 0xce, 0x31, 0x25, 0x19, 0x63, 0x48,
	0x0c, 0x0c, 0x43, 0x46, 0xe7, 0x30, 0x48, 0x89, 0xe6, 0xa2, 0x04, 0x6a, 0xf7, 0x1c, 0xb1, 0xde,
	0x46, 0x3e, 0x88, 0x2f, 0x55, 0x2f, 0x41, 0x25, 0x5b, 0xa6, 0x29, 0x46, 0xb1, 0x55, 0xb5, 0xcf,
	0xcc, 0xfc, 0xd9, 0x66, 0x9a, 0x70, 0xbe, 0x51, 0x75, 0x08, 0x4e, 0x68, 0x24, 0x7c, 0x8a, 0x89,
	0xdf, 0xcd, 0xd6, 0x68, 0xff, 0x92, 0xfc, 0x85, 0x9c, 0x8f, 0xb7, 0xde, 0xe6, 0x70, 0x47, 0x16,
	0xc4, 0x56, 0x4c, 0x3c, 0x3a, 0xdb, 0xb3, 0x16, 0x0f, 0x59, 0xfb, 0x39, 0xdc, 0x91, 0x05, 0xea,
	0x13, 0x68, 0xc3, 0x48, 0xd0, 0xcd, 0x07, 0x34, 0x40, 0xc1, 0xa4, 0x4f, 0xb0, 0xc0, 0x50, 0xa0,
	0x71, 0x76, 0xd4, 0x90, 0x41, 0xc2, 0x27, 0x88, 0x71, 0xad, 0x64, 0x28, 0xad, 0x8a, 0xf3, 0xf7,
	0xc0, 0x21, 0x7b, 0x76, 0xdc, 0xd6, 0xfe, 0xff, 0xb0, 0x5d, 0x0a, 0xa8, 0xd7, 0xa0, 0xb1, 0x03,
	0x77, 0x83, 0x40, 0x76, 0x96, 0x13, 0xe7, 0x6f, 0x98, 0x7a, 0x03, 0x8e, 0xe3, 0xa2, 0xde, 0x6d,
	0x8b, 0xa3, 0x1d, 0x19, 0x4a, 0xab, 0x6a, 0x9f, 0xff, 0xfc, 0xb2, 0x3b, 0xa0, 0x93, 0x4f, 0xf6,
	0x1e, 0x16, 0x2b, 0x5d, 0x59, 0xae, 0x74, 0xe5, 0x73, 0xa5, 0x2b, 0xef, 0x6b, 0xbd, 0xb0, 0x5c,
	0xeb, 0x85, 0x8f, 0xb5, 0x5e, 0x78, 0xbc, 0xf2, 0xb1, 0x98, 0x46, 0xae, 0xe9, 0xd1, 0x99, 0xe5,
	0x62, 0xe1, 0xc2, 0xb1, 0x8f, 0xf8, 0x76, 0xf2, 0xa6, 0x10, 0x13, 0xeb, 0xc5, 0xda, 0x2b, 0xab,
	0x78, 0x0d, 0x11, 0x8f, 0x2b, 0xeb, 0x96, 0x93, 0xa6, 0x76, 0xbe, 0x02, 0x00, 0x00, 0xff, 0xff,
	0xc0, 0x01, 0x0c, 0xf1, 0x65, 0x03, 0x00, 0x00,
}

func (m *UserBalanceStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserBalanceStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserBalanceStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserPermissions != nil {
		{
			size, err := m.UserPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUserBalanceStore(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.AutoApproveAllIncomingTransfers {
		i--
		if m.AutoApproveAllIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		i--
		if m.AutoApproveSelfInitiatedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		i--
		if m.AutoApproveSelfInitiatedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.IncomingApprovals) > 0 {
		for iNdEx := len(m.IncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IncomingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUserBalanceStore(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OutgoingApprovals) > 0 {
		for iNdEx := len(m.OutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutgoingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUserBalanceStore(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUserBalanceStore(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintUserBalanceStore(dAtA []byte, offset int, v uint64) int {
	offset -= sovUserBalanceStore(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserBalanceStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovUserBalanceStore(uint64(l))
		}
	}
	if len(m.OutgoingApprovals) > 0 {
		for _, e := range m.OutgoingApprovals {
			l = e.Size()
			n += 1 + l + sovUserBalanceStore(uint64(l))
		}
	}
	if len(m.IncomingApprovals) > 0 {
		for _, e := range m.IncomingApprovals {
			l = e.Size()
			n += 1 + l + sovUserBalanceStore(uint64(l))
		}
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		n += 2
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		n += 2
	}
	if m.AutoApproveAllIncomingTransfers {
		n += 2
	}
	if m.UserPermissions != nil {
		l = m.UserPermissions.Size()
		n += 1 + l + sovUserBalanceStore(uint64(l))
	}
	return n
}

func sovUserBalanceStore(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozUserBalanceStore(x uint64) (n int) {
	return sovUserBalanceStore(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserBalanceStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserBalanceStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserBalanceStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserBalanceStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserBalanceStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserBalanceStore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserBalanceStore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserBalanceStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserBalanceStore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserBalanceStore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutgoingApprovals = append(m.OutgoingApprovals, &UserOutgoingApproval{})
			if err := m.OutgoingApprovals[len(m.OutgoingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserBalanceStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserBalanceStore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserBalanceStore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncomingApprovals = append(m.IncomingApprovals, &UserIncomingApproval{})
			if err := m.IncomingApprovals[len(m.IncomingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserBalanceStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserBalanceStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveAllIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserBalanceStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveAllIncomingTransfers = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserBalanceStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserBalanceStore
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUserBalanceStore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPermissions == nil {
				m.UserPermissions = &UserPermissions{}
			}
			if err := m.UserPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserBalanceStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUserBalanceStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUserBalanceStore(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUserBalanceStore
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUserBalanceStore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUserBalanceStore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthUserBalanceStore
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupUserBalanceStore
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthUserBalanceStore
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthUserBalanceStore        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUserBalanceStore          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupUserBalanceStore = fmt.Errorf("proto: unexpected end of group")
)
