// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tokenization/v21/collections.proto

package v21

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A TokenCollection is the top-level object for a collection of tokens.
// It defines everything about the collection, such as the manager, metadata, etc.
//
// All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).
//
// All collections can have a manager who is responsible for managing the collection and can be granted certain admin
// permissions, such as the ability to mint new tokens.
//
// Certain fields are timeline-based, which means they may have different values at different block heights.
// We fetch the value according to the current time.
// For example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.
//
// Collections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.
//
// See documentation for more details.
type TokenCollection struct {
	// The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The metadata for the collection itself, which can vary over time.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,2,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// The metadata for each token in the collection, also subject to changes over time.
	TokenMetadataTimeline []*TokenMetadataTimeline `protobuf:"bytes,3,rep,name=tokenMetadataTimeline,proto3" json:"tokenMetadataTimeline,omitempty"`
	// An arbitrary field that can store any data, subject to changes over time.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,4,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// The address of the manager of this collection, subject to changes over time.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,5,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Permissions that define what the manager of the collection can do or not do.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,6,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Transferability of the collection for collections with standard balances, subject to changes over time.
	// Overrides user approvals for a transfer if specified.
	// Transfer must satisfy both user and collection-level approvals.
	// Only applicable to on-chain balances.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,7,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Standards that define how to interpret the fields of the collection, subject to changes over time.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,8,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// Whether the collection is archived or not, subject to changes over time.
	// When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,9,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// The default store of a balance / approvals for a user, upon genesis.
	DefaultBalances *UserBalanceStore `protobuf:"bytes,10,opt,name=defaultBalances,proto3" json:"defaultBalances,omitempty"`
	// The user or entity who created the collection.
	CreatedBy string `protobuf:"bytes,11,opt,name=createdBy,proto3" json:"createdBy,omitempty"`
	// The valid token IDs for this collection.
	ValidTokenIds []*UintRange `protobuf:"bytes,12,rep,name=validTokenIds,proto3" json:"validTokenIds,omitempty"`
	//The generated address of the collection. Also used to escrow Mint balances.
	MintEscrowAddress string `protobuf:"bytes,13,opt,name=mintEscrowAddress,proto3" json:"mintEscrowAddress,omitempty"`
	// The IBC wrapper (sdk.coin) paths for the collection.
	CosmosCoinWrapperPaths []*CosmosCoinWrapperPath `protobuf:"bytes,14,rep,name=cosmosCoinWrapperPaths,proto3" json:"cosmosCoinWrapperPaths,omitempty"`
	// Collection-level invariants that cannot be broken.
	// These are set upon genesis and cannot be modified.
	Invariants *CollectionInvariants `protobuf:"bytes,15,opt,name=invariants,proto3" json:"invariants,omitempty"`
}

func (m *TokenCollection) Reset()         { *m = TokenCollection{} }
func (m *TokenCollection) String() string { return proto.CompactTextString(m) }
func (*TokenCollection) ProtoMessage()    {}
func (*TokenCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9110e7d403045d, []int{0}
}
func (m *TokenCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenCollection.Merge(m, src)
}
func (m *TokenCollection) XXX_Size() int {
	return m.Size()
}
func (m *TokenCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenCollection.DiscardUnknown(m)
}

var xxx_messageInfo_TokenCollection proto.InternalMessageInfo

func (m *TokenCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *TokenCollection) GetTokenMetadataTimeline() []*TokenMetadataTimeline {
	if m != nil {
		return m.TokenMetadataTimeline
	}
	return nil
}

func (m *TokenCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *TokenCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *TokenCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *TokenCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *TokenCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *TokenCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *TokenCollection) GetDefaultBalances() *UserBalanceStore {
	if m != nil {
		return m.DefaultBalances
	}
	return nil
}

func (m *TokenCollection) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *TokenCollection) GetValidTokenIds() []*UintRange {
	if m != nil {
		return m.ValidTokenIds
	}
	return nil
}

func (m *TokenCollection) GetMintEscrowAddress() string {
	if m != nil {
		return m.MintEscrowAddress
	}
	return ""
}

func (m *TokenCollection) GetCosmosCoinWrapperPaths() []*CosmosCoinWrapperPath {
	if m != nil {
		return m.CosmosCoinWrapperPaths
	}
	return nil
}

func (m *TokenCollection) GetInvariants() *CollectionInvariants {
	if m != nil {
		return m.Invariants
	}
	return nil
}

type CosmosCoinWrapperPath struct {
	Address                        string       `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Denom                          string       `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Balances                       []*Balance   `protobuf:"bytes,3,rep,name=balances,proto3" json:"balances,omitempty"`
	Symbol                         string       `protobuf:"bytes,4,opt,name=symbol,proto3" json:"symbol,omitempty"`
	DenomUnits                     []*DenomUnit `protobuf:"bytes,5,rep,name=denomUnits,proto3" json:"denomUnits,omitempty"`
	AllowOverrideWithAnyValidToken bool         `protobuf:"varint,6,opt,name=allowOverrideWithAnyValidToken,proto3" json:"allowOverrideWithAnyValidToken,omitempty"`
	AllowCosmosWrapping            bool         `protobuf:"varint,7,opt,name=allowCosmosWrapping,proto3" json:"allowCosmosWrapping,omitempty"`
}

func (m *CosmosCoinWrapperPath) Reset()         { *m = CosmosCoinWrapperPath{} }
func (m *CosmosCoinWrapperPath) String() string { return proto.CompactTextString(m) }
func (*CosmosCoinWrapperPath) ProtoMessage()    {}
func (*CosmosCoinWrapperPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9110e7d403045d, []int{1}
}
func (m *CosmosCoinWrapperPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosCoinWrapperPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosCoinWrapperPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosCoinWrapperPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosCoinWrapperPath.Merge(m, src)
}
func (m *CosmosCoinWrapperPath) XXX_Size() int {
	return m.Size()
}
func (m *CosmosCoinWrapperPath) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosCoinWrapperPath.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosCoinWrapperPath proto.InternalMessageInfo

func (m *CosmosCoinWrapperPath) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *CosmosCoinWrapperPath) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetDenomUnits() []*DenomUnit {
	if m != nil {
		return m.DenomUnits
	}
	return nil
}

func (m *CosmosCoinWrapperPath) GetAllowOverrideWithAnyValidToken() bool {
	if m != nil {
		return m.AllowOverrideWithAnyValidToken
	}
	return false
}

func (m *CosmosCoinWrapperPath) GetAllowCosmosWrapping() bool {
	if m != nil {
		return m.AllowCosmosWrapping
	}
	return false
}

type CosmosCoinBackedPath struct {
	Address   string     `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	IbcDenom  string     `protobuf:"bytes,2,opt,name=ibcDenom,proto3" json:"ibcDenom,omitempty"`
	Balances  []*Balance `protobuf:"bytes,3,rep,name=balances,proto3" json:"balances,omitempty"`
	IbcAmount Uint       `protobuf:"bytes,4,opt,name=ibcAmount,proto3,customtype=Uint" json:"ibcAmount"`
}

func (m *CosmosCoinBackedPath) Reset()         { *m = CosmosCoinBackedPath{} }
func (m *CosmosCoinBackedPath) String() string { return proto.CompactTextString(m) }
func (*CosmosCoinBackedPath) ProtoMessage()    {}
func (*CosmosCoinBackedPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9110e7d403045d, []int{2}
}
func (m *CosmosCoinBackedPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosCoinBackedPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosCoinBackedPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosCoinBackedPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosCoinBackedPath.Merge(m, src)
}
func (m *CosmosCoinBackedPath) XXX_Size() int {
	return m.Size()
}
func (m *CosmosCoinBackedPath) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosCoinBackedPath.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosCoinBackedPath proto.InternalMessageInfo

func (m *CosmosCoinBackedPath) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CosmosCoinBackedPath) GetIbcDenom() string {
	if m != nil {
		return m.IbcDenom
	}
	return ""
}

func (m *CosmosCoinBackedPath) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

type DenomUnit struct {
	Decimals         Uint   `protobuf:"bytes,1,opt,name=decimals,proto3,customtype=Uint" json:"decimals"`
	Symbol           string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`
	IsDefaultDisplay bool   `protobuf:"varint,3,opt,name=isDefaultDisplay,proto3" json:"isDefaultDisplay,omitempty"`
}

func (m *DenomUnit) Reset()         { *m = DenomUnit{} }
func (m *DenomUnit) String() string { return proto.CompactTextString(m) }
func (*DenomUnit) ProtoMessage()    {}
func (*DenomUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9110e7d403045d, []int{3}
}
func (m *DenomUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenomUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenomUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenomUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenomUnit.Merge(m, src)
}
func (m *DenomUnit) XXX_Size() int {
	return m.Size()
}
func (m *DenomUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_DenomUnit.DiscardUnknown(m)
}

var xxx_messageInfo_DenomUnit proto.InternalMessageInfo

func (m *DenomUnit) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *DenomUnit) GetIsDefaultDisplay() bool {
	if m != nil {
		return m.IsDefaultDisplay
	}
	return false
}

// CollectionInvariants defines the invariants that apply to a collection.
type CollectionInvariants struct {
	// If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].
	// This prevents time-based restrictions on token ownership.
	NoCustomOwnershipTimes bool `protobuf:"varint,1,opt,name=noCustomOwnershipTimes,proto3" json:"noCustomOwnershipTimes,omitempty"`
	// Maximum supply per token ID. If set, no balance can exceed this amount.
	// This prevents any single token ID from having more than the specified supply.
	MaxSupplyPerId Uint `protobuf:"bytes,2,opt,name=maxSupplyPerId,proto3,customtype=Uint" json:"maxSupplyPerId"`
	// The IBC backed (sdk.coin) path for the collection. Only one path is allowed.
	CosmosCoinBackedPath *CosmosCoinBackedPath `protobuf:"bytes,3,opt,name=cosmosCoinBackedPath,proto3" json:"cosmosCoinBackedPath,omitempty"`
	// If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.
	// This prevents forceful transfers that bypass user-level approvals.
	// This only applies to transfers where the from address does not equal "Mint".
	NoForcefulPostMintTransfers bool `protobuf:"varint,4,opt,name=noForcefulPostMintTransfers,proto3" json:"noForcefulPostMintTransfers,omitempty"`
	// If true, disallows pool creation with this collection's assets.
	// When true, any attempt to create a pool with tokenization assets from this collection will fail.
	DisablePoolCreation bool `protobuf:"varint,5,opt,name=disablePoolCreation,proto3" json:"disablePoolCreation,omitempty"`
}

func (m *CollectionInvariants) Reset()         { *m = CollectionInvariants{} }
func (m *CollectionInvariants) String() string { return proto.CompactTextString(m) }
func (*CollectionInvariants) ProtoMessage()    {}
func (*CollectionInvariants) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9110e7d403045d, []int{4}
}
func (m *CollectionInvariants) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionInvariants) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionInvariants.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionInvariants) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionInvariants.Merge(m, src)
}
func (m *CollectionInvariants) XXX_Size() int {
	return m.Size()
}
func (m *CollectionInvariants) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionInvariants.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionInvariants proto.InternalMessageInfo

func (m *CollectionInvariants) GetNoCustomOwnershipTimes() bool {
	if m != nil {
		return m.NoCustomOwnershipTimes
	}
	return false
}

func (m *CollectionInvariants) GetCosmosCoinBackedPath() *CosmosCoinBackedPath {
	if m != nil {
		return m.CosmosCoinBackedPath
	}
	return nil
}

func (m *CollectionInvariants) GetNoForcefulPostMintTransfers() bool {
	if m != nil {
		return m.NoForcefulPostMintTransfers
	}
	return false
}

func (m *CollectionInvariants) GetDisablePoolCreation() bool {
	if m != nil {
		return m.DisablePoolCreation
	}
	return false
}

func init() {
	proto.RegisterType((*TokenCollection)(nil), "tokenization.v21.TokenCollection")
	proto.RegisterType((*CosmosCoinWrapperPath)(nil), "tokenization.v21.CosmosCoinWrapperPath")
	proto.RegisterType((*CosmosCoinBackedPath)(nil), "tokenization.v21.CosmosCoinBackedPath")
	proto.RegisterType((*DenomUnit)(nil), "tokenization.v21.DenomUnit")
	proto.RegisterType((*CollectionInvariants)(nil), "tokenization.v21.CollectionInvariants")
}

func init() {
	proto.RegisterFile("tokenization/v21/collections.proto", fileDescriptor_eb9110e7d403045d)
}

var fileDescriptor_eb9110e7d403045d = []byte{
	// 943 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdd, 0x6e, 0xdb, 0x36,
	0x14, 0x8e, 0xdd, 0xfc, 0xd8, 0x6c, 0xda, 0xb4, 0x6c, 0x1a, 0xa8, 0xee, 0xe0, 0x64, 0xde, 0xb0,
	0x05, 0x45, 0x61, 0xb7, 0xd9, 0xcf, 0xcd, 0x76, 0x31, 0xff, 0x2c, 0x80, 0xb1, 0x05, 0xf5, 0x18,
	0x27, 0x05, 0x0a, 0x0c, 0x03, 0x25, 0x32, 0x32, 0x51, 0x89, 0x14, 0x48, 0xda, 0xa9, 0xf7, 0x14,
	0xbb, 0xdd, 0x53, 0xec, 0x35, 0x7a, 0x33, 0xa0, 0x17, 0xbb, 0x18, 0x76, 0x51, 0x0c, 0xc9, 0x8b,
	0x0c, 0xa2, 0x64, 0xc9, 0xb6, 0xe8, 0x14, 0xd8, 0x9d, 0xc8, 0xf3, 0x9d, 0xef, 0x1c, 0x7e, 0x87,
	0xe7, 0x88, 0xa0, 0xa1, 0xc5, 0x6b, 0xca, 0xd9, 0xaf, 0x58, 0x33, 0xc1, 0x5b, 0x93, 0xa3, 0xe7,
	0x2d, 0x4f, 0x04, 0x01, 0xf5, 0xe2, 0xa5, 0x6a, 0x46, 0x52, 0x68, 0x01, 0xef, 0xcd, 0x63, 0x9a,
	0x93, 0xa3, 0xe7, 0xb5, 0x47, 0xbe, 0x10, 0x7e, 0x40, 0x5b, 0xc6, 0xee, 0x8e, 0x2f, 0x5a, 0x98,
	0x4f, 0x13, 0x70, 0xed, 0xa0, 0x40, 0xa8, 0x25, 0xe6, 0xea, 0x82, 0xca, 0x94, 0xae, 0xb6, 0x5f,
	0x40, 0xb8, 0x38, 0xc0, 0xdc, 0xa3, 0x33, 0x40, 0x31, 0xa7, 0x88, 0xca, 0x90, 0x29, 0x95, 0xe7,
	0x64, 0x21, 0x09, 0xa9, 0xc6, 0x04, 0x6b, 0xbc, 0x3a, 0x0f, 0x16, 0xd2, 0x80, 0xf1, 0x2c, 0xcc,
	0xae, 0x2f, 0x7c, 0x61, 0x3e, 0x5b, 0xf1, 0x57, 0xb2, 0xdb, 0xf8, 0xbd, 0x0a, 0x76, 0x86, 0xb1,
	0x6b, 0x37, 0xd3, 0x01, 0x3e, 0x03, 0xdb, 0xb9, 0x2a, 0x7d, 0xe2, 0x94, 0x0e, 0x4a, 0x87, 0xd5,
	0xce, 0xf6, 0xdb, 0xf7, 0xfb, 0x6b, 0xff, 0xbc, 0xdf, 0x5f, 0x3f, 0x63, 0x5c, 0xa3, 0x05, 0x04,
	0x0c, 0x40, 0x2d, 0x5f, 0x9f, 0xa4, 0x99, 0x0d, 0xd3, 0x04, 0x9c, 0xf2, 0xc1, 0xad, 0xc3, 0xdb,
	0x47, 0x4f, 0x9b, 0xcb, 0xba, 0x36, 0xbb, 0x2b, 0x7d, 0xd0, 0x0d, 0x7c, 0xf0, 0x67, 0xf0, 0xd0,
	0x50, 0x15, 0x02, 0xdd, 0x32, 0x81, 0x3e, 0x2f, 0x06, 0x1a, 0xda, 0xe0, 0xc8, 0xce, 0x02, 0x87,
	0x00, 0x7a, 0x63, 0xa5, 0x45, 0xd8, 0x9b, 0xe7, 0x5e, 0x37, 0xdc, 0x9f, 0x5a, 0x0e, 0x51, 0xc0,
	0x22, 0x8b, 0x3f, 0xfc, 0x01, 0xec, 0x84, 0x98, 0x63, 0x9f, 0xca, 0x8c, 0x72, 0xc3, 0x50, 0x7e,
	0x5c, 0xa4, 0x3c, 0x59, 0x04, 0xa2, 0x65, 0xcf, 0x58, 0x81, 0x5c, 0x9f, 0x41, 0x7e, 0x5b, 0x9c,
	0xcd, 0x83, 0x92, 0x5d, 0x81, 0xae, 0x0d, 0x8e, 0xec, 0x2c, 0xf0, 0x1c, 0x3c, 0xc8, 0x0d, 0xed,
	0x28, 0x92, 0x62, 0x82, 0x03, 0xe5, 0x6c, 0xad, 0x94, 0xa0, 0x00, 0x46, 0x36, 0x02, 0xf8, 0x13,
	0xb8, 0xaf, 0x34, 0xe6, 0x04, 0x4b, 0xa2, 0x32, 0x15, 0x2a, 0x86, 0xf5, 0x93, 0x22, 0xeb, 0xe9,
	0x32, 0x14, 0x15, 0xbd, 0xe3, 0x62, 0x31, 0xd5, 0x96, 0xde, 0x88, 0x4d, 0x28, 0xc9, 0x38, 0xab,
	0xab, 0x32, 0xed, 0x17, 0xb0, 0xc8, 0xe2, 0x0f, 0x7f, 0x04, 0x3b, 0x84, 0x5e, 0xe0, 0x71, 0xa0,
	0x3b, 0x69, 0xaf, 0x3a, 0xc0, 0x28, 0xdb, 0x28, 0x52, 0x9e, 0x29, 0x2a, 0x53, 0xd4, 0xa9, 0x16,
	0x92, 0xa2, 0x65, 0x57, 0xf8, 0x11, 0xa8, 0x7a, 0x92, 0x62, 0x4d, 0x49, 0x67, 0xea, 0xdc, 0x8e,
	0x9b, 0x09, 0xe5, 0x1b, 0xb0, 0x0d, 0xee, 0x4c, 0x70, 0xc0, 0x88, 0xb9, 0xa3, 0x7d, 0xa2, 0x9c,
	0x6d, 0x93, 0xfc, 0x63, 0x4b, 0xa4, 0xb8, 0xf1, 0x30, 0xf7, 0x29, 0x5a, 0xf4, 0x80, 0x4f, 0xc1,
	0xfd, 0x90, 0x71, 0xfd, 0xbd, 0xf2, 0xa4, 0xb8, 0x6c, 0x13, 0x22, 0xa9, 0x52, 0xce, 0x1d, 0x13,
	0xa8, 0x68, 0x80, 0xbf, 0x80, 0x3d, 0x4f, 0xa8, 0x50, 0xa8, 0xae, 0x60, 0xfc, 0xa5, 0xc4, 0x51,
	0x44, 0xe5, 0x00, 0xeb, 0x91, 0x72, 0xee, 0xae, 0xea, 0x9f, 0xae, 0x0d, 0x8f, 0x56, 0xd0, 0xc0,
	0x63, 0x00, 0x18, 0x9f, 0x60, 0xc9, 0x30, 0xd7, 0xca, 0xd9, 0x31, 0xc2, 0x7d, 0x76, 0xd3, 0xad,
	0xe9, 0x67, 0x68, 0x34, 0xe7, 0xd9, 0xf8, 0xb3, 0x0c, 0x1e, 0x5a, 0x23, 0x43, 0x07, 0x6c, 0xe1,
	0xf4, 0x98, 0x66, 0x38, 0xa1, 0xd9, 0x12, 0xee, 0x82, 0x0d, 0x42, 0xb9, 0x08, 0x9d, 0xb2, 0xd9,
	0x4f, 0x16, 0xf0, 0x2b, 0x50, 0x99, 0x0d, 0xdd, 0x74, 0x48, 0x3c, 0x2a, 0xe6, 0x93, 0xd6, 0x0b,
	0x65, 0x50, 0xb8, 0x07, 0x36, 0xd5, 0x34, 0x74, 0x45, 0xe0, 0xac, 0x1b, 0xb6, 0x74, 0x05, 0xbf,
	0x01, 0xc0, 0xf0, 0x9e, 0x71, 0xa6, 0x55, 0xda, 0xc6, 0x96, 0x7a, 0xf5, 0x66, 0x18, 0x34, 0x07,
	0x87, 0xc7, 0xa0, 0x8e, 0x83, 0x40, 0x5c, 0xbe, 0x98, 0x50, 0x29, 0x19, 0xa1, 0x2f, 0x99, 0x1e,
	0xb5, 0xf9, 0xf4, 0x3c, 0xab, 0xa8, 0x69, 0xe2, 0x0a, 0xfa, 0x00, 0x0a, 0x3e, 0x03, 0x0f, 0x0c,
	0x22, 0x51, 0xc8, 0xa8, 0xc3, 0xb8, 0xef, 0x6c, 0x19, 0x67, 0x9b, 0xa9, 0xf1, 0x47, 0x09, 0xec,
	0xe6, 0x7a, 0x76, 0xb0, 0xf7, 0x9a, 0x92, 0x0f, 0xc8, 0x59, 0x03, 0x15, 0xe6, 0x7a, 0xbd, 0x39,
	0x45, 0xb3, 0xf5, 0xff, 0x15, 0xf5, 0x09, 0xa8, 0x32, 0xd7, 0x6b, 0x87, 0x62, 0xcc, 0x75, 0xa2,
	0xeb, 0xd2, 0xaf, 0x25, 0x37, 0x37, 0xa6, 0xa0, 0x9a, 0x89, 0x08, 0x0f, 0x41, 0x85, 0x50, 0x8f,
	0x85, 0xf1, 0x28, 0xb2, 0xfd, 0x92, 0x32, 0xeb, 0x5c, 0xdd, 0xca, 0x0b, 0x75, 0x7b, 0x02, 0xee,
	0x31, 0xd5, 0x4b, 0xba, 0xb3, 0xc7, 0x54, 0x14, 0xe0, 0xa9, 0x73, 0xcb, 0xe8, 0x55, 0xd8, 0x6f,
	0xfc, 0x55, 0x8e, 0xc5, 0x2a, 0xde, 0x50, 0xf8, 0x35, 0xd8, 0xe3, 0x22, 0x19, 0xfa, 0x2f, 0x2e,
	0x39, 0x95, 0x6a, 0xc4, 0xa2, 0x78, 0x70, 0x24, 0x49, 0x55, 0xd0, 0x0a, 0x2b, 0xfc, 0x12, 0xdc,
	0x0d, 0xf1, 0x9b, 0xd3, 0x71, 0x14, 0x05, 0xd3, 0x01, 0x95, 0x7d, 0x92, 0x24, 0xb7, 0x74, 0x88,
	0x25, 0x0c, 0x7c, 0x05, 0x76, 0x3d, 0x4b, 0xc9, 0x4c, 0xda, 0x2b, 0xba, 0xaa, 0x88, 0x46, 0x56,
	0x0e, 0xf8, 0x1d, 0x78, 0xcc, 0xc5, 0xb1, 0x90, 0x1e, 0xbd, 0x18, 0x07, 0x03, 0xa1, 0xf4, 0x09,
	0xe3, 0x7a, 0x38, 0x7b, 0xbe, 0x98, 0xda, 0x54, 0xd0, 0x4d, 0x90, 0xf8, 0x0e, 0x12, 0xa6, 0xb0,
	0x1b, 0xd0, 0x81, 0x10, 0x41, 0x37, 0x9e, 0x69, 0x4c, 0x70, 0x67, 0x23, 0xb9, 0x83, 0x16, 0x53,
	0xe7, 0xfc, 0xed, 0x55, 0xbd, 0xf4, 0xee, 0xaa, 0x5e, 0xfa, 0xf7, 0xaa, 0x5e, 0xfa, 0xed, 0xba,
	0xbe, 0xf6, 0xee, 0xba, 0xbe, 0xf6, 0xf7, 0x75, 0x7d, 0xed, 0xd5, 0xb7, 0x3e, 0xd3, 0xa3, 0xb1,
	0xdb, 0xf4, 0x44, 0xd8, 0x72, 0x99, 0x76, 0x31, 0xf1, 0xa9, 0xca, 0xbf, 0xbc, 0x11, 0x66, 0xbc,
	0xf5, 0xa6, 0xb5, 0xf0, 0xce, 0xd1, 0xd3, 0x88, 0xaa, 0xf8, 0xb5, 0xe3, 0x6e, 0x9a, 0xe7, 0xcc,
	0x17, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x82, 0x7a, 0x5f, 0xeb, 0xe1, 0x09, 0x00, 0x00,
}

func (m *TokenCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Invariants != nil {
		{
			size, err := m.Invariants.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.CosmosCoinWrapperPaths) > 0 {
		for iNdEx := len(m.CosmosCoinWrapperPaths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CosmosCoinWrapperPaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.MintEscrowAddress) > 0 {
		i -= len(m.MintEscrowAddress)
		copy(dAtA[i:], m.MintEscrowAddress)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.MintEscrowAddress)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ValidTokenIds) > 0 {
		for iNdEx := len(m.ValidTokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidTokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.CreatedBy) > 0 {
		i -= len(m.CreatedBy)
		copy(dAtA[i:], m.CreatedBy)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CreatedBy)))
		i--
		dAtA[i] = 0x5a
	}
	if m.DefaultBalances != nil {
		{
			size, err := m.DefaultBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TokenMetadataTimeline) > 0 {
		for iNdEx := len(m.TokenMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CosmosCoinWrapperPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosCoinWrapperPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosCoinWrapperPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowCosmosWrapping {
		i--
		if m.AllowCosmosWrapping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.AllowOverrideWithAnyValidToken {
		i--
		if m.AllowOverrideWithAnyValidToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.DenomUnits) > 0 {
		for iNdEx := len(m.DenomUnits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DenomUnits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CosmosCoinBackedPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosCoinBackedPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosCoinBackedPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.IbcAmount.Size()
		i -= size
		if _, err := m.IbcAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.IbcDenom) > 0 {
		i -= len(m.IbcDenom)
		copy(dAtA[i:], m.IbcDenom)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.IbcDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DenomUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenomUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenomUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsDefaultDisplay {
		i--
		if m.IsDefaultDisplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Decimals.Size()
		i -= size
		if _, err := m.Decimals.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CollectionInvariants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionInvariants) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionInvariants) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisablePoolCreation {
		i--
		if m.DisablePoolCreation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.NoForcefulPostMintTransfers {
		i--
		if m.NoForcefulPostMintTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CosmosCoinBackedPath != nil {
		{
			size, err := m.CosmosCoinBackedPath.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.MaxSupplyPerId.Size()
		i -= size
		if _, err := m.MaxSupplyPerId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.NoCustomOwnershipTimes {
		i--
		if m.NoCustomOwnershipTimes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCollections(dAtA []byte, offset int, v uint64) int {
	offset -= sovCollections(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TokenCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovCollections(uint64(l))
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.TokenMetadataTimeline) > 0 {
		for _, e := range m.TokenMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.DefaultBalances != nil {
		l = m.DefaultBalances.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.CreatedBy)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.ValidTokenIds) > 0 {
		for _, e := range m.ValidTokenIds {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.MintEscrowAddress)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.CosmosCoinWrapperPaths) > 0 {
		for _, e := range m.CosmosCoinWrapperPaths {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.Invariants != nil {
		l = m.Invariants.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *CosmosCoinWrapperPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.DenomUnits) > 0 {
		for _, e := range m.DenomUnits {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.AllowOverrideWithAnyValidToken {
		n += 2
	}
	if m.AllowCosmosWrapping {
		n += 2
	}
	return n
}

func (m *CosmosCoinBackedPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.IbcDenom)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = m.IbcAmount.Size()
	n += 1 + l + sovCollections(uint64(l))
	return n
}

func (m *DenomUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Decimals.Size()
	n += 1 + l + sovCollections(uint64(l))
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.IsDefaultDisplay {
		n += 2
	}
	return n
}

func (m *CollectionInvariants) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoCustomOwnershipTimes {
		n += 2
	}
	l = m.MaxSupplyPerId.Size()
	n += 1 + l + sovCollections(uint64(l))
	if m.CosmosCoinBackedPath != nil {
		l = m.CosmosCoinBackedPath.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.NoForcefulPostMintTransfers {
		n += 2
	}
	if m.DisablePoolCreation {
		n += 2
	}
	return n
}

func sovCollections(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCollections(x uint64) (n int) {
	return sovCollections(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TokenCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenMetadataTimeline = append(m.TokenMetadataTimeline, &TokenMetadataTimeline{})
			if err := m.TokenMetadataTimeline[len(m.TokenMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBalances == nil {
				m.DefaultBalances = &UserBalanceStore{}
			}
			if err := m.DefaultBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidTokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidTokenIds = append(m.ValidTokenIds, &UintRange{})
			if err := m.ValidTokenIds[len(m.ValidTokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintEscrowAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintEscrowAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinWrapperPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosCoinWrapperPaths = append(m.CosmosCoinWrapperPaths, &CosmosCoinWrapperPath{})
			if err := m.CosmosCoinWrapperPaths[len(m.CosmosCoinWrapperPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invariants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invariants == nil {
				m.Invariants = &CollectionInvariants{}
			}
			if err := m.Invariants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosCoinWrapperPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosCoinWrapperPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosCoinWrapperPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomUnits = append(m.DenomUnits, &DenomUnit{})
			if err := m.DenomUnits[len(m.DenomUnits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideWithAnyValidToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideWithAnyValidToken = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCosmosWrapping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowCosmosWrapping = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosCoinBackedPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosCoinBackedPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosCoinBackedPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IbcDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IbcAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenomUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenomUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenomUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Decimals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDefaultDisplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDefaultDisplay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionInvariants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionInvariants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionInvariants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCustomOwnershipTimes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoCustomOwnershipTimes = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSupplyPerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSupplyPerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinBackedPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CosmosCoinBackedPath == nil {
				m.CosmosCoinBackedPath = &CosmosCoinBackedPath{}
			}
			if err := m.CosmosCoinBackedPath.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoForcefulPostMintTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoForcefulPostMintTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePoolCreation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePoolCreation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCollections(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCollections
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCollections
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCollections
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCollections        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCollections          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCollections = fmt.Errorf("proto: unexpected end of group")
)
