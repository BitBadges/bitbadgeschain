// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tokenization/v21/transfers.proto

package v21

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UserBalanceStore is the store for the user balances for a collection.
//
// It consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,
// as well as the permissions for updating the approved incoming/outgoing transfers.
//
// Upon initialization, all fields (minus the balances) are set to the defaults specified by the collection.
//
// The outgoing transfers can be used to allow / disallow transfers which are sent from this user.
// If a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)
// and autoApproveSelfInitiatedOutgoingTransfers is set to true.
//
// The incoming transfers can be used to allow / disallow transfers which are sent to this user.
// If a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)
// and autoApproveSelfInitiatedIncomingTransfers is set to true.
//
// Note that the user approved transfers are only checked if the collection approved transfers do not specify to override
// the user approved transfers.
//
// The permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.
type UserBalanceStore struct {
	// The list of balances associated with this user.
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
	// The list of approved outgoing transfers for this user.
	OutgoingApprovals []*UserOutgoingApproval `protobuf:"bytes,2,rep,name=outgoingApprovals,proto3" json:"outgoingApprovals,omitempty"`
	// The list of approved incoming transfers for this user.
	IncomingApprovals []*UserIncomingApproval `protobuf:"bytes,3,rep,name=incomingApprovals,proto3" json:"incomingApprovals,omitempty"`
	// Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).
	AutoApproveSelfInitiatedOutgoingTransfers bool `protobuf:"varint,4,opt,name=autoApproveSelfInitiatedOutgoingTransfers,proto3" json:"autoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).
	AutoApproveSelfInitiatedIncomingTransfers bool `protobuf:"varint,5,opt,name=autoApproveSelfInitiatedIncomingTransfers,proto3" json:"autoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// Whether to auto-approve all incoming transfers by default.
	// This is just shorthand for adding an accept everything incoming approval
	// with no restrictions.
	AutoApproveAllIncomingTransfers bool `protobuf:"varint,6,opt,name=autoApproveAllIncomingTransfers,proto3" json:"autoApproveAllIncomingTransfers,omitempty"`
	// The permissions for this user's actions and transfers.
	UserPermissions *UserPermissions `protobuf:"bytes,7,opt,name=userPermissions,proto3" json:"userPermissions,omitempty"`
}

func (m *UserBalanceStore) Reset()         { *m = UserBalanceStore{} }
func (m *UserBalanceStore) String() string { return proto.CompactTextString(m) }
func (*UserBalanceStore) ProtoMessage()    {}
func (*UserBalanceStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{0}
}
func (m *UserBalanceStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserBalanceStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserBalanceStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserBalanceStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserBalanceStore.Merge(m, src)
}
func (m *UserBalanceStore) XXX_Size() int {
	return m.Size()
}
func (m *UserBalanceStore) XXX_DiscardUnknown() {
	xxx_messageInfo_UserBalanceStore.DiscardUnknown(m)
}

var xxx_messageInfo_UserBalanceStore proto.InternalMessageInfo

func (m *UserBalanceStore) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *UserBalanceStore) GetOutgoingApprovals() []*UserOutgoingApproval {
	if m != nil {
		return m.OutgoingApprovals
	}
	return nil
}

func (m *UserBalanceStore) GetIncomingApprovals() []*UserIncomingApproval {
	if m != nil {
		return m.IncomingApprovals
	}
	return nil
}

func (m *UserBalanceStore) GetAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (m *UserBalanceStore) GetAutoApproveSelfInitiatedIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (m *UserBalanceStore) GetAutoApproveAllIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveAllIncomingTransfers
	}
	return false
}

func (m *UserBalanceStore) GetUserPermissions() *UserPermissions {
	if m != nil {
		return m.UserPermissions
	}
	return nil
}

// Challenges define a rule for the approval in the form of a Merkle challenge.
//
// A Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,
// then the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.
//
// IMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.
//
// IMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.
// If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
// We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
type MerkleChallenge struct {
	// The root hash of the Merkle tree to which the Merkle path must lead for verification.
	Root string `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty"`
	// The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.
	ExpectedProofLength Uint `protobuf:"bytes,2,opt,name=expectedProofLength,proto3,customtype=Uint" json:"expectedProofLength"`
	// If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.
	UseCreatorAddressAsLeaf bool `protobuf:"varint,3,opt,name=useCreatorAddressAsLeaf,proto3" json:"useCreatorAddressAsLeaf,omitempty"`
	// The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.
	MaxUsesPerLeaf Uint `protobuf:"bytes,4,opt,name=maxUsesPerLeaf,proto3,customtype=Uint" json:"maxUsesPerLeaf"`
	// The URI associated with this Merkle challenge, optionally providing metadata about the challenge.
	Uri string `protobuf:"bytes,5,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this Merkle challenge.
	CustomData string `protobuf:"bytes,6,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this Merkle challenge for tracking the number of uses per leaf.
	ChallengeTrackerId string `protobuf:"bytes,7,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	// Leaf must be signed by. Used to protect against man in the middle attacks.`
	// Scheme we use is sign(leaf + "-" +
	LeafSigner string `protobuf:"bytes,8,opt,name=leafSigner,proto3" json:"leafSigner,omitempty"`
}

func (m *MerkleChallenge) Reset()         { *m = MerkleChallenge{} }
func (m *MerkleChallenge) String() string { return proto.CompactTextString(m) }
func (*MerkleChallenge) ProtoMessage()    {}
func (*MerkleChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{1}
}
func (m *MerkleChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerkleChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerkleChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerkleChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerkleChallenge.Merge(m, src)
}
func (m *MerkleChallenge) XXX_Size() int {
	return m.Size()
}
func (m *MerkleChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_MerkleChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_MerkleChallenge proto.InternalMessageInfo

func (m *MerkleChallenge) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

func (m *MerkleChallenge) GetUseCreatorAddressAsLeaf() bool {
	if m != nil {
		return m.UseCreatorAddressAsLeaf
	}
	return false
}

func (m *MerkleChallenge) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *MerkleChallenge) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *MerkleChallenge) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *MerkleChallenge) GetLeafSigner() string {
	if m != nil {
		return m.LeafSigner
	}
	return ""
}

// ETHSignatureChallenge defines a rule for the approval in the form of an Ethereum signature challenge.
//
// An ETH signature challenge is a challenge where the user must provide a valid Ethereum signature for a specific nonce.
// The signature scheme is ETHSign(nonce + "-" + creatorAddress) and each signature can only be used once.
// All challenges must be met with valid solutions for the transfer to be approved.
//
// IMPORTANT: We track the usage of each signature to prevent replay attacks. Each signature can only be used once.
// If you update the challenge ID, then the used signatures tracker will reset and start a new tally.
// We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
type ETHSignatureChallenge struct {
	// The Ethereum address that must sign the nonce for verification.
	Signer string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	// The ID of this ETH signature challenge for tracking the number of uses per signature.
	ChallengeTrackerId string `protobuf:"bytes,2,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	// The URI associated with this ETH signature challenge, optionally providing metadata about the challenge.
	Uri string `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this ETH signature challenge.
	CustomData string `protobuf:"bytes,4,opt,name=customData,proto3" json:"customData,omitempty"`
}

func (m *ETHSignatureChallenge) Reset()         { *m = ETHSignatureChallenge{} }
func (m *ETHSignatureChallenge) String() string { return proto.CompactTextString(m) }
func (*ETHSignatureChallenge) ProtoMessage()    {}
func (*ETHSignatureChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{2}
}
func (m *ETHSignatureChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ETHSignatureChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ETHSignatureChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ETHSignatureChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ETHSignatureChallenge.Merge(m, src)
}
func (m *ETHSignatureChallenge) XXX_Size() int {
	return m.Size()
}
func (m *ETHSignatureChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_ETHSignatureChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_ETHSignatureChallenge proto.InternalMessageInfo

func (m *ETHSignatureChallenge) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *ETHSignatureChallenge) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *ETHSignatureChallenge) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *ETHSignatureChallenge) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

// UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.
type UserOutgoingApproval struct {
	// The list ID for the recipient of the transfer.
	ToListId string `protobuf:"bytes,1,opt,name=toListId,proto3" json:"toListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,2,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of token IDs for approval.
	TokenIds []*UintRange `protobuf:"bytes,4,rep,name=tokenIds,proto3" json:"tokenIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,6,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,7,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,8,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *OutgoingApprovalCriteria `protobuf:"bytes,9,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
	// Version of the approval. Maintained internally.
	Version Uint `protobuf:"bytes,10,opt,name=version,proto3,customtype=Uint" json:"version"`
}

func (m *UserOutgoingApproval) Reset()         { *m = UserOutgoingApproval{} }
func (m *UserOutgoingApproval) String() string { return proto.CompactTextString(m) }
func (*UserOutgoingApproval) ProtoMessage()    {}
func (*UserOutgoingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{3}
}
func (m *UserOutgoingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserOutgoingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserOutgoingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserOutgoingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserOutgoingApproval.Merge(m, src)
}
func (m *UserOutgoingApproval) XXX_Size() int {
	return m.Size()
}
func (m *UserOutgoingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_UserOutgoingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_UserOutgoingApproval proto.InternalMessageInfo

func (m *UserOutgoingApproval) GetToListId() string {
	if m != nil {
		return m.ToListId
	}
	return ""
}

func (m *UserOutgoingApproval) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *UserOutgoingApproval) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserOutgoingApproval) GetTokenIds() []*UintRange {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

func (m *UserOutgoingApproval) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserOutgoingApproval) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *UserOutgoingApproval) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *UserOutgoingApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *UserOutgoingApproval) GetApprovalCriteria() *OutgoingApprovalCriteria {
	if m != nil {
		return m.ApprovalCriteria
	}
	return nil
}

// UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.
type UserIncomingApproval struct {
	// The list ID for the sender of the transfer.
	FromListId string `protobuf:"bytes,1,opt,name=fromListId,proto3" json:"fromListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,2,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of token IDs for approval.
	TokenIds []*UintRange `protobuf:"bytes,4,rep,name=tokenIds,proto3" json:"tokenIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,6,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,7,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,8,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *IncomingApprovalCriteria `protobuf:"bytes,9,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
	// Version of the approval. Maintained internally.
	Version Uint `protobuf:"bytes,10,opt,name=version,proto3,customtype=Uint" json:"version"`
}

func (m *UserIncomingApproval) Reset()         { *m = UserIncomingApproval{} }
func (m *UserIncomingApproval) String() string { return proto.CompactTextString(m) }
func (*UserIncomingApproval) ProtoMessage()    {}
func (*UserIncomingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{4}
}
func (m *UserIncomingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserIncomingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserIncomingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserIncomingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserIncomingApproval.Merge(m, src)
}
func (m *UserIncomingApproval) XXX_Size() int {
	return m.Size()
}
func (m *UserIncomingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_UserIncomingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_UserIncomingApproval proto.InternalMessageInfo

func (m *UserIncomingApproval) GetFromListId() string {
	if m != nil {
		return m.FromListId
	}
	return ""
}

func (m *UserIncomingApproval) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *UserIncomingApproval) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserIncomingApproval) GetTokenIds() []*UintRange {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

func (m *UserIncomingApproval) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserIncomingApproval) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *UserIncomingApproval) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *UserIncomingApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *UserIncomingApproval) GetApprovalCriteria() *IncomingApprovalCriteria {
	if m != nil {
		return m.ApprovalCriteria
	}
	return nil
}

// ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.
type ManualBalances struct {
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
}

func (m *ManualBalances) Reset()         { *m = ManualBalances{} }
func (m *ManualBalances) String() string { return proto.CompactTextString(m) }
func (*ManualBalances) ProtoMessage()    {}
func (*ManualBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{5}
}
func (m *ManualBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ManualBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ManualBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ManualBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManualBalances.Merge(m, src)
}
func (m *ManualBalances) XXX_Size() int {
	return m.Size()
}
func (m *ManualBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_ManualBalances.DiscardUnknown(m)
}

var xxx_messageInfo_ManualBalances proto.InternalMessageInfo

func (m *ManualBalances) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

// RecurringOwnershipTimes represents a list of recurring ownership times.
type RecurringOwnershipTimes struct {
	// The original start time of the first interval.
	StartTime Uint `protobuf:"bytes,1,opt,name=startTime,proto3,customtype=Uint" json:"startTime"`
	// The interval length in unix milliseconds.
	IntervalLength Uint `protobuf:"bytes,2,opt,name=intervalLength,proto3,customtype=Uint" json:"intervalLength"`
	// Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period
	ChargePeriodLength Uint `protobuf:"bytes,3,opt,name=chargePeriodLength,proto3,customtype=Uint" json:"chargePeriodLength"`
}

func (m *RecurringOwnershipTimes) Reset()         { *m = RecurringOwnershipTimes{} }
func (m *RecurringOwnershipTimes) String() string { return proto.CompactTextString(m) }
func (*RecurringOwnershipTimes) ProtoMessage()    {}
func (*RecurringOwnershipTimes) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{6}
}
func (m *RecurringOwnershipTimes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecurringOwnershipTimes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecurringOwnershipTimes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecurringOwnershipTimes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecurringOwnershipTimes.Merge(m, src)
}
func (m *RecurringOwnershipTimes) XXX_Size() int {
	return m.Size()
}
func (m *RecurringOwnershipTimes) XXX_DiscardUnknown() {
	xxx_messageInfo_RecurringOwnershipTimes.DiscardUnknown(m)
}

var xxx_messageInfo_RecurringOwnershipTimes proto.InternalMessageInfo

// IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.
type IncrementedBalances struct {
	StartBalances []*Balance `protobuf:"bytes,1,rep,name=startBalances,proto3" json:"startBalances,omitempty"`
	// The amount by which to increment token IDs.
	IncrementTokenIdsBy Uint `protobuf:"bytes,2,opt,name=incrementTokenIdsBy,proto3,customtype=Uint" json:"incrementTokenIdsBy"`
	// The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.
	IncrementOwnershipTimesBy Uint `protobuf:"bytes,3,opt,name=incrementOwnershipTimesBy,proto3,customtype=Uint" json:"incrementOwnershipTimesBy"`
	// The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.
	DurationFromTimestamp Uint `protobuf:"bytes,4,opt,name=durationFromTimestamp,proto3,customtype=Uint" json:"durationFromTimestamp"`
	// Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).
	AllowOverrideTimestamp bool `protobuf:"varint,5,opt,name=allowOverrideTimestamp,proto3" json:"allowOverrideTimestamp,omitempty"`
	// Recurring ownership times.
	RecurringOwnershipTimes *RecurringOwnershipTimes `protobuf:"bytes,6,opt,name=recurringOwnershipTimes,proto3" json:"recurringOwnershipTimes,omitempty"`
	// Allow override of any valid ID
	AllowOverrideWithAnyValidToken bool `protobuf:"varint,7,opt,name=allowOverrideWithAnyValidToken,proto3" json:"allowOverrideWithAnyValidToken,omitempty"`
}

func (m *IncrementedBalances) Reset()         { *m = IncrementedBalances{} }
func (m *IncrementedBalances) String() string { return proto.CompactTextString(m) }
func (*IncrementedBalances) ProtoMessage()    {}
func (*IncrementedBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{7}
}
func (m *IncrementedBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrementedBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncrementedBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncrementedBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrementedBalances.Merge(m, src)
}
func (m *IncrementedBalances) XXX_Size() int {
	return m.Size()
}
func (m *IncrementedBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrementedBalances.DiscardUnknown(m)
}

var xxx_messageInfo_IncrementedBalances proto.InternalMessageInfo

func (m *IncrementedBalances) GetStartBalances() []*Balance {
	if m != nil {
		return m.StartBalances
	}
	return nil
}

func (m *IncrementedBalances) GetAllowOverrideTimestamp() bool {
	if m != nil {
		return m.AllowOverrideTimestamp
	}
	return false
}

func (m *IncrementedBalances) GetRecurringOwnershipTimes() *RecurringOwnershipTimes {
	if m != nil {
		return m.RecurringOwnershipTimes
	}
	return nil
}

func (m *IncrementedBalances) GetAllowOverrideWithAnyValidToken() bool {
	if m != nil {
		return m.AllowOverrideWithAnyValidToken
	}
	return false
}

// PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.
type PredeterminedOrderCalculationMethod struct {
	// Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.
	UseOverallNumTransfers bool `protobuf:"varint,1,opt,name=useOverallNumTransfers,proto3" json:"useOverallNumTransfers,omitempty"`
	// Use the number of transfers per "to" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.
	UsePerToAddressNumTransfers bool `protobuf:"varint,2,opt,name=usePerToAddressNumTransfers,proto3" json:"usePerToAddressNumTransfers,omitempty"`
	// Use the number of transfers per "from" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.
	UsePerFromAddressNumTransfers bool `protobuf:"varint,3,opt,name=usePerFromAddressNumTransfers,proto3" json:"usePerFromAddressNumTransfers,omitempty"`
	// Use the number of transfers per "initiated by" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.
	UsePerInitiatedByAddressNumTransfers bool `protobuf:"varint,4,opt,name=usePerInitiatedByAddressNumTransfers,proto3" json:"usePerInitiatedByAddressNumTransfers,omitempty"`
	// Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.
	UseMerkleChallengeLeafIndex bool `protobuf:"varint,5,opt,name=useMerkleChallengeLeafIndex,proto3" json:"useMerkleChallengeLeafIndex,omitempty"`
	// If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.
	ChallengeTrackerId string `protobuf:"bytes,6,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
}

func (m *PredeterminedOrderCalculationMethod) Reset()         { *m = PredeterminedOrderCalculationMethod{} }
func (m *PredeterminedOrderCalculationMethod) String() string { return proto.CompactTextString(m) }
func (*PredeterminedOrderCalculationMethod) ProtoMessage()    {}
func (*PredeterminedOrderCalculationMethod) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{8}
}
func (m *PredeterminedOrderCalculationMethod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredeterminedOrderCalculationMethod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredeterminedOrderCalculationMethod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredeterminedOrderCalculationMethod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredeterminedOrderCalculationMethod.Merge(m, src)
}
func (m *PredeterminedOrderCalculationMethod) XXX_Size() int {
	return m.Size()
}
func (m *PredeterminedOrderCalculationMethod) XXX_DiscardUnknown() {
	xxx_messageInfo_PredeterminedOrderCalculationMethod.DiscardUnknown(m)
}

var xxx_messageInfo_PredeterminedOrderCalculationMethod proto.InternalMessageInfo

func (m *PredeterminedOrderCalculationMethod) GetUseOverallNumTransfers() bool {
	if m != nil {
		return m.UseOverallNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerToAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerToAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerFromAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerFromAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerInitiatedByAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerInitiatedByAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUseMerkleChallengeLeafIndex() bool {
	if m != nil {
		return m.UseMerkleChallengeLeafIndex
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

// PredeterminedBalances represents balances with predetermined order calculation.
type PredeterminedBalances struct {
	// Manual balances that can be entered. If this is nil, then we use the incremented balances.
	ManualBalances []*ManualBalances `protobuf:"bytes,1,rep,name=manualBalances,proto3" json:"manualBalances,omitempty"`
	// Balances that have a starting amount and increment. If this is nil, then we use the manual balances.
	IncrementedBalances *IncrementedBalances `protobuf:"bytes,2,opt,name=incrementedBalances,proto3" json:"incrementedBalances,omitempty"`
	// The method to calculate the order of predetermined balances.
	OrderCalculationMethod *PredeterminedOrderCalculationMethod `protobuf:"bytes,3,opt,name=orderCalculationMethod,proto3" json:"orderCalculationMethod,omitempty"`
}

func (m *PredeterminedBalances) Reset()         { *m = PredeterminedBalances{} }
func (m *PredeterminedBalances) String() string { return proto.CompactTextString(m) }
func (*PredeterminedBalances) ProtoMessage()    {}
func (*PredeterminedBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{9}
}
func (m *PredeterminedBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredeterminedBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredeterminedBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredeterminedBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredeterminedBalances.Merge(m, src)
}
func (m *PredeterminedBalances) XXX_Size() int {
	return m.Size()
}
func (m *PredeterminedBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_PredeterminedBalances.DiscardUnknown(m)
}

var xxx_messageInfo_PredeterminedBalances proto.InternalMessageInfo

func (m *PredeterminedBalances) GetManualBalances() []*ManualBalances {
	if m != nil {
		return m.ManualBalances
	}
	return nil
}

func (m *PredeterminedBalances) GetIncrementedBalances() *IncrementedBalances {
	if m != nil {
		return m.IncrementedBalances
	}
	return nil
}

func (m *PredeterminedBalances) GetOrderCalculationMethod() *PredeterminedOrderCalculationMethod {
	if m != nil {
		return m.OrderCalculationMethod
	}
	return nil
}

// AutoDeletionOptions defines the options for auto-deletion of approvals.
type AutoDeletionOptions struct {
	// After one use?
	AfterOneUse bool `protobuf:"varint,1,opt,name=afterOneUse,proto3" json:"afterOneUse,omitempty"`
	// After overall max number of uses threshold is met?
	AfterOverallMaxNumTransfers bool `protobuf:"varint,2,opt,name=afterOverallMaxNumTransfers,proto3" json:"afterOverallMaxNumTransfers,omitempty"`
	// Allow counterparty to purge this approval if they are the only initiator
	AllowCounterpartyPurge bool `protobuf:"varint,3,opt,name=allowCounterpartyPurge,proto3" json:"allowCounterpartyPurge,omitempty"`
	// Allow others to call PurgeApprovals on behalf of this approval owner
	AllowPurgeIfExpired bool `protobuf:"varint,4,opt,name=allowPurgeIfExpired,proto3" json:"allowPurgeIfExpired,omitempty"`
}

func (m *AutoDeletionOptions) Reset()         { *m = AutoDeletionOptions{} }
func (m *AutoDeletionOptions) String() string { return proto.CompactTextString(m) }
func (*AutoDeletionOptions) ProtoMessage()    {}
func (*AutoDeletionOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{10}
}
func (m *AutoDeletionOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutoDeletionOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutoDeletionOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutoDeletionOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutoDeletionOptions.Merge(m, src)
}
func (m *AutoDeletionOptions) XXX_Size() int {
	return m.Size()
}
func (m *AutoDeletionOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_AutoDeletionOptions.DiscardUnknown(m)
}

var xxx_messageInfo_AutoDeletionOptions proto.InternalMessageInfo

func (m *AutoDeletionOptions) GetAfterOneUse() bool {
	if m != nil {
		return m.AfterOneUse
	}
	return false
}

func (m *AutoDeletionOptions) GetAfterOverallMaxNumTransfers() bool {
	if m != nil {
		return m.AfterOverallMaxNumTransfers
	}
	return false
}

func (m *AutoDeletionOptions) GetAllowCounterpartyPurge() bool {
	if m != nil {
		return m.AllowCounterpartyPurge
	}
	return false
}

func (m *AutoDeletionOptions) GetAllowPurgeIfExpired() bool {
	if m != nil {
		return m.AllowPurgeIfExpired
	}
	return false
}

// ApprovalAmounts defines approval amounts per unique "from," "to," and/or "initiated by" address.
// If any of these are nil or "0", we assume unlimited approvals.
// If they are set to a value, then the running tally of the amounts transferred for the specified token IDs and ownership times
// must not exceed the corresponding value.
type ApprovalAmounts struct {
	// Overall approval amount.
	OverallApprovalAmount Uint `protobuf:"bytes,1,opt,name=overallApprovalAmount,proto3,customtype=Uint" json:"overallApprovalAmount"`
	// Approval amount per "to" address.
	PerToAddressApprovalAmount Uint `protobuf:"bytes,2,opt,name=perToAddressApprovalAmount,proto3,customtype=Uint" json:"perToAddressApprovalAmount"`
	// Approval amount per "from" address.
	PerFromAddressApprovalAmount Uint `protobuf:"bytes,3,opt,name=perFromAddressApprovalAmount,proto3,customtype=Uint" json:"perFromAddressApprovalAmount"`
	// Approval amount per "initiated by" address.
	PerInitiatedByAddressApprovalAmount Uint `protobuf:"bytes,4,opt,name=perInitiatedByAddressApprovalAmount,proto3,customtype=Uint" json:"perInitiatedByAddressApprovalAmount"`
	// The ID of the amount tracker associated with this approval.
	// We use this ID to track the number of transfers and amounts transferred.
	AmountTrackerId string `protobuf:"bytes,6,opt,name=amountTrackerId,proto3" json:"amountTrackerId,omitempty"`
	// Time intervals to reset the trackers at.
	ResetTimeIntervals *ResetTimeIntervals `protobuf:"bytes,7,opt,name=resetTimeIntervals,proto3" json:"resetTimeIntervals,omitempty"`
}

func (m *ApprovalAmounts) Reset()         { *m = ApprovalAmounts{} }
func (m *ApprovalAmounts) String() string { return proto.CompactTextString(m) }
func (*ApprovalAmounts) ProtoMessage()    {}
func (*ApprovalAmounts) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{11}
}
func (m *ApprovalAmounts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalAmounts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalAmounts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalAmounts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalAmounts.Merge(m, src)
}
func (m *ApprovalAmounts) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalAmounts) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalAmounts.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalAmounts proto.InternalMessageInfo

func (m *ApprovalAmounts) GetAmountTrackerId() string {
	if m != nil {
		return m.AmountTrackerId
	}
	return ""
}

func (m *ApprovalAmounts) GetResetTimeIntervals() *ResetTimeIntervals {
	if m != nil {
		return m.ResetTimeIntervals
	}
	return nil
}

// Time intervals to reset the trackers at.
type ResetTimeIntervals struct {
	// Original start time of the first interval.
	StartTime Uint `protobuf:"bytes,1,opt,name=startTime,proto3,customtype=Uint" json:"startTime"`
	// Interval length in unix milliseconds.
	IntervalLength Uint `protobuf:"bytes,2,opt,name=intervalLength,proto3,customtype=Uint" json:"intervalLength"`
}

func (m *ResetTimeIntervals) Reset()         { *m = ResetTimeIntervals{} }
func (m *ResetTimeIntervals) String() string { return proto.CompactTextString(m) }
func (*ResetTimeIntervals) ProtoMessage()    {}
func (*ResetTimeIntervals) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{12}
}
func (m *ResetTimeIntervals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetTimeIntervals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetTimeIntervals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetTimeIntervals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetTimeIntervals.Merge(m, src)
}
func (m *ResetTimeIntervals) XXX_Size() int {
	return m.Size()
}
func (m *ResetTimeIntervals) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetTimeIntervals.DiscardUnknown(m)
}

var xxx_messageInfo_ResetTimeIntervals proto.InternalMessageInfo

// MaxNumTransfers defines the maximum number of transfers per unique "from," "to," and/or "initiated by" address.
// If any of these are nil or "0", we assume unlimited approvals.
// If they are set to a value, then the running tally of the number of transfers for the specified token IDs and ownership times
// must not exceed the corresponding value.
type MaxNumTransfers struct {
	// Overall maximum number of transfers.
	OverallMaxNumTransfers Uint `protobuf:"bytes,1,opt,name=overallMaxNumTransfers,proto3,customtype=Uint" json:"overallMaxNumTransfers"`
	// Maximum number of transfers per "to" address.
	PerToAddressMaxNumTransfers Uint `protobuf:"bytes,2,opt,name=perToAddressMaxNumTransfers,proto3,customtype=Uint" json:"perToAddressMaxNumTransfers"`
	// Maximum number of transfers per "from" address.
	PerFromAddressMaxNumTransfers Uint `protobuf:"bytes,3,opt,name=perFromAddressMaxNumTransfers,proto3,customtype=Uint" json:"perFromAddressMaxNumTransfers"`
	// Maximum number of transfers per "initiated by" address.
	PerInitiatedByAddressMaxNumTransfers Uint `protobuf:"bytes,4,opt,name=perInitiatedByAddressMaxNumTransfers,proto3,customtype=Uint" json:"perInitiatedByAddressMaxNumTransfers"`
	// The ID of the amount tracker associated with this approval.
	// We use this ID to track the number of transfers and amounts transferred.
	AmountTrackerId string `protobuf:"bytes,6,opt,name=amountTrackerId,proto3" json:"amountTrackerId,omitempty"`
	// Time intervals to reset the trackers at.
	ResetTimeIntervals *ResetTimeIntervals `protobuf:"bytes,7,opt,name=resetTimeIntervals,proto3" json:"resetTimeIntervals,omitempty"`
}

func (m *MaxNumTransfers) Reset()         { *m = MaxNumTransfers{} }
func (m *MaxNumTransfers) String() string { return proto.CompactTextString(m) }
func (*MaxNumTransfers) ProtoMessage()    {}
func (*MaxNumTransfers) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{13}
}
func (m *MaxNumTransfers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxNumTransfers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxNumTransfers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxNumTransfers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxNumTransfers.Merge(m, src)
}
func (m *MaxNumTransfers) XXX_Size() int {
	return m.Size()
}
func (m *MaxNumTransfers) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxNumTransfers.DiscardUnknown(m)
}

var xxx_messageInfo_MaxNumTransfers proto.InternalMessageInfo

func (m *MaxNumTransfers) GetAmountTrackerId() string {
	if m != nil {
		return m.AmountTrackerId
	}
	return ""
}

func (m *MaxNumTransfers) GetResetTimeIntervals() *ResetTimeIntervals {
	if m != nil {
		return m.ResetTimeIntervals
	}
	return nil
}

// ApprovalTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.
type ApprovalTracker struct {
	// The number of transfers that have been processed.
	NumTransfers Uint `protobuf:"bytes,1,opt,name=numTransfers,proto3,customtype=Uint" json:"numTransfers"`
	// Cumulative balances associated with the transfers that have been processed.
	Amounts []*Balance `protobuf:"bytes,2,rep,name=amounts,proto3" json:"amounts,omitempty"`
	// Last updated at time.
	LastUpdatedAt Uint `protobuf:"bytes,3,opt,name=lastUpdatedAt,proto3,customtype=Uint" json:"lastUpdatedAt"`
}

func (m *ApprovalTracker) Reset()         { *m = ApprovalTracker{} }
func (m *ApprovalTracker) String() string { return proto.CompactTextString(m) }
func (*ApprovalTracker) ProtoMessage()    {}
func (*ApprovalTracker) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{14}
}
func (m *ApprovalTracker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalTracker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalTracker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalTracker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalTracker.Merge(m, src)
}
func (m *ApprovalTracker) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalTracker) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalTracker.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalTracker proto.InternalMessageInfo

func (m *ApprovalTracker) GetAmounts() []*Balance {
	if m != nil {
		return m.Amounts
	}
	return nil
}

type CoinTransfer struct {
	// The address of the recipient of the transfer.
	To string `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	// The sdk.Coins to be transferred.
	Coins []*types.Coin `protobuf:"bytes,2,rep,name=coins,proto3" json:"coins,omitempty"`
	// By default, the from address is the initiator of the transaction.
	// If this is set to true, we will override the from address with the approver address.
	// Note: This is not applicable for collection approvals (since approverAddress == â€).
	OverrideFromWithApproverAddress bool `protobuf:"varint,3,opt,name=overrideFromWithApproverAddress,proto3" json:"overrideFromWithApproverAddress,omitempty"`
	// By default, the to address is what is specified in the coin transfer.
	// If this is set to true, we will override the to address with the initiator of the transaction.
	OverrideToWithInitiator bool `protobuf:"varint,4,opt,name=overrideToWithInitiator,proto3" json:"overrideToWithInitiator,omitempty"`
}

func (m *CoinTransfer) Reset()         { *m = CoinTransfer{} }
func (m *CoinTransfer) String() string { return proto.CompactTextString(m) }
func (*CoinTransfer) ProtoMessage()    {}
func (*CoinTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{15}
}
func (m *CoinTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinTransfer.Merge(m, src)
}
func (m *CoinTransfer) XXX_Size() int {
	return m.Size()
}
func (m *CoinTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_CoinTransfer proto.InternalMessageInfo

func (m *CoinTransfer) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *CoinTransfer) GetCoins() []*types.Coin {
	if m != nil {
		return m.Coins
	}
	return nil
}

func (m *CoinTransfer) GetOverrideFromWithApproverAddress() bool {
	if m != nil {
		return m.OverrideFromWithApproverAddress
	}
	return false
}

func (m *CoinTransfer) GetOverrideToWithInitiator() bool {
	if m != nil {
		return m.OverrideToWithInitiator
	}
	return false
}

// MustOwnTokens represents a condition where a user must own specific tokens
// to be approved to transfer.
//
// - collectionId: The ID of the collection for the tokens that must be owned
// - amountRange: The range of amounts the user must own (min to max)
// - ownershipTimes: The time ranges during which the user must own the tokens.
// - tokenIds: The token IDs the user must own.
// - overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.
// - mustSatisfyForAllAssets: If true, the user must own all specified tokens; otherwise, owning any one for >= 1 millisecond is sufficient.
type MustOwnTokens struct {
	// The ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The range of amounts the user must own (min to max).
	AmountRange *UintRange `protobuf:"bytes,2,opt,name=amountRange,proto3" json:"amountRange,omitempty"`
	// The time ranges during which the user must own the tokens.
	OwnershipTimes []*UintRange `protobuf:"bytes,3,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The token IDs the user must own.
	TokenIds []*UintRange `protobuf:"bytes,4,rep,name=tokenIds,proto3" json:"tokenIds,omitempty"`
	// If true, override ownershipTimes with the current time.
	OverrideWithCurrentTime bool `protobuf:"varint,5,opt,name=overrideWithCurrentTime,proto3" json:"overrideWithCurrentTime,omitempty"`
	// If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.
	MustSatisfyForAllAssets bool `protobuf:"varint,6,opt,name=mustSatisfyForAllAssets,proto3" json:"mustSatisfyForAllAssets,omitempty"`
	// The party to check ownership for. Options are "initiator", "sender", or "recipient". Defaults to "initiator" if empty.
	OwnershipCheckParty string `protobuf:"bytes,7,opt,name=ownershipCheckParty,proto3" json:"ownershipCheckParty,omitempty"`
}

func (m *MustOwnTokens) Reset()         { *m = MustOwnTokens{} }
func (m *MustOwnTokens) String() string { return proto.CompactTextString(m) }
func (*MustOwnTokens) ProtoMessage()    {}
func (*MustOwnTokens) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{16}
}
func (m *MustOwnTokens) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MustOwnTokens) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MustOwnTokens.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MustOwnTokens) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MustOwnTokens.Merge(m, src)
}
func (m *MustOwnTokens) XXX_Size() int {
	return m.Size()
}
func (m *MustOwnTokens) XXX_DiscardUnknown() {
	xxx_messageInfo_MustOwnTokens.DiscardUnknown(m)
}

var xxx_messageInfo_MustOwnTokens proto.InternalMessageInfo

func (m *MustOwnTokens) GetAmountRange() *UintRange {
	if m != nil {
		return m.AmountRange
	}
	return nil
}

func (m *MustOwnTokens) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *MustOwnTokens) GetTokenIds() []*UintRange {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

func (m *MustOwnTokens) GetOverrideWithCurrentTime() bool {
	if m != nil {
		return m.OverrideWithCurrentTime
	}
	return false
}

func (m *MustOwnTokens) GetMustSatisfyForAllAssets() bool {
	if m != nil {
		return m.MustSatisfyForAllAssets
	}
	return false
}

func (m *MustOwnTokens) GetOwnershipCheckParty() string {
	if m != nil {
		return m.OwnershipCheckParty
	}
	return ""
}

// DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.
type DynamicStoreChallenge struct {
	// The ID of the dynamic store to check.
	StoreId Uint `protobuf:"bytes,1,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
}

func (m *DynamicStoreChallenge) Reset()         { *m = DynamicStoreChallenge{} }
func (m *DynamicStoreChallenge) String() string { return proto.CompactTextString(m) }
func (*DynamicStoreChallenge) ProtoMessage()    {}
func (*DynamicStoreChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{17}
}
func (m *DynamicStoreChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicStoreChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicStoreChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicStoreChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicStoreChallenge.Merge(m, src)
}
func (m *DynamicStoreChallenge) XXX_Size() int {
	return m.Size()
}
func (m *DynamicStoreChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicStoreChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicStoreChallenge proto.InternalMessageInfo

// AddressChecks defines checks for address types (WASM contract, liquidity pool, etc.)
type AddressChecks struct {
	// Require the address to be a WASM contract.
	MustBeWasmContract bool `protobuf:"varint,1,opt,name=mustBeWasmContract,proto3" json:"mustBeWasmContract,omitempty"`
	// Require the address to not be a WASM contract.
	MustNotBeWasmContract bool `protobuf:"varint,2,opt,name=mustNotBeWasmContract,proto3" json:"mustNotBeWasmContract,omitempty"`
	// Require the address to be a liquidity pool.
	MustBeLiquidityPool bool `protobuf:"varint,3,opt,name=mustBeLiquidityPool,proto3" json:"mustBeLiquidityPool,omitempty"`
	// Require the address to not be a liquidity pool.
	MustNotBeLiquidityPool bool `protobuf:"varint,4,opt,name=mustNotBeLiquidityPool,proto3" json:"mustNotBeLiquidityPool,omitempty"`
}

func (m *AddressChecks) Reset()         { *m = AddressChecks{} }
func (m *AddressChecks) String() string { return proto.CompactTextString(m) }
func (*AddressChecks) ProtoMessage()    {}
func (*AddressChecks) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{18}
}
func (m *AddressChecks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressChecks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressChecks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressChecks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressChecks.Merge(m, src)
}
func (m *AddressChecks) XXX_Size() int {
	return m.Size()
}
func (m *AddressChecks) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressChecks.DiscardUnknown(m)
}

var xxx_messageInfo_AddressChecks proto.InternalMessageInfo

func (m *AddressChecks) GetMustBeWasmContract() bool {
	if m != nil {
		return m.MustBeWasmContract
	}
	return false
}

func (m *AddressChecks) GetMustNotBeWasmContract() bool {
	if m != nil {
		return m.MustNotBeWasmContract
	}
	return false
}

func (m *AddressChecks) GetMustBeLiquidityPool() bool {
	if m != nil {
		return m.MustBeLiquidityPool
	}
	return false
}

func (m *AddressChecks) GetMustNotBeLiquidityPool() bool {
	if m != nil {
		return m.MustNotBeLiquidityPool
	}
	return false
}

// AltTimeChecks defines alternative time-based checks for approval denial.
// If the transfer time falls within any of the specified offline hours or days, the approval is denied.
// Uses UTC timezone for neutral timezone approach.
// offlineHours: ranges of hours (0-23) when transfers should be denied
// offlineDays: ranges of days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied
type AltTimeChecks struct {
	// Hours (0-23) when transfers should be denied. Uses UTC timezone.
	OfflineHours []*UintRange `protobuf:"bytes,1,rep,name=offlineHours,proto3" json:"offlineHours,omitempty"`
	// Days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied. Uses UTC timezone.
	OfflineDays []*UintRange `protobuf:"bytes,2,rep,name=offlineDays,proto3" json:"offlineDays,omitempty"`
}

func (m *AltTimeChecks) Reset()         { *m = AltTimeChecks{} }
func (m *AltTimeChecks) String() string { return proto.CompactTextString(m) }
func (*AltTimeChecks) ProtoMessage()    {}
func (*AltTimeChecks) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{19}
}
func (m *AltTimeChecks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AltTimeChecks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AltTimeChecks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AltTimeChecks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AltTimeChecks.Merge(m, src)
}
func (m *AltTimeChecks) XXX_Size() int {
	return m.Size()
}
func (m *AltTimeChecks) XXX_DiscardUnknown() {
	xxx_messageInfo_AltTimeChecks.DiscardUnknown(m)
}

var xxx_messageInfo_AltTimeChecks proto.InternalMessageInfo

func (m *AltTimeChecks) GetOfflineHours() []*UintRange {
	if m != nil {
		return m.OfflineHours
	}
	return nil
}

func (m *AltTimeChecks) GetOfflineDays() []*UintRange {
	if m != nil {
		return m.OfflineDays
	}
	return nil
}

// ApprovalCriteria defines the criteria for approving transfers.
type ApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,7,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,8,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,9,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
	// Overrides the user's outgoing approvals for approval.
	OverridesFromOutgoingApprovals bool `protobuf:"varint,10,opt,name=overridesFromOutgoingApprovals,proto3" json:"overridesFromOutgoingApprovals,omitempty"`
	// Overrides the user's incoming approvals for approval.
	OverridesToIncomingApprovals bool `protobuf:"varint,11,opt,name=overridesToIncomingApprovals,proto3" json:"overridesToIncomingApprovals,omitempty"`
	// Auto-deletion options.
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,12,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// User level royalties to apply to the transfer.
	UserRoyalties *UserRoyalties `protobuf:"bytes,13,opt,name=userRoyalties,proto3" json:"userRoyalties,omitempty"`
	// Must own tokens for approval.
	MustOwnTokens []*MustOwnTokens `protobuf:"bytes,14,rep,name=mustOwnTokens,proto3" json:"mustOwnTokens,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval.
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,15,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
	// ETH signature challenges that the initiator must pass for approval.
	EthSignatureChallenges []*ETHSignatureChallenge `protobuf:"bytes,16,rep,name=ethSignatureChallenges,proto3" json:"ethSignatureChallenges,omitempty"`
	// Address checks for sender, recipient, and initiator.
	SenderChecks    *AddressChecks `protobuf:"bytes,17,opt,name=senderChecks,proto3" json:"senderChecks,omitempty"`
	RecipientChecks *AddressChecks `protobuf:"bytes,18,opt,name=recipientChecks,proto3" json:"recipientChecks,omitempty"`
	InitiatorChecks *AddressChecks `protobuf:"bytes,19,opt,name=initiatorChecks,proto3" json:"initiatorChecks,omitempty"`
	// Alternative time-based checks for approval denial (offline hours/days).
	AltTimeChecks *AltTimeChecks `protobuf:"bytes,20,opt,name=altTimeChecks,proto3" json:"altTimeChecks,omitempty"`
	// If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
	MustPrioritize bool `protobuf:"varint,21,opt,name=mustPrioritize,proto3" json:"mustPrioritize,omitempty"`
}

func (m *ApprovalCriteria) Reset()         { *m = ApprovalCriteria{} }
func (m *ApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*ApprovalCriteria) ProtoMessage()    {}
func (*ApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{20}
}
func (m *ApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalCriteria.Merge(m, src)
}
func (m *ApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalCriteria proto.InternalMessageInfo

func (m *ApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *ApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *ApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *ApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *ApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetOverridesFromOutgoingApprovals() bool {
	if m != nil {
		return m.OverridesFromOutgoingApprovals
	}
	return false
}

func (m *ApprovalCriteria) GetOverridesToIncomingApprovals() bool {
	if m != nil {
		return m.OverridesToIncomingApprovals
	}
	return false
}

func (m *ApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *ApprovalCriteria) GetUserRoyalties() *UserRoyalties {
	if m != nil {
		return m.UserRoyalties
	}
	return nil
}

func (m *ApprovalCriteria) GetMustOwnTokens() []*MustOwnTokens {
	if m != nil {
		return m.MustOwnTokens
	}
	return nil
}

func (m *ApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetEthSignatureChallenges() []*ETHSignatureChallenge {
	if m != nil {
		return m.EthSignatureChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetSenderChecks() *AddressChecks {
	if m != nil {
		return m.SenderChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetRecipientChecks() *AddressChecks {
	if m != nil {
		return m.RecipientChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetInitiatorChecks() *AddressChecks {
	if m != nil {
		return m.InitiatorChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetAltTimeChecks() *AltTimeChecks {
	if m != nil {
		return m.AltTimeChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetMustPrioritize() bool {
	if m != nil {
		return m.MustPrioritize
	}
	return false
}

// UserRoyalties defines the royalties for a user.
type UserRoyalties struct {
	// Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.
	Percentage Uint `protobuf:"bytes,1,opt,name=percentage,proto3,customtype=Uint" json:"percentage"`
	// Payout address for the royalties.
	PayoutAddress string `protobuf:"bytes,2,opt,name=payoutAddress,proto3" json:"payoutAddress,omitempty"`
}

func (m *UserRoyalties) Reset()         { *m = UserRoyalties{} }
func (m *UserRoyalties) String() string { return proto.CompactTextString(m) }
func (*UserRoyalties) ProtoMessage()    {}
func (*UserRoyalties) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{21}
}
func (m *UserRoyalties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRoyalties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRoyalties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRoyalties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRoyalties.Merge(m, src)
}
func (m *UserRoyalties) XXX_Size() int {
	return m.Size()
}
func (m *UserRoyalties) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRoyalties.DiscardUnknown(m)
}

var xxx_messageInfo_UserRoyalties proto.InternalMessageInfo

func (m *UserRoyalties) GetPayoutAddress() string {
	if m != nil {
		return m.PayoutAddress
	}
	return ""
}

// OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.
type OutgoingApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,7,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
	// Auto-deletion options.
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,8,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// Must own tokens for approval.
	MustOwnTokens []*MustOwnTokens `protobuf:"bytes,9,rep,name=mustOwnTokens,proto3" json:"mustOwnTokens,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval.
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,10,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
	// ETH signature challenges that the initiator must pass for approval.
	EthSignatureChallenges []*ETHSignatureChallenge `protobuf:"bytes,11,rep,name=ethSignatureChallenges,proto3" json:"ethSignatureChallenges,omitempty"`
	// Address checks for recipient and initiator (no sender checks for outgoing approvals).
	RecipientChecks *AddressChecks `protobuf:"bytes,12,opt,name=recipientChecks,proto3" json:"recipientChecks,omitempty"`
	InitiatorChecks *AddressChecks `protobuf:"bytes,13,opt,name=initiatorChecks,proto3" json:"initiatorChecks,omitempty"`
	// Alternative time-based checks for approval denial (offline hours/days).
	AltTimeChecks *AltTimeChecks `protobuf:"bytes,14,opt,name=altTimeChecks,proto3" json:"altTimeChecks,omitempty"`
	// If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
	MustPrioritize bool `protobuf:"varint,15,opt,name=mustPrioritize,proto3" json:"mustPrioritize,omitempty"`
}

func (m *OutgoingApprovalCriteria) Reset()         { *m = OutgoingApprovalCriteria{} }
func (m *OutgoingApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*OutgoingApprovalCriteria) ProtoMessage()    {}
func (*OutgoingApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{22}
}
func (m *OutgoingApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutgoingApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutgoingApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutgoingApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutgoingApprovalCriteria.Merge(m, src)
}
func (m *OutgoingApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *OutgoingApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_OutgoingApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_OutgoingApprovalCriteria proto.InternalMessageInfo

func (m *OutgoingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *OutgoingApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

func (m *OutgoingApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMustOwnTokens() []*MustOwnTokens {
	if m != nil {
		return m.MustOwnTokens
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetEthSignatureChallenges() []*ETHSignatureChallenge {
	if m != nil {
		return m.EthSignatureChallenges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetRecipientChecks() *AddressChecks {
	if m != nil {
		return m.RecipientChecks
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetInitiatorChecks() *AddressChecks {
	if m != nil {
		return m.InitiatorChecks
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetAltTimeChecks() *AltTimeChecks {
	if m != nil {
		return m.AltTimeChecks
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMustPrioritize() bool {
	if m != nil {
		return m.MustPrioritize
	}
	return false
}

// IncomingApprovalCriteria defines the criteria for approving incoming transfers.
type IncomingApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,7,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
	// Auto-deletion options.
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,8,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// Must own tokens for approval.
	MustOwnTokens []*MustOwnTokens `protobuf:"bytes,9,rep,name=mustOwnTokens,proto3" json:"mustOwnTokens,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval.
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,10,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
	// ETH signature challenges that the initiator must pass for approval.
	EthSignatureChallenges []*ETHSignatureChallenge `protobuf:"bytes,11,rep,name=ethSignatureChallenges,proto3" json:"ethSignatureChallenges,omitempty"`
	// Address checks for sender and initiator (no recipient checks for incoming approvals).
	SenderChecks    *AddressChecks `protobuf:"bytes,12,opt,name=senderChecks,proto3" json:"senderChecks,omitempty"`
	InitiatorChecks *AddressChecks `protobuf:"bytes,13,opt,name=initiatorChecks,proto3" json:"initiatorChecks,omitempty"`
	// Alternative time-based checks for approval denial (offline hours/days).
	AltTimeChecks *AltTimeChecks `protobuf:"bytes,14,opt,name=altTimeChecks,proto3" json:"altTimeChecks,omitempty"`
	// If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
	MustPrioritize bool `protobuf:"varint,15,opt,name=mustPrioritize,proto3" json:"mustPrioritize,omitempty"`
}

func (m *IncomingApprovalCriteria) Reset()         { *m = IncomingApprovalCriteria{} }
func (m *IncomingApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*IncomingApprovalCriteria) ProtoMessage()    {}
func (*IncomingApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{23}
}
func (m *IncomingApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncomingApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncomingApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncomingApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncomingApprovalCriteria.Merge(m, src)
}
func (m *IncomingApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *IncomingApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_IncomingApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_IncomingApprovalCriteria proto.InternalMessageInfo

func (m *IncomingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *IncomingApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

func (m *IncomingApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMustOwnTokens() []*MustOwnTokens {
	if m != nil {
		return m.MustOwnTokens
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetEthSignatureChallenges() []*ETHSignatureChallenge {
	if m != nil {
		return m.EthSignatureChallenges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetSenderChecks() *AddressChecks {
	if m != nil {
		return m.SenderChecks
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetInitiatorChecks() *AddressChecks {
	if m != nil {
		return m.InitiatorChecks
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetAltTimeChecks() *AltTimeChecks {
	if m != nil {
		return m.AltTimeChecks
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMustPrioritize() bool {
	if m != nil {
		return m.MustPrioritize
	}
	return false
}

// CollectionApproval defines the rules for the approval of a transfer on the collection level
type CollectionApproval struct {
	// The list ID for the sender of the transfer.
	FromListId string `protobuf:"bytes,1,opt,name=fromListId,proto3" json:"fromListId,omitempty"`
	// The list ID for the recipient of the transfer.
	ToListId string `protobuf:"bytes,2,opt,name=toListId,proto3" json:"toListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,3,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,4,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of token IDs for approval.
	TokenIds []*UintRange `protobuf:"bytes,5,rep,name=tokenIds,proto3" json:"tokenIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,6,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,7,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,8,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,9,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *ApprovalCriteria `protobuf:"bytes,10,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
	// Version of the approval. Maintained internally.
	Version Uint `protobuf:"bytes,11,opt,name=version,proto3,customtype=Uint" json:"version"`
}

func (m *CollectionApproval) Reset()         { *m = CollectionApproval{} }
func (m *CollectionApproval) String() string { return proto.CompactTextString(m) }
func (*CollectionApproval) ProtoMessage()    {}
func (*CollectionApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{24}
}
func (m *CollectionApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApproval.Merge(m, src)
}
func (m *CollectionApproval) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApproval.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApproval proto.InternalMessageInfo

func (m *CollectionApproval) GetFromListId() string {
	if m != nil {
		return m.FromListId
	}
	return ""
}

func (m *CollectionApproval) GetToListId() string {
	if m != nil {
		return m.ToListId
	}
	return ""
}

func (m *CollectionApproval) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *CollectionApproval) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *CollectionApproval) GetTokenIds() []*UintRange {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

func (m *CollectionApproval) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *CollectionApproval) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *CollectionApproval) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *CollectionApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *CollectionApproval) GetApprovalCriteria() *ApprovalCriteria {
	if m != nil {
		return m.ApprovalCriteria
	}
	return nil
}

// ApprovalIdentifierDetails defines the details to identify a specific approval.
type ApprovalIdentifierDetails struct {
	// The ID of the approval.
	ApprovalId string `protobuf:"bytes,1,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The level of the approval. Can be "collection", "incoming", or "outgoing".
	ApprovalLevel string `protobuf:"bytes,2,opt,name=approvalLevel,proto3" json:"approvalLevel,omitempty"`
	// The address of the approver. Leave blank "" if approvalLevel == "collection".
	ApproverAddress string `protobuf:"bytes,3,opt,name=approverAddress,proto3" json:"approverAddress,omitempty"`
	// The version of the approval.
	Version Uint `protobuf:"bytes,4,opt,name=version,proto3,customtype=Uint" json:"version"`
}

func (m *ApprovalIdentifierDetails) Reset()         { *m = ApprovalIdentifierDetails{} }
func (m *ApprovalIdentifierDetails) String() string { return proto.CompactTextString(m) }
func (*ApprovalIdentifierDetails) ProtoMessage()    {}
func (*ApprovalIdentifierDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{25}
}
func (m *ApprovalIdentifierDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalIdentifierDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalIdentifierDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalIdentifierDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalIdentifierDetails.Merge(m, src)
}
func (m *ApprovalIdentifierDetails) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalIdentifierDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalIdentifierDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalIdentifierDetails proto.InternalMessageInfo

func (m *ApprovalIdentifierDetails) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *ApprovalIdentifierDetails) GetApprovalLevel() string {
	if m != nil {
		return m.ApprovalLevel
	}
	return ""
}

func (m *ApprovalIdentifierDetails) GetApproverAddress() string {
	if m != nil {
		return m.ApproverAddress
	}
	return ""
}

// Transfer defines the details of a transfer of tokens.
type Transfer struct {
	// The address of the sender of the transfer.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// The addresses of the recipients of the transfer.
	ToAddresses []string `protobuf:"bytes,2,rep,name=toAddresses,proto3" json:"toAddresses,omitempty"`
	// The balances to be transferred.
	Balances []*Balance `protobuf:"bytes,3,rep,name=balances,proto3" json:"balances,omitempty"`
	// If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.
	// We will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.
	PrecalculateBalancesFromApproval *ApprovalIdentifierDetails `protobuf:"bytes,4,opt,name=precalculateBalancesFromApproval,proto3" json:"precalculateBalancesFromApproval,omitempty"`
	// The Merkle proofs / solutions for all Merkle challenges required for the transfer.
	MerkleProofs []*MerkleProof `protobuf:"bytes,5,rep,name=merkleProofs,proto3" json:"merkleProofs,omitempty"`
	// The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.
	EthSignatureProofs []*ETHSignatureProof `protobuf:"bytes,6,rep,name=ethSignatureProofs,proto3" json:"ethSignatureProofs,omitempty"`
	// The memo for the transfer.
	Memo string `protobuf:"bytes,7,opt,name=memo,proto3" json:"memo,omitempty"`
	// The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.
	// This field can be used to prioritize specific approvals and scan through them first.
	PrioritizedApprovals []*ApprovalIdentifierDetails `protobuf:"bytes,8,rep,name=prioritizedApprovals,proto3" json:"prioritizedApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedCollectionApprovals bool `protobuf:"varint,9,opt,name=onlyCheckPrioritizedCollectionApprovals,proto3" json:"onlyCheckPrioritizedCollectionApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedIncomingApprovals bool `protobuf:"varint,10,opt,name=onlyCheckPrioritizedIncomingApprovals,proto3" json:"onlyCheckPrioritizedIncomingApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedOutgoingApprovals bool `protobuf:"varint,11,opt,name=onlyCheckPrioritizedOutgoingApprovals,proto3" json:"onlyCheckPrioritizedOutgoingApprovals,omitempty"`
	// The options for precalculating the balances.
	PrecalculationOptions *PrecalculationOptions `protobuf:"bytes,12,opt,name=precalculationOptions,proto3" json:"precalculationOptions,omitempty"`
	// The number of times to attempt approval validation. If 0 / not specified, we default to only one.
	NumAttempts Uint `protobuf:"bytes,13,opt,name=numAttempts,proto3,customtype=Uint" json:"numAttempts"`
}

func (m *Transfer) Reset()         { *m = Transfer{} }
func (m *Transfer) String() string { return proto.CompactTextString(m) }
func (*Transfer) ProtoMessage()    {}
func (*Transfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{26}
}
func (m *Transfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transfer.Merge(m, src)
}
func (m *Transfer) XXX_Size() int {
	return m.Size()
}
func (m *Transfer) XXX_DiscardUnknown() {
	xxx_messageInfo_Transfer.DiscardUnknown(m)
}

var xxx_messageInfo_Transfer proto.InternalMessageInfo

func (m *Transfer) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Transfer) GetToAddresses() []string {
	if m != nil {
		return m.ToAddresses
	}
	return nil
}

func (m *Transfer) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *Transfer) GetPrecalculateBalancesFromApproval() *ApprovalIdentifierDetails {
	if m != nil {
		return m.PrecalculateBalancesFromApproval
	}
	return nil
}

func (m *Transfer) GetMerkleProofs() []*MerkleProof {
	if m != nil {
		return m.MerkleProofs
	}
	return nil
}

func (m *Transfer) GetEthSignatureProofs() []*ETHSignatureProof {
	if m != nil {
		return m.EthSignatureProofs
	}
	return nil
}

func (m *Transfer) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *Transfer) GetPrioritizedApprovals() []*ApprovalIdentifierDetails {
	if m != nil {
		return m.PrioritizedApprovals
	}
	return nil
}

func (m *Transfer) GetOnlyCheckPrioritizedCollectionApprovals() bool {
	if m != nil {
		return m.OnlyCheckPrioritizedCollectionApprovals
	}
	return false
}

func (m *Transfer) GetOnlyCheckPrioritizedIncomingApprovals() bool {
	if m != nil {
		return m.OnlyCheckPrioritizedIncomingApprovals
	}
	return false
}

func (m *Transfer) GetOnlyCheckPrioritizedOutgoingApprovals() bool {
	if m != nil {
		return m.OnlyCheckPrioritizedOutgoingApprovals
	}
	return false
}

func (m *Transfer) GetPrecalculationOptions() *PrecalculationOptions {
	if m != nil {
		return m.PrecalculationOptions
	}
	return nil
}

// PrecalculationOptions defines the options for precalculating the balances.
type PrecalculationOptions struct {
	// The timestamp to override with when calculating the balances.
	OverrideTimestamp Uint `protobuf:"bytes,1,opt,name=overrideTimestamp,proto3,customtype=Uint" json:"overrideTimestamp"`
	// The IDs to override for the transfer. Only applicable if using this option in precalculation.
	TokenIdsOverride []*UintRange `protobuf:"bytes,2,rep,name=tokenIdsOverride,proto3" json:"tokenIdsOverride,omitempty"`
}

func (m *PrecalculationOptions) Reset()         { *m = PrecalculationOptions{} }
func (m *PrecalculationOptions) String() string { return proto.CompactTextString(m) }
func (*PrecalculationOptions) ProtoMessage()    {}
func (*PrecalculationOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{27}
}
func (m *PrecalculationOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrecalculationOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrecalculationOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrecalculationOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrecalculationOptions.Merge(m, src)
}
func (m *PrecalculationOptions) XXX_Size() int {
	return m.Size()
}
func (m *PrecalculationOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_PrecalculationOptions.DiscardUnknown(m)
}

var xxx_messageInfo_PrecalculationOptions proto.InternalMessageInfo

func (m *PrecalculationOptions) GetTokenIdsOverride() []*UintRange {
	if m != nil {
		return m.TokenIdsOverride
	}
	return nil
}

// MerklePathItem represents an item in a Merkle path.
type MerklePathItem struct {
	// The hash of the sibling node (aunt) in the Merkle path.
	Aunt string `protobuf:"bytes,1,opt,name=aunt,proto3" json:"aunt,omitempty"`
	// Indicates whether the aunt node is on the right side of the path.
	OnRight bool `protobuf:"varint,2,opt,name=onRight,proto3" json:"onRight,omitempty"`
}

func (m *MerklePathItem) Reset()         { *m = MerklePathItem{} }
func (m *MerklePathItem) String() string { return proto.CompactTextString(m) }
func (*MerklePathItem) ProtoMessage()    {}
func (*MerklePathItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{28}
}
func (m *MerklePathItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerklePathItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerklePathItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerklePathItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerklePathItem.Merge(m, src)
}
func (m *MerklePathItem) XXX_Size() int {
	return m.Size()
}
func (m *MerklePathItem) XXX_DiscardUnknown() {
	xxx_messageInfo_MerklePathItem.DiscardUnknown(m)
}

var xxx_messageInfo_MerklePathItem proto.InternalMessageInfo

func (m *MerklePathItem) GetAunt() string {
	if m != nil {
		return m.Aunt
	}
	return ""
}

func (m *MerklePathItem) GetOnRight() bool {
	if m != nil {
		return m.OnRight
	}
	return false
}

// MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.
type MerkleProof struct {
	// The hash of the leaf node for which the proof is generated.
	Leaf string `protobuf:"bytes,1,opt,name=leaf,proto3" json:"leaf,omitempty"`
	// List of Merkle path items (aunts) that make up the proof.
	Aunts []*MerklePathItem `protobuf:"bytes,2,rep,name=aunts,proto3" json:"aunts,omitempty"`
	// The signature of the leaf node tying the address to the leaf node.
	LeafSignature string `protobuf:"bytes,3,opt,name=leafSignature,proto3" json:"leafSignature,omitempty"`
}

func (m *MerkleProof) Reset()         { *m = MerkleProof{} }
func (m *MerkleProof) String() string { return proto.CompactTextString(m) }
func (*MerkleProof) ProtoMessage()    {}
func (*MerkleProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{29}
}
func (m *MerkleProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerkleProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerkleProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerkleProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerkleProof.Merge(m, src)
}
func (m *MerkleProof) XXX_Size() int {
	return m.Size()
}
func (m *MerkleProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MerkleProof.DiscardUnknown(m)
}

var xxx_messageInfo_MerkleProof proto.InternalMessageInfo

func (m *MerkleProof) GetLeaf() string {
	if m != nil {
		return m.Leaf
	}
	return ""
}

func (m *MerkleProof) GetAunts() []*MerklePathItem {
	if m != nil {
		return m.Aunts
	}
	return nil
}

func (m *MerkleProof) GetLeafSignature() string {
	if m != nil {
		return m.LeafSignature
	}
	return ""
}

// ETHSignatureProof represents an Ethereum signature proof for a challenge.
type ETHSignatureProof struct {
	// The nonce that was signed. The signature scheme is ETHSign(nonce + "-" + creatorAddress).
	Nonce string `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// The Ethereum signature of the nonce.
	Signature string `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *ETHSignatureProof) Reset()         { *m = ETHSignatureProof{} }
func (m *ETHSignatureProof) String() string { return proto.CompactTextString(m) }
func (*ETHSignatureProof) ProtoMessage()    {}
func (*ETHSignatureProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_8770d666838a98f8, []int{30}
}
func (m *ETHSignatureProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ETHSignatureProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ETHSignatureProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ETHSignatureProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ETHSignatureProof.Merge(m, src)
}
func (m *ETHSignatureProof) XXX_Size() int {
	return m.Size()
}
func (m *ETHSignatureProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ETHSignatureProof.DiscardUnknown(m)
}

var xxx_messageInfo_ETHSignatureProof proto.InternalMessageInfo

func (m *ETHSignatureProof) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *ETHSignatureProof) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func init() {
	proto.RegisterType((*UserBalanceStore)(nil), "tokenization.v21.UserBalanceStore")
	proto.RegisterType((*MerkleChallenge)(nil), "tokenization.v21.MerkleChallenge")
	proto.RegisterType((*ETHSignatureChallenge)(nil), "tokenization.v21.ETHSignatureChallenge")
	proto.RegisterType((*UserOutgoingApproval)(nil), "tokenization.v21.UserOutgoingApproval")
	proto.RegisterType((*UserIncomingApproval)(nil), "tokenization.v21.UserIncomingApproval")
	proto.RegisterType((*ManualBalances)(nil), "tokenization.v21.ManualBalances")
	proto.RegisterType((*RecurringOwnershipTimes)(nil), "tokenization.v21.RecurringOwnershipTimes")
	proto.RegisterType((*IncrementedBalances)(nil), "tokenization.v21.IncrementedBalances")
	proto.RegisterType((*PredeterminedOrderCalculationMethod)(nil), "tokenization.v21.PredeterminedOrderCalculationMethod")
	proto.RegisterType((*PredeterminedBalances)(nil), "tokenization.v21.PredeterminedBalances")
	proto.RegisterType((*AutoDeletionOptions)(nil), "tokenization.v21.AutoDeletionOptions")
	proto.RegisterType((*ApprovalAmounts)(nil), "tokenization.v21.ApprovalAmounts")
	proto.RegisterType((*ResetTimeIntervals)(nil), "tokenization.v21.ResetTimeIntervals")
	proto.RegisterType((*MaxNumTransfers)(nil), "tokenization.v21.MaxNumTransfers")
	proto.RegisterType((*ApprovalTracker)(nil), "tokenization.v21.ApprovalTracker")
	proto.RegisterType((*CoinTransfer)(nil), "tokenization.v21.CoinTransfer")
	proto.RegisterType((*MustOwnTokens)(nil), "tokenization.v21.MustOwnTokens")
	proto.RegisterType((*DynamicStoreChallenge)(nil), "tokenization.v21.DynamicStoreChallenge")
	proto.RegisterType((*AddressChecks)(nil), "tokenization.v21.AddressChecks")
	proto.RegisterType((*AltTimeChecks)(nil), "tokenization.v21.AltTimeChecks")
	proto.RegisterType((*ApprovalCriteria)(nil), "tokenization.v21.ApprovalCriteria")
	proto.RegisterType((*UserRoyalties)(nil), "tokenization.v21.UserRoyalties")
	proto.RegisterType((*OutgoingApprovalCriteria)(nil), "tokenization.v21.OutgoingApprovalCriteria")
	proto.RegisterType((*IncomingApprovalCriteria)(nil), "tokenization.v21.IncomingApprovalCriteria")
	proto.RegisterType((*CollectionApproval)(nil), "tokenization.v21.CollectionApproval")
	proto.RegisterType((*ApprovalIdentifierDetails)(nil), "tokenization.v21.ApprovalIdentifierDetails")
	proto.RegisterType((*Transfer)(nil), "tokenization.v21.Transfer")
	proto.RegisterType((*PrecalculationOptions)(nil), "tokenization.v21.PrecalculationOptions")
	proto.RegisterType((*MerklePathItem)(nil), "tokenization.v21.MerklePathItem")
	proto.RegisterType((*MerkleProof)(nil), "tokenization.v21.MerkleProof")
	proto.RegisterType((*ETHSignatureProof)(nil), "tokenization.v21.ETHSignatureProof")
}

func init() { proto.RegisterFile("tokenization/v21/transfers.proto", fileDescriptor_8770d666838a98f8) }

var fileDescriptor_8770d666838a98f8 = []byte{
	// 2779 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0xcb, 0x73, 0x1c, 0xb7,
	0xd1, 0xd7, 0x72, 0xf9, 0xda, 0x5e, 0xbe, 0x04, 0x89, 0xd2, 0x5a, 0xb6, 0x29, 0x7e, 0x63, 0x59,
	0x96, 0xfd, 0xb9, 0x48, 0x8b, 0x7e, 0xc4, 0x95, 0x72, 0xec, 0x2c, 0x49, 0xd9, 0x5a, 0x5b, 0x12,
	0x59, 0xa3, 0x95, 0x9d, 0x4a, 0x25, 0x71, 0xc0, 0x59, 0xec, 0x12, 0xa5, 0x99, 0xc1, 0x1a, 0xc0,
	0xd0, 0x5c, 0x5f, 0x72, 0x4e, 0xe5, 0x90, 0xc7, 0x35, 0xc9, 0x2d, 0x97, 0x54, 0x72, 0xcb, 0x29,
	0xa7, 0x5c, 0x7d, 0x74, 0x55, 0x2a, 0x95, 0x54, 0xaa, 0xe2, 0xa4, 0xac, 0x3f, 0x21, 0x87, 0x5c,
	0x53, 0xc0, 0x60, 0x76, 0xe7, 0x81, 0x59, 0xae, 0x65, 0x3a, 0xaf, 0xd2, 0x85, 0xb5, 0x03, 0xfc,
	0xfa, 0x37, 0x98, 0x46, 0x77, 0xa3, 0xd1, 0x00, 0x61, 0x5d, 0xb2, 0xfb, 0x24, 0xa4, 0x1f, 0x61,
	0x49, 0x59, 0xb8, 0x79, 0xb4, 0x75, 0x7d, 0x53, 0x72, 0x1c, 0x8a, 0x2e, 0xe1, 0x62, 0xa3, 0xcf,
	0x99, 0x64, 0x68, 0x25, 0x8d, 0xd8, 0x38, 0xda, 0xba, 0x7e, 0xe9, 0x7c, 0x8f, 0xf5, 0x98, 0xee,
	0xdc, 0x54, 0xbf, 0x62, 0xdc, 0x25, 0xa7, 0xc0, 0xd4, 0x27, 0x3c, 0xa0, 0x42, 0x50, 0x16, 0x1a,
	0xae, 0x4b, 0x57, 0x0a, 0x18, 0xdc, 0xe9, 0x70, 0x22, 0xc4, 0xfb, 0x3e, 0x15, 0x32, 0x41, 0x5d,
	0x2e, 0xa0, 0x0e, 0xb0, 0x8f, 0x43, 0x8f, 0x24, 0x80, 0x35, 0x8f, 0x89, 0x80, 0x89, 0xcd, 0x03,
	0x2c, 0xc8, 0xe6, 0xd1, 0xf5, 0x03, 0x22, 0xf1, 0xf5, 0x4d, 0x8f, 0xd1, 0x30, 0xee, 0x77, 0x3e,
	0x9e, 0x86, 0x95, 0x7b, 0x82, 0xf0, 0xed, 0x58, 0xec, 0xae, 0x64, 0x9c, 0xa0, 0x97, 0x61, 0x3e,
	0xa1, 0x69, 0x54, 0xd6, 0xab, 0xd7, 0xea, 0x5b, 0x8f, 0x6d, 0xe4, 0x3f, 0x6d, 0xc3, 0x48, 0xb8,
	0x43, 0x28, 0x6a, 0xc3, 0x59, 0x16, 0xc9, 0x1e, 0xa3, 0x61, 0xaf, 0xd9, 0xef, 0x73, 0x76, 0x84,
	0x7d, 0xd1, 0x98, 0xd2, 0xf2, 0x57, 0x8b, 0xf2, 0xea, 0xad, 0x7b, 0x39, 0xb8, 0x5b, 0x24, 0x50,
	0xac, 0x34, 0xf4, 0x58, 0x90, 0x61, 0xad, 0x8e, 0x63, 0x6d, 0xe5, 0xe0, 0x6e, 0x91, 0x00, 0x7d,
	0x0b, 0x9e, 0xc5, 0x91, 0x64, 0x71, 0x03, 0xb9, 0x4b, 0xfc, 0x6e, 0x2b, 0xa4, 0x92, 0x62, 0x49,
	0x3a, 0xc9, 0xa0, 0xda, 0xc9, 0xec, 0x36, 0xa6, 0xd7, 0x2b, 0xd7, 0xe6, 0xdd, 0xc9, 0x05, 0xc6,
	0xb1, 0x27, 0x83, 0x1b, 0xb1, 0xcf, 0x8c, 0x67, 0x2f, 0x08, 0xa0, 0x9b, 0x70, 0x39, 0x05, 0x6e,
	0xfa, 0x7e, 0x91, 0x73, 0x56, 0x73, 0x9e, 0x04, 0x43, 0xef, 0xc0, 0x72, 0x24, 0x08, 0xdf, 0x1f,
	0x59, 0x5f, 0x63, 0x6e, 0xbd, 0x72, 0xad, 0xbe, 0xf5, 0x7f, 0x76, 0xcd, 0xa6, 0x80, 0x6e, 0x5e,
	0xd2, 0xf9, 0xe3, 0x14, 0x2c, 0xdf, 0x26, 0xfc, 0xbe, 0x4f, 0x76, 0x0e, 0xb1, 0xef, 0x93, 0xb0,
	0x47, 0x10, 0x82, 0x69, 0xce, 0x98, 0x6c, 0x54, 0xd6, 0x2b, 0xd7, 0x6a, 0xae, 0xfe, 0x8d, 0x5e,
	0x87, 0x73, 0xe4, 0xb8, 0x4f, 0x3c, 0x49, 0x3a, 0xfb, 0x9c, 0xb1, 0xee, 0x2d, 0x12, 0xf6, 0xe4,
	0x61, 0x63, 0x4a, 0x41, 0xb6, 0x17, 0x3e, 0xfe, 0xf4, 0xf2, 0x99, 0x3f, 0x7f, 0x7a, 0x79, 0xfa,
	0x1e, 0x0d, 0xa5, 0x6b, 0x03, 0xa2, 0x57, 0xe1, 0x62, 0x24, 0xc8, 0x0e, 0x27, 0x58, 0x32, 0xde,
	0x8c, 0x9d, 0xa2, 0x29, 0x6e, 0x11, 0xdc, 0x6d, 0x54, 0xf5, 0x67, 0x97, 0x75, 0xa3, 0x97, 0x60,
	0x29, 0xc0, 0xc7, 0xf7, 0x04, 0x11, 0xfb, 0x84, 0x6b, 0x81, 0x69, 0xcb, 0x4b, 0x73, 0x18, 0xb4,
	0x02, 0xd5, 0x88, 0x53, 0x3d, 0x4d, 0x35, 0x57, 0xfd, 0x44, 0x6b, 0x00, 0x5e, 0x24, 0x24, 0x0b,
	0x76, 0xb1, 0xc4, 0x5a, 0xd7, 0x35, 0x37, 0xd5, 0x82, 0x36, 0x00, 0x79, 0x89, 0x0a, 0xda, 0x1c,
	0x7b, 0xf7, 0x09, 0x6f, 0x75, 0xb4, 0x66, 0x6b, 0xae, 0xa5, 0x47, 0xf1, 0xf9, 0x04, 0x77, 0xef,
	0xd2, 0x5e, 0x48, 0x78, 0x63, 0x3e, 0xe6, 0x1b, 0xb5, 0x38, 0x3f, 0xae, 0xc0, 0xea, 0x8d, 0xf6,
	0x4d, 0xf5, 0x84, 0x65, 0xc4, 0x53, 0xfa, 0xbd, 0x00, 0xb3, 0x22, 0x96, 0x8a, 0x35, 0x6c, 0x9e,
	0x4a, 0x46, 0x30, 0x55, 0x3a, 0x02, 0xf3, 0x8d, 0xd5, 0xb2, 0x6f, 0x9c, 0xce, 0x7f, 0xa3, 0xf3,
	0xf7, 0x2a, 0x9c, 0xb7, 0xb9, 0x30, 0xba, 0x04, 0xf3, 0x92, 0xdd, 0xa2, 0x42, 0xb6, 0x3a, 0x66,
	0x50, 0xc3, 0x67, 0xf4, 0xbc, 0xf2, 0x65, 0x63, 0xd7, 0xdb, 0x03, 0x03, 0x8a, 0x47, 0x55, 0xec,
	0x40, 0x4d, 0x58, 0x4c, 0x22, 0x6c, 0x9b, 0x06, 0x24, 0xf1, 0xfa, 0xc7, 0x2d, 0xb6, 0xa9, 0xe6,
	0x0d, 0x87, 0x3d, 0xe2, 0x66, 0x25, 0xd0, 0x57, 0xd4, 0x60, 0xee, 0x93, 0xb0, 0xd5, 0x51, 0x5e,
	0x7c, 0xa2, 0xf4, 0x10, 0x8c, 0x76, 0x60, 0x89, 0x7d, 0x18, 0x12, 0x2e, 0x0e, 0x69, 0x3f, 0x7e,
	0xf9, 0xcc, 0xc9, 0xe2, 0x39, 0x91, 0x44, 0xab, 0xb3, 0x65, 0x5a, 0x9d, 0x2b, 0x58, 0xce, 0x1a,
	0x00, 0x36, 0x8a, 0x6c, 0x75, 0x12, 0x4b, 0x18, 0xb5, 0xa0, 0x77, 0x61, 0x25, 0x79, 0xda, 0xe1,
	0x54, 0x12, 0x4e, 0x71, 0xa3, 0xa6, 0x3d, 0xf6, 0xb9, 0xe2, 0xc0, 0xf2, 0x53, 0x93, 0x48, 0xb8,
	0x05, 0x0e, 0x74, 0x15, 0xe6, 0x8e, 0x08, 0x57, 0x7e, 0xdc, 0x00, 0x8b, 0x4b, 0x24, 0x9d, 0xce,
	0x3f, 0xcc, 0xac, 0xe7, 0x43, 0xac, 0x1a, 0x78, 0x97, 0xb3, 0x20, 0x33, 0xef, 0xa9, 0x96, 0x47,
	0x33, 0xff, 0x2f, 0x9d, 0xf9, 0xfc, 0xf4, 0x9c, 0xc2, 0xcc, 0xbf, 0x05, 0x4b, 0xb7, 0x71, 0x18,
	0x61, 0x7f, 0x3b, 0x59, 0xee, 0x1f, 0x2e, 0x4b, 0x70, 0x7e, 0x5b, 0x81, 0x8b, 0x2e, 0xf1, 0x22,
	0xce, 0x69, 0xd8, 0xdb, 0xcb, 0xaa, 0xed, 0x39, 0xa8, 0x09, 0x89, 0xb9, 0x54, 0x4f, 0xb1, 0x11,
	0xe5, 0x86, 0x33, 0xea, 0x56, 0xc1, 0x9c, 0x86, 0x92, 0xf0, 0x23, 0xec, 0x8f, 0x59, 0x41, 0x72,
	0x18, 0xf4, 0x9a, 0x0e, 0x8c, 0xbc, 0x47, 0xf6, 0x09, 0xa7, 0xac, 0x63, 0x24, 0xab, 0x16, 0x49,
	0x0b, 0xce, 0xf9, 0xc1, 0x34, 0x9c, 0x6b, 0x85, 0x1e, 0x27, 0x01, 0x09, 0x95, 0xbd, 0x26, 0xaa,
	0x78, 0x03, 0x16, 0xf5, 0xc0, 0xb6, 0x27, 0xd6, 0x47, 0x16, 0xaf, 0xd6, 0x44, 0x9a, 0xf0, 0xb6,
	0x8d, 0x25, 0x6e, 0x0f, 0xec, 0x6b, 0xa2, 0x05, 0x88, 0xde, 0x86, 0xc7, 0x86, 0xcd, 0x59, 0x9d,
	0x6e, 0x0f, 0xac, 0x5f, 0x57, 0x0e, 0x47, 0xdb, 0xb0, 0xda, 0x89, 0xb8, 0x1e, 0xf2, 0x9b, 0x9c,
	0x05, 0xba, 0x59, 0xe2, 0xa0, 0x6f, 0x5d, 0x2c, 0xed, 0x50, 0xf4, 0x0a, 0x5c, 0xc0, 0xbe, 0xcf,
	0x3e, 0xdc, 0x3b, 0x22, 0x9c, 0xd3, 0x0e, 0x19, 0x91, 0xc4, 0xd9, 0x4e, 0x49, 0x2f, 0xf2, 0xe0,
	0x22, 0xb7, 0xdb, 0x86, 0xf6, 0xa5, 0xfa, 0xd6, 0xb3, 0x45, 0x95, 0x96, 0x18, 0x93, 0x5b, 0xc6,
	0x84, 0xde, 0x84, 0xb5, 0xcc, 0xeb, 0xdf, 0xa3, 0xf2, 0xb0, 0x19, 0x0e, 0xde, 0xc5, 0x3e, 0xed,
	0x68, 0x9d, 0x6a, 0xf7, 0x9c, 0x77, 0x4f, 0x40, 0x39, 0xbf, 0xaa, 0xc2, 0x53, 0xfb, 0x9c, 0x74,
	0x88, 0x54, 0x59, 0x50, 0x48, 0x3a, 0x7b, 0xbc, 0x43, 0xf8, 0x0e, 0xf6, 0xbd, 0xc8, 0xd7, 0xc3,
	0xbb, 0x4d, 0xe4, 0x21, 0xeb, 0x28, 0x65, 0x44, 0x82, 0x28, 0x1e, 0xec, 0xfb, 0x77, 0xa2, 0x60,
	0x94, 0xa6, 0x55, 0x62, 0x65, 0xd8, 0x7b, 0xd1, 0xd7, 0xe1, 0xf1, 0x48, 0x28, 0x03, 0x6c, 0x33,
	0x93, 0xc7, 0x64, 0x84, 0xa7, 0xb4, 0xf0, 0x38, 0x08, 0xda, 0x85, 0x27, 0xe3, 0x6e, 0x35, 0x3b,
	0x36, 0x8e, 0x38, 0x61, 0x1a, 0x0f, 0x42, 0x2e, 0x5c, 0x89, 0x01, 0xad, 0x51, 0xa0, 0xb6, 0x91,
	0xc5, 0x69, 0xf2, 0x44, 0x58, 0xf3, 0x6d, 0xb9, 0x74, 0x51, 0xa5, 0x5b, 0xad, 0xb0, 0x43, 0x8e,
	0x8d, 0x95, 0x8c, 0x83, 0x94, 0xa4, 0x38, 0xb3, 0x65, 0x29, 0x8e, 0xf3, 0xcb, 0x29, 0x58, 0xcd,
	0xcc, 0xd6, 0xd0, 0xf9, 0x6e, 0xaa, 0xb4, 0x30, 0x1d, 0xda, 0x8c, 0xfb, 0xae, 0x17, 0x6d, 0x2d,
	0x1b, 0x02, 0xdd, 0x9c, 0x1c, 0x7a, 0x2f, 0xe5, 0xc6, 0xa3, 0x17, 0xe8, 0x99, 0xaa, 0x6f, 0x3d,
	0x6d, 0x8d, 0xd3, 0x79, 0xb0, 0x6b, 0x63, 0x40, 0x01, 0x5c, 0x60, 0x56, 0xe3, 0xd2, 0x33, 0x58,
	0xdf, 0x7a, 0xb9, 0xc8, 0x3d, 0x81, 0x65, 0xba, 0x25, 0xa4, 0xce, 0x83, 0x0a, 0x9c, 0x6b, 0x46,
	0x92, 0xed, 0x12, 0x9f, 0xa8, 0xe6, 0xbd, 0xbe, 0xfa, 0x2b, 0xd0, 0x3a, 0xd4, 0x71, 0x57, 0x12,
	0xbe, 0x17, 0x92, 0x7b, 0x82, 0x18, 0xf3, 0x4d, 0x37, 0xa9, 0x79, 0x8d, 0x1f, 0x63, 0x7b, 0xbe,
	0x8d, 0x8f, 0x6d, 0x36, 0x3b, 0x06, 0x32, 0x0c, 0x1d, 0x3b, 0x2c, 0x52, 0xa1, 0xbb, 0x8f, 0xb9,
	0x1c, 0xec, 0x47, 0xbc, 0x47, 0x8c, 0xb1, 0x96, 0xf4, 0xa2, 0x17, 0xe0, 0x9c, 0xee, 0xd1, 0x4f,
	0xad, 0xee, 0x8d, 0xe3, 0x3e, 0xe5, 0xa4, 0x63, 0x8c, 0xd2, 0xd6, 0xe5, 0xfc, 0xa1, 0x0a, 0xcb,
	0xc9, 0x0a, 0xd9, 0x0c, 0x14, 0xa1, 0x50, 0xc1, 0x8f, 0xc5, 0xe3, 0xca, 0xf6, 0x58, 0x57, 0x23,
	0x3b, 0x14, 0xdd, 0x82, 0x4b, 0xfd, 0x94, 0x47, 0xe6, 0x88, 0x6c, 0x31, 0x7d, 0x0c, 0x1e, 0xed,
	0xc3, 0x13, 0xfd, 0x8c, 0x6f, 0xe6, 0xf8, 0x6c, 0xd1, 0x7d, 0xac, 0x04, 0xfa, 0x0e, 0x3c, 0xd5,
	0xb7, 0x39, 0x68, 0x8e, 0xd8, 0x16, 0xee, 0x27, 0x11, 0x44, 0xd7, 0x60, 0x19, 0xeb, 0x5f, 0x79,
	0xb7, 0xcc, 0x37, 0xa3, 0x36, 0x20, 0x4e, 0x04, 0xd1, 0x0b, 0x7a, 0xcb, 0x2c, 0xd4, 0xc9, 0x16,
	0xf4, 0x8a, 0x2d, 0xd2, 0xe7, 0xb1, 0xae, 0x45, 0xde, 0x39, 0x02, 0x54, 0x44, 0x7e, 0xf9, 0xb9,
	0x85, 0xf3, 0x97, 0x2a, 0x2c, 0xe7, 0xad, 0x79, 0x17, 0x2e, 0x30, 0xbb, 0x2b, 0xd8, 0x86, 0x50,
	0x82, 0x45, 0x77, 0xe0, 0xf1, 0xb4, 0x85, 0xd8, 0xbc, 0x2a, 0x4f, 0x35, 0x4e, 0x00, 0xb9, 0xf0,
	0x64, 0xd6, 0x42, 0xf2, 0x8c, 0x36, 0xa3, 0x1a, 0x2f, 0x82, 0xbe, 0x0b, 0x57, 0xac, 0xc6, 0x91,
	0xa7, 0xb6, 0x99, 0xd5, 0x44, 0x92, 0xff, 0x76, 0xbb, 0xfa, 0x75, 0x65, 0x14, 0x2f, 0xcc, 0xbb,
	0xd0, 0x0b, 0xb0, 0x10, 0x9e, 0x34, 0xab, 0x19, 0x04, 0x7a, 0x11, 0xe6, 0xe2, 0xe1, 0x26, 0xb5,
	0xb1, 0x31, 0x59, 0x62, 0x82, 0x44, 0x5b, 0xb0, 0xe8, 0x63, 0x21, 0xef, 0xf5, 0x3b, 0x4a, 0x43,
	0x4d, 0xbb, 0xd7, 0x67, 0x21, 0xce, 0xef, 0x2b, 0xb0, 0xb0, 0xc3, 0x68, 0x98, 0xbc, 0x1a, 0x2d,
	0xc1, 0x94, 0x64, 0x66, 0x6f, 0x36, 0x25, 0x19, 0xda, 0x84, 0x19, 0x8f, 0xd1, 0x70, 0x34, 0x8e,
	0xb8, 0x56, 0xb8, 0x71, 0x80, 0x05, 0xd9, 0x30, 0xb5, 0xc2, 0x0d, 0xc5, 0xe0, 0xc6, 0x38, 0x74,
	0x13, 0x2e, 0x33, 0x93, 0x0d, 0x29, 0x43, 0xd0, 0x19, 0x51, 0x5c, 0x5d, 0x4a, 0x0a, 0x2d, 0x26,
	0x46, 0x9f, 0x04, 0x43, 0xaf, 0xc2, 0xc5, 0x04, 0xd2, 0x66, 0x0a, 0x60, 0x66, 0x9f, 0x71, 0x13,
	0xb0, 0xcb, 0xba, 0x9d, 0x5f, 0x54, 0x61, 0xf1, 0x76, 0x24, 0x54, 0xda, 0xaa, 0xb3, 0x30, 0xa1,
	0xa6, 0xc0, 0x63, 0xbe, 0x4f, 0x3c, 0xa5, 0xbe, 0x64, 0xf3, 0x99, 0x9f, 0x82, 0x34, 0x02, 0x7d,
	0x0d, 0xea, 0xb1, 0x62, 0xf5, 0xe6, 0xcd, 0x2c, 0xcf, 0x63, 0xf7, 0x77, 0x69, 0xbc, 0x65, 0x87,
	0x58, 0xfd, 0xfc, 0x3b, 0xc4, 0x87, 0xde, 0x9f, 0xa6, 0x54, 0xa7, 0x34, 0xb3, 0x13, 0x71, 0xae,
	0xf6, 0x02, 0x2a, 0xaa, 0xcd, 0x64, 0x55, 0x97, 0xeb, 0x56, 0x92, 0x41, 0x24, 0xe4, 0x5d, 0x2c,
	0xa9, 0xe8, 0x0e, 0xde, 0x64, 0xbc, 0xe9, 0xfb, 0x4d, 0x21, 0x88, 0x4c, 0xea, 0x85, 0x65, 0xdd,
	0x6a, 0x6d, 0x1d, 0x0e, 0x7f, 0xe7, 0x90, 0x78, 0xf7, 0xf7, 0xd5, 0xba, 0x6b, 0x76, 0xb1, 0xb6,
	0x2e, 0xe7, 0x0d, 0x58, 0xdd, 0x1d, 0x84, 0x38, 0xa0, 0x9e, 0x2e, 0x29, 0x8f, 0x2a, 0x56, 0x57,
	0x61, 0x4e, 0xa8, 0x96, 0x92, 0x89, 0x4a, 0x3a, 0x9d, 0xbf, 0x56, 0x60, 0xd1, 0x58, 0x8b, 0xa6,
	0x15, 0x2a, 0xe1, 0x53, 0xe3, 0xdb, 0x26, 0xef, 0x61, 0x11, 0xec, 0xb0, 0x50, 0x72, 0xec, 0x49,
	0x93, 0x83, 0x58, 0x7a, 0xd0, 0x4b, 0xb0, 0xaa, 0x5a, 0xef, 0xb0, 0xbc, 0x48, 0x9c, 0x84, 0xd8,
	0x3b, 0xd5, 0xa7, 0xc6, 0x5c, 0xb7, 0xe8, 0x07, 0x11, 0xed, 0x50, 0x39, 0xd8, 0x67, 0xcc, 0x37,
	0x76, 0x6d, 0xeb, 0x52, 0x09, 0xcb, 0x90, 0x2a, 0x2b, 0x14, 0x9b, 0x72, 0x49, 0xaf, 0xf3, 0x43,
	0xf5, 0x85, 0xbe, 0x9e, 0x1a, 0xf3, 0x85, 0x6f, 0xc0, 0x02, 0xeb, 0x76, 0x7d, 0x1a, 0x92, 0x9b,
	0x2c, 0xe2, 0x49, 0x1a, 0x3a, 0xd6, 0x2e, 0x32, 0x02, 0xca, 0xb0, 0xcd, 0xf3, 0x2e, 0x1e, 0x24,
	0x7e, 0x3d, 0xde, 0xb0, 0x53, 0x78, 0xe7, 0x77, 0x0b, 0xb0, 0x92, 0x2f, 0x19, 0xa0, 0xdb, 0xb0,
	0x12, 0x64, 0x73, 0xf0, 0x64, 0x60, 0x96, 0x22, 0x71, 0x2e, 0x5b, 0x77, 0x0b, 0xa2, 0xe8, 0xdb,
	0xb0, 0xda, 0xb7, 0x65, 0xe1, 0xc6, 0x0b, 0x9f, 0x39, 0x21, 0x91, 0x1d, 0xa6, 0xc9, 0x76, 0x16,
	0xf4, 0x0e, 0x2c, 0xe3, 0x6c, 0x4a, 0x67, 0x32, 0x64, 0xcb, 0x60, 0x73, 0xb9, 0x9f, 0x9b, 0x97,
	0x54, 0x64, 0x81, 0x65, 0xf5, 0xb2, 0x7f, 0x79, 0x16, 0xe8, 0xe6, 0x25, 0xd1, 0x2e, 0x2c, 0x7a,
	0xa9, 0x68, 0x9c, 0x94, 0x95, 0xd6, 0x8a, 0x54, 0xe9, 0xa0, 0xed, 0x66, 0x85, 0xd0, 0xeb, 0x70,
	0x89, 0x93, 0x0f, 0x22, 0xca, 0x49, 0x9b, 0xdd, 0xf8, 0x20, 0xc2, 0xbe, 0x48, 0xad, 0x9b, 0xc6,
	0x8d, 0xc7, 0x20, 0xd0, 0x36, 0x3c, 0x61, 0x7a, 0x55, 0x68, 0x2e, 0x32, 0xc4, 0x3b, 0xdf, 0xb1,
	0x18, 0xf4, 0x36, 0xac, 0x0f, 0xdf, 0xb0, 0xcb, 0x88, 0xb8, 0xc3, 0xa4, 0x06, 0xa5, 0x79, 0xe6,
	0x35, 0xcf, 0x89, 0x38, 0x74, 0x07, 0x9c, 0xd4, 0xbb, 0xca, 0xd8, 0x6a, 0x9a, 0x6d, 0x02, 0xa4,
	0xda, 0xdb, 0x27, 0xe1, 0x4f, 0x28, 0xdc, 0x5e, 0xe1, 0x40, 0x0a, 0xe2, 0xbd, 0xfd, 0x78, 0x94,
	0xd2, 0xd3, 0x10, 0xd1, 0x66, 0xad, 0xc2, 0x01, 0x54, 0x3d, 0xd6, 0xd3, 0x38, 0x8c, 0xda, 0x0d,
	0xe2, 0xe2, 0x26, 0xaa, 0xb1, 0x50, 0xb6, 0x1b, 0xb4, 0xec, 0xb8, 0x5c, 0x1b, 0x03, 0xba, 0x01,
	0x8b, 0x91, 0x20, 0xdc, 0x65, 0x03, 0xec, 0x4b, 0x4a, 0x44, 0x63, 0x51, 0x53, 0x5e, 0xb6, 0x1f,
	0xda, 0x0c, 0x61, 0x6e, 0x56, 0x4a, 0xd1, 0x04, 0xe9, 0x95, 0xb4, 0xb1, 0xa4, 0x2d, 0xd2, 0x42,
	0x93, 0x59, 0x70, 0xdd, 0xac, 0x14, 0x7a, 0x1f, 0x2e, 0x74, 0x6c, 0xa1, 0x5e, 0x34, 0x96, 0x35,
	0x9f, 0xc5, 0xa5, 0xad, 0x4b, 0x83, 0x5b, 0x42, 0xa3, 0x5e, 0x40, 0xe4, 0x61, 0xf1, 0xf4, 0x43,
	0x34, 0x56, 0xca, 0x5e, 0x60, 0x3d, 0x2d, 0x71, 0x4b, 0x68, 0xd0, 0x0e, 0x2c, 0x08, 0x12, 0xaa,
	0x9d, 0xb0, 0x8e, 0xc3, 0x8d, 0xb3, 0x65, 0xea, 0xcc, 0x2c, 0x48, 0x6e, 0x46, 0x08, 0xb5, 0x60,
	0x99, 0x13, 0x8f, 0xf6, 0x29, 0x09, 0xa5, 0xe1, 0x41, 0x93, 0xf1, 0xe4, 0xe5, 0x14, 0x15, 0x4d,
	0x12, 0x1e, 0x43, 0x75, 0x6e, 0x42, 0xaa, 0x9c, 0x9c, 0x9a, 0x63, 0x9c, 0x5e, 0x63, 0x1a, 0xe7,
	0x4b, 0x89, 0xd2, 0x30, 0x37, 0x2b, 0x85, 0xae, 0xc2, 0x92, 0x9a, 0xf4, 0x7d, 0x4e, 0x19, 0xa7,
	0x92, 0x7e, 0x44, 0x1a, 0xab, 0xda, 0x01, 0x72, 0xad, 0x8e, 0x07, 0x8b, 0x19, 0x93, 0x43, 0xcf,
	0x03, 0xf4, 0x09, 0xf7, 0x48, 0x28, 0x71, 0xcf, 0xbe, 0xed, 0x4a, 0xf5, 0xa3, 0x2b, 0xb0, 0xd8,
	0xc7, 0x03, 0x16, 0xc9, 0x24, 0x9d, 0x8c, 0x4f, 0x08, 0xb2, 0x8d, 0xce, 0x4f, 0x6b, 0xd0, 0x28,
	0x3b, 0xdb, 0x78, 0xb4, 0x5c, 0xfd, 0x4f, 0x2d, 0x57, 0x93, 0x2c, 0x35, 0x73, 0x13, 0x2e, 0x35,
	0x25, 0xe1, 0x78, 0xfe, 0x34, 0xc2, 0x71, 0x36, 0x8e, 0xd6, 0x4e, 0x39, 0x8e, 0xc2, 0x97, 0x1d,
	0x47, 0xeb, 0xa7, 0x13, 0x47, 0x2d, 0x21, 0x70, 0xe1, 0xf4, 0x42, 0xe0, 0xe2, 0x69, 0x85, 0xc0,
	0xa5, 0x53, 0x0a, 0x81, 0xcb, 0xd6, 0x10, 0xf8, 0xf3, 0x1a, 0x34, 0xca, 0xce, 0xdf, 0x1e, 0x45,
	0xa7, 0xff, 0xa8, 0xe8, 0x74, 0x52, 0x32, 0x3c, 0x3b, 0x41, 0x32, 0x3c, 0x59, 0x02, 0x3b, 0x37,
	0x71, 0x02, 0xfb, 0x28, 0x4a, 0x7d, 0xd9, 0x51, 0x2a, 0x9f, 0xed, 0x2d, 0x3c, 0x64, 0xb6, 0xf7,
	0x5f, 0x1a, 0x9f, 0xbe, 0x3f, 0x0d, 0x68, 0x67, 0x58, 0x0d, 0x9b, 0xf8, 0x02, 0x47, 0xfa, 0x5a,
	0xcf, 0xd4, 0x24, 0xd7, 0x7a, 0xaa, 0x13, 0x5f, 0xee, 0x98, 0xfe, 0x42, 0x97, 0x3b, 0x66, 0xbe,
	0xd8, 0xe5, 0x8e, 0xd9, 0x87, 0xbe, 0xdc, 0x31, 0x57, 0x76, 0xb9, 0x63, 0xfe, 0x84, 0xcb, 0x1d,
	0xb5, 0xc2, 0xe5, 0x8e, 0x3b, 0x96, 0xcb, 0x1d, 0xa0, 0xad, 0xc0, 0x29, 0x8f, 0xb4, 0x93, 0x5d,
	0xea, 0xa8, 0x8f, 0xbb, 0xd4, 0xf1, 0x9b, 0x0a, 0x3c, 0xd6, 0x1c, 0x0e, 0x83, 0x84, 0x92, 0x76,
	0x29, 0xe1, 0xbb, 0x44, 0x62, 0xea, 0x8b, 0xdc, 0xa8, 0x2b, 0x85, 0x51, 0x5f, 0x81, 0xc5, 0xe4,
	0xe9, 0x16, 0x39, 0x22, 0x7e, 0x92, 0xad, 0x67, 0x1a, 0x75, 0xd5, 0xde, 0x52, 0x24, 0xae, 0xb9,
	0xf9, 0xe6, 0xf4, 0xa8, 0xa7, 0xc7, 0x8d, 0xfa, 0x27, 0x73, 0x30, 0x3f, 0x2c, 0x6a, 0x23, 0x98,
	0x56, 0x56, 0x9a, 0xdc, 0x30, 0x54, 0xbf, 0xd1, 0x3a, 0xd4, 0x65, 0x72, 0xf4, 0x41, 0xe2, 0x32,
	0x58, 0xcd, 0x4d, 0x37, 0x65, 0xee, 0xae, 0x54, 0x27, 0xbf, 0xe1, 0xfa, 0x21, 0xac, 0xf7, 0x39,
	0xf1, 0xcc, 0x79, 0x29, 0x49, 0x16, 0x4a, 0x7d, 0x2a, 0x62, 0x3e, 0xda, 0x2c, 0x6a, 0xff, 0x5f,
	0x3e, 0x6f, 0x05, 0x45, 0xbb, 0x27, 0x92, 0xa2, 0x26, 0x2c, 0xc4, 0x8b, 0xbf, 0xbe, 0x08, 0x99,
	0x18, 0xfd, 0x93, 0x65, 0x39, 0x83, 0x46, 0xb9, 0x19, 0x11, 0x74, 0x17, 0x50, 0x3a, 0x20, 0x1a,
	0xa2, 0xd8, 0xfc, 0x9f, 0x1a, 0x1f, 0x53, 0x63, 0x3a, 0x8b, 0xb8, 0xd2, 0x7e, 0x40, 0x02, 0x66,
	0x7c, 0x41, 0xff, 0x46, 0xef, 0xc3, 0xf9, 0xfe, 0x30, 0xdc, 0x74, 0x46, 0x25, 0x93, 0x79, 0xfd,
	0xaa, 0xcf, 0xa5, 0x18, 0x2b, 0x11, 0xfa, 0x06, 0x3c, 0xc3, 0x42, 0x7f, 0x10, 0x57, 0x9b, 0x47,
	0x80, 0x62, 0x50, 0x13, 0xa6, 0x70, 0x34, 0x29, 0x1c, 0xb5, 0xe1, 0x69, 0x1b, 0xb4, 0x58, 0xfe,
	0x89, 0x8b, 0x48, 0x93, 0x81, 0xcb, 0x58, 0x8b, 0xa5, 0xa9, 0x7a, 0x39, 0x6b, 0xb1, 0x42, 0x15,
	0xe7, 0x7e, 0xde, 0xe8, 0xec, 0x3e, 0x5b, 0x5f, 0xb2, 0xe7, 0x7e, 0x45, 0xb8, 0x6b, 0x67, 0x41,
	0x1b, 0x50, 0x0f, 0xa3, 0xa0, 0x29, 0x25, 0x09, 0xfa, 0x32, 0x5e, 0xdc, 0xf2, 0x0e, 0x99, 0x06,
	0x38, 0x3f, 0xab, 0xe8, 0xeb, 0x15, 0x16, 0xa6, 0xaf, 0xc2, 0x59, 0x56, 0xb8, 0x06, 0x64, 0xab,
	0x04, 0x14, 0x61, 0xe8, 0x2d, 0x58, 0x49, 0x62, 0x77, 0x72, 0x0f, 0x67, 0x92, 0xaa, 0x76, 0x41,
	0xc8, 0x79, 0x1d, 0x96, 0x8c, 0x6b, 0x60, 0x79, 0xd8, 0x92, 0x24, 0x50, 0xa6, 0x8b, 0x87, 0x07,
	0xfb, 0xae, 0xfe, 0x8d, 0x1a, 0x30, 0xc7, 0x42, 0x97, 0xf6, 0x0e, 0x93, 0x43, 0x82, 0xe4, 0xd1,
	0xf9, 0x1e, 0xd4, 0x53, 0xae, 0xa5, 0x84, 0x7d, 0x82, 0xbb, 0x89, 0xb0, 0xfa, 0x8d, 0x5e, 0x81,
	0x19, 0x9c, 0x3a, 0xd6, 0x5b, 0x2f, 0x75, 0x4e, 0x33, 0x02, 0x37, 0x86, 0xab, 0x30, 0x9a, 0xdc,
	0xf5, 0xd5, 0xae, 0x65, 0xc2, 0x63, 0xb6, 0xd1, 0x79, 0x0b, 0xce, 0x16, 0x5c, 0x12, 0x9d, 0x87,
	0x99, 0x90, 0x85, 0x9e, 0x29, 0xac, 0xb8, 0xf1, 0x03, 0x7a, 0x02, 0x6a, 0x62, 0x48, 0x16, 0xc7,
	0xe4, 0x51, 0xc3, 0xf6, 0xbb, 0x1f, 0x7f, 0xb6, 0x56, 0xf9, 0xe4, 0xb3, 0xb5, 0xca, 0xdf, 0x3e,
	0x5b, 0xab, 0xfc, 0xe8, 0xc1, 0xda, 0x99, 0x4f, 0x1e, 0xac, 0x9d, 0xf9, 0xd3, 0x83, 0xb5, 0x33,
	0xdf, 0x7c, 0xad, 0x47, 0xe5, 0x61, 0x74, 0xb0, 0xe1, 0xb1, 0x60, 0xf3, 0x80, 0xca, 0x03, 0xdc,
	0xe9, 0x11, 0x31, 0xfa, 0xe5, 0x1d, 0x62, 0x1a, 0x6e, 0x1e, 0x6f, 0x66, 0xfe, 0xe5, 0x40, 0x0e,
	0xfa, 0x44, 0x6c, 0x1e, 0x6d, 0x5d, 0x3f, 0x98, 0xd5, 0xff, 0x50, 0xf0, 0xe2, 0x3f, 0x03, 0x00,
	0x00, 0xff, 0xff, 0x3b, 0x9a, 0x61, 0x77, 0x27, 0x31, 0x00, 0x00,
}

func (m *UserBalanceStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserBalanceStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserBalanceStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserPermissions != nil {
		{
			size, err := m.UserPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.AutoApproveAllIncomingTransfers {
		i--
		if m.AutoApproveAllIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		i--
		if m.AutoApproveSelfInitiatedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		i--
		if m.AutoApproveSelfInitiatedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.IncomingApprovals) > 0 {
		for iNdEx := len(m.IncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IncomingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OutgoingApprovals) > 0 {
		for iNdEx := len(m.OutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutgoingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MerkleChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerkleChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LeafSigner) > 0 {
		i -= len(m.LeafSigner)
		copy(dAtA[i:], m.LeafSigner)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.LeafSigner)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.MaxUsesPerLeaf.Size()
		i -= size
		if _, err := m.MaxUsesPerLeaf.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.UseCreatorAddressAsLeaf {
		i--
		if m.UseCreatorAddressAsLeaf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ExpectedProofLength.Size()
		i -= size
		if _, err := m.ExpectedProofLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ETHSignatureChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ETHSignatureChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ETHSignatureChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserOutgoingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserOutgoingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserOutgoingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Version.Size()
		i -= size
		if _, err := m.Version.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.ApprovalCriteria != nil {
		{
			size, err := m.ApprovalCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToListId) > 0 {
		i -= len(m.ToListId)
		copy(dAtA[i:], m.ToListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserIncomingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIncomingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserIncomingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Version.Size()
		i -= size
		if _, err := m.Version.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.ApprovalCriteria != nil {
		{
			size, err := m.ApprovalCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromListId) > 0 {
		i -= len(m.FromListId)
		copy(dAtA[i:], m.FromListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.FromListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ManualBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManualBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ManualBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecurringOwnershipTimes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecurringOwnershipTimes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecurringOwnershipTimes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ChargePeriodLength.Size()
		i -= size
		if _, err := m.ChargePeriodLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.IntervalLength.Size()
		i -= size
		if _, err := m.IntervalLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.StartTime.Size()
		i -= size
		if _, err := m.StartTime.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IncrementedBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrementedBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrementedBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowOverrideWithAnyValidToken {
		i--
		if m.AllowOverrideWithAnyValidToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RecurringOwnershipTimes != nil {
		{
			size, err := m.RecurringOwnershipTimes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.AllowOverrideTimestamp {
		i--
		if m.AllowOverrideTimestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.DurationFromTimestamp.Size()
		i -= size
		if _, err := m.DurationFromTimestamp.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.IncrementOwnershipTimesBy.Size()
		i -= size
		if _, err := m.IncrementOwnershipTimesBy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.IncrementTokenIdsBy.Size()
		i -= size
		if _, err := m.IncrementTokenIdsBy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.StartBalances) > 0 {
		for iNdEx := len(m.StartBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StartBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PredeterminedOrderCalculationMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredeterminedOrderCalculationMethod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredeterminedOrderCalculationMethod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	if m.UseMerkleChallengeLeafIndex {
		i--
		if m.UseMerkleChallengeLeafIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.UsePerInitiatedByAddressNumTransfers {
		i--
		if m.UsePerInitiatedByAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UsePerFromAddressNumTransfers {
		i--
		if m.UsePerFromAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UsePerToAddressNumTransfers {
		i--
		if m.UsePerToAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UseOverallNumTransfers {
		i--
		if m.UseOverallNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PredeterminedBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredeterminedBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredeterminedBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderCalculationMethod != nil {
		{
			size, err := m.OrderCalculationMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IncrementedBalances != nil {
		{
			size, err := m.IncrementedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ManualBalances) > 0 {
		for iNdEx := len(m.ManualBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManualBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AutoDeletionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoDeletionOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutoDeletionOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowPurgeIfExpired {
		i--
		if m.AllowPurgeIfExpired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AllowCounterpartyPurge {
		i--
		if m.AllowCounterpartyPurge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AfterOverallMaxNumTransfers {
		i--
		if m.AfterOverallMaxNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.AfterOneUse {
		i--
		if m.AfterOneUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ApprovalAmounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalAmounts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalAmounts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResetTimeIntervals != nil {
		{
			size, err := m.ResetTimeIntervals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AmountTrackerId) > 0 {
		i -= len(m.AmountTrackerId)
		copy(dAtA[i:], m.AmountTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.AmountTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.PerInitiatedByAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerInitiatedByAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PerFromAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerFromAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PerToAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerToAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OverallApprovalAmount.Size()
		i -= size
		if _, err := m.OverallApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResetTimeIntervals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetTimeIntervals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetTimeIntervals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.IntervalLength.Size()
		i -= size
		if _, err := m.IntervalLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.StartTime.Size()
		i -= size
		if _, err := m.StartTime.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MaxNumTransfers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxNumTransfers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxNumTransfers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResetTimeIntervals != nil {
		{
			size, err := m.ResetTimeIntervals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AmountTrackerId) > 0 {
		i -= len(m.AmountTrackerId)
		copy(dAtA[i:], m.AmountTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.AmountTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.PerInitiatedByAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerInitiatedByAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PerFromAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerFromAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PerToAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerToAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OverallMaxNumTransfers.Size()
		i -= size
		if _, err := m.OverallMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApprovalTracker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalTracker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalTracker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.LastUpdatedAt.Size()
		i -= size
		if _, err := m.LastUpdatedAt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Amounts) > 0 {
		for iNdEx := len(m.Amounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.NumTransfers.Size()
		i -= size
		if _, err := m.NumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CoinTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverrideToWithInitiator {
		i--
		if m.OverrideToWithInitiator {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.OverrideFromWithApproverAddress {
		i--
		if m.OverrideFromWithApproverAddress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MustOwnTokens) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MustOwnTokens) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MustOwnTokens) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OwnershipCheckParty) > 0 {
		i -= len(m.OwnershipCheckParty)
		copy(dAtA[i:], m.OwnershipCheckParty)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.OwnershipCheckParty)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MustSatisfyForAllAssets {
		i--
		if m.MustSatisfyForAllAssets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.OverrideWithCurrentTime {
		i--
		if m.OverrideWithCurrentTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.AmountRange != nil {
		{
			size, err := m.AmountRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DynamicStoreChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicStoreChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicStoreChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AddressChecks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressChecks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressChecks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MustNotBeLiquidityPool {
		i--
		if m.MustNotBeLiquidityPool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.MustBeLiquidityPool {
		i--
		if m.MustBeLiquidityPool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.MustNotBeWasmContract {
		i--
		if m.MustNotBeWasmContract {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MustBeWasmContract {
		i--
		if m.MustBeWasmContract {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AltTimeChecks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AltTimeChecks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AltTimeChecks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OfflineDays) > 0 {
		for iNdEx := len(m.OfflineDays) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OfflineDays[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OfflineHours) > 0 {
		for iNdEx := len(m.OfflineHours) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OfflineHours[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MustPrioritize {
		i--
		if m.MustPrioritize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.AltTimeChecks != nil {
		{
			size, err := m.AltTimeChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.InitiatorChecks != nil {
		{
			size, err := m.InitiatorChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.RecipientChecks != nil {
		{
			size, err := m.RecipientChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.SenderChecks != nil {
		{
			size, err := m.SenderChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.EthSignatureChallenges) > 0 {
		for iNdEx := len(m.EthSignatureChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EthSignatureChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.MustOwnTokens) > 0 {
		for iNdEx := len(m.MustOwnTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.UserRoyalties != nil {
		{
			size, err := m.UserRoyalties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.OverridesToIncomingApprovals {
		i--
		if m.OverridesToIncomingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.OverridesFromOutgoingApprovals {
		i--
		if m.OverridesFromOutgoingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserRoyalties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRoyalties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRoyalties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PayoutAddress) > 0 {
		i -= len(m.PayoutAddress)
		copy(dAtA[i:], m.PayoutAddress)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.PayoutAddress)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Percentage.Size()
		i -= size
		if _, err := m.Percentage.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OutgoingApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutgoingApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutgoingApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MustPrioritize {
		i--
		if m.MustPrioritize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.AltTimeChecks != nil {
		{
			size, err := m.AltTimeChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.InitiatorChecks != nil {
		{
			size, err := m.InitiatorChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.RecipientChecks != nil {
		{
			size, err := m.RecipientChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.EthSignatureChallenges) > 0 {
		for iNdEx := len(m.EthSignatureChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EthSignatureChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.MustOwnTokens) > 0 {
		for iNdEx := len(m.MustOwnTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IncomingApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomingApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncomingApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MustPrioritize {
		i--
		if m.MustPrioritize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.AltTimeChecks != nil {
		{
			size, err := m.AltTimeChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.InitiatorChecks != nil {
		{
			size, err := m.InitiatorChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.SenderChecks != nil {
		{
			size, err := m.SenderChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.EthSignatureChallenges) > 0 {
		for iNdEx := len(m.EthSignatureChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EthSignatureChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.MustOwnTokens) > 0 {
		for iNdEx := len(m.MustOwnTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Version.Size()
		i -= size
		if _, err := m.Version.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.ApprovalCriteria != nil {
		{
			size, err := m.ApprovalCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ToListId) > 0 {
		i -= len(m.ToListId)
		copy(dAtA[i:], m.ToListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromListId) > 0 {
		i -= len(m.FromListId)
		copy(dAtA[i:], m.FromListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.FromListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApprovalIdentifierDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalIdentifierDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalIdentifierDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Version.Size()
		i -= size
		if _, err := m.Version.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ApproverAddress) > 0 {
		i -= len(m.ApproverAddress)
		copy(dAtA[i:], m.ApproverAddress)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApproverAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ApprovalLevel) > 0 {
		i -= len(m.ApprovalLevel)
		copy(dAtA[i:], m.ApprovalLevel)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalLevel)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Transfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NumAttempts.Size()
		i -= size
		if _, err := m.NumAttempts.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if m.PrecalculationOptions != nil {
		{
			size, err := m.PrecalculationOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.OnlyCheckPrioritizedOutgoingApprovals {
		i--
		if m.OnlyCheckPrioritizedOutgoingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.OnlyCheckPrioritizedIncomingApprovals {
		i--
		if m.OnlyCheckPrioritizedIncomingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.OnlyCheckPrioritizedCollectionApprovals {
		i--
		if m.OnlyCheckPrioritizedCollectionApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.PrioritizedApprovals) > 0 {
		for iNdEx := len(m.PrioritizedApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrioritizedApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.EthSignatureProofs) > 0 {
		for iNdEx := len(m.EthSignatureProofs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EthSignatureProofs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.MerkleProofs) > 0 {
		for iNdEx := len(m.MerkleProofs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleProofs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PrecalculateBalancesFromApproval != nil {
		{
			size, err := m.PrecalculateBalancesFromApproval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ToAddresses) > 0 {
		for iNdEx := len(m.ToAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ToAddresses[iNdEx])
			copy(dAtA[i:], m.ToAddresses[iNdEx])
			i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToAddresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrecalculationOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrecalculationOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrecalculationOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenIdsOverride) > 0 {
		for iNdEx := len(m.TokenIdsOverride) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenIdsOverride[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.OverrideTimestamp.Size()
		i -= size
		if _, err := m.OverrideTimestamp.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MerklePathItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerklePathItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerklePathItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OnRight {
		i--
		if m.OnRight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Aunt) > 0 {
		i -= len(m.Aunt)
		copy(dAtA[i:], m.Aunt)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Aunt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MerkleProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerkleProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LeafSignature) > 0 {
		i -= len(m.LeafSignature)
		copy(dAtA[i:], m.LeafSignature)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.LeafSignature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Aunts) > 0 {
		for iNdEx := len(m.Aunts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Aunts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Leaf) > 0 {
		i -= len(m.Leaf)
		copy(dAtA[i:], m.Leaf)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Leaf)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ETHSignatureProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ETHSignatureProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ETHSignatureProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTransfers(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransfers(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserBalanceStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OutgoingApprovals) > 0 {
		for _, e := range m.OutgoingApprovals {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.IncomingApprovals) > 0 {
		for _, e := range m.IncomingApprovals {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		n += 2
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		n += 2
	}
	if m.AutoApproveAllIncomingTransfers {
		n += 2
	}
	if m.UserPermissions != nil {
		l = m.UserPermissions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *MerkleChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.ExpectedProofLength.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if m.UseCreatorAddressAsLeaf {
		n += 2
	}
	l = m.MaxUsesPerLeaf.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.LeafSigner)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *ETHSignatureChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *UserOutgoingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.TokenIds) > 0 {
		for _, e := range m.TokenIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalCriteria != nil {
		l = m.ApprovalCriteria.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.Version.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *UserIncomingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.TokenIds) > 0 {
		for _, e := range m.TokenIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalCriteria != nil {
		l = m.ApprovalCriteria.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.Version.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *ManualBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *RecurringOwnershipTimes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StartTime.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.IntervalLength.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.ChargePeriodLength.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *IncrementedBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StartBalances) > 0 {
		for _, e := range m.StartBalances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = m.IncrementTokenIdsBy.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.IncrementOwnershipTimesBy.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.DurationFromTimestamp.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if m.AllowOverrideTimestamp {
		n += 2
	}
	if m.RecurringOwnershipTimes != nil {
		l = m.RecurringOwnershipTimes.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.AllowOverrideWithAnyValidToken {
		n += 2
	}
	return n
}

func (m *PredeterminedOrderCalculationMethod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseOverallNumTransfers {
		n += 2
	}
	if m.UsePerToAddressNumTransfers {
		n += 2
	}
	if m.UsePerFromAddressNumTransfers {
		n += 2
	}
	if m.UsePerInitiatedByAddressNumTransfers {
		n += 2
	}
	if m.UseMerkleChallengeLeafIndex {
		n += 2
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *PredeterminedBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ManualBalances) > 0 {
		for _, e := range m.ManualBalances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.IncrementedBalances != nil {
		l = m.IncrementedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.OrderCalculationMethod != nil {
		l = m.OrderCalculationMethod.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *AutoDeletionOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AfterOneUse {
		n += 2
	}
	if m.AfterOverallMaxNumTransfers {
		n += 2
	}
	if m.AllowCounterpartyPurge {
		n += 2
	}
	if m.AllowPurgeIfExpired {
		n += 2
	}
	return n
}

func (m *ApprovalAmounts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OverallApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerToAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerFromAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerInitiatedByAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = len(m.AmountTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ResetTimeIntervals != nil {
		l = m.ResetTimeIntervals.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *ResetTimeIntervals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StartTime.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.IntervalLength.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *MaxNumTransfers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OverallMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerToAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerFromAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerInitiatedByAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = len(m.AmountTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ResetTimeIntervals != nil {
		l = m.ResetTimeIntervals.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *ApprovalTracker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if len(m.Amounts) > 0 {
		for _, e := range m.Amounts {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = m.LastUpdatedAt.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *CoinTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.OverrideFromWithApproverAddress {
		n += 2
	}
	if m.OverrideToWithInitiator {
		n += 2
	}
	return n
}

func (m *MustOwnTokens) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if m.AmountRange != nil {
		l = m.AmountRange.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.TokenIds) > 0 {
		for _, e := range m.TokenIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.OverrideWithCurrentTime {
		n += 2
	}
	if m.MustSatisfyForAllAssets {
		n += 2
	}
	l = len(m.OwnershipCheckParty)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *DynamicStoreChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StoreId.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *AddressChecks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MustBeWasmContract {
		n += 2
	}
	if m.MustNotBeWasmContract {
		n += 2
	}
	if m.MustBeLiquidityPool {
		n += 2
	}
	if m.MustNotBeLiquidityPool {
		n += 2
	}
	return n
}

func (m *AltTimeChecks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OfflineHours) > 0 {
		for _, e := range m.OfflineHours {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OfflineDays) > 0 {
		for _, e := range m.OfflineDays {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *ApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.OverridesFromOutgoingApprovals {
		n += 2
	}
	if m.OverridesToIncomingApprovals {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.UserRoyalties != nil {
		l = m.UserRoyalties.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.MustOwnTokens) > 0 {
		for _, e := range m.MustOwnTokens {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.EthSignatureChallenges) > 0 {
		for _, e := range m.EthSignatureChallenges {
			l = e.Size()
			n += 2 + l + sovTransfers(uint64(l))
		}
	}
	if m.SenderChecks != nil {
		l = m.SenderChecks.Size()
		n += 2 + l + sovTransfers(uint64(l))
	}
	if m.RecipientChecks != nil {
		l = m.RecipientChecks.Size()
		n += 2 + l + sovTransfers(uint64(l))
	}
	if m.InitiatorChecks != nil {
		l = m.InitiatorChecks.Size()
		n += 2 + l + sovTransfers(uint64(l))
	}
	if m.AltTimeChecks != nil {
		l = m.AltTimeChecks.Size()
		n += 2 + l + sovTransfers(uint64(l))
	}
	if m.MustPrioritize {
		n += 3
	}
	return n
}

func (m *UserRoyalties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Percentage.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = len(m.PayoutAddress)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *OutgoingApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.MustOwnTokens) > 0 {
		for _, e := range m.MustOwnTokens {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.EthSignatureChallenges) > 0 {
		for _, e := range m.EthSignatureChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.RecipientChecks != nil {
		l = m.RecipientChecks.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.InitiatorChecks != nil {
		l = m.InitiatorChecks.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.AltTimeChecks != nil {
		l = m.AltTimeChecks.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MustPrioritize {
		n += 2
	}
	return n
}

func (m *IncomingApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.MustOwnTokens) > 0 {
		for _, e := range m.MustOwnTokens {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.EthSignatureChallenges) > 0 {
		for _, e := range m.EthSignatureChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.SenderChecks != nil {
		l = m.SenderChecks.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.InitiatorChecks != nil {
		l = m.InitiatorChecks.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.AltTimeChecks != nil {
		l = m.AltTimeChecks.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MustPrioritize {
		n += 2
	}
	return n
}

func (m *CollectionApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ToListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.TokenIds) > 0 {
		for _, e := range m.TokenIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalCriteria != nil {
		l = m.ApprovalCriteria.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.Version.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *ApprovalIdentifierDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalLevel)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApproverAddress)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.Version.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *Transfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.ToAddresses) > 0 {
		for _, s := range m.ToAddresses {
			l = len(s)
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PrecalculateBalancesFromApproval != nil {
		l = m.PrecalculateBalancesFromApproval.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.MerkleProofs) > 0 {
		for _, e := range m.MerkleProofs {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.EthSignatureProofs) > 0 {
		for _, e := range m.EthSignatureProofs {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.PrioritizedApprovals) > 0 {
		for _, e := range m.PrioritizedApprovals {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.OnlyCheckPrioritizedCollectionApprovals {
		n += 2
	}
	if m.OnlyCheckPrioritizedIncomingApprovals {
		n += 2
	}
	if m.OnlyCheckPrioritizedOutgoingApprovals {
		n += 2
	}
	if m.PrecalculationOptions != nil {
		l = m.PrecalculationOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.NumAttempts.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *PrecalculationOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OverrideTimestamp.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if len(m.TokenIdsOverride) > 0 {
		for _, e := range m.TokenIdsOverride {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *MerklePathItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Aunt)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.OnRight {
		n += 2
	}
	return n
}

func (m *MerkleProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Leaf)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.Aunts) > 0 {
		for _, e := range m.Aunts {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.LeafSignature)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *ETHSignatureProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func sovTransfers(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransfers(x uint64) (n int) {
	return sovTransfers(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserBalanceStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserBalanceStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserBalanceStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutgoingApprovals = append(m.OutgoingApprovals, &UserOutgoingApproval{})
			if err := m.OutgoingApprovals[len(m.OutgoingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncomingApprovals = append(m.IncomingApprovals, &UserIncomingApproval{})
			if err := m.IncomingApprovals[len(m.IncomingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveAllIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveAllIncomingTransfers = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPermissions == nil {
				m.UserPermissions = &UserPermissions{}
			}
			if err := m.UserPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedProofLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpectedProofLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCreatorAddressAsLeaf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseCreatorAddressAsLeaf = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUsesPerLeaf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxUsesPerLeaf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafSigner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeafSigner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ETHSignatureChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ETHSignatureChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ETHSignatureChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserOutgoingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserOutgoingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserOutgoingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, &UintRange{})
			if err := m.TokenIds[len(m.TokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalCriteria == nil {
				m.ApprovalCriteria = &OutgoingApprovalCriteria{}
			}
			if err := m.ApprovalCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIncomingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIncomingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIncomingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, &UintRange{})
			if err := m.TokenIds[len(m.TokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalCriteria == nil {
				m.ApprovalCriteria = &IncomingApprovalCriteria{}
			}
			if err := m.ApprovalCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManualBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManualBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManualBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecurringOwnershipTimes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecurringOwnershipTimes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecurringOwnershipTimes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IntervalLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargePeriodLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChargePeriodLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrementedBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrementedBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrementedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartBalances = append(m.StartBalances, &Balance{})
			if err := m.StartBalances[len(m.StartBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementTokenIdsBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncrementTokenIdsBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementOwnershipTimesBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncrementOwnershipTimesBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationFromTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DurationFromTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideTimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideTimestamp = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecurringOwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecurringOwnershipTimes == nil {
				m.RecurringOwnershipTimes = &RecurringOwnershipTimes{}
			}
			if err := m.RecurringOwnershipTimes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideWithAnyValidToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideWithAnyValidToken = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredeterminedOrderCalculationMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredeterminedOrderCalculationMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredeterminedOrderCalculationMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseOverallNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseOverallNumTransfers = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerToAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerToAddressNumTransfers = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerFromAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerFromAddressNumTransfers = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerInitiatedByAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerInitiatedByAddressNumTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMerkleChallengeLeafIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMerkleChallengeLeafIndex = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredeterminedBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredeterminedBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredeterminedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManualBalances = append(m.ManualBalances, &ManualBalances{})
			if err := m.ManualBalances[len(m.ManualBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncrementedBalances == nil {
				m.IncrementedBalances = &IncrementedBalances{}
			}
			if err := m.IncrementedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderCalculationMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderCalculationMethod == nil {
				m.OrderCalculationMethod = &PredeterminedOrderCalculationMethod{}
			}
			if err := m.OrderCalculationMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoDeletionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoDeletionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoDeletionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterOneUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AfterOneUse = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterOverallMaxNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AfterOverallMaxNumTransfers = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCounterpartyPurge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowCounterpartyPurge = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPurgeIfExpired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPurgeIfExpired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalAmounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalAmounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalAmounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverallApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerToAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerToAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerFromAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerFromAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerInitiatedByAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerInitiatedByAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetTimeIntervals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResetTimeIntervals == nil {
				m.ResetTimeIntervals = &ResetTimeIntervals{}
			}
			if err := m.ResetTimeIntervals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetTimeIntervals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetTimeIntervals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetTimeIntervals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IntervalLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxNumTransfers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxNumTransfers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxNumTransfers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverallMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerToAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerToAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerFromAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerFromAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerInitiatedByAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerInitiatedByAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetTimeIntervals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResetTimeIntervals == nil {
				m.ResetTimeIntervals = &ResetTimeIntervals{}
			}
			if err := m.ResetTimeIntervals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalTracker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalTracker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalTracker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amounts = append(m.Amounts, &Balance{})
			if err := m.Amounts[len(m.Amounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastUpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, &types.Coin{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideFromWithApproverAddress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideFromWithApproverAddress = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideToWithInitiator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideToWithInitiator = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MustOwnTokens) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MustOwnTokens: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MustOwnTokens: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AmountRange == nil {
				m.AmountRange = &UintRange{}
			}
			if err := m.AmountRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, &UintRange{})
			if err := m.TokenIds[len(m.TokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideWithCurrentTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideWithCurrentTime = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustSatisfyForAllAssets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustSatisfyForAllAssets = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipCheckParty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipCheckParty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicStoreChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicStoreChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicStoreChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressChecks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressChecks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressChecks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustBeWasmContract", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustBeWasmContract = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustNotBeWasmContract", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustNotBeWasmContract = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustBeLiquidityPool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustBeLiquidityPool = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustNotBeLiquidityPool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustNotBeLiquidityPool = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AltTimeChecks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AltTimeChecks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AltTimeChecks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfflineHours", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfflineHours = append(m.OfflineHours, &UintRange{})
			if err := m.OfflineHours[len(m.OfflineHours)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfflineDays", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfflineDays = append(m.OfflineDays, &UintRange{})
			if err := m.OfflineDays[len(m.OfflineDays)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesFromOutgoingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesFromOutgoingApprovals = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesToIncomingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesToIncomingApprovals = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRoyalties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserRoyalties == nil {
				m.UserRoyalties = &UserRoyalties{}
			}
			if err := m.UserRoyalties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnTokens = append(m.MustOwnTokens, &MustOwnTokens{})
			if err := m.MustOwnTokens[len(m.MustOwnTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSignatureChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthSignatureChallenges = append(m.EthSignatureChallenges, &ETHSignatureChallenge{})
			if err := m.EthSignatureChallenges[len(m.EthSignatureChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SenderChecks == nil {
				m.SenderChecks = &AddressChecks{}
			}
			if err := m.SenderChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecipientChecks == nil {
				m.RecipientChecks = &AddressChecks{}
			}
			if err := m.RecipientChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatorChecks == nil {
				m.InitiatorChecks = &AddressChecks{}
			}
			if err := m.InitiatorChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltTimeChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AltTimeChecks == nil {
				m.AltTimeChecks = &AltTimeChecks{}
			}
			if err := m.AltTimeChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustPrioritize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustPrioritize = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRoyalties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRoyalties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRoyalties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayoutAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutgoingApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutgoingApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutgoingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnTokens = append(m.MustOwnTokens, &MustOwnTokens{})
			if err := m.MustOwnTokens[len(m.MustOwnTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSignatureChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthSignatureChallenges = append(m.EthSignatureChallenges, &ETHSignatureChallenge{})
			if err := m.EthSignatureChallenges[len(m.EthSignatureChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecipientChecks == nil {
				m.RecipientChecks = &AddressChecks{}
			}
			if err := m.RecipientChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatorChecks == nil {
				m.InitiatorChecks = &AddressChecks{}
			}
			if err := m.InitiatorChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltTimeChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AltTimeChecks == nil {
				m.AltTimeChecks = &AltTimeChecks{}
			}
			if err := m.AltTimeChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustPrioritize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustPrioritize = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomingApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomingApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnTokens = append(m.MustOwnTokens, &MustOwnTokens{})
			if err := m.MustOwnTokens[len(m.MustOwnTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSignatureChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthSignatureChallenges = append(m.EthSignatureChallenges, &ETHSignatureChallenge{})
			if err := m.EthSignatureChallenges[len(m.EthSignatureChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SenderChecks == nil {
				m.SenderChecks = &AddressChecks{}
			}
			if err := m.SenderChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatorChecks == nil {
				m.InitiatorChecks = &AddressChecks{}
			}
			if err := m.InitiatorChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltTimeChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AltTimeChecks == nil {
				m.AltTimeChecks = &AltTimeChecks{}
			}
			if err := m.AltTimeChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustPrioritize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustPrioritize = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, &UintRange{})
			if err := m.TokenIds[len(m.TokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalCriteria == nil {
				m.ApprovalCriteria = &ApprovalCriteria{}
			}
			if err := m.ApprovalCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalIdentifierDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalIdentifierDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalIdentifierDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproverAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApproverAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddresses = append(m.ToAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecalculateBalancesFromApproval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrecalculateBalancesFromApproval == nil {
				m.PrecalculateBalancesFromApproval = &ApprovalIdentifierDetails{}
			}
			if err := m.PrecalculateBalancesFromApproval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleProofs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleProofs = append(m.MerkleProofs, &MerkleProof{})
			if err := m.MerkleProofs[len(m.MerkleProofs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSignatureProofs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthSignatureProofs = append(m.EthSignatureProofs, &ETHSignatureProof{})
			if err := m.EthSignatureProofs[len(m.EthSignatureProofs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrioritizedApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrioritizedApprovals = append(m.PrioritizedApprovals, &ApprovalIdentifierDetails{})
			if err := m.PrioritizedApprovals[len(m.PrioritizedApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedCollectionApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyCheckPrioritizedCollectionApprovals = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedIncomingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyCheckPrioritizedIncomingApprovals = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedOutgoingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyCheckPrioritizedOutgoingApprovals = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecalculationOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrecalculationOptions == nil {
				m.PrecalculationOptions = &PrecalculationOptions{}
			}
			if err := m.PrecalculationOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAttempts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NumAttempts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrecalculationOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrecalculationOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrecalculationOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverrideTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIdsOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIdsOverride = append(m.TokenIdsOverride, &UintRange{})
			if err := m.TokenIdsOverride[len(m.TokenIdsOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerklePathItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerklePathItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerklePathItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aunt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aunt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnRight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnRight = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leaf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aunts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aunts = append(m.Aunts, &MerklePathItem{})
			if err := m.Aunts[len(m.Aunts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeafSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ETHSignatureProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ETHSignatureProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ETHSignatureProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransfers(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransfers
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransfers
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransfers
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransfers        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransfers          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransfers = fmt.Errorf("proto: unexpected end of group")
)
