// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tokenization/v22/permissions.proto

package v22

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).
//
// There are three types of permissions for a collection: ActionPermission, TokenIdsActionPermission, and CollectionApprovalPermission.
//
// The permission type allows fine-grained access control for each action.
// - ActionPermission: defines when the manager can perform an action or update a field.
// - TokenIdsActionPermission: defines when the manager can perform an action for specific tokens
// - CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.
//
// Note there are a few different times here which could get confusing:
// - permanentlyPermitted/ForbiddenTimes - the times that a permission can be performed
// - transferTimes - the times that a transfer occurs
// - ownershipTimes - the times when a token is owned by a user
//
// The permitted/permanentlyForbiddenTimes are used to determine when a permission can be executed.
// Once a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.
// If a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.
//
// IMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1,
// we will only check the first permission (forbid time T) and not the second permission (permit time T).
type CollectionPermissions struct {
	// Permissions related to deleting the collection.
	CanDeleteCollection []*ActionPermission `protobuf:"bytes,1,rep,name=canDeleteCollection,proto3" json:"canDeleteCollection,omitempty"`
	// Permissions related to archiving the collection.
	CanArchiveCollection []*ActionPermission `protobuf:"bytes,2,rep,name=canArchiveCollection,proto3" json:"canArchiveCollection,omitempty"`
	// Permissions related to updating standards for the collection.
	CanUpdateStandards []*ActionPermission `protobuf:"bytes,3,rep,name=canUpdateStandards,proto3" json:"canUpdateStandards,omitempty"`
	// Permissions related to updating custom data for the collection.
	CanUpdateCustomData []*ActionPermission `protobuf:"bytes,4,rep,name=canUpdateCustomData,proto3" json:"canUpdateCustomData,omitempty"`
	// Permissions related to updating the collection's manager.
	CanUpdateManager []*ActionPermission `protobuf:"bytes,5,rep,name=canUpdateManager,proto3" json:"canUpdateManager,omitempty"`
	// Permissions related to updating the metadata of the collection.
	CanUpdateCollectionMetadata []*ActionPermission `protobuf:"bytes,6,rep,name=canUpdateCollectionMetadata,proto3" json:"canUpdateCollectionMetadata,omitempty"`
	// Permissions related to creating more tokens for the collection.
	CanUpdateValidTokenIds []*TokenIdsActionPermission `protobuf:"bytes,7,rep,name=canUpdateValidTokenIds,proto3" json:"canUpdateValidTokenIds,omitempty"`
	// Permissions related to updating token metadata for specific tokens.
	CanUpdateTokenMetadata []*TokenIdsActionPermission `protobuf:"bytes,8,rep,name=canUpdateTokenMetadata,proto3" json:"canUpdateTokenMetadata,omitempty"`
	// Permissions related to updating collection approvals.
	CanUpdateCollectionApprovals []*CollectionApprovalPermission `protobuf:"bytes,9,rep,name=canUpdateCollectionApprovals,proto3" json:"canUpdateCollectionApprovals,omitempty"`
	// Permissions related to adding more alias paths to the collection.
	CanAddMoreAliasPaths []*ActionPermission `protobuf:"bytes,10,rep,name=canAddMoreAliasPaths,proto3" json:"canAddMoreAliasPaths,omitempty"`
	// Permissions related to adding more cosmos coin wrapper paths to the collection.
	CanAddMoreCosmosCoinWrapperPaths []*ActionPermission `protobuf:"bytes,11,rep,name=canAddMoreCosmosCoinWrapperPaths,proto3" json:"canAddMoreCosmosCoinWrapperPaths,omitempty"`
}

func (m *CollectionPermissions) Reset()         { *m = CollectionPermissions{} }
func (m *CollectionPermissions) String() string { return proto.CompactTextString(m) }
func (*CollectionPermissions) ProtoMessage()    {}
func (*CollectionPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe19afd822d39bdd, []int{0}
}
func (m *CollectionPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionPermissions.Merge(m, src)
}
func (m *CollectionPermissions) XXX_Size() int {
	return m.Size()
}
func (m *CollectionPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionPermissions proto.InternalMessageInfo

func (m *CollectionPermissions) GetCanDeleteCollection() []*ActionPermission {
	if m != nil {
		return m.CanDeleteCollection
	}
	return nil
}

func (m *CollectionPermissions) GetCanArchiveCollection() []*ActionPermission {
	if m != nil {
		return m.CanArchiveCollection
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateStandards() []*ActionPermission {
	if m != nil {
		return m.CanUpdateStandards
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCustomData() []*ActionPermission {
	if m != nil {
		return m.CanUpdateCustomData
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateManager() []*ActionPermission {
	if m != nil {
		return m.CanUpdateManager
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCollectionMetadata() []*ActionPermission {
	if m != nil {
		return m.CanUpdateCollectionMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateValidTokenIds() []*TokenIdsActionPermission {
	if m != nil {
		return m.CanUpdateValidTokenIds
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateTokenMetadata() []*TokenIdsActionPermission {
	if m != nil {
		return m.CanUpdateTokenMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCollectionApprovals() []*CollectionApprovalPermission {
	if m != nil {
		return m.CanUpdateCollectionApprovals
	}
	return nil
}

func (m *CollectionPermissions) GetCanAddMoreAliasPaths() []*ActionPermission {
	if m != nil {
		return m.CanAddMoreAliasPaths
	}
	return nil
}

func (m *CollectionPermissions) GetCanAddMoreCosmosCoinWrapperPaths() []*ActionPermission {
	if m != nil {
		return m.CanAddMoreCosmosCoinWrapperPaths
	}
	return nil
}

// UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).
//
// See CollectionPermissions for more details on the different types of permissions.
//
// canUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,
// but certain fields are removed because they are not relevant to the user.
type UserPermissions struct {
	// Permissions related to updating the user's approved outgoing transfers.
	CanUpdateOutgoingApprovals []*UserOutgoingApprovalPermission `protobuf:"bytes,1,rep,name=canUpdateOutgoingApprovals,proto3" json:"canUpdateOutgoingApprovals,omitempty"`
	// Permissions related to updating the user's approved incoming transfers.
	CanUpdateIncomingApprovals []*UserIncomingApprovalPermission `protobuf:"bytes,2,rep,name=canUpdateIncomingApprovals,proto3" json:"canUpdateIncomingApprovals,omitempty"`
	// Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).
	CanUpdateAutoApproveSelfInitiatedOutgoingTransfers []*ActionPermission `protobuf:"bytes,3,rep,name=canUpdateAutoApproveSelfInitiatedOutgoingTransfers,proto3" json:"canUpdateAutoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).
	CanUpdateAutoApproveSelfInitiatedIncomingTransfers []*ActionPermission `protobuf:"bytes,4,rep,name=canUpdateAutoApproveSelfInitiatedIncomingTransfers,proto3" json:"canUpdateAutoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// Permissions related to updating auto-approval settings for all incoming transfers (whether they are allowed by default).
	CanUpdateAutoApproveAllIncomingTransfers []*ActionPermission `protobuf:"bytes,5,rep,name=canUpdateAutoApproveAllIncomingTransfers,proto3" json:"canUpdateAutoApproveAllIncomingTransfers,omitempty"`
}

func (m *UserPermissions) Reset()         { *m = UserPermissions{} }
func (m *UserPermissions) String() string { return proto.CompactTextString(m) }
func (*UserPermissions) ProtoMessage()    {}
func (*UserPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe19afd822d39bdd, []int{1}
}
func (m *UserPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPermissions.Merge(m, src)
}
func (m *UserPermissions) XXX_Size() int {
	return m.Size()
}
func (m *UserPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_UserPermissions proto.InternalMessageInfo

func (m *UserPermissions) GetCanUpdateOutgoingApprovals() []*UserOutgoingApprovalPermission {
	if m != nil {
		return m.CanUpdateOutgoingApprovals
	}
	return nil
}

func (m *UserPermissions) GetCanUpdateIncomingApprovals() []*UserIncomingApprovalPermission {
	if m != nil {
		return m.CanUpdateIncomingApprovals
	}
	return nil
}

func (m *UserPermissions) GetCanUpdateAutoApproveSelfInitiatedOutgoingTransfers() []*ActionPermission {
	if m != nil {
		return m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers
	}
	return nil
}

func (m *UserPermissions) GetCanUpdateAutoApproveSelfInitiatedIncomingTransfers() []*ActionPermission {
	if m != nil {
		return m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers
	}
	return nil
}

func (m *UserPermissions) GetCanUpdateAutoApproveAllIncomingTransfers() []*ActionPermission {
	if m != nil {
		return m.CanUpdateAutoApproveAllIncomingTransfers
	}
	return nil
}

// CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.
//
// Each transfer is broken down to a (from, to, initiatedBy, transferTime, tokenId) tuple.
// For a transfer to match, we need to match ALL of the fields in the combination.
// These are determined by the fromListId, toListId, initiatedByListId, transferTimes, tokenIds fields.
// AddressLists are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressLists).
//
// permanentlyPermitted/ForbiddenTimes: when can the manager execute this permission?
//
// Ex: Let's say we are updating the transferability for the transfer tuple ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", 10, 1000).
// We would check to find the FIRST CollectionApprovalPermission that matches this combination.
// If we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).
//
// Ex: So if you wanted to freeze the transferability to enforce that token ID 1 will always be transferable, you could set
// the combination ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", "All Transfer Times", 1) to always be forbidden.
type CollectionApprovalPermission struct {
	// Identifier for the sender list.
	FromListId string `protobuf:"bytes,1,opt,name=fromListId,proto3" json:"fromListId,omitempty"`
	// Identifier for the recipient list.
	ToListId string `protobuf:"bytes,2,opt,name=toListId,proto3" json:"toListId,omitempty"`
	// Identifier for the initiator list (who is approved?).
	InitiatedByListId string `protobuf:"bytes,3,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// Specifies the times when the transfer can occur.
	TransferTimes []*UintRange `protobuf:"bytes,4,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// Specifies the token IDs involved in the transfer.
	TokenIds []*UintRange `protobuf:"bytes,5,rep,name=tokenIds,proto3" json:"tokenIds,omitempty"`
	// Specifies the ownership times for the tokens in the transfer.
	OwnershipTimes []*UintRange `protobuf:"bytes,6,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// Identifier for the approvalId. You can use "All" or "!approvalId" for shorthand.
	// If you use "All", this approval will match to all approvalIds.
	// If you use "!approvalId", this approval will match to all approvalIds except for approvalId.
	// If you use "approvalId", this approval will match to only the specified approvalId and fail on all others.
	ApprovalId string `protobuf:"bytes,7,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
	PermanentlyPermittedTimes []*UintRange `protobuf:"bytes,8,rep,name=permanentlyPermittedTimes,proto3" json:"permanentlyPermittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
	PermanentlyForbiddenTimes []*UintRange `protobuf:"bytes,9,rep,name=permanentlyForbiddenTimes,proto3" json:"permanentlyForbiddenTimes,omitempty"`
}

func (m *CollectionApprovalPermission) Reset()         { *m = CollectionApprovalPermission{} }
func (m *CollectionApprovalPermission) String() string { return proto.CompactTextString(m) }
func (*CollectionApprovalPermission) ProtoMessage()    {}
func (*CollectionApprovalPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe19afd822d39bdd, []int{2}
}
func (m *CollectionApprovalPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApprovalPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApprovalPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApprovalPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApprovalPermission.Merge(m, src)
}
func (m *CollectionApprovalPermission) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApprovalPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApprovalPermission.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApprovalPermission proto.InternalMessageInfo

func (m *CollectionApprovalPermission) GetFromListId() string {
	if m != nil {
		return m.FromListId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetToListId() string {
	if m != nil {
		return m.ToListId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *CollectionApprovalPermission) GetTokenIds() []*UintRange {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

func (m *CollectionApprovalPermission) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *CollectionApprovalPermission) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetPermanentlyPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermanentlyPermittedTimes
	}
	return nil
}

func (m *CollectionApprovalPermission) GetPermanentlyForbiddenTimes() []*UintRange {
	if m != nil {
		return m.PermanentlyForbiddenTimes
	}
	return nil
}

// UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.
type UserOutgoingApprovalPermission struct {
	// Identifier for the recipient list.
	ToListId string `protobuf:"bytes,1,opt,name=toListId,proto3" json:"toListId,omitempty"`
	// Identifier for the initiator list (who is approved?).
	InitiatedByListId string `protobuf:"bytes,2,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// Specifies the times when the transfer can occur.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// Specifies the token IDs involved in the transfer.
	TokenIds []*UintRange `protobuf:"bytes,4,rep,name=tokenIds,proto3" json:"tokenIds,omitempty"`
	// Specifies the ownership times for the tokens in the transfer.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// Identifier for the approvalId. You can use "All" or "!approvalId" for shorthand.
	// If you use "All", this approval will match to all approvalIds.
	// If you use "!approvalId", this approval will match to all approvalIds except for approvalId.
	// If you use "approvalId", this approval will match to only the specified approvalId and fail on all others.
	ApprovalId string `protobuf:"bytes,6,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
	PermanentlyPermittedTimes []*UintRange `protobuf:"bytes,7,rep,name=permanentlyPermittedTimes,proto3" json:"permanentlyPermittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
	PermanentlyForbiddenTimes []*UintRange `protobuf:"bytes,8,rep,name=permanentlyForbiddenTimes,proto3" json:"permanentlyForbiddenTimes,omitempty"`
}

func (m *UserOutgoingApprovalPermission) Reset()         { *m = UserOutgoingApprovalPermission{} }
func (m *UserOutgoingApprovalPermission) String() string { return proto.CompactTextString(m) }
func (*UserOutgoingApprovalPermission) ProtoMessage()    {}
func (*UserOutgoingApprovalPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe19afd822d39bdd, []int{3}
}
func (m *UserOutgoingApprovalPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserOutgoingApprovalPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserOutgoingApprovalPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserOutgoingApprovalPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserOutgoingApprovalPermission.Merge(m, src)
}
func (m *UserOutgoingApprovalPermission) XXX_Size() int {
	return m.Size()
}
func (m *UserOutgoingApprovalPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_UserOutgoingApprovalPermission.DiscardUnknown(m)
}

var xxx_messageInfo_UserOutgoingApprovalPermission proto.InternalMessageInfo

func (m *UserOutgoingApprovalPermission) GetToListId() string {
	if m != nil {
		return m.ToListId
	}
	return ""
}

func (m *UserOutgoingApprovalPermission) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *UserOutgoingApprovalPermission) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetTokenIds() []*UintRange {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *UserOutgoingApprovalPermission) GetPermanentlyPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermanentlyPermittedTimes
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetPermanentlyForbiddenTimes() []*UintRange {
	if m != nil {
		return m.PermanentlyForbiddenTimes
	}
	return nil
}

// UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.
//
// See CollectionApprovalPermission for more details. This is equivalent without the toListId field because that is always the user.
type UserIncomingApprovalPermission struct {
	// Identifier for the sender list.
	FromListId string `protobuf:"bytes,1,opt,name=fromListId,proto3" json:"fromListId,omitempty"`
	// Identifier for the initiator list (who is approved?).
	InitiatedByListId string `protobuf:"bytes,2,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// Specifies the times when the transfer can occur.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// Specifies the token IDs involved in the transfer.
	TokenIds []*UintRange `protobuf:"bytes,4,rep,name=tokenIds,proto3" json:"tokenIds,omitempty"`
	// Specifies the ownership times for the tokens in the transfer.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// Identifier for the approvalId. You can use "All" or "!approvalId" for shorthand.
	// If you use "All", this approval will match to all approvalIds.
	// If you use "!approvalId", this approval will match to all approvalIds except for approvalId.
	// If you use "approvalId", this approval will match to only the specified approvalId and fail on all others.
	ApprovalId string `protobuf:"bytes,6,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
	PermanentlyPermittedTimes []*UintRange `protobuf:"bytes,7,rep,name=permanentlyPermittedTimes,proto3" json:"permanentlyPermittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
	PermanentlyForbiddenTimes []*UintRange `protobuf:"bytes,8,rep,name=permanentlyForbiddenTimes,proto3" json:"permanentlyForbiddenTimes,omitempty"`
}

func (m *UserIncomingApprovalPermission) Reset()         { *m = UserIncomingApprovalPermission{} }
func (m *UserIncomingApprovalPermission) String() string { return proto.CompactTextString(m) }
func (*UserIncomingApprovalPermission) ProtoMessage()    {}
func (*UserIncomingApprovalPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe19afd822d39bdd, []int{4}
}
func (m *UserIncomingApprovalPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserIncomingApprovalPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserIncomingApprovalPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserIncomingApprovalPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserIncomingApprovalPermission.Merge(m, src)
}
func (m *UserIncomingApprovalPermission) XXX_Size() int {
	return m.Size()
}
func (m *UserIncomingApprovalPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_UserIncomingApprovalPermission.DiscardUnknown(m)
}

var xxx_messageInfo_UserIncomingApprovalPermission proto.InternalMessageInfo

func (m *UserIncomingApprovalPermission) GetFromListId() string {
	if m != nil {
		return m.FromListId
	}
	return ""
}

func (m *UserIncomingApprovalPermission) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *UserIncomingApprovalPermission) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetTokenIds() []*UintRange {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *UserIncomingApprovalPermission) GetPermanentlyPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermanentlyPermittedTimes
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetPermanentlyForbiddenTimes() []*UintRange {
	if m != nil {
		return m.PermanentlyForbiddenTimes
	}
	return nil
}

// TokenIdsActionPermission defines the permissions for performing an action for specific tokens.
// Currently, this is only used for creating new tokens.
//
// Ex: If you want to lock the ability to create new tokens for tokenIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021,
// you could set the combination (tokenIds: [1,2], ownershipTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
type TokenIdsActionPermission struct {
	// Specifies the token IDs involved in the transfer.
	TokenIds []*UintRange `protobuf:"bytes,1,rep,name=tokenIds,proto3" json:"tokenIds,omitempty"`
	// Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
	PermanentlyPermittedTimes []*UintRange `protobuf:"bytes,2,rep,name=permanentlyPermittedTimes,proto3" json:"permanentlyPermittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
	PermanentlyForbiddenTimes []*UintRange `protobuf:"bytes,3,rep,name=permanentlyForbiddenTimes,proto3" json:"permanentlyForbiddenTimes,omitempty"`
}

func (m *TokenIdsActionPermission) Reset()         { *m = TokenIdsActionPermission{} }
func (m *TokenIdsActionPermission) String() string { return proto.CompactTextString(m) }
func (*TokenIdsActionPermission) ProtoMessage()    {}
func (*TokenIdsActionPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe19afd822d39bdd, []int{5}
}
func (m *TokenIdsActionPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenIdsActionPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenIdsActionPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenIdsActionPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenIdsActionPermission.Merge(m, src)
}
func (m *TokenIdsActionPermission) XXX_Size() int {
	return m.Size()
}
func (m *TokenIdsActionPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenIdsActionPermission.DiscardUnknown(m)
}

var xxx_messageInfo_TokenIdsActionPermission proto.InternalMessageInfo

func (m *TokenIdsActionPermission) GetTokenIds() []*UintRange {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

func (m *TokenIdsActionPermission) GetPermanentlyPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermanentlyPermittedTimes
	}
	return nil
}

func (m *TokenIdsActionPermission) GetPermanentlyForbiddenTimes() []*UintRange {
	if m != nil {
		return m.PermanentlyForbiddenTimes
	}
	return nil
}

// ActionPermission defines the permissions for performing an action.
//
// This is simple and straightforward as the only thing we need to check is the permitted/forbidden times.
type ActionPermission struct {
	// Specifies the times when this permission is permitted. Can not overlap with permanentlyForbiddenTimes.
	PermanentlyPermittedTimes []*UintRange `protobuf:"bytes,1,rep,name=permanentlyPermittedTimes,proto3" json:"permanentlyPermittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permanentlyPermittedTimes.
	PermanentlyForbiddenTimes []*UintRange `protobuf:"bytes,2,rep,name=permanentlyForbiddenTimes,proto3" json:"permanentlyForbiddenTimes,omitempty"`
}

func (m *ActionPermission) Reset()         { *m = ActionPermission{} }
func (m *ActionPermission) String() string { return proto.CompactTextString(m) }
func (*ActionPermission) ProtoMessage()    {}
func (*ActionPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe19afd822d39bdd, []int{6}
}
func (m *ActionPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionPermission.Merge(m, src)
}
func (m *ActionPermission) XXX_Size() int {
	return m.Size()
}
func (m *ActionPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionPermission.DiscardUnknown(m)
}

var xxx_messageInfo_ActionPermission proto.InternalMessageInfo

func (m *ActionPermission) GetPermanentlyPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermanentlyPermittedTimes
	}
	return nil
}

func (m *ActionPermission) GetPermanentlyForbiddenTimes() []*UintRange {
	if m != nil {
		return m.PermanentlyForbiddenTimes
	}
	return nil
}

func init() {
	proto.RegisterType((*CollectionPermissions)(nil), "tokenization.v22.CollectionPermissions")
	proto.RegisterType((*UserPermissions)(nil), "tokenization.v22.UserPermissions")
	proto.RegisterType((*CollectionApprovalPermission)(nil), "tokenization.v22.CollectionApprovalPermission")
	proto.RegisterType((*UserOutgoingApprovalPermission)(nil), "tokenization.v22.UserOutgoingApprovalPermission")
	proto.RegisterType((*UserIncomingApprovalPermission)(nil), "tokenization.v22.UserIncomingApprovalPermission")
	proto.RegisterType((*TokenIdsActionPermission)(nil), "tokenization.v22.TokenIdsActionPermission")
	proto.RegisterType((*ActionPermission)(nil), "tokenization.v22.ActionPermission")
}

func init() {
	proto.RegisterFile("tokenization/v22/permissions.proto", fileDescriptor_fe19afd822d39bdd)
}

var fileDescriptor_fe19afd822d39bdd = []byte{
	// 844 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0x4d, 0x6f, 0xeb, 0x44,
	0x14, 0xad, 0xf3, 0xd5, 0x74, 0x9e, 0x80, 0x32, 0x3c, 0x90, 0x5f, 0xde, 0x93, 0xa9, 0x22, 0x16,
	0x15, 0x42, 0x31, 0x0a, 0x0b, 0x36, 0x6c, 0xd2, 0x54, 0x48, 0x91, 0x28, 0x54, 0x69, 0x5a, 0x04,
	0x1b, 0x34, 0xf6, 0x4c, 0x9c, 0x11, 0xce, 0x8c, 0x35, 0x33, 0x09, 0x84, 0x05, 0x12, 0x0b, 0x16,
	0xec, 0x10, 0x7f, 0xa0, 0x6b, 0xfe, 0x49, 0x97, 0x5d, 0xb2, 0x44, 0xed, 0x1f, 0x41, 0xfe, 0x88,
	0x1d, 0xdb, 0x89, 0xe3, 0x10, 0xba, 0x41, 0x6f, 0xe7, 0xce, 0xdc, 0x73, 0xce, 0xbd, 0x47, 0xa7,
	0x37, 0x36, 0x68, 0x2b, 0xfe, 0x3d, 0x61, 0xf4, 0x27, 0xa4, 0x28, 0x67, 0xe6, 0xbc, 0xdb, 0x35,
	0x3d, 0x22, 0xa6, 0x54, 0x4a, 0xca, 0x99, 0xec, 0x78, 0x82, 0x2b, 0x0e, 0x8f, 0x57, 0x6b, 0x3a,
	0xf3, 0x6e, 0xb7, 0xf5, 0xc2, 0xe1, 0xdc, 0x71, 0x89, 0x19, 0xdc, 0x5b, 0xb3, 0xb1, 0x89, 0xd8,
	0x22, 0x2c, 0x6e, 0xbd, 0x9f, 0x23, 0xb4, 0x90, 0x8b, 0x98, 0x4d, 0x22, 0xb6, 0xd6, 0x07, 0xb9,
	0x02, 0x84, 0xb1, 0x20, 0x52, 0x7e, 0xe7, 0x52, 0xa9, 0x96, 0x55, 0xcf, 0x1d, 0xee, 0xf0, 0xe0,
	0xd1, 0xf4, 0x9f, 0xc2, 0xd3, 0xf6, 0x9f, 0x4d, 0xf0, 0x6e, 0x9f, 0xbb, 0x2e, 0xb1, 0x7d, 0xf0,
	0x65, 0xd2, 0x29, 0x1c, 0x81, 0x77, 0x6c, 0xc4, 0xce, 0x89, 0x4b, 0x14, 0x49, 0x2a, 0x74, 0xed,
	0xa4, 0x7a, 0xfa, 0xac, 0xdb, 0xee, 0x64, 0x27, 0xe8, 0xf4, 0x32, 0x0c, 0xc3, 0x75, 0x70, 0x78,
	0x03, 0x9e, 0xdb, 0x88, 0xf5, 0x84, 0x3d, 0xa1, 0xf3, 0x55, 0xda, 0x4a, 0x69, 0xda, 0xb5, 0x78,
	0x38, 0x04, 0xd0, 0x46, 0xec, 0xda, 0xc3, 0x48, 0x91, 0x2b, 0x85, 0x18, 0x46, 0x02, 0x4b, 0xbd,
	0x5a, 0x9a, 0x75, 0x0d, 0x3a, 0x72, 0x20, 0x3c, 0xed, 0xcf, 0xa4, 0xe2, 0xd3, 0x73, 0xa4, 0x90,
	0x5e, 0xdb, 0xc9, 0x81, 0x2c, 0x1c, 0x7e, 0x09, 0x8e, 0xe3, 0xe3, 0x0b, 0xc4, 0x90, 0x43, 0x84,
	0x5e, 0x2f, 0x4d, 0x99, 0xc3, 0x42, 0x0c, 0x5e, 0x26, 0x32, 0xb1, 0x21, 0x17, 0x44, 0x21, 0xec,
	0x77, 0xdb, 0x28, 0x4d, 0x5d, 0x44, 0x03, 0x2d, 0xf0, 0x5e, 0x7c, 0x7d, 0x83, 0x5c, 0x8a, 0x47,
	0x3e, 0xdf, 0x00, 0x4b, 0xfd, 0x30, 0x10, 0xf8, 0x30, 0x2f, 0xb0, 0xac, 0xc8, 0x09, 0x6d, 0x60,
	0x4a, 0x69, 0x04, 0x87, 0xf1, 0x10, 0xcd, 0x3d, 0x34, 0x52, 0x4c, 0x50, 0x80, 0x57, 0x6b, 0xc6,
	0xec, 0x79, 0x9e, 0xe0, 0x73, 0xe4, 0x4a, 0xfd, 0x28, 0x50, 0xea, 0xe4, 0x95, 0xf2, 0xc5, 0x2b,
	0x6a, 0x85, 0x9c, 0xcb, 0xcc, 0x63, 0x7c, 0xc1, 0x05, 0xe9, 0xb9, 0x14, 0xc9, 0x4b, 0xa4, 0x26,
	0x52, 0x07, 0xbb, 0x65, 0x3e, 0x8b, 0x87, 0x0c, 0x9c, 0x24, 0xe7, 0x7d, 0x2e, 0xa7, 0x5c, 0xf6,
	0x39, 0x65, 0x5f, 0x0b, 0xe4, 0x79, 0x44, 0x84, 0x1a, 0xcf, 0x4a, 0x6b, 0x6c, 0xe5, 0x6a, 0xdf,
	0xd6, 0xc1, 0x5b, 0xd7, 0x92, 0x88, 0xd5, 0x2d, 0xe1, 0x81, 0x56, 0x3c, 0xfb, 0x57, 0x33, 0xe5,
	0x70, 0xca, 0x9c, 0xc4, 0xcd, 0x70, 0x59, 0x7c, 0x9c, 0x57, 0xf7, 0x69, 0xb2, 0xe5, 0x2b, 0xbd,
	0x14, 0x70, 0xa6, 0x14, 0x07, 0xcc, 0xe6, 0xd3, 0x94, 0x62, 0xa5, 0x48, 0x31, 0x5b, 0xbe, 0x56,
	0x31, 0xc7, 0x09, 0xff, 0xd0, 0x40, 0x37, 0xbe, 0xee, 0xcd, 0x14, 0x0f, 0xaf, 0xc8, 0x15, 0x71,
	0xc7, 0x03, 0x46, 0x15, 0x45, 0x8a, 0xe0, 0x65, 0xa3, 0x23, 0x81, 0x98, 0x1c, 0x13, 0xb1, 0xcb,
	0xf2, 0xf9, 0x17, 0xec, 0xe5, 0x9a, 0x5a, 0xce, 0x92, 0x34, 0x55, 0xfb, 0x0f, 0x9b, 0xca, 0xb1,
	0xc3, 0x9f, 0xc1, 0xe9, 0x3a, 0x54, 0xcf, 0x75, 0xf3, 0x9d, 0x94, 0xdf, 0x79, 0xa5, 0x39, 0xdb,
	0xb7, 0x35, 0xf0, 0xaa, 0xe8, 0x1f, 0x15, 0x1a, 0x00, 0x8c, 0x05, 0x9f, 0x7e, 0x41, 0xa5, 0x1a,
	0x60, 0x5d, 0x3b, 0xd1, 0x4e, 0x8f, 0x86, 0x2b, 0x27, 0xb0, 0x05, 0x9a, 0x8a, 0x47, 0xb7, 0x95,
	0xe0, 0x36, 0xfe, 0x1b, 0x7e, 0x04, 0xde, 0xa6, 0xcb, 0xd1, 0xcf, 0x16, 0x51, 0x51, 0x35, 0x28,
	0xca, 0x5f, 0xc0, 0x1e, 0x78, 0x43, 0x45, 0x7d, 0x8d, 0xe8, 0x94, 0x2c, 0x9d, 0x7f, 0xb9, 0x26,
	0x99, 0x94, 0xa9, 0x21, 0x62, 0x0e, 0x19, 0xa6, 0x11, 0xf0, 0x53, 0xbf, 0x99, 0x68, 0xcb, 0xd6,
	0xb7, 0xa3, 0xe3, 0x62, 0xd8, 0x07, 0x6f, 0xf2, 0x1f, 0x18, 0x11, 0x72, 0x42, 0xbd, 0x50, 0xbc,
	0xb1, 0x1d, 0x9e, 0x81, 0xf8, 0x56, 0xa1, 0xc8, 0xc0, 0x01, 0xd6, 0x0f, 0x43, 0xab, 0x92, 0x13,
	0xf8, 0x0d, 0x78, 0xe1, 0xbf, 0xd8, 0x20, 0x46, 0x98, 0x72, 0x17, 0x81, 0xc7, 0x4a, 0x11, 0x1c,
	0xea, 0x35, 0xb7, 0xeb, 0x6d, 0x46, 0x67, 0xa8, 0x3f, 0xe7, 0xc2, 0xa2, 0x18, 0x13, 0x16, 0x52,
	0x1f, 0xed, 0x46, 0x9d, 0x46, 0xb7, 0x7f, 0xa9, 0x01, 0xa3, 0x78, 0xf9, 0xa4, 0x32, 0xa0, 0x95,
	0xc9, 0x40, 0xa5, 0x74, 0x06, 0xaa, 0x7b, 0x65, 0xa0, 0xb6, 0x5f, 0x06, 0xea, 0xfb, 0x66, 0xa0,
	0xb1, 0x5b, 0x06, 0x0e, 0x9f, 0x2e, 0x03, 0xcd, 0xbd, 0x32, 0xf0, 0x6b, 0x94, 0x81, 0xcd, 0x3f,
	0x07, 0x5b, 0xf7, 0xc4, 0xeb, 0x1c, 0xfc, 0x0f, 0x72, 0xf0, 0x5b, 0x05, 0xe8, 0x9b, 0x5e, 0x20,
	0x53, 0x86, 0x6b, 0xbb, 0x18, 0x5e, 0xe8, 0x45, 0xe5, 0xe9, 0xbc, 0xa8, 0xee, 0xe5, 0xc5, 0x9d,
	0x06, 0x8e, 0x73, 0x1e, 0x14, 0x8e, 0xa2, 0x3d, 0xdd, 0x28, 0x95, 0x7d, 0x46, 0x39, 0xbb, 0xb9,
	0x7b, 0x30, 0xb4, 0xfb, 0x07, 0x43, 0xfb, 0xfb, 0xc1, 0xd0, 0x7e, 0x7f, 0x34, 0x0e, 0xee, 0x1f,
	0x8d, 0x83, 0xbf, 0x1e, 0x8d, 0x83, 0x6f, 0x3f, 0x73, 0xa8, 0x9a, 0xcc, 0xac, 0x8e, 0xcd, 0xa7,
	0xa6, 0x45, 0x95, 0x85, 0xb0, 0x43, 0x64, 0xf2, 0x64, 0x4f, 0x10, 0x65, 0xe6, 0x8f, 0x66, 0xea,
	0x73, 0x5a, 0x2d, 0x3c, 0x22, 0xfd, 0x8f, 0x6a, 0xab, 0x11, 0x7c, 0x31, 0x7f, 0xf2, 0x4f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x7a, 0x04, 0x4f, 0xf5, 0xe1, 0x0f, 0x00, 0x00,
}

func (m *CollectionPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanAddMoreCosmosCoinWrapperPaths) > 0 {
		for iNdEx := len(m.CanAddMoreCosmosCoinWrapperPaths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanAddMoreCosmosCoinWrapperPaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.CanAddMoreAliasPaths) > 0 {
		for iNdEx := len(m.CanAddMoreAliasPaths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanAddMoreAliasPaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.CanUpdateCollectionApprovals) > 0 {
		for iNdEx := len(m.CanUpdateCollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CanUpdateTokenMetadata) > 0 {
		for iNdEx := len(m.CanUpdateTokenMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateTokenMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CanUpdateValidTokenIds) > 0 {
		for iNdEx := len(m.CanUpdateValidTokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateValidTokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for iNdEx := len(m.CanUpdateCollectionMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for iNdEx := len(m.CanUpdateManager) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateManager[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for iNdEx := len(m.CanUpdateCustomData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCustomData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CanUpdateStandards) > 0 {
		for iNdEx := len(m.CanUpdateStandards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateStandards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CanArchiveCollection) > 0 {
		for iNdEx := len(m.CanArchiveCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanArchiveCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CanDeleteCollection) > 0 {
		for iNdEx := len(m.CanDeleteCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanDeleteCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateAutoApproveAllIncomingTransfers) > 0 {
		for iNdEx := len(m.CanUpdateAutoApproveAllIncomingTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateAutoApproveAllIncomingTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers) > 0 {
		for iNdEx := len(m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers) > 0 {
		for iNdEx := len(m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CanUpdateIncomingApprovals) > 0 {
		for iNdEx := len(m.CanUpdateIncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateIncomingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CanUpdateOutgoingApprovals) > 0 {
		for iNdEx := len(m.CanUpdateOutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateOutgoingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApprovalPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApprovalPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApprovalPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PermanentlyForbiddenTimes) > 0 {
		for iNdEx := len(m.PermanentlyForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermanentlyForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.PermanentlyPermittedTimes) > 0 {
		for iNdEx := len(m.PermanentlyPermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermanentlyPermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ToListId) > 0 {
		i -= len(m.ToListId)
		copy(dAtA[i:], m.ToListId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ToListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromListId) > 0 {
		i -= len(m.FromListId)
		copy(dAtA[i:], m.FromListId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.FromListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserOutgoingApprovalPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserOutgoingApprovalPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserOutgoingApprovalPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PermanentlyForbiddenTimes) > 0 {
		for iNdEx := len(m.PermanentlyForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermanentlyForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PermanentlyPermittedTimes) > 0 {
		for iNdEx := len(m.PermanentlyPermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermanentlyPermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToListId) > 0 {
		i -= len(m.ToListId)
		copy(dAtA[i:], m.ToListId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ToListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserIncomingApprovalPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIncomingApprovalPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserIncomingApprovalPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PermanentlyForbiddenTimes) > 0 {
		for iNdEx := len(m.PermanentlyForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermanentlyForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PermanentlyPermittedTimes) > 0 {
		for iNdEx := len(m.PermanentlyPermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermanentlyPermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromListId) > 0 {
		i -= len(m.FromListId)
		copy(dAtA[i:], m.FromListId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.FromListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TokenIdsActionPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenIdsActionPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenIdsActionPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PermanentlyForbiddenTimes) > 0 {
		for iNdEx := len(m.PermanentlyForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermanentlyForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PermanentlyPermittedTimes) > 0 {
		for iNdEx := len(m.PermanentlyPermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermanentlyPermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PermanentlyForbiddenTimes) > 0 {
		for iNdEx := len(m.PermanentlyForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermanentlyForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PermanentlyPermittedTimes) > 0 {
		for iNdEx := len(m.PermanentlyPermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermanentlyPermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPermissions(dAtA []byte, offset int, v uint64) int {
	offset -= sovPermissions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CollectionPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CanDeleteCollection) > 0 {
		for _, e := range m.CanDeleteCollection {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanArchiveCollection) > 0 {
		for _, e := range m.CanArchiveCollection {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateStandards) > 0 {
		for _, e := range m.CanUpdateStandards {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for _, e := range m.CanUpdateCustomData {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for _, e := range m.CanUpdateManager {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for _, e := range m.CanUpdateCollectionMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateValidTokenIds) > 0 {
		for _, e := range m.CanUpdateValidTokenIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateTokenMetadata) > 0 {
		for _, e := range m.CanUpdateTokenMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionApprovals) > 0 {
		for _, e := range m.CanUpdateCollectionApprovals {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanAddMoreAliasPaths) > 0 {
		for _, e := range m.CanAddMoreAliasPaths {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanAddMoreCosmosCoinWrapperPaths) > 0 {
		for _, e := range m.CanAddMoreCosmosCoinWrapperPaths {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CanUpdateOutgoingApprovals) > 0 {
		for _, e := range m.CanUpdateOutgoingApprovals {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateIncomingApprovals) > 0 {
		for _, e := range m.CanUpdateIncomingApprovals {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers) > 0 {
		for _, e := range m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers) > 0 {
		for _, e := range m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateAutoApproveAllIncomingTransfers) > 0 {
		for _, e := range m.CanUpdateAutoApproveAllIncomingTransfers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *CollectionApprovalPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromListId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ToListId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.TokenIds) > 0 {
		for _, e := range m.TokenIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.PermanentlyPermittedTimes) > 0 {
		for _, e := range m.PermanentlyPermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermanentlyForbiddenTimes) > 0 {
		for _, e := range m.PermanentlyForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserOutgoingApprovalPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToListId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.TokenIds) > 0 {
		for _, e := range m.TokenIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.PermanentlyPermittedTimes) > 0 {
		for _, e := range m.PermanentlyPermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermanentlyForbiddenTimes) > 0 {
		for _, e := range m.PermanentlyForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserIncomingApprovalPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromListId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.TokenIds) > 0 {
		for _, e := range m.TokenIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.PermanentlyPermittedTimes) > 0 {
		for _, e := range m.PermanentlyPermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermanentlyForbiddenTimes) > 0 {
		for _, e := range m.PermanentlyForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *TokenIdsActionPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TokenIds) > 0 {
		for _, e := range m.TokenIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermanentlyPermittedTimes) > 0 {
		for _, e := range m.PermanentlyPermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermanentlyForbiddenTimes) > 0 {
		for _, e := range m.PermanentlyForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ActionPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PermanentlyPermittedTimes) > 0 {
		for _, e := range m.PermanentlyPermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermanentlyForbiddenTimes) > 0 {
		for _, e := range m.PermanentlyForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func sovPermissions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPermissions(x uint64) (n int) {
	return sovPermissions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CollectionPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDeleteCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanDeleteCollection = append(m.CanDeleteCollection, &ActionPermission{})
			if err := m.CanDeleteCollection[len(m.CanDeleteCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanArchiveCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanArchiveCollection = append(m.CanArchiveCollection, &ActionPermission{})
			if err := m.CanArchiveCollection[len(m.CanArchiveCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateStandards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateStandards = append(m.CanUpdateStandards, &ActionPermission{})
			if err := m.CanUpdateStandards[len(m.CanUpdateStandards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCustomData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCustomData = append(m.CanUpdateCustomData, &ActionPermission{})
			if err := m.CanUpdateCustomData[len(m.CanUpdateCustomData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateManager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateManager = append(m.CanUpdateManager, &ActionPermission{})
			if err := m.CanUpdateManager[len(m.CanUpdateManager)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionMetadata = append(m.CanUpdateCollectionMetadata, &ActionPermission{})
			if err := m.CanUpdateCollectionMetadata[len(m.CanUpdateCollectionMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateValidTokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateValidTokenIds = append(m.CanUpdateValidTokenIds, &TokenIdsActionPermission{})
			if err := m.CanUpdateValidTokenIds[len(m.CanUpdateValidTokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateTokenMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateTokenMetadata = append(m.CanUpdateTokenMetadata, &TokenIdsActionPermission{})
			if err := m.CanUpdateTokenMetadata[len(m.CanUpdateTokenMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionApprovals = append(m.CanUpdateCollectionApprovals, &CollectionApprovalPermission{})
			if err := m.CanUpdateCollectionApprovals[len(m.CanUpdateCollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanAddMoreAliasPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanAddMoreAliasPaths = append(m.CanAddMoreAliasPaths, &ActionPermission{})
			if err := m.CanAddMoreAliasPaths[len(m.CanAddMoreAliasPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanAddMoreCosmosCoinWrapperPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanAddMoreCosmosCoinWrapperPaths = append(m.CanAddMoreCosmosCoinWrapperPaths, &ActionPermission{})
			if err := m.CanAddMoreCosmosCoinWrapperPaths[len(m.CanAddMoreCosmosCoinWrapperPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateOutgoingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateOutgoingApprovals = append(m.CanUpdateOutgoingApprovals, &UserOutgoingApprovalPermission{})
			if err := m.CanUpdateOutgoingApprovals[len(m.CanUpdateOutgoingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateIncomingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateIncomingApprovals = append(m.CanUpdateIncomingApprovals, &UserIncomingApprovalPermission{})
			if err := m.CanUpdateIncomingApprovals[len(m.CanUpdateIncomingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateAutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers = append(m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers, &ActionPermission{})
			if err := m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers[len(m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateAutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers = append(m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers, &ActionPermission{})
			if err := m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers[len(m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateAutoApproveAllIncomingTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateAutoApproveAllIncomingTransfers = append(m.CanUpdateAutoApproveAllIncomingTransfers, &ActionPermission{})
			if err := m.CanUpdateAutoApproveAllIncomingTransfers[len(m.CanUpdateAutoApproveAllIncomingTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApprovalPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApprovalPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApprovalPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, &UintRange{})
			if err := m.TokenIds[len(m.TokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermanentlyPermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermanentlyPermittedTimes = append(m.PermanentlyPermittedTimes, &UintRange{})
			if err := m.PermanentlyPermittedTimes[len(m.PermanentlyPermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermanentlyForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermanentlyForbiddenTimes = append(m.PermanentlyForbiddenTimes, &UintRange{})
			if err := m.PermanentlyForbiddenTimes[len(m.PermanentlyForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserOutgoingApprovalPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserOutgoingApprovalPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserOutgoingApprovalPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, &UintRange{})
			if err := m.TokenIds[len(m.TokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermanentlyPermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermanentlyPermittedTimes = append(m.PermanentlyPermittedTimes, &UintRange{})
			if err := m.PermanentlyPermittedTimes[len(m.PermanentlyPermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermanentlyForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermanentlyForbiddenTimes = append(m.PermanentlyForbiddenTimes, &UintRange{})
			if err := m.PermanentlyForbiddenTimes[len(m.PermanentlyForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIncomingApprovalPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIncomingApprovalPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIncomingApprovalPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, &UintRange{})
			if err := m.TokenIds[len(m.TokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermanentlyPermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermanentlyPermittedTimes = append(m.PermanentlyPermittedTimes, &UintRange{})
			if err := m.PermanentlyPermittedTimes[len(m.PermanentlyPermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermanentlyForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermanentlyForbiddenTimes = append(m.PermanentlyForbiddenTimes, &UintRange{})
			if err := m.PermanentlyForbiddenTimes[len(m.PermanentlyForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenIdsActionPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenIdsActionPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenIdsActionPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, &UintRange{})
			if err := m.TokenIds[len(m.TokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermanentlyPermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermanentlyPermittedTimes = append(m.PermanentlyPermittedTimes, &UintRange{})
			if err := m.PermanentlyPermittedTimes[len(m.PermanentlyPermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermanentlyForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermanentlyForbiddenTimes = append(m.PermanentlyForbiddenTimes, &UintRange{})
			if err := m.PermanentlyForbiddenTimes[len(m.PermanentlyForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermanentlyPermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermanentlyPermittedTimes = append(m.PermanentlyPermittedTimes, &UintRange{})
			if err := m.PermanentlyPermittedTimes[len(m.PermanentlyPermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermanentlyForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermanentlyForbiddenTimes = append(m.PermanentlyForbiddenTimes, &UintRange{})
			if err := m.PermanentlyForbiddenTimes[len(m.PermanentlyForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPermissions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPermissions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPermissions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPermissions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPermissions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPermissions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPermissions = fmt.Errorf("proto: unexpected end of group")
)
