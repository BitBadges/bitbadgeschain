// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tokenization/v22/approval_conditions.proto

package v22

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CoinTransfer struct {
	// The address of the recipient of the transfer.
	To string `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	// The sdk.Coins to be transferred.
	Coins []*types.Coin `protobuf:"bytes,2,rep,name=coins,proto3" json:"coins,omitempty"`
	// By default, the from address is the initiator of the transaction.
	// If this is set to true, we will override the from address with the approver address.
	// Note: This is not applicable for collection approvals (since approverAddress == '').
	OverrideFromWithApproverAddress bool `protobuf:"varint,3,opt,name=overrideFromWithApproverAddress,proto3" json:"overrideFromWithApproverAddress,omitempty"`
	// By default, the to address is what is specified in the coin transfer.
	// If this is set to true, we will override the to address with the initiator of the transaction.
	OverrideToWithInitiator bool `protobuf:"varint,4,opt,name=overrideToWithInitiator,proto3" json:"overrideToWithInitiator,omitempty"`
}

func (m *CoinTransfer) Reset()         { *m = CoinTransfer{} }
func (m *CoinTransfer) String() string { return proto.CompactTextString(m) }
func (*CoinTransfer) ProtoMessage()    {}
func (*CoinTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_d45bfeb6c5c9ab29, []int{0}
}
func (m *CoinTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinTransfer.Merge(m, src)
}
func (m *CoinTransfer) XXX_Size() int {
	return m.Size()
}
func (m *CoinTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_CoinTransfer proto.InternalMessageInfo

func (m *CoinTransfer) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *CoinTransfer) GetCoins() []*types.Coin {
	if m != nil {
		return m.Coins
	}
	return nil
}

func (m *CoinTransfer) GetOverrideFromWithApproverAddress() bool {
	if m != nil {
		return m.OverrideFromWithApproverAddress
	}
	return false
}

func (m *CoinTransfer) GetOverrideToWithInitiator() bool {
	if m != nil {
		return m.OverrideToWithInitiator
	}
	return false
}

// MustOwnTokens represents a condition where a user must own specific tokens
// to be approved to transfer.
//
// - collectionId: The ID of the collection for the tokens that must be owned
// - amountRange: The range of amounts the user must own (min to max)
// - ownershipTimes: The time ranges during which the user must own the tokens.
// - tokenIds: The token IDs the user must own.
// - overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.
// - mustSatisfyForAllAssets: If true, the user must own all specified tokens; otherwise, owning any one for >= 1 millisecond is sufficient.
type MustOwnTokens struct {
	// The ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The range of amounts the user must own (min to max).
	AmountRange *UintRange `protobuf:"bytes,2,opt,name=amountRange,proto3" json:"amountRange,omitempty"`
	// The time ranges during which the user must own the tokens.
	OwnershipTimes []*UintRange `protobuf:"bytes,3,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The token IDs the user must own.
	TokenIds []*UintRange `protobuf:"bytes,4,rep,name=tokenIds,proto3" json:"tokenIds,omitempty"`
	// If true, override ownershipTimes with the current time.
	OverrideWithCurrentTime bool `protobuf:"varint,5,opt,name=overrideWithCurrentTime,proto3" json:"overrideWithCurrentTime,omitempty"`
	// If true, the user must meet ownership requirements for all specified tokens; else, must meet requirements for any single token.
	MustSatisfyForAllAssets bool `protobuf:"varint,6,opt,name=mustSatisfyForAllAssets,proto3" json:"mustSatisfyForAllAssets,omitempty"`
	// The party to check ownership for. Options are "initiator", "sender", "recipient", or any valid bb1 address.
	// If a valid bb1 address is provided, ownership will be checked for that specific address.
	// This enables use cases like halt tokens where ownership is checked for an arbitrary address (e.g., halt token owner).
	// Defaults to "initiator" if empty or if the value is not a recognized option or valid bb1 address.
	OwnershipCheckParty string `protobuf:"bytes,7,opt,name=ownershipCheckParty,proto3" json:"ownershipCheckParty,omitempty"`
}

func (m *MustOwnTokens) Reset()         { *m = MustOwnTokens{} }
func (m *MustOwnTokens) String() string { return proto.CompactTextString(m) }
func (*MustOwnTokens) ProtoMessage()    {}
func (*MustOwnTokens) Descriptor() ([]byte, []int) {
	return fileDescriptor_d45bfeb6c5c9ab29, []int{1}
}
func (m *MustOwnTokens) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MustOwnTokens) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MustOwnTokens.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MustOwnTokens) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MustOwnTokens.Merge(m, src)
}
func (m *MustOwnTokens) XXX_Size() int {
	return m.Size()
}
func (m *MustOwnTokens) XXX_DiscardUnknown() {
	xxx_messageInfo_MustOwnTokens.DiscardUnknown(m)
}

var xxx_messageInfo_MustOwnTokens proto.InternalMessageInfo

func (m *MustOwnTokens) GetAmountRange() *UintRange {
	if m != nil {
		return m.AmountRange
	}
	return nil
}

func (m *MustOwnTokens) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *MustOwnTokens) GetTokenIds() []*UintRange {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

func (m *MustOwnTokens) GetOverrideWithCurrentTime() bool {
	if m != nil {
		return m.OverrideWithCurrentTime
	}
	return false
}

func (m *MustOwnTokens) GetMustSatisfyForAllAssets() bool {
	if m != nil {
		return m.MustSatisfyForAllAssets
	}
	return false
}

func (m *MustOwnTokens) GetOwnershipCheckParty() string {
	if m != nil {
		return m.OwnershipCheckParty
	}
	return ""
}

// DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.
type DynamicStoreChallenge struct {
	// The ID of the dynamic store to check.
	StoreId Uint `protobuf:"bytes,1,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
}

func (m *DynamicStoreChallenge) Reset()         { *m = DynamicStoreChallenge{} }
func (m *DynamicStoreChallenge) String() string { return proto.CompactTextString(m) }
func (*DynamicStoreChallenge) ProtoMessage()    {}
func (*DynamicStoreChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_d45bfeb6c5c9ab29, []int{2}
}
func (m *DynamicStoreChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicStoreChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicStoreChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicStoreChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicStoreChallenge.Merge(m, src)
}
func (m *DynamicStoreChallenge) XXX_Size() int {
	return m.Size()
}
func (m *DynamicStoreChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicStoreChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicStoreChallenge proto.InternalMessageInfo

// AddressChecks defines checks for address types (WASM contract, liquidity pool, etc.)
type AddressChecks struct {
	// Require the address to be a WASM contract.
	MustBeWasmContract bool `protobuf:"varint,1,opt,name=mustBeWasmContract,proto3" json:"mustBeWasmContract,omitempty"`
	// Require the address to not be a WASM contract.
	MustNotBeWasmContract bool `protobuf:"varint,2,opt,name=mustNotBeWasmContract,proto3" json:"mustNotBeWasmContract,omitempty"`
	// Require the address to be a liquidity pool.
	MustBeLiquidityPool bool `protobuf:"varint,3,opt,name=mustBeLiquidityPool,proto3" json:"mustBeLiquidityPool,omitempty"`
	// Require the address to not be a liquidity pool.
	MustNotBeLiquidityPool bool `protobuf:"varint,4,opt,name=mustNotBeLiquidityPool,proto3" json:"mustNotBeLiquidityPool,omitempty"`
}

func (m *AddressChecks) Reset()         { *m = AddressChecks{} }
func (m *AddressChecks) String() string { return proto.CompactTextString(m) }
func (*AddressChecks) ProtoMessage()    {}
func (*AddressChecks) Descriptor() ([]byte, []int) {
	return fileDescriptor_d45bfeb6c5c9ab29, []int{3}
}
func (m *AddressChecks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressChecks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressChecks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressChecks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressChecks.Merge(m, src)
}
func (m *AddressChecks) XXX_Size() int {
	return m.Size()
}
func (m *AddressChecks) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressChecks.DiscardUnknown(m)
}

var xxx_messageInfo_AddressChecks proto.InternalMessageInfo

func (m *AddressChecks) GetMustBeWasmContract() bool {
	if m != nil {
		return m.MustBeWasmContract
	}
	return false
}

func (m *AddressChecks) GetMustNotBeWasmContract() bool {
	if m != nil {
		return m.MustNotBeWasmContract
	}
	return false
}

func (m *AddressChecks) GetMustBeLiquidityPool() bool {
	if m != nil {
		return m.MustBeLiquidityPool
	}
	return false
}

func (m *AddressChecks) GetMustNotBeLiquidityPool() bool {
	if m != nil {
		return m.MustNotBeLiquidityPool
	}
	return false
}

// AltTimeChecks defines alternative time-based checks for approval denial.
// If the transfer time falls within any of the specified offline hours or days, the approval is denied.
// Uses UTC timezone for neutral timezone approach.
// offlineHours: ranges of hours (0-23) when transfers should be denied
// offlineDays: ranges of days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied
type AltTimeChecks struct {
	// Hours (0-23) when transfers should be denied. Uses UTC timezone.
	OfflineHours []*UintRange `protobuf:"bytes,1,rep,name=offlineHours,proto3" json:"offlineHours,omitempty"`
	// Days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied. Uses UTC timezone.
	OfflineDays []*UintRange `protobuf:"bytes,2,rep,name=offlineDays,proto3" json:"offlineDays,omitempty"`
}

func (m *AltTimeChecks) Reset()         { *m = AltTimeChecks{} }
func (m *AltTimeChecks) String() string { return proto.CompactTextString(m) }
func (*AltTimeChecks) ProtoMessage()    {}
func (*AltTimeChecks) Descriptor() ([]byte, []int) {
	return fileDescriptor_d45bfeb6c5c9ab29, []int{4}
}
func (m *AltTimeChecks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AltTimeChecks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AltTimeChecks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AltTimeChecks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AltTimeChecks.Merge(m, src)
}
func (m *AltTimeChecks) XXX_Size() int {
	return m.Size()
}
func (m *AltTimeChecks) XXX_DiscardUnknown() {
	xxx_messageInfo_AltTimeChecks.DiscardUnknown(m)
}

var xxx_messageInfo_AltTimeChecks proto.InternalMessageInfo

func (m *AltTimeChecks) GetOfflineHours() []*UintRange {
	if m != nil {
		return m.OfflineHours
	}
	return nil
}

func (m *AltTimeChecks) GetOfflineDays() []*UintRange {
	if m != nil {
		return m.OfflineDays
	}
	return nil
}

// UserRoyalties defines the royalties for a user.
type UserRoyalties struct {
	// Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.
	Percentage Uint `protobuf:"bytes,1,opt,name=percentage,proto3,customtype=Uint" json:"percentage"`
	// Payout address for the royalties.
	PayoutAddress string `protobuf:"bytes,2,opt,name=payoutAddress,proto3" json:"payoutAddress,omitempty"`
}

func (m *UserRoyalties) Reset()         { *m = UserRoyalties{} }
func (m *UserRoyalties) String() string { return proto.CompactTextString(m) }
func (*UserRoyalties) ProtoMessage()    {}
func (*UserRoyalties) Descriptor() ([]byte, []int) {
	return fileDescriptor_d45bfeb6c5c9ab29, []int{5}
}
func (m *UserRoyalties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRoyalties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRoyalties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRoyalties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRoyalties.Merge(m, src)
}
func (m *UserRoyalties) XXX_Size() int {
	return m.Size()
}
func (m *UserRoyalties) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRoyalties.DiscardUnknown(m)
}

var xxx_messageInfo_UserRoyalties proto.InternalMessageInfo

func (m *UserRoyalties) GetPayoutAddress() string {
	if m != nil {
		return m.PayoutAddress
	}
	return ""
}

func init() {
	proto.RegisterType((*CoinTransfer)(nil), "tokenization.v22.CoinTransfer")
	proto.RegisterType((*MustOwnTokens)(nil), "tokenization.v22.MustOwnTokens")
	proto.RegisterType((*DynamicStoreChallenge)(nil), "tokenization.v22.DynamicStoreChallenge")
	proto.RegisterType((*AddressChecks)(nil), "tokenization.v22.AddressChecks")
	proto.RegisterType((*AltTimeChecks)(nil), "tokenization.v22.AltTimeChecks")
	proto.RegisterType((*UserRoyalties)(nil), "tokenization.v22.UserRoyalties")
}

func init() {
	proto.RegisterFile("tokenization/v22/approval_conditions.proto", fileDescriptor_d45bfeb6c5c9ab29)
}

var fileDescriptor_d45bfeb6c5c9ab29 = []byte{
	// 684 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0xcd, 0x6e, 0xd3, 0x4a,
	0x14, 0x8e, 0x93, 0xfe, 0xdd, 0x69, 0x52, 0x5d, 0xcd, 0xbd, 0xbd, 0xd7, 0x14, 0x29, 0x89, 0x22,
	0x84, 0x22, 0x84, 0xec, 0x36, 0x20, 0x60, 0x01, 0xaa, 0xd2, 0x54, 0x55, 0x2b, 0xf1, 0x53, 0xb9,
	0x29, 0x95, 0xd8, 0xa0, 0xb1, 0x3d, 0x49, 0x46, 0xb5, 0xe7, 0x98, 0x99, 0x71, 0x8a, 0x79, 0x09,
	0x78, 0x08, 0x1e, 0xa6, 0xcb, 0x4a, 0x6c, 0x10, 0x8b, 0x82, 0xda, 0x17, 0x41, 0x63, 0x27, 0x25,
	0x09, 0x09, 0xd9, 0x39, 0xe7, 0xfb, 0xd1, 0x9c, 0x73, 0xbe, 0x1c, 0x74, 0x4f, 0xc1, 0x29, 0xe5,
	0xec, 0x03, 0x51, 0x0c, 0xb8, 0xdd, 0x6f, 0x34, 0x6c, 0x12, 0x45, 0x02, 0xfa, 0x24, 0x78, 0xeb,
	0x01, 0xf7, 0x99, 0x2e, 0x4b, 0x2b, 0x12, 0xa0, 0x00, 0xff, 0x3d, 0xca, 0xb5, 0xfa, 0x8d, 0xc6,
	0xc6, 0xbf, 0x5d, 0xe8, 0x42, 0x0a, 0xda, 0xfa, 0x2b, 0xe3, 0x6d, 0x54, 0x7e, 0xf3, 0x74, 0x49,
	0x40, 0xb8, 0x47, 0x07, 0x46, 0x1b, 0x65, 0x0f, 0x64, 0x08, 0xd2, 0x76, 0x89, 0xa4, 0x76, 0x7f,
	0xcb, 0xa5, 0x8a, 0x6c, 0xd9, 0x1e, 0x30, 0x9e, 0xe1, 0xb5, 0x2f, 0x06, 0x2a, 0xb6, 0x80, 0xf1,
	0xb6, 0x20, 0x5c, 0x76, 0xa8, 0xc0, 0x6b, 0x28, 0xaf, 0xc0, 0x34, 0xaa, 0x46, 0xfd, 0x2f, 0x27,
	0xaf, 0x00, 0xdb, 0x68, 0x51, 0xd3, 0xa5, 0x99, 0xaf, 0x16, 0xea, 0xab, 0x8d, 0x5b, 0x56, 0x66,
	0x68, 0x69, 0x43, 0x6b, 0x60, 0x68, 0x69, 0x07, 0x27, 0xe3, 0xe1, 0x7d, 0x54, 0x81, 0x3e, 0x15,
	0x82, 0xf9, 0x74, 0x4f, 0x40, 0x78, 0xc2, 0x54, 0xaf, 0x99, 0xf6, 0x49, 0x45, 0xd3, 0xf7, 0x05,
	0x95, 0xd2, 0x2c, 0x54, 0x8d, 0xfa, 0x8a, 0x33, 0x8f, 0x86, 0x9f, 0xa0, 0xff, 0x87, 0x94, 0x36,
	0x68, 0xc2, 0x01, 0x67, 0x8a, 0x11, 0x05, 0xc2, 0x5c, 0x48, 0x1d, 0x66, 0xc1, 0xb5, 0xcf, 0x05,
	0x54, 0x7a, 0x11, 0x4b, 0xf5, 0xea, 0x8c, 0xb7, 0xf5, 0x80, 0x24, 0xde, 0x44, 0x45, 0x0f, 0x82,
	0x80, 0x7a, 0x7a, 0x50, 0x07, 0x7e, 0xd6, 0xe0, 0x4e, 0xf1, 0xfc, 0xb2, 0x92, 0xfb, 0x76, 0x59,
	0x59, 0x38, 0x66, 0x5c, 0x39, 0x63, 0x0c, 0xfc, 0x0c, 0xad, 0x92, 0x10, 0x62, 0xae, 0x1c, 0xc2,
	0xbb, 0xd4, 0xcc, 0x57, 0x8d, 0xfa, 0x6a, 0xe3, 0xb6, 0x35, 0xb9, 0x18, 0x2b, 0x95, 0x6a, 0x8a,
	0x33, 0xca, 0xc7, 0x2d, 0xb4, 0x06, 0x67, 0x9c, 0x0a, 0xd9, 0x63, 0x51, 0x9b, 0x85, 0x54, 0x77,
	0x5d, 0x98, 0xe7, 0x30, 0x21, 0xc1, 0x8f, 0xd1, 0x4a, 0xca, 0x3e, 0xf0, 0xa5, 0xb9, 0x30, 0x5f,
	0x7e, 0x43, 0x1e, 0x1d, 0x9d, 0x9e, 0x4c, 0x2b, 0x16, 0x82, 0x72, 0xa5, 0x4d, 0xcd, 0xc5, 0xf1,
	0xd1, 0x4d, 0xc0, 0x5a, 0x19, 0xc6, 0x52, 0x1d, 0x11, 0xc5, 0x64, 0x27, 0xd9, 0x03, 0xd1, 0x0c,
	0x82, 0xa6, 0x94, 0x54, 0x49, 0x73, 0x29, 0x53, 0xce, 0x80, 0xf1, 0x26, 0xfa, 0xe7, 0xe6, 0xf9,
	0xad, 0x1e, 0xf5, 0x4e, 0x0f, 0x89, 0x50, 0x89, 0xb9, 0x9c, 0x46, 0x69, 0x1a, 0x54, 0xdb, 0x46,
	0xeb, 0xbb, 0x09, 0x27, 0x21, 0xf3, 0x8e, 0x14, 0x08, 0xda, 0xea, 0x91, 0x20, 0xa0, 0x7a, 0x78,
	0x77, 0xd1, 0xb2, 0xd4, 0x95, 0x19, 0x8b, 0x1a, 0x82, 0xb5, 0xef, 0x06, 0x2a, 0x0d, 0xd2, 0x92,
	0xda, 0x4a, 0x6c, 0x21, 0xac, 0xdf, 0xb7, 0x43, 0x4f, 0x88, 0x0c, 0x5b, 0xc0, 0x95, 0x20, 0x9e,
	0x4a, 0x4d, 0x56, 0x9c, 0x29, 0x08, 0x7e, 0x88, 0xd6, 0x75, 0xf5, 0x25, 0x4c, 0x4a, 0xf2, 0xa9,
	0x64, 0x3a, 0xa8, 0x5b, 0xcd, 0xbc, 0x9e, 0xb3, 0x77, 0x31, 0xf3, 0x99, 0x4a, 0x0e, 0x01, 0x82,
	0x41, 0xae, 0xa7, 0x41, 0xf8, 0x11, 0xfa, 0xef, 0xc6, 0x6a, 0x5c, 0x94, 0x45, 0x79, 0x06, 0x5a,
	0xfb, 0xa8, 0x3b, 0x0c, 0xd2, 0xd5, 0x0c, 0x3a, 0xdc, 0x46, 0x45, 0xe8, 0x74, 0x02, 0xc6, 0xe9,
	0x3e, 0xc4, 0x42, 0x9a, 0xc6, 0xfc, 0x5c, 0x8c, 0x09, 0x74, 0xb0, 0x07, 0xbf, 0x77, 0x49, 0x32,
	0xfc, 0x5f, 0xff, 0x39, 0xd8, 0x23, 0xfc, 0x9a, 0x87, 0x4a, 0xc7, 0x92, 0x0a, 0x07, 0x12, 0x12,
	0x28, 0x46, 0x25, 0xbe, 0x8f, 0x50, 0x44, 0x85, 0x47, 0xb9, 0x22, 0x5d, 0x3a, 0x75, 0x5f, 0x23,
	0x38, 0xbe, 0x83, 0x4a, 0x11, 0x49, 0x20, 0x56, 0xc3, 0x63, 0x90, 0x4f, 0xf3, 0x31, 0x5e, 0xdc,
	0x79, 0x7d, 0x7e, 0x55, 0x36, 0x2e, 0xae, 0xca, 0xc6, 0x8f, 0xab, 0xb2, 0xf1, 0xe9, 0xba, 0x9c,
	0xbb, 0xb8, 0x2e, 0xe7, 0xbe, 0x5e, 0x97, 0x73, 0x6f, 0x9e, 0x76, 0x99, 0xea, 0xc5, 0xae, 0xe5,
	0x41, 0x68, 0xbb, 0x4c, 0xb9, 0xc4, 0xef, 0x52, 0xf9, 0xeb, 0xcb, 0xeb, 0x11, 0xc6, 0xed, 0xf7,
	0xf6, 0xd8, 0x5d, 0x54, 0x49, 0x44, 0xa5, 0xbe, 0x8e, 0xee, 0x52, 0x7a, 0xf5, 0x1e, 0xfc, 0x0c,
	0x00, 0x00, 0xff, 0xff, 0xed, 0x3a, 0xa2, 0x8c, 0x8c, 0x05, 0x00, 0x00,
}

func (m *CoinTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverrideToWithInitiator {
		i--
		if m.OverrideToWithInitiator {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.OverrideFromWithApproverAddress {
		i--
		if m.OverrideFromWithApproverAddress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalConditions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintApprovalConditions(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MustOwnTokens) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MustOwnTokens) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MustOwnTokens) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OwnershipCheckParty) > 0 {
		i -= len(m.OwnershipCheckParty)
		copy(dAtA[i:], m.OwnershipCheckParty)
		i = encodeVarintApprovalConditions(dAtA, i, uint64(len(m.OwnershipCheckParty)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MustSatisfyForAllAssets {
		i--
		if m.MustSatisfyForAllAssets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.OverrideWithCurrentTime {
		i--
		if m.OverrideWithCurrentTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalConditions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalConditions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.AmountRange != nil {
		{
			size, err := m.AmountRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalConditions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintApprovalConditions(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DynamicStoreChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicStoreChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicStoreChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintApprovalConditions(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AddressChecks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressChecks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressChecks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MustNotBeLiquidityPool {
		i--
		if m.MustNotBeLiquidityPool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.MustBeLiquidityPool {
		i--
		if m.MustBeLiquidityPool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.MustNotBeWasmContract {
		i--
		if m.MustNotBeWasmContract {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MustBeWasmContract {
		i--
		if m.MustBeWasmContract {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AltTimeChecks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AltTimeChecks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AltTimeChecks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OfflineDays) > 0 {
		for iNdEx := len(m.OfflineDays) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OfflineDays[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalConditions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OfflineHours) > 0 {
		for iNdEx := len(m.OfflineHours) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OfflineHours[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalConditions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserRoyalties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRoyalties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRoyalties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PayoutAddress) > 0 {
		i -= len(m.PayoutAddress)
		copy(dAtA[i:], m.PayoutAddress)
		i = encodeVarintApprovalConditions(dAtA, i, uint64(len(m.PayoutAddress)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Percentage.Size()
		i -= size
		if _, err := m.Percentage.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintApprovalConditions(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintApprovalConditions(dAtA []byte, offset int, v uint64) int {
	offset -= sovApprovalConditions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CoinTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovApprovalConditions(uint64(l))
	}
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovApprovalConditions(uint64(l))
		}
	}
	if m.OverrideFromWithApproverAddress {
		n += 2
	}
	if m.OverrideToWithInitiator {
		n += 2
	}
	return n
}

func (m *MustOwnTokens) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovApprovalConditions(uint64(l))
	if m.AmountRange != nil {
		l = m.AmountRange.Size()
		n += 1 + l + sovApprovalConditions(uint64(l))
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovApprovalConditions(uint64(l))
		}
	}
	if len(m.TokenIds) > 0 {
		for _, e := range m.TokenIds {
			l = e.Size()
			n += 1 + l + sovApprovalConditions(uint64(l))
		}
	}
	if m.OverrideWithCurrentTime {
		n += 2
	}
	if m.MustSatisfyForAllAssets {
		n += 2
	}
	l = len(m.OwnershipCheckParty)
	if l > 0 {
		n += 1 + l + sovApprovalConditions(uint64(l))
	}
	return n
}

func (m *DynamicStoreChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StoreId.Size()
	n += 1 + l + sovApprovalConditions(uint64(l))
	return n
}

func (m *AddressChecks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MustBeWasmContract {
		n += 2
	}
	if m.MustNotBeWasmContract {
		n += 2
	}
	if m.MustBeLiquidityPool {
		n += 2
	}
	if m.MustNotBeLiquidityPool {
		n += 2
	}
	return n
}

func (m *AltTimeChecks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OfflineHours) > 0 {
		for _, e := range m.OfflineHours {
			l = e.Size()
			n += 1 + l + sovApprovalConditions(uint64(l))
		}
	}
	if len(m.OfflineDays) > 0 {
		for _, e := range m.OfflineDays {
			l = e.Size()
			n += 1 + l + sovApprovalConditions(uint64(l))
		}
	}
	return n
}

func (m *UserRoyalties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Percentage.Size()
	n += 1 + l + sovApprovalConditions(uint64(l))
	l = len(m.PayoutAddress)
	if l > 0 {
		n += 1 + l + sovApprovalConditions(uint64(l))
	}
	return n
}

func sovApprovalConditions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApprovalConditions(x uint64) (n int) {
	return sovApprovalConditions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CoinTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalConditions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, &types.Coin{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideFromWithApproverAddress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideFromWithApproverAddress = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideToWithInitiator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideToWithInitiator = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalConditions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MustOwnTokens) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalConditions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MustOwnTokens: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MustOwnTokens: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AmountRange == nil {
				m.AmountRange = &UintRange{}
			}
			if err := m.AmountRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, &UintRange{})
			if err := m.TokenIds[len(m.TokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideWithCurrentTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideWithCurrentTime = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustSatisfyForAllAssets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustSatisfyForAllAssets = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipCheckParty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipCheckParty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalConditions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicStoreChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalConditions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicStoreChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicStoreChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalConditions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressChecks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalConditions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressChecks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressChecks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustBeWasmContract", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustBeWasmContract = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustNotBeWasmContract", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustNotBeWasmContract = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustBeLiquidityPool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustBeLiquidityPool = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustNotBeLiquidityPool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustNotBeLiquidityPool = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalConditions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AltTimeChecks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalConditions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AltTimeChecks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AltTimeChecks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfflineHours", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfflineHours = append(m.OfflineHours, &UintRange{})
			if err := m.OfflineHours[len(m.OfflineHours)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfflineDays", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfflineDays = append(m.OfflineDays, &UintRange{})
			if err := m.OfflineDays[len(m.OfflineDays)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalConditions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRoyalties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalConditions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRoyalties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRoyalties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayoutAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalConditions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalConditions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApprovalConditions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApprovalConditions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApprovalConditions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApprovalConditions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApprovalConditions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApprovalConditions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApprovalConditions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApprovalConditions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApprovalConditions = fmt.Errorf("proto: unexpected end of group")
)
