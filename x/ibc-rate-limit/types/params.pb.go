// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibcratelimit/params.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TimeframeType defines the type of timeframe
type TimeframeType int32

const (
	TimeframeType_TIMEFRAME_TYPE_UNSPECIFIED TimeframeType = 0
	TimeframeType_TIMEFRAME_TYPE_BLOCK       TimeframeType = 1
	TimeframeType_TIMEFRAME_TYPE_HOUR        TimeframeType = 2
	TimeframeType_TIMEFRAME_TYPE_DAY         TimeframeType = 3
)

var TimeframeType_name = map[int32]string{
	0: "TIMEFRAME_TYPE_UNSPECIFIED",
	1: "TIMEFRAME_TYPE_BLOCK",
	2: "TIMEFRAME_TYPE_HOUR",
	3: "TIMEFRAME_TYPE_DAY",
}

var TimeframeType_value = map[string]int32{
	"TIMEFRAME_TYPE_UNSPECIFIED": 0,
	"TIMEFRAME_TYPE_BLOCK":       1,
	"TIMEFRAME_TYPE_HOUR":        2,
	"TIMEFRAME_TYPE_DAY":         3,
}

func (x TimeframeType) String() string {
	return proto.EnumName(TimeframeType_name, int32(x))
}

func (TimeframeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e8c0c72281699922, []int{0}
}

// TimeframeLimit defines a limit for a specific timeframe
type TimeframeLimit struct {
	// max_amount is the maximum absolute amount of supply change allowed in this timeframe
	// Value is represented as an integer (e.g., "1000000" = 1,000,000 tokens)
	// If set to 0, this limit is disabled
	MaxAmount cosmossdk_io_math.Int `protobuf:"bytes,1,opt,name=max_amount,json=maxAmount,proto3,customtype=cosmossdk.io/math.Int" json:"max_amount"`
	// timeframe_type defines the type of timeframe (block, hour, day)
	TimeframeType TimeframeType `protobuf:"varint,2,opt,name=timeframe_type,json=timeframeType,proto3,enum=ibcratelimit.TimeframeType" json:"timeframe_type,omitempty"`
	// timeframe_duration is the duration of the timeframe
	// For BLOCK: number of blocks
	// For HOUR: number of hours (will be converted to blocks using block time)
	// For DAY: number of days (will be converted to blocks using block time)
	TimeframeDuration int64 `protobuf:"varint,3,opt,name=timeframe_duration,json=timeframeDuration,proto3" json:"timeframe_duration,omitempty"`
}

func (m *TimeframeLimit) Reset()         { *m = TimeframeLimit{} }
func (m *TimeframeLimit) String() string { return proto.CompactTextString(m) }
func (*TimeframeLimit) ProtoMessage()    {}
func (*TimeframeLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_e8c0c72281699922, []int{0}
}
func (m *TimeframeLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeframeLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeframeLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeframeLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeframeLimit.Merge(m, src)
}
func (m *TimeframeLimit) XXX_Size() int {
	return m.Size()
}
func (m *TimeframeLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeframeLimit.DiscardUnknown(m)
}

var xxx_messageInfo_TimeframeLimit proto.InternalMessageInfo

func (m *TimeframeLimit) GetTimeframeType() TimeframeType {
	if m != nil {
		return m.TimeframeType
	}
	return TimeframeType_TIMEFRAME_TYPE_UNSPECIFIED
}

func (m *TimeframeLimit) GetTimeframeDuration() int64 {
	if m != nil {
		return m.TimeframeDuration
	}
	return 0
}

// UniqueSenderLimit defines limits on unique senders per channel
type UniqueSenderLimit struct {
	// max_unique_senders is the maximum number of unique senders allowed in the timeframe
	// If set to 0, this limit is disabled
	MaxUniqueSenders int64 `protobuf:"varint,1,opt,name=max_unique_senders,json=maxUniqueSenders,proto3" json:"max_unique_senders,omitempty"`
	// timeframe_type defines the type of timeframe (block, hour, day)
	TimeframeType TimeframeType `protobuf:"varint,2,opt,name=timeframe_type,json=timeframeType,proto3,enum=ibcratelimit.TimeframeType" json:"timeframe_type,omitempty"`
	// timeframe_duration is the duration of the timeframe
	TimeframeDuration int64 `protobuf:"varint,3,opt,name=timeframe_duration,json=timeframeDuration,proto3" json:"timeframe_duration,omitempty"`
}

func (m *UniqueSenderLimit) Reset()         { *m = UniqueSenderLimit{} }
func (m *UniqueSenderLimit) String() string { return proto.CompactTextString(m) }
func (*UniqueSenderLimit) ProtoMessage()    {}
func (*UniqueSenderLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_e8c0c72281699922, []int{1}
}
func (m *UniqueSenderLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniqueSenderLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UniqueSenderLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UniqueSenderLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniqueSenderLimit.Merge(m, src)
}
func (m *UniqueSenderLimit) XXX_Size() int {
	return m.Size()
}
func (m *UniqueSenderLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_UniqueSenderLimit.DiscardUnknown(m)
}

var xxx_messageInfo_UniqueSenderLimit proto.InternalMessageInfo

func (m *UniqueSenderLimit) GetMaxUniqueSenders() int64 {
	if m != nil {
		return m.MaxUniqueSenders
	}
	return 0
}

func (m *UniqueSenderLimit) GetTimeframeType() TimeframeType {
	if m != nil {
		return m.TimeframeType
	}
	return TimeframeType_TIMEFRAME_TYPE_UNSPECIFIED
}

func (m *UniqueSenderLimit) GetTimeframeDuration() int64 {
	if m != nil {
		return m.TimeframeDuration
	}
	return 0
}

// AddressLimit defines limits per address
type AddressLimit struct {
	// max_transfers is the maximum number of transfers allowed per address in the timeframe
	// If set to 0, transfer count limit is disabled
	MaxTransfers int64 `protobuf:"varint,1,opt,name=max_transfers,json=maxTransfers,proto3" json:"max_transfers,omitempty"`
	// max_amount is the maximum total amount allowed per address in the timeframe
	// Value is represented as an integer (e.g., "1000000" = 1,000,000 tokens)
	// If set to 0, amount limit is disabled
	MaxAmount cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=max_amount,json=maxAmount,proto3,customtype=cosmossdk.io/math.Int" json:"max_amount"`
	// timeframe_type defines the type of timeframe (block, hour, day)
	TimeframeType TimeframeType `protobuf:"varint,3,opt,name=timeframe_type,json=timeframeType,proto3,enum=ibcratelimit.TimeframeType" json:"timeframe_type,omitempty"`
	// timeframe_duration is the duration of the timeframe
	TimeframeDuration int64 `protobuf:"varint,4,opt,name=timeframe_duration,json=timeframeDuration,proto3" json:"timeframe_duration,omitempty"`
}

func (m *AddressLimit) Reset()         { *m = AddressLimit{} }
func (m *AddressLimit) String() string { return proto.CompactTextString(m) }
func (*AddressLimit) ProtoMessage()    {}
func (*AddressLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_e8c0c72281699922, []int{2}
}
func (m *AddressLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressLimit.Merge(m, src)
}
func (m *AddressLimit) XXX_Size() int {
	return m.Size()
}
func (m *AddressLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressLimit.DiscardUnknown(m)
}

var xxx_messageInfo_AddressLimit proto.InternalMessageInfo

func (m *AddressLimit) GetMaxTransfers() int64 {
	if m != nil {
		return m.MaxTransfers
	}
	return 0
}

func (m *AddressLimit) GetTimeframeType() TimeframeType {
	if m != nil {
		return m.TimeframeType
	}
	return TimeframeType_TIMEFRAME_TYPE_UNSPECIFIED
}

func (m *AddressLimit) GetTimeframeDuration() int64 {
	if m != nil {
		return m.TimeframeDuration
	}
	return 0
}

// RateLimitConfig defines a rate limit configuration for a specific channel and denom
type RateLimitConfig struct {
	// channel_id is the IBC channel ID this rate limit applies to
	// If empty, applies to all channels
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	// denom is the denomination this rate limit applies to
	// If empty, applies to all denominations
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	// DEPRECATED: Use supply_shift_limits instead
	// max_supply_shift is the maximum absolute amount of supply change allowed per window
	MaxSupplyShift cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=max_supply_shift,json=maxSupplyShift,proto3,customtype=cosmossdk.io/math.Int" json:"max_supply_shift"`
	// DEPRECATED: Use supply_shift_limits instead
	// window_duration is the duration of the rate limit window in blocks
	WindowDuration int64 `protobuf:"varint,4,opt,name=window_duration,json=windowDuration,proto3" json:"window_duration,omitempty"`
	// supply_shift_limits defines multiple timeframe limits for supply shift
	// All limits are checked, and the transfer is rejected if any limit would be exceeded
	SupplyShiftLimits []TimeframeLimit `protobuf:"bytes,5,rep,name=supply_shift_limits,json=supplyShiftLimits,proto3" json:"supply_shift_limits"`
	// unique_sender_limits defines limits on unique senders per channel
	// All limits are checked, and the transfer is rejected if any limit would be exceeded
	UniqueSenderLimits []UniqueSenderLimit `protobuf:"bytes,6,rep,name=unique_sender_limits,json=uniqueSenderLimits,proto3" json:"unique_sender_limits"`
	// address_limits defines per-address transfer limits
	// All limits are checked, and the transfer is rejected if any limit would be exceeded
	AddressLimits []AddressLimit `protobuf:"bytes,7,rep,name=address_limits,json=addressLimits,proto3" json:"address_limits"`
}

func (m *RateLimitConfig) Reset()         { *m = RateLimitConfig{} }
func (m *RateLimitConfig) String() string { return proto.CompactTextString(m) }
func (*RateLimitConfig) ProtoMessage()    {}
func (*RateLimitConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e8c0c72281699922, []int{3}
}
func (m *RateLimitConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitConfig.Merge(m, src)
}
func (m *RateLimitConfig) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitConfig proto.InternalMessageInfo

func (m *RateLimitConfig) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *RateLimitConfig) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *RateLimitConfig) GetWindowDuration() int64 {
	if m != nil {
		return m.WindowDuration
	}
	return 0
}

func (m *RateLimitConfig) GetSupplyShiftLimits() []TimeframeLimit {
	if m != nil {
		return m.SupplyShiftLimits
	}
	return nil
}

func (m *RateLimitConfig) GetUniqueSenderLimits() []UniqueSenderLimit {
	if m != nil {
		return m.UniqueSenderLimits
	}
	return nil
}

func (m *RateLimitConfig) GetAddressLimits() []AddressLimit {
	if m != nil {
		return m.AddressLimits
	}
	return nil
}

// Params defines the parameters for the module.
type Params struct {
	// rate_limits is an array of rate limit configurations
	// Each configuration can specify channel_id, denom, max_supply_shift, and window_duration
	// Configurations are checked in order, and the first matching config is used
	// If no config matches, the transfer is allowed (no rate limit)
	RateLimits []RateLimitConfig `protobuf:"bytes,1,rep,name=rate_limits,json=rateLimits,proto3" json:"rate_limits"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_e8c0c72281699922, []int{4}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetRateLimits() []RateLimitConfig {
	if m != nil {
		return m.RateLimits
	}
	return nil
}

func init() {
	proto.RegisterEnum("ibcratelimit.TimeframeType", TimeframeType_name, TimeframeType_value)
	proto.RegisterType((*TimeframeLimit)(nil), "ibcratelimit.TimeframeLimit")
	proto.RegisterType((*UniqueSenderLimit)(nil), "ibcratelimit.UniqueSenderLimit")
	proto.RegisterType((*AddressLimit)(nil), "ibcratelimit.AddressLimit")
	proto.RegisterType((*RateLimitConfig)(nil), "ibcratelimit.RateLimitConfig")
	proto.RegisterType((*Params)(nil), "ibcratelimit.Params")
}

func init() { proto.RegisterFile("ibcratelimit/params.proto", fileDescriptor_e8c0c72281699922) }

var fileDescriptor_e8c0c72281699922 = []byte{
	// 710 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x95, 0xc1, 0x4e, 0xdb, 0x4a,
	0x14, 0x86, 0xe3, 0x18, 0xb8, 0x62, 0x20, 0x21, 0x19, 0x72, 0xef, 0x4d, 0x03, 0x38, 0x51, 0xda,
	0x8a, 0x08, 0x95, 0x58, 0xa2, 0xbb, 0xb4, 0x9b, 0x84, 0x04, 0x1a, 0x15, 0x0a, 0x72, 0x82, 0x2a,
	0xba, 0xb1, 0x26, 0xb1, 0x93, 0x8c, 0xca, 0x78, 0x52, 0xcf, 0x58, 0x84, 0x3e, 0x41, 0xd5, 0x55,
	0x17, 0x7d, 0x80, 0x3e, 0x42, 0x1f, 0x83, 0x25, 0x9b, 0x4a, 0x55, 0xa5, 0xa2, 0x0a, 0x16, 0xf4,
	0x31, 0x2a, 0x8f, 0x63, 0x62, 0x1b, 0xa1, 0x4a, 0x6d, 0xa5, 0x6e, 0xa2, 0xf1, 0xf9, 0xe7, 0xfc,
	0x67, 0xbe, 0x73, 0xc6, 0x31, 0xb8, 0x83, 0x3b, 0x5d, 0x1b, 0x71, 0xf3, 0x08, 0x13, 0xcc, 0xd5,
	0x21, 0xb2, 0x11, 0x61, 0xe5, 0xa1, 0x4d, 0x39, 0x85, 0xf3, 0x41, 0x29, 0x97, 0x46, 0x04, 0x5b,
	0x54, 0x15, 0xbf, 0xde, 0x86, 0x5c, 0xa6, 0x4f, 0xfb, 0x54, 0x2c, 0x55, 0x77, 0xe5, 0x45, 0x8b,
	0x57, 0x12, 0x48, 0xb6, 0x31, 0x31, 0x7b, 0x36, 0x22, 0xe6, 0x8e, 0x9b, 0x0b, 0x1f, 0x03, 0x40,
	0xd0, 0x48, 0x47, 0x84, 0x3a, 0x16, 0xcf, 0x4a, 0x05, 0xa9, 0x34, 0x5b, 0x5b, 0x39, 0x3d, 0xcf,
	0xc7, 0xbe, 0x9c, 0xe7, 0xff, 0xed, 0x52, 0x46, 0x28, 0x63, 0xc6, 0xcb, 0x32, 0xa6, 0x2a, 0x41,
	0x7c, 0x50, 0x6e, 0x5a, 0x5c, 0x9b, 0x25, 0x68, 0x54, 0x15, 0xfb, 0x61, 0x0d, 0x24, 0xb9, 0xef,
	0xa7, 0xf3, 0x93, 0xa1, 0x99, 0x8d, 0x17, 0xa4, 0x52, 0x72, 0x63, 0xa9, 0x1c, 0x3c, 0x60, 0xf9,
	0xba, 0x66, 0xfb, 0x64, 0x68, 0x6a, 0x09, 0x1e, 0x7c, 0x84, 0xeb, 0x00, 0x4e, 0x3c, 0x0c, 0xc7,
	0x46, 0x1c, 0x53, 0x2b, 0x2b, 0x17, 0xa4, 0x92, 0xac, 0xa5, 0xaf, 0x95, 0xfa, 0x58, 0xa8, 0xdc,
	0xfb, 0xfe, 0x21, 0x2f, 0xbd, 0xbd, 0xfa, 0xb8, 0xb6, 0x14, 0x6a, 0x4f, 0x18, 0xab, 0xf8, 0x55,
	0x02, 0xe9, 0x03, 0x0b, 0xbf, 0x72, 0xcc, 0x96, 0x69, 0x19, 0xa6, 0xed, 0xc1, 0x3e, 0x00, 0xd0,
	0x85, 0x75, 0x84, 0xa0, 0x33, 0xa1, 0x30, 0x01, 0x2d, 0x6b, 0x29, 0x82, 0x46, 0xc1, 0x0c, 0xf6,
	0x37, 0xe0, 0x56, 0x7d, 0x38, 0x25, 0x04, 0x77, 0x83, 0xa4, 0xf8, 0x26, 0x0e, 0xe6, 0xab, 0x86,
	0x61, 0x9b, 0x8c, 0x79, 0x68, 0x77, 0x41, 0xc2, 0x45, 0xe3, 0x36, 0xb2, 0x58, 0x6f, 0x42, 0x35,
	0x4f, 0xd0, 0xa8, 0xed, 0xc7, 0x22, 0xc3, 0x8e, 0xff, 0xf6, 0xb0, 0xe5, 0x3f, 0xd4, 0x8f, 0xa9,
	0xdb, 0xfa, 0x51, 0xf4, 0xfb, 0x11, 0x7e, 0x17, 0x82, 0xe4, 0xc5, 0x4f, 0x32, 0x58, 0xd0, 0x10,
	0xf7, 0x06, 0xbf, 0x49, 0xad, 0x1e, 0xee, 0xc3, 0x15, 0x00, 0xba, 0x03, 0x64, 0x59, 0xe6, 0x91,
	0x8e, 0x0d, 0xef, 0x56, 0x6b, 0xb3, 0xe3, 0x48, 0xd3, 0x80, 0x19, 0x30, 0x6d, 0x98, 0x16, 0x25,
	0x5e, 0x0b, 0x34, 0xef, 0x01, 0x6e, 0x03, 0xf7, 0x0e, 0xe8, 0xcc, 0x19, 0x0e, 0x8f, 0x4e, 0x74,
	0x36, 0xc0, 0x3d, 0x2e, 0x08, 0x7f, 0xda, 0xa3, 0x24, 0x41, 0xa3, 0x96, 0xc8, 0x6a, 0xb9, 0x49,
	0x70, 0x15, 0x2c, 0x1c, 0x63, 0xcb, 0xa0, 0xc7, 0x51, 0xc2, 0xa4, 0x17, 0xf6, 0xf1, 0xa0, 0x06,
	0x16, 0x83, 0xd5, 0x74, 0x41, 0xc7, 0xb2, 0xd3, 0x05, 0xb9, 0x34, 0xb7, 0xb1, 0x7c, 0x4b, 0x5b,
	0x05, 0x67, 0x6d, 0xca, 0x3d, 0x92, 0x96, 0x66, 0x93, 0xb2, 0x22, 0xce, 0xe0, 0x73, 0x90, 0x09,
	0xdd, 0x6f, 0xdf, 0x74, 0x46, 0x98, 0xe6, 0xc3, 0xa6, 0x37, 0x2e, 0xd6, 0xd8, 0x17, 0x3a, 0x51,
	0x81, 0xc1, 0x6d, 0x90, 0x44, 0x5e, 0xdf, 0x7d, 0xcb, 0x7f, 0x84, 0x65, 0x2e, 0x6c, 0x19, 0x9c,
	0xcd, 0xd8, 0x2d, 0x81, 0x02, 0x31, 0x56, 0xb9, 0xef, 0x0f, 0x75, 0x39, 0x34, 0xd4, 0xc8, 0x0c,
	0x8b, 0xef, 0x25, 0x30, 0xb3, 0x2f, 0xfe, 0xf4, 0x60, 0x1d, 0xcc, 0xb9, 0xfb, 0xfc, 0xba, 0x92,
	0xa8, 0xbb, 0x12, 0xae, 0x1b, 0x49, 0x1f, 0x97, 0x06, 0xb6, 0x1f, 0x66, 0x95, 0xba, 0x5f, 0xf7,
	0x51, 0x1f, 0xf3, 0x81, 0xd3, 0x29, 0x77, 0x29, 0x51, 0x3b, 0x98, 0x77, 0x90, 0xd1, 0x37, 0xd9,
	0x64, 0xd5, 0x1d, 0x20, 0x6c, 0xa9, 0x23, 0x15, 0x77, 0xba, 0xeb, 0x6e, 0xfa, 0xba, 0x77, 0x3e,
	0xef, 0x2c, 0x6b, 0xaf, 0x41, 0x22, 0x74, 0xc3, 0xa1, 0x02, 0x72, 0xed, 0xe6, 0x6e, 0x63, 0x4b,
	0xab, 0xee, 0x36, 0xf4, 0xf6, 0xe1, 0x7e, 0x43, 0x3f, 0x78, 0xd6, 0xda, 0x6f, 0x6c, 0x36, 0xb7,
	0x9a, 0x8d, 0x7a, 0x2a, 0x06, 0xb3, 0x20, 0x13, 0xd1, 0x6b, 0x3b, 0x7b, 0x9b, 0x4f, 0x53, 0x12,
	0xfc, 0x1f, 0x2c, 0x46, 0x94, 0x27, 0x7b, 0x07, 0x5a, 0x2a, 0x0e, 0xff, 0x03, 0x30, 0x22, 0xd4,
	0xab, 0x87, 0x29, 0xb9, 0xd6, 0x3e, 0xbd, 0x50, 0xa4, 0xb3, 0x0b, 0x45, 0xfa, 0x76, 0xa1, 0x48,
	0xef, 0x2e, 0x95, 0xd8, 0xd9, 0xa5, 0x12, 0xfb, 0x7c, 0xa9, 0xc4, 0x5e, 0x54, 0x7e, 0x09, 0xc9,
	0x7d, 0x89, 0x59, 0x67, 0x46, 0x7c, 0x1c, 0x1e, 0xfe, 0x08, 0x00, 0x00, 0xff, 0xff, 0xc9, 0xa7,
	0x65, 0x9c, 0x70, 0x06, 0x00, 0x00,
}

func (this *TimeframeLimit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TimeframeLimit)
	if !ok {
		that2, ok := that.(TimeframeLimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MaxAmount.Equal(that1.MaxAmount) {
		return false
	}
	if this.TimeframeType != that1.TimeframeType {
		return false
	}
	if this.TimeframeDuration != that1.TimeframeDuration {
		return false
	}
	return true
}
func (this *UniqueSenderLimit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UniqueSenderLimit)
	if !ok {
		that2, ok := that.(UniqueSenderLimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxUniqueSenders != that1.MaxUniqueSenders {
		return false
	}
	if this.TimeframeType != that1.TimeframeType {
		return false
	}
	if this.TimeframeDuration != that1.TimeframeDuration {
		return false
	}
	return true
}
func (this *AddressLimit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddressLimit)
	if !ok {
		that2, ok := that.(AddressLimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxTransfers != that1.MaxTransfers {
		return false
	}
	if !this.MaxAmount.Equal(that1.MaxAmount) {
		return false
	}
	if this.TimeframeType != that1.TimeframeType {
		return false
	}
	if this.TimeframeDuration != that1.TimeframeDuration {
		return false
	}
	return true
}
func (this *RateLimitConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RateLimitConfig)
	if !ok {
		that2, ok := that.(RateLimitConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChannelId != that1.ChannelId {
		return false
	}
	if this.Denom != that1.Denom {
		return false
	}
	if !this.MaxSupplyShift.Equal(that1.MaxSupplyShift) {
		return false
	}
	if this.WindowDuration != that1.WindowDuration {
		return false
	}
	if len(this.SupplyShiftLimits) != len(that1.SupplyShiftLimits) {
		return false
	}
	for i := range this.SupplyShiftLimits {
		if !this.SupplyShiftLimits[i].Equal(&that1.SupplyShiftLimits[i]) {
			return false
		}
	}
	if len(this.UniqueSenderLimits) != len(that1.UniqueSenderLimits) {
		return false
	}
	for i := range this.UniqueSenderLimits {
		if !this.UniqueSenderLimits[i].Equal(&that1.UniqueSenderLimits[i]) {
			return false
		}
	}
	if len(this.AddressLimits) != len(that1.AddressLimits) {
		return false
	}
	for i := range this.AddressLimits {
		if !this.AddressLimits[i].Equal(&that1.AddressLimits[i]) {
			return false
		}
	}
	return true
}
func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RateLimits) != len(that1.RateLimits) {
		return false
	}
	for i := range this.RateLimits {
		if !this.RateLimits[i].Equal(&that1.RateLimits[i]) {
			return false
		}
	}
	return true
}
func (m *TimeframeLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeframeLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeframeLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeframeDuration != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TimeframeDuration))
		i--
		dAtA[i] = 0x18
	}
	if m.TimeframeType != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TimeframeType))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.MaxAmount.Size()
		i -= size
		if _, err := m.MaxAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UniqueSenderLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniqueSenderLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UniqueSenderLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeframeDuration != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TimeframeDuration))
		i--
		dAtA[i] = 0x18
	}
	if m.TimeframeType != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TimeframeType))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxUniqueSenders != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxUniqueSenders))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddressLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeframeDuration != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TimeframeDuration))
		i--
		dAtA[i] = 0x20
	}
	if m.TimeframeType != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.TimeframeType))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.MaxAmount.Size()
		i -= size
		if _, err := m.MaxAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.MaxTransfers != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxTransfers))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddressLimits) > 0 {
		for iNdEx := len(m.AddressLimits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddressLimits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintParams(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.UniqueSenderLimits) > 0 {
		for iNdEx := len(m.UniqueSenderLimits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UniqueSenderLimits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintParams(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SupplyShiftLimits) > 0 {
		for iNdEx := len(m.SupplyShiftLimits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SupplyShiftLimits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintParams(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.WindowDuration != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.WindowDuration))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.MaxSupplyShift.Size()
		i -= size
		if _, err := m.MaxSupplyShift.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintParams(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintParams(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintParams(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RateLimits) > 0 {
		for iNdEx := len(m.RateLimits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintParams(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int {
	offset -= sovParams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TimeframeLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MaxAmount.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.TimeframeType != 0 {
		n += 1 + sovParams(uint64(m.TimeframeType))
	}
	if m.TimeframeDuration != 0 {
		n += 1 + sovParams(uint64(m.TimeframeDuration))
	}
	return n
}

func (m *UniqueSenderLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxUniqueSenders != 0 {
		n += 1 + sovParams(uint64(m.MaxUniqueSenders))
	}
	if m.TimeframeType != 0 {
		n += 1 + sovParams(uint64(m.TimeframeType))
	}
	if m.TimeframeDuration != 0 {
		n += 1 + sovParams(uint64(m.TimeframeDuration))
	}
	return n
}

func (m *AddressLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxTransfers != 0 {
		n += 1 + sovParams(uint64(m.MaxTransfers))
	}
	l = m.MaxAmount.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.TimeframeType != 0 {
		n += 1 + sovParams(uint64(m.TimeframeType))
	}
	if m.TimeframeDuration != 0 {
		n += 1 + sovParams(uint64(m.TimeframeDuration))
	}
	return n
}

func (m *RateLimitConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = m.MaxSupplyShift.Size()
	n += 1 + l + sovParams(uint64(l))
	if m.WindowDuration != 0 {
		n += 1 + sovParams(uint64(m.WindowDuration))
	}
	if len(m.SupplyShiftLimits) > 0 {
		for _, e := range m.SupplyShiftLimits {
			l = e.Size()
			n += 1 + l + sovParams(uint64(l))
		}
	}
	if len(m.UniqueSenderLimits) > 0 {
		for _, e := range m.UniqueSenderLimits {
			l = e.Size()
			n += 1 + l + sovParams(uint64(l))
		}
	}
	if len(m.AddressLimits) > 0 {
		for _, e := range m.AddressLimits {
			l = e.Size()
			n += 1 + l + sovParams(uint64(l))
		}
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RateLimits) > 0 {
		for _, e := range m.RateLimits {
			l = e.Size()
			n += 1 + l + sovParams(uint64(l))
		}
	}
	return n
}

func sovParams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozParams(x uint64) (n int) {
	return sovParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TimeframeLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeframeLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeframeLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeframeType", wireType)
			}
			m.TimeframeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeframeType |= TimeframeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeframeDuration", wireType)
			}
			m.TimeframeDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeframeDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UniqueSenderLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UniqueSenderLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UniqueSenderLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUniqueSenders", wireType)
			}
			m.MaxUniqueSenders = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUniqueSenders |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeframeType", wireType)
			}
			m.TimeframeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeframeType |= TimeframeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeframeDuration", wireType)
			}
			m.TimeframeDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeframeDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTransfers", wireType)
			}
			m.MaxTransfers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTransfers |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeframeType", wireType)
			}
			m.TimeframeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeframeType |= TimeframeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeframeDuration", wireType)
			}
			m.TimeframeDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeframeDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimitConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimitConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSupplyShift", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSupplyShift.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowDuration", wireType)
			}
			m.WindowDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyShiftLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplyShiftLimits = append(m.SupplyShiftLimits, TimeframeLimit{})
			if err := m.SupplyShiftLimits[len(m.SupplyShiftLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueSenderLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueSenderLimits = append(m.UniqueSenderLimits, UniqueSenderLimit{})
			if err := m.UniqueSenderLimits[len(m.UniqueSenderLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressLimits = append(m.AddressLimits, AddressLimit{})
			if err := m.AddressLimits[len(m.AddressLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimits = append(m.RateLimits, RateLimitConfig{})
			if err := m.RateLimits[len(m.RateLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthParams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupParams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthParams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
