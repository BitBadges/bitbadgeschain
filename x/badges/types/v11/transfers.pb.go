// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/v11/transfers.proto

package v11

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UserBalanceStore is the store for the user balances for a collection.
//
// It consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,
// as well as the permissions for updating the approved incoming/outgoing transfers.
//
// Upon initialization, all fields (minus the balances) are set to the defaults specified by the collection.
//
// The outgoing transfers can be used to allow / disallow transfers which are sent from this user.
// If a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)
// and autoApproveSelfInitiatedOutgoingTransfers is set to true.
//
// The incoming transfers can be used to allow / disallow transfers which are sent to this user.
// If a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)
// and autoApproveSelfInitiatedIncomingTransfers is set to true.
//
// Note that the user approved transfers are only checked if the collection approved transfers do not specify to override
// the user approved transfers.
//
// The permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.
type UserBalanceStore struct {
	// The list of balances associated with this user.
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
	// The list of approved outgoing transfers for this user.
	OutgoingApprovals []*UserOutgoingApproval `protobuf:"bytes,2,rep,name=outgoingApprovals,proto3" json:"outgoingApprovals,omitempty"`
	// The list of approved incoming transfers for this user.
	IncomingApprovals []*UserIncomingApproval `protobuf:"bytes,3,rep,name=incomingApprovals,proto3" json:"incomingApprovals,omitempty"`
	// Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).
	AutoApproveSelfInitiatedOutgoingTransfers bool `protobuf:"varint,4,opt,name=autoApproveSelfInitiatedOutgoingTransfers,proto3" json:"autoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).
	AutoApproveSelfInitiatedIncomingTransfers bool `protobuf:"varint,5,opt,name=autoApproveSelfInitiatedIncomingTransfers,proto3" json:"autoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// Whether to auto-approve all incoming transfers by default.
	// This is just shorthand for adding an accept everything incoming approval
	// with no restrictions.
	AutoApproveAllIncomingTransfers bool `protobuf:"varint,6,opt,name=autoApproveAllIncomingTransfers,proto3" json:"autoApproveAllIncomingTransfers,omitempty"`
	// The permissions for this user's actions and transfers.
	UserPermissions *UserPermissions `protobuf:"bytes,7,opt,name=userPermissions,proto3" json:"userPermissions,omitempty"`
}

func (m *UserBalanceStore) Reset()         { *m = UserBalanceStore{} }
func (m *UserBalanceStore) String() string { return proto.CompactTextString(m) }
func (*UserBalanceStore) ProtoMessage()    {}
func (*UserBalanceStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{0}
}
func (m *UserBalanceStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserBalanceStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserBalanceStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserBalanceStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserBalanceStore.Merge(m, src)
}
func (m *UserBalanceStore) XXX_Size() int {
	return m.Size()
}
func (m *UserBalanceStore) XXX_DiscardUnknown() {
	xxx_messageInfo_UserBalanceStore.DiscardUnknown(m)
}

var xxx_messageInfo_UserBalanceStore proto.InternalMessageInfo

func (m *UserBalanceStore) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *UserBalanceStore) GetOutgoingApprovals() []*UserOutgoingApproval {
	if m != nil {
		return m.OutgoingApprovals
	}
	return nil
}

func (m *UserBalanceStore) GetIncomingApprovals() []*UserIncomingApproval {
	if m != nil {
		return m.IncomingApprovals
	}
	return nil
}

func (m *UserBalanceStore) GetAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (m *UserBalanceStore) GetAutoApproveSelfInitiatedIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (m *UserBalanceStore) GetAutoApproveAllIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveAllIncomingTransfers
	}
	return false
}

func (m *UserBalanceStore) GetUserPermissions() *UserPermissions {
	if m != nil {
		return m.UserPermissions
	}
	return nil
}

// Challenges define a rule for the approval in the form of a Merkle challenge.
//
// A Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,
// then the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.
//
// IMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.
//
// IMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.
// If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
// We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
type MerkleChallenge struct {
	// The root hash of the Merkle tree to which the Merkle path must lead for verification.
	Root string `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty"`
	// The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.
	ExpectedProofLength Uint `protobuf:"bytes,2,opt,name=expectedProofLength,proto3,customtype=Uint" json:"expectedProofLength"`
	// If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.
	UseCreatorAddressAsLeaf bool `protobuf:"varint,3,opt,name=useCreatorAddressAsLeaf,proto3" json:"useCreatorAddressAsLeaf,omitempty"`
	// The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.
	MaxUsesPerLeaf Uint `protobuf:"bytes,4,opt,name=maxUsesPerLeaf,proto3,customtype=Uint" json:"maxUsesPerLeaf"`
	// The URI associated with this Merkle challenge, optionally providing metadata about the challenge.
	Uri string `protobuf:"bytes,5,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this Merkle challenge.
	CustomData string `protobuf:"bytes,6,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this Merkle challenge for tracking the number of uses per leaf.
	ChallengeTrackerId string `protobuf:"bytes,7,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	// Leaf must be signed by. Used to protect against man in the middle attacks.`
	// Scheme we use is sign(leaf + "-" +
	LeafSigner string `protobuf:"bytes,8,opt,name=leafSigner,proto3" json:"leafSigner,omitempty"`
}

func (m *MerkleChallenge) Reset()         { *m = MerkleChallenge{} }
func (m *MerkleChallenge) String() string { return proto.CompactTextString(m) }
func (*MerkleChallenge) ProtoMessage()    {}
func (*MerkleChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{1}
}
func (m *MerkleChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerkleChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerkleChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerkleChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerkleChallenge.Merge(m, src)
}
func (m *MerkleChallenge) XXX_Size() int {
	return m.Size()
}
func (m *MerkleChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_MerkleChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_MerkleChallenge proto.InternalMessageInfo

func (m *MerkleChallenge) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

func (m *MerkleChallenge) GetUseCreatorAddressAsLeaf() bool {
	if m != nil {
		return m.UseCreatorAddressAsLeaf
	}
	return false
}

func (m *MerkleChallenge) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *MerkleChallenge) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *MerkleChallenge) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *MerkleChallenge) GetLeafSigner() string {
	if m != nil {
		return m.LeafSigner
	}
	return ""
}

// UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.
type UserOutgoingApproval struct {
	// The list ID for the recipient of the transfer.
	ToListId string `protobuf:"bytes,1,opt,name=toListId,proto3" json:"toListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,2,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of badge IDs for approval.
	BadgeIds []*UintRange `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,8,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,9,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,10,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *OutgoingApprovalCriteria `protobuf:"bytes,11,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
	// Version of the approval. Maintained internally.
	Version Uint `protobuf:"bytes,12,opt,name=version,proto3,customtype=Uint" json:"version"`
}

func (m *UserOutgoingApproval) Reset()         { *m = UserOutgoingApproval{} }
func (m *UserOutgoingApproval) String() string { return proto.CompactTextString(m) }
func (*UserOutgoingApproval) ProtoMessage()    {}
func (*UserOutgoingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{2}
}
func (m *UserOutgoingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserOutgoingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserOutgoingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserOutgoingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserOutgoingApproval.Merge(m, src)
}
func (m *UserOutgoingApproval) XXX_Size() int {
	return m.Size()
}
func (m *UserOutgoingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_UserOutgoingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_UserOutgoingApproval proto.InternalMessageInfo

func (m *UserOutgoingApproval) GetToListId() string {
	if m != nil {
		return m.ToListId
	}
	return ""
}

func (m *UserOutgoingApproval) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *UserOutgoingApproval) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserOutgoingApproval) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserOutgoingApproval) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserOutgoingApproval) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *UserOutgoingApproval) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *UserOutgoingApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *UserOutgoingApproval) GetApprovalCriteria() *OutgoingApprovalCriteria {
	if m != nil {
		return m.ApprovalCriteria
	}
	return nil
}

// UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.
type UserIncomingApproval struct {
	// The list ID for the sender of the transfer.
	FromListId string `protobuf:"bytes,1,opt,name=fromListId,proto3" json:"fromListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,2,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of badge IDs for approval.
	BadgeIds []*UintRange `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,8,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,9,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,10,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *IncomingApprovalCriteria `protobuf:"bytes,11,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
	// Version of the approval. Maintained internally.
	Version Uint `protobuf:"bytes,12,opt,name=version,proto3,customtype=Uint" json:"version"`
}

func (m *UserIncomingApproval) Reset()         { *m = UserIncomingApproval{} }
func (m *UserIncomingApproval) String() string { return proto.CompactTextString(m) }
func (*UserIncomingApproval) ProtoMessage()    {}
func (*UserIncomingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{3}
}
func (m *UserIncomingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserIncomingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserIncomingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserIncomingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserIncomingApproval.Merge(m, src)
}
func (m *UserIncomingApproval) XXX_Size() int {
	return m.Size()
}
func (m *UserIncomingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_UserIncomingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_UserIncomingApproval proto.InternalMessageInfo

func (m *UserIncomingApproval) GetFromListId() string {
	if m != nil {
		return m.FromListId
	}
	return ""
}

func (m *UserIncomingApproval) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *UserIncomingApproval) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserIncomingApproval) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserIncomingApproval) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserIncomingApproval) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *UserIncomingApproval) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *UserIncomingApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *UserIncomingApproval) GetApprovalCriteria() *IncomingApprovalCriteria {
	if m != nil {
		return m.ApprovalCriteria
	}
	return nil
}

// ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.
type ManualBalances struct {
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
}

func (m *ManualBalances) Reset()         { *m = ManualBalances{} }
func (m *ManualBalances) String() string { return proto.CompactTextString(m) }
func (*ManualBalances) ProtoMessage()    {}
func (*ManualBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{4}
}
func (m *ManualBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ManualBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ManualBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ManualBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManualBalances.Merge(m, src)
}
func (m *ManualBalances) XXX_Size() int {
	return m.Size()
}
func (m *ManualBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_ManualBalances.DiscardUnknown(m)
}

var xxx_messageInfo_ManualBalances proto.InternalMessageInfo

func (m *ManualBalances) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

// RecurringOwnershipTimes represents a list of recurring ownership times.
type RecurringOwnershipTimes struct {
	// The original start time of the first interval.
	StartTime Uint `protobuf:"bytes,1,opt,name=startTime,proto3,customtype=Uint" json:"startTime"`
	// The interval length in unix milliseconds.
	IntervalLength Uint `protobuf:"bytes,2,opt,name=intervalLength,proto3,customtype=Uint" json:"intervalLength"`
	// Grace period length where you can charge the next interval (nextStartTime - chargePeriodLength) until (nextStartTime) = charge period
	ChargePeriodLength Uint `protobuf:"bytes,3,opt,name=chargePeriodLength,proto3,customtype=Uint" json:"chargePeriodLength"`
}

func (m *RecurringOwnershipTimes) Reset()         { *m = RecurringOwnershipTimes{} }
func (m *RecurringOwnershipTimes) String() string { return proto.CompactTextString(m) }
func (*RecurringOwnershipTimes) ProtoMessage()    {}
func (*RecurringOwnershipTimes) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{5}
}
func (m *RecurringOwnershipTimes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecurringOwnershipTimes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecurringOwnershipTimes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecurringOwnershipTimes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecurringOwnershipTimes.Merge(m, src)
}
func (m *RecurringOwnershipTimes) XXX_Size() int {
	return m.Size()
}
func (m *RecurringOwnershipTimes) XXX_DiscardUnknown() {
	xxx_messageInfo_RecurringOwnershipTimes.DiscardUnknown(m)
}

var xxx_messageInfo_RecurringOwnershipTimes proto.InternalMessageInfo

// IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.
type IncrementedBalances struct {
	StartBalances []*Balance `protobuf:"bytes,1,rep,name=startBalances,proto3" json:"startBalances,omitempty"`
	// The amount by which to increment badge IDs.
	IncrementBadgeIdsBy Uint `protobuf:"bytes,2,opt,name=incrementBadgeIdsBy,proto3,customtype=Uint" json:"incrementBadgeIdsBy"`
	// The amount by which to increment ownership times. Incompatible with approveStartingFromNowBy.
	IncrementOwnershipTimesBy Uint `protobuf:"bytes,3,opt,name=incrementOwnershipTimesBy,proto3,customtype=Uint" json:"incrementOwnershipTimesBy"`
	// The amount of unix milliseconds to approve starting from now. Incompatible with incrementOwnershipTimesBy.
	DurationFromTimestamp Uint `protobuf:"bytes,4,opt,name=durationFromTimestamp,proto3,customtype=Uint" json:"durationFromTimestamp"`
	// Whether to allow overriding the timestamp for the balances (only applicable with durationFromTimestamp set).
	AllowOverrideTimestamp bool `protobuf:"varint,5,opt,name=allowOverrideTimestamp,proto3" json:"allowOverrideTimestamp,omitempty"`
	// Recurring ownership times.
	RecurringOwnershipTimes *RecurringOwnershipTimes `protobuf:"bytes,6,opt,name=recurringOwnershipTimes,proto3" json:"recurringOwnershipTimes,omitempty"`
	// Allow override of any valid badge
	AllowOverrideWithAnyValidBadge bool `protobuf:"varint,7,opt,name=allowOverrideWithAnyValidBadge,proto3" json:"allowOverrideWithAnyValidBadge,omitempty"`
}

func (m *IncrementedBalances) Reset()         { *m = IncrementedBalances{} }
func (m *IncrementedBalances) String() string { return proto.CompactTextString(m) }
func (*IncrementedBalances) ProtoMessage()    {}
func (*IncrementedBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{6}
}
func (m *IncrementedBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrementedBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncrementedBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncrementedBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrementedBalances.Merge(m, src)
}
func (m *IncrementedBalances) XXX_Size() int {
	return m.Size()
}
func (m *IncrementedBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrementedBalances.DiscardUnknown(m)
}

var xxx_messageInfo_IncrementedBalances proto.InternalMessageInfo

func (m *IncrementedBalances) GetStartBalances() []*Balance {
	if m != nil {
		return m.StartBalances
	}
	return nil
}

func (m *IncrementedBalances) GetAllowOverrideTimestamp() bool {
	if m != nil {
		return m.AllowOverrideTimestamp
	}
	return false
}

func (m *IncrementedBalances) GetRecurringOwnershipTimes() *RecurringOwnershipTimes {
	if m != nil {
		return m.RecurringOwnershipTimes
	}
	return nil
}

func (m *IncrementedBalances) GetAllowOverrideWithAnyValidBadge() bool {
	if m != nil {
		return m.AllowOverrideWithAnyValidBadge
	}
	return false
}

// PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.
type PredeterminedOrderCalculationMethod struct {
	// Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.
	UseOverallNumTransfers bool `protobuf:"varint,1,opt,name=useOverallNumTransfers,proto3" json:"useOverallNumTransfers,omitempty"`
	// Use the number of transfers per "to" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.
	UsePerToAddressNumTransfers bool `protobuf:"varint,2,opt,name=usePerToAddressNumTransfers,proto3" json:"usePerToAddressNumTransfers,omitempty"`
	// Use the number of transfers per "from" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.
	UsePerFromAddressNumTransfers bool `protobuf:"varint,3,opt,name=usePerFromAddressNumTransfers,proto3" json:"usePerFromAddressNumTransfers,omitempty"`
	// Use the number of transfers per "initiated by" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.
	UsePerInitiatedByAddressNumTransfers bool `protobuf:"varint,4,opt,name=usePerInitiatedByAddressNumTransfers,proto3" json:"usePerInitiatedByAddressNumTransfers,omitempty"`
	// Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.
	UseMerkleChallengeLeafIndex bool `protobuf:"varint,5,opt,name=useMerkleChallengeLeafIndex,proto3" json:"useMerkleChallengeLeafIndex,omitempty"`
	// If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.
	ChallengeTrackerId string `protobuf:"bytes,6,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
}

func (m *PredeterminedOrderCalculationMethod) Reset()         { *m = PredeterminedOrderCalculationMethod{} }
func (m *PredeterminedOrderCalculationMethod) String() string { return proto.CompactTextString(m) }
func (*PredeterminedOrderCalculationMethod) ProtoMessage()    {}
func (*PredeterminedOrderCalculationMethod) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{7}
}
func (m *PredeterminedOrderCalculationMethod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredeterminedOrderCalculationMethod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredeterminedOrderCalculationMethod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredeterminedOrderCalculationMethod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredeterminedOrderCalculationMethod.Merge(m, src)
}
func (m *PredeterminedOrderCalculationMethod) XXX_Size() int {
	return m.Size()
}
func (m *PredeterminedOrderCalculationMethod) XXX_DiscardUnknown() {
	xxx_messageInfo_PredeterminedOrderCalculationMethod.DiscardUnknown(m)
}

var xxx_messageInfo_PredeterminedOrderCalculationMethod proto.InternalMessageInfo

func (m *PredeterminedOrderCalculationMethod) GetUseOverallNumTransfers() bool {
	if m != nil {
		return m.UseOverallNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerToAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerToAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerFromAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerFromAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerInitiatedByAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerInitiatedByAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUseMerkleChallengeLeafIndex() bool {
	if m != nil {
		return m.UseMerkleChallengeLeafIndex
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

// PredeterminedBalances represents balances with predetermined order calculation.
type PredeterminedBalances struct {
	// Manual balances that can be entered. If this is nil, then we use the incremented balances.
	ManualBalances []*ManualBalances `protobuf:"bytes,1,rep,name=manualBalances,proto3" json:"manualBalances,omitempty"`
	// Balances that have a starting amount and increment. If this is nil, then we use the manual balances.
	IncrementedBalances *IncrementedBalances `protobuf:"bytes,2,opt,name=incrementedBalances,proto3" json:"incrementedBalances,omitempty"`
	// The method to calculate the order of predetermined balances.
	OrderCalculationMethod *PredeterminedOrderCalculationMethod `protobuf:"bytes,3,opt,name=orderCalculationMethod,proto3" json:"orderCalculationMethod,omitempty"`
}

func (m *PredeterminedBalances) Reset()         { *m = PredeterminedBalances{} }
func (m *PredeterminedBalances) String() string { return proto.CompactTextString(m) }
func (*PredeterminedBalances) ProtoMessage()    {}
func (*PredeterminedBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{8}
}
func (m *PredeterminedBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredeterminedBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredeterminedBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredeterminedBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredeterminedBalances.Merge(m, src)
}
func (m *PredeterminedBalances) XXX_Size() int {
	return m.Size()
}
func (m *PredeterminedBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_PredeterminedBalances.DiscardUnknown(m)
}

var xxx_messageInfo_PredeterminedBalances proto.InternalMessageInfo

func (m *PredeterminedBalances) GetManualBalances() []*ManualBalances {
	if m != nil {
		return m.ManualBalances
	}
	return nil
}

func (m *PredeterminedBalances) GetIncrementedBalances() *IncrementedBalances {
	if m != nil {
		return m.IncrementedBalances
	}
	return nil
}

func (m *PredeterminedBalances) GetOrderCalculationMethod() *PredeterminedOrderCalculationMethod {
	if m != nil {
		return m.OrderCalculationMethod
	}
	return nil
}

// AutoDeletionOptions defines the options for auto-deletion of approvals.
type AutoDeletionOptions struct {
	// After one use?
	AfterOneUse bool `protobuf:"varint,1,opt,name=afterOneUse,proto3" json:"afterOneUse,omitempty"`
	// After overall max number of uses threshold is met?
	AfterOverallMaxNumTransfers bool `protobuf:"varint,2,opt,name=afterOverallMaxNumTransfers,proto3" json:"afterOverallMaxNumTransfers,omitempty"`
	// Allow counterparty to purge this approval if they are the only initiator
	AllowCounterpartyPurge bool `protobuf:"varint,3,opt,name=allowCounterpartyPurge,proto3" json:"allowCounterpartyPurge,omitempty"`
	// Allow others to call PurgeApprovals on behalf of this approval owner
	AllowPurgeIfExpired bool `protobuf:"varint,4,opt,name=allowPurgeIfExpired,proto3" json:"allowPurgeIfExpired,omitempty"`
}

func (m *AutoDeletionOptions) Reset()         { *m = AutoDeletionOptions{} }
func (m *AutoDeletionOptions) String() string { return proto.CompactTextString(m) }
func (*AutoDeletionOptions) ProtoMessage()    {}
func (*AutoDeletionOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{9}
}
func (m *AutoDeletionOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutoDeletionOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutoDeletionOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutoDeletionOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutoDeletionOptions.Merge(m, src)
}
func (m *AutoDeletionOptions) XXX_Size() int {
	return m.Size()
}
func (m *AutoDeletionOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_AutoDeletionOptions.DiscardUnknown(m)
}

var xxx_messageInfo_AutoDeletionOptions proto.InternalMessageInfo

func (m *AutoDeletionOptions) GetAfterOneUse() bool {
	if m != nil {
		return m.AfterOneUse
	}
	return false
}

func (m *AutoDeletionOptions) GetAfterOverallMaxNumTransfers() bool {
	if m != nil {
		return m.AfterOverallMaxNumTransfers
	}
	return false
}

func (m *AutoDeletionOptions) GetAllowCounterpartyPurge() bool {
	if m != nil {
		return m.AllowCounterpartyPurge
	}
	return false
}

func (m *AutoDeletionOptions) GetAllowPurgeIfExpired() bool {
	if m != nil {
		return m.AllowPurgeIfExpired
	}
	return false
}

// ApprovalAmounts defines approval amounts per unique "from," "to," and/or "initiated by" address.
// If any of these are nil or "0", we assume unlimited approvals.
// If they are set to a value, then the running tally of the amounts transferred for the specified badge IDs and ownership times
// must not exceed the corresponding value.
type ApprovalAmounts struct {
	// Overall approval amount.
	OverallApprovalAmount Uint `protobuf:"bytes,1,opt,name=overallApprovalAmount,proto3,customtype=Uint" json:"overallApprovalAmount"`
	// Approval amount per "to" address.
	PerToAddressApprovalAmount Uint `protobuf:"bytes,2,opt,name=perToAddressApprovalAmount,proto3,customtype=Uint" json:"perToAddressApprovalAmount"`
	// Approval amount per "from" address.
	PerFromAddressApprovalAmount Uint `protobuf:"bytes,3,opt,name=perFromAddressApprovalAmount,proto3,customtype=Uint" json:"perFromAddressApprovalAmount"`
	// Approval amount per "initiated by" address.
	PerInitiatedByAddressApprovalAmount Uint `protobuf:"bytes,4,opt,name=perInitiatedByAddressApprovalAmount,proto3,customtype=Uint" json:"perInitiatedByAddressApprovalAmount"`
	// The ID of the amount tracker associated with this approval.
	// We use this ID to track the number of transfers and amounts transferred.
	AmountTrackerId string `protobuf:"bytes,6,opt,name=amountTrackerId,proto3" json:"amountTrackerId,omitempty"`
	// Time intervals to reset the trackers at.
	ResetTimeIntervals *ResetTimeIntervals `protobuf:"bytes,7,opt,name=resetTimeIntervals,proto3" json:"resetTimeIntervals,omitempty"`
}

func (m *ApprovalAmounts) Reset()         { *m = ApprovalAmounts{} }
func (m *ApprovalAmounts) String() string { return proto.CompactTextString(m) }
func (*ApprovalAmounts) ProtoMessage()    {}
func (*ApprovalAmounts) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{10}
}
func (m *ApprovalAmounts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalAmounts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalAmounts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalAmounts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalAmounts.Merge(m, src)
}
func (m *ApprovalAmounts) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalAmounts) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalAmounts.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalAmounts proto.InternalMessageInfo

func (m *ApprovalAmounts) GetAmountTrackerId() string {
	if m != nil {
		return m.AmountTrackerId
	}
	return ""
}

func (m *ApprovalAmounts) GetResetTimeIntervals() *ResetTimeIntervals {
	if m != nil {
		return m.ResetTimeIntervals
	}
	return nil
}

// Time intervals to reset the trackers at.
type ResetTimeIntervals struct {
	// Original start time of the first interval.
	StartTime Uint `protobuf:"bytes,1,opt,name=startTime,proto3,customtype=Uint" json:"startTime"`
	// Interval length in unix milliseconds.
	IntervalLength Uint `protobuf:"bytes,2,opt,name=intervalLength,proto3,customtype=Uint" json:"intervalLength"`
}

func (m *ResetTimeIntervals) Reset()         { *m = ResetTimeIntervals{} }
func (m *ResetTimeIntervals) String() string { return proto.CompactTextString(m) }
func (*ResetTimeIntervals) ProtoMessage()    {}
func (*ResetTimeIntervals) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{11}
}
func (m *ResetTimeIntervals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetTimeIntervals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetTimeIntervals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetTimeIntervals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetTimeIntervals.Merge(m, src)
}
func (m *ResetTimeIntervals) XXX_Size() int {
	return m.Size()
}
func (m *ResetTimeIntervals) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetTimeIntervals.DiscardUnknown(m)
}

var xxx_messageInfo_ResetTimeIntervals proto.InternalMessageInfo

// MaxNumTransfers defines the maximum number of transfers per unique "from," "to," and/or "initiated by" address.
// If any of these are nil or "0", we assume unlimited approvals.
// If they are set to a value, then the running tally of the number of transfers for the specified badge IDs and ownership times
// must not exceed the corresponding value.
type MaxNumTransfers struct {
	// Overall maximum number of transfers.
	OverallMaxNumTransfers Uint `protobuf:"bytes,1,opt,name=overallMaxNumTransfers,proto3,customtype=Uint" json:"overallMaxNumTransfers"`
	// Maximum number of transfers per "to" address.
	PerToAddressMaxNumTransfers Uint `protobuf:"bytes,2,opt,name=perToAddressMaxNumTransfers,proto3,customtype=Uint" json:"perToAddressMaxNumTransfers"`
	// Maximum number of transfers per "from" address.
	PerFromAddressMaxNumTransfers Uint `protobuf:"bytes,3,opt,name=perFromAddressMaxNumTransfers,proto3,customtype=Uint" json:"perFromAddressMaxNumTransfers"`
	// Maximum number of transfers per "initiated by" address.
	PerInitiatedByAddressMaxNumTransfers Uint `protobuf:"bytes,4,opt,name=perInitiatedByAddressMaxNumTransfers,proto3,customtype=Uint" json:"perInitiatedByAddressMaxNumTransfers"`
	// The ID of the amount tracker associated with this approval.
	// We use this ID to track the number of transfers and amounts transferred.
	AmountTrackerId string `protobuf:"bytes,6,opt,name=amountTrackerId,proto3" json:"amountTrackerId,omitempty"`
	// Time intervals to reset the trackers at.
	ResetTimeIntervals *ResetTimeIntervals `protobuf:"bytes,7,opt,name=resetTimeIntervals,proto3" json:"resetTimeIntervals,omitempty"`
}

func (m *MaxNumTransfers) Reset()         { *m = MaxNumTransfers{} }
func (m *MaxNumTransfers) String() string { return proto.CompactTextString(m) }
func (*MaxNumTransfers) ProtoMessage()    {}
func (*MaxNumTransfers) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{12}
}
func (m *MaxNumTransfers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxNumTransfers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxNumTransfers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxNumTransfers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxNumTransfers.Merge(m, src)
}
func (m *MaxNumTransfers) XXX_Size() int {
	return m.Size()
}
func (m *MaxNumTransfers) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxNumTransfers.DiscardUnknown(m)
}

var xxx_messageInfo_MaxNumTransfers proto.InternalMessageInfo

func (m *MaxNumTransfers) GetAmountTrackerId() string {
	if m != nil {
		return m.AmountTrackerId
	}
	return ""
}

func (m *MaxNumTransfers) GetResetTimeIntervals() *ResetTimeIntervals {
	if m != nil {
		return m.ResetTimeIntervals
	}
	return nil
}

// ApprovalTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.
type ApprovalTracker struct {
	// The number of transfers that have been processed.
	NumTransfers Uint `protobuf:"bytes,1,opt,name=numTransfers,proto3,customtype=Uint" json:"numTransfers"`
	// Cumulative balances associated with the transfers that have been processed.
	Amounts []*Balance `protobuf:"bytes,2,rep,name=amounts,proto3" json:"amounts,omitempty"`
	// Last updated at time.
	LastUpdatedAt Uint `protobuf:"bytes,3,opt,name=lastUpdatedAt,proto3,customtype=Uint" json:"lastUpdatedAt"`
}

func (m *ApprovalTracker) Reset()         { *m = ApprovalTracker{} }
func (m *ApprovalTracker) String() string { return proto.CompactTextString(m) }
func (*ApprovalTracker) ProtoMessage()    {}
func (*ApprovalTracker) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{13}
}
func (m *ApprovalTracker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalTracker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalTracker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalTracker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalTracker.Merge(m, src)
}
func (m *ApprovalTracker) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalTracker) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalTracker.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalTracker proto.InternalMessageInfo

func (m *ApprovalTracker) GetAmounts() []*Balance {
	if m != nil {
		return m.Amounts
	}
	return nil
}

type CoinTransfer struct {
	// The address of the recipient of the transfer.
	To string `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	// The sdk.Coins to be transferred.
	Coins []*types.Coin `protobuf:"bytes,2,rep,name=coins,proto3" json:"coins,omitempty"`
	// By default, the from address is the initiator of the transaction.
	// If this is set to true, we will override the from address with the approver address.
	// Note: This is not applicable for collection approvals (since approverAddress == ”).
	OverrideFromWithApproverAddress bool `protobuf:"varint,3,opt,name=overrideFromWithApproverAddress,proto3" json:"overrideFromWithApproverAddress,omitempty"`
	// By default, the to address is what is specified in the coin transfer.
	// If this is set to true, we will override the to address with the initiator of the transaction.
	OverrideToWithInitiator bool `protobuf:"varint,4,opt,name=overrideToWithInitiator,proto3" json:"overrideToWithInitiator,omitempty"`
}

func (m *CoinTransfer) Reset()         { *m = CoinTransfer{} }
func (m *CoinTransfer) String() string { return proto.CompactTextString(m) }
func (*CoinTransfer) ProtoMessage()    {}
func (*CoinTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{14}
}
func (m *CoinTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinTransfer.Merge(m, src)
}
func (m *CoinTransfer) XXX_Size() int {
	return m.Size()
}
func (m *CoinTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_CoinTransfer proto.InternalMessageInfo

func (m *CoinTransfer) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *CoinTransfer) GetCoins() []*types.Coin {
	if m != nil {
		return m.Coins
	}
	return nil
}

func (m *CoinTransfer) GetOverrideFromWithApproverAddress() bool {
	if m != nil {
		return m.OverrideFromWithApproverAddress
	}
	return false
}

func (m *CoinTransfer) GetOverrideToWithInitiator() bool {
	if m != nil {
		return m.OverrideToWithInitiator
	}
	return false
}

// MustOwnBadges represents a condition where a user must own specific badges
// to be approved to transfer.
//
// - collectionId: The ID of the badge collection for the badges that must be owned
// - amountRange: The range of badge amounts the user must own (min to max)
// - ownershipTimes: The time ranges during which the user must own the badges.
// - badgeIds: The badge IDs the user must own.
// - overrideWithCurrentTime: If true, auto override ownershipTimes with the current time.
// - mustSatisfyForAllAssets: If true, the user must own all specified badges; otherwise, owning any one for >= 1 millisecond is sufficient.
type MustOwnBadges struct {
	// The ID of the badge collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The range of badge amounts the user must own (min to max).
	AmountRange *UintRange `protobuf:"bytes,2,opt,name=amountRange,proto3" json:"amountRange,omitempty"`
	// The time ranges during which the user must own the badges.
	OwnershipTimes []*UintRange `protobuf:"bytes,3,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The badge IDs the user must own.
	BadgeIds []*UintRange `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// If true, override ownershipTimes with the current time.
	OverrideWithCurrentTime bool `protobuf:"varint,5,opt,name=overrideWithCurrentTime,proto3" json:"overrideWithCurrentTime,omitempty"`
	// If true, the user must meet ownership requirements for all specified badges; else, must meet requirements for any single badge.
	MustSatisfyForAllAssets bool `protobuf:"varint,6,opt,name=mustSatisfyForAllAssets,proto3" json:"mustSatisfyForAllAssets,omitempty"`
}

func (m *MustOwnBadges) Reset()         { *m = MustOwnBadges{} }
func (m *MustOwnBadges) String() string { return proto.CompactTextString(m) }
func (*MustOwnBadges) ProtoMessage()    {}
func (*MustOwnBadges) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{15}
}
func (m *MustOwnBadges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MustOwnBadges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MustOwnBadges.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MustOwnBadges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MustOwnBadges.Merge(m, src)
}
func (m *MustOwnBadges) XXX_Size() int {
	return m.Size()
}
func (m *MustOwnBadges) XXX_DiscardUnknown() {
	xxx_messageInfo_MustOwnBadges.DiscardUnknown(m)
}

var xxx_messageInfo_MustOwnBadges proto.InternalMessageInfo

func (m *MustOwnBadges) GetAmountRange() *UintRange {
	if m != nil {
		return m.AmountRange
	}
	return nil
}

func (m *MustOwnBadges) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *MustOwnBadges) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *MustOwnBadges) GetOverrideWithCurrentTime() bool {
	if m != nil {
		return m.OverrideWithCurrentTime
	}
	return false
}

func (m *MustOwnBadges) GetMustSatisfyForAllAssets() bool {
	if m != nil {
		return m.MustSatisfyForAllAssets
	}
	return false
}

// DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.
type DynamicStoreChallenge struct {
	// The ID of the dynamic store to check.
	StoreId Uint `protobuf:"bytes,1,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
}

func (m *DynamicStoreChallenge) Reset()         { *m = DynamicStoreChallenge{} }
func (m *DynamicStoreChallenge) String() string { return proto.CompactTextString(m) }
func (*DynamicStoreChallenge) ProtoMessage()    {}
func (*DynamicStoreChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{16}
}
func (m *DynamicStoreChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DynamicStoreChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DynamicStoreChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DynamicStoreChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DynamicStoreChallenge.Merge(m, src)
}
func (m *DynamicStoreChallenge) XXX_Size() int {
	return m.Size()
}
func (m *DynamicStoreChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_DynamicStoreChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_DynamicStoreChallenge proto.InternalMessageInfo

// ApprovalCriteria defines the criteria for approving transfers.
type ApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,7,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,8,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,9,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
	// Overrides the user's outgoing approvals for approval.
	OverridesFromOutgoingApprovals bool `protobuf:"varint,10,opt,name=overridesFromOutgoingApprovals,proto3" json:"overridesFromOutgoingApprovals,omitempty"`
	// Overrides the user's incoming approvals for approval.
	OverridesToIncomingApprovals bool `protobuf:"varint,11,opt,name=overridesToIncomingApprovals,proto3" json:"overridesToIncomingApprovals,omitempty"`
	// Auto-deletion options.
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,12,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// User level royalties to apply to the transfer.
	UserRoyalties *UserRoyalties `protobuf:"bytes,13,opt,name=userRoyalties,proto3" json:"userRoyalties,omitempty"`
	// Must own badges for approval.
	MustOwnBadges []*MustOwnBadges `protobuf:"bytes,14,rep,name=mustOwnBadges,proto3" json:"mustOwnBadges,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval.
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,15,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
	// User level payments configuration for approval.
	UserLevelPayments *UserLevelPayments `protobuf:"bytes,16,opt,name=userLevelPayments,proto3" json:"userLevelPayments,omitempty"`
}

func (m *ApprovalCriteria) Reset()         { *m = ApprovalCriteria{} }
func (m *ApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*ApprovalCriteria) ProtoMessage()    {}
func (*ApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{17}
}
func (m *ApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalCriteria.Merge(m, src)
}
func (m *ApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalCriteria proto.InternalMessageInfo

func (m *ApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *ApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *ApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *ApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *ApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetOverridesFromOutgoingApprovals() bool {
	if m != nil {
		return m.OverridesFromOutgoingApprovals
	}
	return false
}

func (m *ApprovalCriteria) GetOverridesToIncomingApprovals() bool {
	if m != nil {
		return m.OverridesToIncomingApprovals
	}
	return false
}

func (m *ApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *ApprovalCriteria) GetUserRoyalties() *UserRoyalties {
	if m != nil {
		return m.UserRoyalties
	}
	return nil
}

func (m *ApprovalCriteria) GetMustOwnBadges() []*MustOwnBadges {
	if m != nil {
		return m.MustOwnBadges
	}
	return nil
}

func (m *ApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetUserLevelPayments() *UserLevelPayments {
	if m != nil {
		return m.UserLevelPayments
	}
	return nil
}

// UserRoyalties defines the royalties for a user.
type UserRoyalties struct {
	// Percentage of the transfer amount to apply as royalties. 1 to 10000 represents basis points.
	Percentage Uint `protobuf:"bytes,1,opt,name=percentage,proto3,customtype=Uint" json:"percentage"`
	// Payout address for the royalties.
	PayoutAddress string `protobuf:"bytes,2,opt,name=payoutAddress,proto3" json:"payoutAddress,omitempty"`
}

func (m *UserRoyalties) Reset()         { *m = UserRoyalties{} }
func (m *UserRoyalties) String() string { return proto.CompactTextString(m) }
func (*UserRoyalties) ProtoMessage()    {}
func (*UserRoyalties) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{18}
}
func (m *UserRoyalties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRoyalties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRoyalties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRoyalties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRoyalties.Merge(m, src)
}
func (m *UserRoyalties) XXX_Size() int {
	return m.Size()
}
func (m *UserRoyalties) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRoyalties.DiscardUnknown(m)
}

var xxx_messageInfo_UserRoyalties proto.InternalMessageInfo

func (m *UserRoyalties) GetPayoutAddress() string {
	if m != nil {
		return m.PayoutAddress
	}
	return ""
}

// UserLevelPayments defines which denoms users can use for their approvals.
type UserLevelPayments struct {
	// If true, ignore the allowedDenoms field and allow all denoms.
	AllowAllDenoms bool `protobuf:"varint,1,opt,name=allowAllDenoms,proto3" json:"allowAllDenoms,omitempty"`
	// List of allowed denoms if allowAllDenoms is false.
	AllowedDenoms []string `protobuf:"bytes,2,rep,name=allowedDenoms,proto3" json:"allowedDenoms,omitempty"`
}

func (m *UserLevelPayments) Reset()         { *m = UserLevelPayments{} }
func (m *UserLevelPayments) String() string { return proto.CompactTextString(m) }
func (*UserLevelPayments) ProtoMessage()    {}
func (*UserLevelPayments) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{19}
}
func (m *UserLevelPayments) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserLevelPayments) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserLevelPayments.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserLevelPayments) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserLevelPayments.Merge(m, src)
}
func (m *UserLevelPayments) XXX_Size() int {
	return m.Size()
}
func (m *UserLevelPayments) XXX_DiscardUnknown() {
	xxx_messageInfo_UserLevelPayments.DiscardUnknown(m)
}

var xxx_messageInfo_UserLevelPayments proto.InternalMessageInfo

func (m *UserLevelPayments) GetAllowAllDenoms() bool {
	if m != nil {
		return m.AllowAllDenoms
	}
	return false
}

func (m *UserLevelPayments) GetAllowedDenoms() []string {
	if m != nil {
		return m.AllowedDenoms
	}
	return nil
}

// OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.
type OutgoingApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,7,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
	// Auto-deletion options.
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,8,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// Must own badges for approval.
	MustOwnBadges []*MustOwnBadges `protobuf:"bytes,9,rep,name=mustOwnBadges,proto3" json:"mustOwnBadges,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval.
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,10,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
}

func (m *OutgoingApprovalCriteria) Reset()         { *m = OutgoingApprovalCriteria{} }
func (m *OutgoingApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*OutgoingApprovalCriteria) ProtoMessage()    {}
func (*OutgoingApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{20}
}
func (m *OutgoingApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutgoingApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutgoingApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutgoingApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutgoingApprovalCriteria.Merge(m, src)
}
func (m *OutgoingApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *OutgoingApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_OutgoingApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_OutgoingApprovalCriteria proto.InternalMessageInfo

func (m *OutgoingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *OutgoingApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

func (m *OutgoingApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMustOwnBadges() []*MustOwnBadges {
	if m != nil {
		return m.MustOwnBadges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

// IncomingApprovalCriteria defines the criteria for approving incoming transfers.
type IncomingApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,7,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
	// Auto-deletion options.
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,8,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// Must own badges for approval.
	MustOwnBadges []*MustOwnBadges `protobuf:"bytes,9,rep,name=mustOwnBadges,proto3" json:"mustOwnBadges,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval.
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,10,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
}

func (m *IncomingApprovalCriteria) Reset()         { *m = IncomingApprovalCriteria{} }
func (m *IncomingApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*IncomingApprovalCriteria) ProtoMessage()    {}
func (*IncomingApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{21}
}
func (m *IncomingApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncomingApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncomingApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncomingApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncomingApprovalCriteria.Merge(m, src)
}
func (m *IncomingApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *IncomingApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_IncomingApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_IncomingApprovalCriteria proto.InternalMessageInfo

func (m *IncomingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *IncomingApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

func (m *IncomingApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMustOwnBadges() []*MustOwnBadges {
	if m != nil {
		return m.MustOwnBadges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

// CollectionApproval defines the rules for the approval of a transfer on the collection level
type CollectionApproval struct {
	// The list ID for the sender of the transfer.
	FromListId string `protobuf:"bytes,1,opt,name=fromListId,proto3" json:"fromListId,omitempty"`
	// The list ID for the recipient of the transfer.
	ToListId string `protobuf:"bytes,2,opt,name=toListId,proto3" json:"toListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,3,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,4,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of badge IDs for approval.
	BadgeIds []*UintRange `protobuf:"bytes,5,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,6,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,9,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,10,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,11,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *ApprovalCriteria `protobuf:"bytes,12,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
	// Version of the approval. Maintained internally.
	Version Uint `protobuf:"bytes,13,opt,name=version,proto3,customtype=Uint" json:"version"`
}

func (m *CollectionApproval) Reset()         { *m = CollectionApproval{} }
func (m *CollectionApproval) String() string { return proto.CompactTextString(m) }
func (*CollectionApproval) ProtoMessage()    {}
func (*CollectionApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{22}
}
func (m *CollectionApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApproval.Merge(m, src)
}
func (m *CollectionApproval) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApproval.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApproval proto.InternalMessageInfo

func (m *CollectionApproval) GetFromListId() string {
	if m != nil {
		return m.FromListId
	}
	return ""
}

func (m *CollectionApproval) GetToListId() string {
	if m != nil {
		return m.ToListId
	}
	return ""
}

func (m *CollectionApproval) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *CollectionApproval) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *CollectionApproval) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *CollectionApproval) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *CollectionApproval) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *CollectionApproval) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *CollectionApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *CollectionApproval) GetApprovalCriteria() *ApprovalCriteria {
	if m != nil {
		return m.ApprovalCriteria
	}
	return nil
}

// ApprovalIdentifierDetails defines the details to identify a specific approval.
type ApprovalIdentifierDetails struct {
	// The ID of the approval.
	ApprovalId string `protobuf:"bytes,1,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The level of the approval. Can be "collection", "incoming", or "outgoing".
	ApprovalLevel string `protobuf:"bytes,2,opt,name=approvalLevel,proto3" json:"approvalLevel,omitempty"`
	// The address of the approver. Leave blank "" if approvalLevel == "collection".
	ApproverAddress string `protobuf:"bytes,3,opt,name=approverAddress,proto3" json:"approverAddress,omitempty"`
	// The version of the approval.
	Version Uint `protobuf:"bytes,4,opt,name=version,proto3,customtype=Uint" json:"version"`
}

func (m *ApprovalIdentifierDetails) Reset()         { *m = ApprovalIdentifierDetails{} }
func (m *ApprovalIdentifierDetails) String() string { return proto.CompactTextString(m) }
func (*ApprovalIdentifierDetails) ProtoMessage()    {}
func (*ApprovalIdentifierDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{23}
}
func (m *ApprovalIdentifierDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalIdentifierDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalIdentifierDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalIdentifierDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalIdentifierDetails.Merge(m, src)
}
func (m *ApprovalIdentifierDetails) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalIdentifierDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalIdentifierDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalIdentifierDetails proto.InternalMessageInfo

func (m *ApprovalIdentifierDetails) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *ApprovalIdentifierDetails) GetApprovalLevel() string {
	if m != nil {
		return m.ApprovalLevel
	}
	return ""
}

func (m *ApprovalIdentifierDetails) GetApproverAddress() string {
	if m != nil {
		return m.ApproverAddress
	}
	return ""
}

// Transfer defines the details of a transfer of badges.
type Transfer struct {
	// The address of the sender of the transfer.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// The addresses of the recipients of the transfer.
	ToAddresses []string `protobuf:"bytes,2,rep,name=toAddresses,proto3" json:"toAddresses,omitempty"`
	// The balances to be transferred.
	Balances []*Balance `protobuf:"bytes,3,rep,name=balances,proto3" json:"balances,omitempty"`
	// If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.
	// We will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.
	PrecalculateBalancesFromApproval *ApprovalIdentifierDetails `protobuf:"bytes,4,opt,name=precalculateBalancesFromApproval,proto3" json:"precalculateBalancesFromApproval,omitempty"`
	// The Merkle proofs / solutions for all Merkle challenges required for the transfer.
	MerkleProofs []*MerkleProof `protobuf:"bytes,5,rep,name=merkleProofs,proto3" json:"merkleProofs,omitempty"`
	// The memo for the transfer.
	Memo string `protobuf:"bytes,6,opt,name=memo,proto3" json:"memo,omitempty"`
	// The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.
	// This field can be used to prioritize specific approvals and scan through them first.
	PrioritizedApprovals []*ApprovalIdentifierDetails `protobuf:"bytes,7,rep,name=prioritizedApprovals,proto3" json:"prioritizedApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedCollectionApprovals bool `protobuf:"varint,8,opt,name=onlyCheckPrioritizedCollectionApprovals,proto3" json:"onlyCheckPrioritizedCollectionApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedIncomingApprovals bool `protobuf:"varint,9,opt,name=onlyCheckPrioritizedIncomingApprovals,proto3" json:"onlyCheckPrioritizedIncomingApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedOutgoingApprovals bool `protobuf:"varint,10,opt,name=onlyCheckPrioritizedOutgoingApprovals,proto3" json:"onlyCheckPrioritizedOutgoingApprovals,omitempty"`
	// The options for precalculating the balances.
	PrecalculationOptions *PrecalculationOptions `protobuf:"bytes,11,opt,name=precalculationOptions,proto3" json:"precalculationOptions,omitempty"`
	// Affiliate address for the transfer.
	AffiliateAddress string `protobuf:"bytes,12,opt,name=affiliateAddress,proto3" json:"affiliateAddress,omitempty"`
	// The number of times to attempt approval validation. If 0 / not specified, we default to only one.
	NumAttempts Uint `protobuf:"bytes,13,opt,name=numAttempts,proto3,customtype=Uint" json:"numAttempts"`
}

func (m *Transfer) Reset()         { *m = Transfer{} }
func (m *Transfer) String() string { return proto.CompactTextString(m) }
func (*Transfer) ProtoMessage()    {}
func (*Transfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{24}
}
func (m *Transfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transfer.Merge(m, src)
}
func (m *Transfer) XXX_Size() int {
	return m.Size()
}
func (m *Transfer) XXX_DiscardUnknown() {
	xxx_messageInfo_Transfer.DiscardUnknown(m)
}

var xxx_messageInfo_Transfer proto.InternalMessageInfo

func (m *Transfer) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Transfer) GetToAddresses() []string {
	if m != nil {
		return m.ToAddresses
	}
	return nil
}

func (m *Transfer) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *Transfer) GetPrecalculateBalancesFromApproval() *ApprovalIdentifierDetails {
	if m != nil {
		return m.PrecalculateBalancesFromApproval
	}
	return nil
}

func (m *Transfer) GetMerkleProofs() []*MerkleProof {
	if m != nil {
		return m.MerkleProofs
	}
	return nil
}

func (m *Transfer) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *Transfer) GetPrioritizedApprovals() []*ApprovalIdentifierDetails {
	if m != nil {
		return m.PrioritizedApprovals
	}
	return nil
}

func (m *Transfer) GetOnlyCheckPrioritizedCollectionApprovals() bool {
	if m != nil {
		return m.OnlyCheckPrioritizedCollectionApprovals
	}
	return false
}

func (m *Transfer) GetOnlyCheckPrioritizedIncomingApprovals() bool {
	if m != nil {
		return m.OnlyCheckPrioritizedIncomingApprovals
	}
	return false
}

func (m *Transfer) GetOnlyCheckPrioritizedOutgoingApprovals() bool {
	if m != nil {
		return m.OnlyCheckPrioritizedOutgoingApprovals
	}
	return false
}

func (m *Transfer) GetPrecalculationOptions() *PrecalculationOptions {
	if m != nil {
		return m.PrecalculationOptions
	}
	return nil
}

func (m *Transfer) GetAffiliateAddress() string {
	if m != nil {
		return m.AffiliateAddress
	}
	return ""
}

// PrecalculationOptions defines the options for precalculating the balances.
type PrecalculationOptions struct {
	// The timestamp to override with when calculating the balances.
	OverrideTimestamp Uint `protobuf:"bytes,1,opt,name=overrideTimestamp,proto3,customtype=Uint" json:"overrideTimestamp"`
	// The badgeIdsOverride to use for the transfer.
	BadgeIdsOverride []*UintRange `protobuf:"bytes,2,rep,name=badgeIdsOverride,proto3" json:"badgeIdsOverride,omitempty"`
}

func (m *PrecalculationOptions) Reset()         { *m = PrecalculationOptions{} }
func (m *PrecalculationOptions) String() string { return proto.CompactTextString(m) }
func (*PrecalculationOptions) ProtoMessage()    {}
func (*PrecalculationOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{25}
}
func (m *PrecalculationOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrecalculationOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrecalculationOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrecalculationOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrecalculationOptions.Merge(m, src)
}
func (m *PrecalculationOptions) XXX_Size() int {
	return m.Size()
}
func (m *PrecalculationOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_PrecalculationOptions.DiscardUnknown(m)
}

var xxx_messageInfo_PrecalculationOptions proto.InternalMessageInfo

func (m *PrecalculationOptions) GetBadgeIdsOverride() []*UintRange {
	if m != nil {
		return m.BadgeIdsOverride
	}
	return nil
}

// MerklePathItem represents an item in a Merkle path.
type MerklePathItem struct {
	// The hash of the sibling node (aunt) in the Merkle path.
	Aunt string `protobuf:"bytes,1,opt,name=aunt,proto3" json:"aunt,omitempty"`
	// Indicates whether the aunt node is on the right side of the path.
	OnRight bool `protobuf:"varint,2,opt,name=onRight,proto3" json:"onRight,omitempty"`
}

func (m *MerklePathItem) Reset()         { *m = MerklePathItem{} }
func (m *MerklePathItem) String() string { return proto.CompactTextString(m) }
func (*MerklePathItem) ProtoMessage()    {}
func (*MerklePathItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{26}
}
func (m *MerklePathItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerklePathItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerklePathItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerklePathItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerklePathItem.Merge(m, src)
}
func (m *MerklePathItem) XXX_Size() int {
	return m.Size()
}
func (m *MerklePathItem) XXX_DiscardUnknown() {
	xxx_messageInfo_MerklePathItem.DiscardUnknown(m)
}

var xxx_messageInfo_MerklePathItem proto.InternalMessageInfo

func (m *MerklePathItem) GetAunt() string {
	if m != nil {
		return m.Aunt
	}
	return ""
}

func (m *MerklePathItem) GetOnRight() bool {
	if m != nil {
		return m.OnRight
	}
	return false
}

// MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.
type MerkleProof struct {
	// The hash of the leaf node for which the proof is generated.
	Leaf string `protobuf:"bytes,1,opt,name=leaf,proto3" json:"leaf,omitempty"`
	// List of Merkle path items (aunts) that make up the proof.
	Aunts []*MerklePathItem `protobuf:"bytes,2,rep,name=aunts,proto3" json:"aunts,omitempty"`
	// The signature of the leaf node tying the address to the leaf node.
	LeafSignature string `protobuf:"bytes,3,opt,name=leafSignature,proto3" json:"leafSignature,omitempty"`
}

func (m *MerkleProof) Reset()         { *m = MerkleProof{} }
func (m *MerkleProof) String() string { return proto.CompactTextString(m) }
func (*MerkleProof) ProtoMessage()    {}
func (*MerkleProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb4f8dfda2bb14b, []int{27}
}
func (m *MerkleProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerkleProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerkleProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerkleProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerkleProof.Merge(m, src)
}
func (m *MerkleProof) XXX_Size() int {
	return m.Size()
}
func (m *MerkleProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MerkleProof.DiscardUnknown(m)
}

var xxx_messageInfo_MerkleProof proto.InternalMessageInfo

func (m *MerkleProof) GetLeaf() string {
	if m != nil {
		return m.Leaf
	}
	return ""
}

func (m *MerkleProof) GetAunts() []*MerklePathItem {
	if m != nil {
		return m.Aunts
	}
	return nil
}

func (m *MerkleProof) GetLeafSignature() string {
	if m != nil {
		return m.LeafSignature
	}
	return ""
}

func init() {
	proto.RegisterType((*UserBalanceStore)(nil), "badges.v11.UserBalanceStore")
	proto.RegisterType((*MerkleChallenge)(nil), "badges.v11.MerkleChallenge")
	proto.RegisterType((*UserOutgoingApproval)(nil), "badges.v11.UserOutgoingApproval")
	proto.RegisterType((*UserIncomingApproval)(nil), "badges.v11.UserIncomingApproval")
	proto.RegisterType((*ManualBalances)(nil), "badges.v11.ManualBalances")
	proto.RegisterType((*RecurringOwnershipTimes)(nil), "badges.v11.RecurringOwnershipTimes")
	proto.RegisterType((*IncrementedBalances)(nil), "badges.v11.IncrementedBalances")
	proto.RegisterType((*PredeterminedOrderCalculationMethod)(nil), "badges.v11.PredeterminedOrderCalculationMethod")
	proto.RegisterType((*PredeterminedBalances)(nil), "badges.v11.PredeterminedBalances")
	proto.RegisterType((*AutoDeletionOptions)(nil), "badges.v11.AutoDeletionOptions")
	proto.RegisterType((*ApprovalAmounts)(nil), "badges.v11.ApprovalAmounts")
	proto.RegisterType((*ResetTimeIntervals)(nil), "badges.v11.ResetTimeIntervals")
	proto.RegisterType((*MaxNumTransfers)(nil), "badges.v11.MaxNumTransfers")
	proto.RegisterType((*ApprovalTracker)(nil), "badges.v11.ApprovalTracker")
	proto.RegisterType((*CoinTransfer)(nil), "badges.v11.CoinTransfer")
	proto.RegisterType((*MustOwnBadges)(nil), "badges.v11.MustOwnBadges")
	proto.RegisterType((*DynamicStoreChallenge)(nil), "badges.v11.DynamicStoreChallenge")
	proto.RegisterType((*ApprovalCriteria)(nil), "badges.v11.ApprovalCriteria")
	proto.RegisterType((*UserRoyalties)(nil), "badges.v11.UserRoyalties")
	proto.RegisterType((*UserLevelPayments)(nil), "badges.v11.UserLevelPayments")
	proto.RegisterType((*OutgoingApprovalCriteria)(nil), "badges.v11.OutgoingApprovalCriteria")
	proto.RegisterType((*IncomingApprovalCriteria)(nil), "badges.v11.IncomingApprovalCriteria")
	proto.RegisterType((*CollectionApproval)(nil), "badges.v11.CollectionApproval")
	proto.RegisterType((*ApprovalIdentifierDetails)(nil), "badges.v11.ApprovalIdentifierDetails")
	proto.RegisterType((*Transfer)(nil), "badges.v11.Transfer")
	proto.RegisterType((*PrecalculationOptions)(nil), "badges.v11.PrecalculationOptions")
	proto.RegisterType((*MerklePathItem)(nil), "badges.v11.MerklePathItem")
	proto.RegisterType((*MerkleProof)(nil), "badges.v11.MerkleProof")
}

func init() { proto.RegisterFile("badges/v11/transfers.proto", fileDescriptor_1bb4f8dfda2bb14b) }

var fileDescriptor_1bb4f8dfda2bb14b = []byte{
	// 2495 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x5b, 0x73, 0x1c, 0x47,
	0xf5, 0xf7, 0x6a, 0x75, 0xdb, 0xb3, 0xd6, 0xc5, 0xed, 0xc8, 0x5e, 0x2b, 0xb6, 0xac, 0xff, 0xd8,
	0xf1, 0xdf, 0xa4, 0x82, 0xd6, 0x12, 0x54, 0x08, 0x04, 0x1c, 0x76, 0x25, 0x1b, 0x6f, 0xb0, 0x25,
	0x31, 0x96, 0x09, 0xa1, 0xb8, 0xb5, 0x66, 0x7a, 0x57, 0x53, 0x9e, 0x99, 0x5e, 0x77, 0xf7, 0x28,
	0x5a, 0xde, 0x79, 0xa4, 0x8a, 0x27, 0xf8, 0x06, 0xbc, 0xe4, 0x85, 0x2a, 0x9e, 0xf8, 0x06, 0xa9,
	0xe2, 0x81, 0x54, 0xf1, 0x10, 0x0a, 0xaa, 0x42, 0xca, 0xfe, 0x04, 0x7c, 0x02, 0xa8, 0xee, 0xe9,
	0xd9, 0x9d, 0x4b, 0xcf, 0x6a, 0xe3, 0x24, 0x50, 0x14, 0x7e, 0xd9, 0x9a, 0xed, 0xfe, 0x9d, 0xd3,
	0x3d, 0xa7, 0xcf, 0xbd, 0x07, 0x56, 0x0f, 0xb1, 0xdb, 0x23, 0xbc, 0x79, 0xbc, 0xb9, 0xd9, 0x14,
	0x0c, 0x87, 0xbc, 0x4b, 0x18, 0xdf, 0xe8, 0x33, 0x2a, 0x28, 0x82, 0x78, 0x6e, 0xe3, 0x78, 0x73,
	0x73, 0xf5, 0xa5, 0x1e, 0xed, 0x51, 0x35, 0xdc, 0x94, 0x4f, 0x31, 0x62, 0xf5, 0x72, 0x8a, 0xba,
	0x4f, 0x58, 0xe0, 0x71, 0xee, 0xd1, 0x50, 0xd3, 0xaf, 0xae, 0xa5, 0x66, 0xb1, 0xeb, 0x32, 0xc2,
	0xf9, 0x4f, 0x7d, 0x8f, 0x8b, 0x64, 0xfe, 0x52, 0x6a, 0xfe, 0x10, 0xfb, 0x38, 0x74, 0xc8, 0x90,
	0xd4, 0xa1, 0x3c, 0xa0, 0xbc, 0x79, 0x88, 0x39, 0x69, 0x1e, 0x6f, 0x1e, 0x12, 0x81, 0x37, 0x9b,
	0x0e, 0xf5, 0xc2, 0x78, 0xde, 0xfa, 0xdd, 0x34, 0x2c, 0x3f, 0xe2, 0x84, 0xb5, 0x63, 0xb2, 0x87,
	0x82, 0x32, 0x82, 0x9a, 0x30, 0x9f, 0xb0, 0x69, 0x54, 0xd6, 0xab, 0x37, 0xeb, 0x5b, 0xe7, 0x37,
	0x46, 0xaf, 0xb0, 0xa1, 0xb1, 0xf6, 0x10, 0x84, 0x76, 0xe1, 0x1c, 0x8d, 0x44, 0x8f, 0x7a, 0x61,
	0xaf, 0xd5, 0xef, 0x33, 0x7a, 0x8c, 0x7d, 0xde, 0x98, 0x52, 0x94, 0xeb, 0x69, 0x4a, 0xb9, 0xd2,
	0x5e, 0x0e, 0x68, 0x17, 0x49, 0x25, 0x3f, 0x2f, 0x74, 0x68, 0x90, 0xe1, 0x57, 0x35, 0xf3, 0xeb,
	0xe4, 0x80, 0x76, 0x91, 0x14, 0xfd, 0x08, 0xbe, 0x84, 0x23, 0x41, 0xe3, 0x01, 0xf2, 0x90, 0xf8,
	0xdd, 0x4e, 0xe8, 0x09, 0x0f, 0x0b, 0xe2, 0x26, 0xdb, 0x39, 0x48, 0xce, 0xac, 0x31, 0xbd, 0x5e,
	0xb9, 0x39, 0x6f, 0x4f, 0x4e, 0x30, 0x8e, 0x7b, 0xb2, 0xb9, 0x11, 0xf7, 0x99, 0xf1, 0xdc, 0x0b,
	0x04, 0xe8, 0x1e, 0x5c, 0x4d, 0x81, 0x5b, 0xbe, 0x5f, 0xe4, 0x39, 0xab, 0x78, 0x9e, 0x06, 0x43,
	0x77, 0x60, 0x29, 0xe2, 0x84, 0xed, 0x8f, 0xf4, 0xab, 0x31, 0xb7, 0x5e, 0xb9, 0x59, 0xdf, 0x7a,
	0x39, 0x2f, 0xd3, 0x14, 0xc4, 0xce, 0xd3, 0x58, 0x1f, 0x4d, 0xc1, 0xd2, 0x03, 0xc2, 0x1e, 0xfb,
	0x64, 0xfb, 0x08, 0xfb, 0x3e, 0x09, 0x7b, 0x04, 0x21, 0x98, 0x66, 0x94, 0x8a, 0x46, 0x65, 0xbd,
	0x72, 0xb3, 0x66, 0xab, 0x67, 0x74, 0x1b, 0xce, 0x93, 0x93, 0x3e, 0x71, 0x04, 0x71, 0xf7, 0x19,
	0xa5, 0xdd, 0xfb, 0x24, 0xec, 0x89, 0xa3, 0xc6, 0x94, 0x84, 0xb4, 0xcf, 0x7e, 0xf0, 0xf1, 0xd5,
	0x33, 0x7f, 0xfd, 0xf8, 0xea, 0xf4, 0x23, 0x2f, 0x14, 0xb6, 0x09, 0x88, 0xde, 0x80, 0x8b, 0x11,
	0x27, 0xdb, 0x8c, 0x60, 0x41, 0x59, 0x2b, 0x56, 0xfb, 0x16, 0xbf, 0x4f, 0x70, 0xb7, 0x51, 0x55,
	0x2f, 0x5c, 0x36, 0x8d, 0xbe, 0x0a, 0x8b, 0x01, 0x3e, 0x79, 0xc4, 0x09, 0xdf, 0x27, 0x4c, 0x11,
	0x4c, 0x1b, 0x16, 0xcd, 0x61, 0xd0, 0x32, 0x54, 0x23, 0xe6, 0xa9, 0x03, 0xaa, 0xd9, 0xf2, 0x11,
	0xad, 0x01, 0x38, 0x11, 0x17, 0x34, 0xd8, 0xc1, 0x02, 0x2b, 0x29, 0xd7, 0xec, 0xd4, 0x08, 0xda,
	0x00, 0xe4, 0x24, 0x22, 0x38, 0x60, 0xd8, 0x79, 0x4c, 0x58, 0xc7, 0x55, 0x32, 0xad, 0xd9, 0x86,
	0x19, 0xc9, 0xcf, 0x27, 0xb8, 0xfb, 0xd0, 0xeb, 0x85, 0x84, 0x35, 0xe6, 0x63, 0x7e, 0xa3, 0x11,
	0xeb, 0x6f, 0x55, 0x78, 0xc9, 0x64, 0x22, 0x68, 0x15, 0xe6, 0x05, 0xbd, 0xef, 0x71, 0xd1, 0x71,
	0xb5, 0x88, 0x87, 0xff, 0xd1, 0x6b, 0xd2, 0x56, 0xb4, 0xf6, 0xb4, 0x07, 0x1a, 0xa4, 0x84, 0x6c,
	0x17, 0x27, 0xd0, 0x9b, 0xb0, 0x90, 0x78, 0xa7, 0x03, 0x2f, 0x20, 0x89, 0x55, 0xad, 0x64, 0x34,
	0x40, 0x4a, 0x07, 0x87, 0x3d, 0x62, 0x67, 0xb1, 0x68, 0x53, 0xfa, 0x05, 0xb7, 0x47, 0x3a, 0xae,
	0xb4, 0x92, 0x31, 0x74, 0x43, 0x18, 0xfa, 0x16, 0x2c, 0xd2, 0xf7, 0x42, 0xc2, 0xf8, 0x91, 0xd7,
	0x8f, 0x17, 0x9c, 0x19, 0x47, 0x98, 0x03, 0x27, 0x67, 0x32, 0x5f, 0x76, 0x26, 0xb5, 0xc2, 0x99,
	0xac, 0x01, 0x60, 0x2d, 0xb6, 0x8e, 0xdb, 0x80, 0x78, 0x7e, 0x34, 0x82, 0xf6, 0x61, 0x39, 0xf9,
	0xb7, 0xcd, 0x3c, 0x41, 0x98, 0x87, 0x1b, 0x75, 0x65, 0x05, 0xd7, 0xd3, 0x5b, 0xca, 0x1f, 0x41,
	0x82, 0xb5, 0x0b, 0xd4, 0xe8, 0x06, 0xcc, 0x1d, 0x13, 0x26, 0x6d, 0xa3, 0x71, 0xd6, 0xa0, 0x66,
	0xc9, 0xa4, 0xf5, 0x77, 0x7d, 0xba, 0x79, 0x87, 0x25, 0xb7, 0xdc, 0x65, 0x34, 0xc8, 0x9c, 0x6f,
	0x6a, 0xe4, 0xc5, 0x09, 0x7f, 0x21, 0x27, 0x9c, 0x3f, 0x86, 0xcf, 0xe1, 0x84, 0x5b, 0xb0, 0xf8,
	0x00, 0x87, 0x11, 0xf6, 0xdb, 0x49, 0x60, 0xfc, 0xb4, 0x91, 0xd4, 0xfa, 0x43, 0x05, 0x2e, 0xda,
	0xc4, 0x89, 0x18, 0xf3, 0xc2, 0xde, 0x5e, 0x56, 0x54, 0xaf, 0x42, 0x8d, 0x0b, 0xcc, 0x84, 0xfc,
	0x17, 0xab, 0x49, 0x6e, 0x23, 0xa3, 0x69, 0xe9, 0x02, 0xbd, 0x50, 0x10, 0x76, 0x8c, 0xfd, 0x31,
	0x7e, 0x37, 0x87, 0x41, 0xdf, 0x54, 0x0e, 0x8d, 0xf5, 0xc8, 0x3e, 0x61, 0x1e, 0x75, 0x35, 0x65,
	0xd5, 0x40, 0x69, 0xc0, 0x59, 0xff, 0xac, 0xc2, 0xf9, 0x4e, 0xe8, 0x30, 0x12, 0x90, 0x50, 0x6a,
	0x64, 0x22, 0x84, 0xaf, 0xc3, 0x82, 0xda, 0x58, 0x7b, 0x02, 0x49, 0x64, 0x91, 0x32, 0x86, 0x78,
	0x09, 0xc7, 0xb6, 0xd6, 0xb8, 0xf6, 0xc0, 0x1c, 0x43, 0x0c, 0x40, 0xf4, 0x36, 0x5c, 0x1a, 0x0e,
	0x67, 0xa5, 0xd9, 0x1e, 0x18, 0xdf, 0xab, 0x1c, 0x8e, 0xda, 0xb0, 0xe2, 0x46, 0x0c, 0x0b, 0x8f,
	0x86, 0x77, 0x19, 0x0d, 0xd4, 0xb0, 0xc0, 0x41, 0xdf, 0x18, 0x5c, 0xcc, 0x50, 0xf4, 0x3a, 0x5c,
	0xc0, 0xbe, 0x4f, 0xdf, 0xdb, 0x3b, 0x26, 0x8c, 0x79, 0x2e, 0x19, 0x31, 0x89, 0xf3, 0x82, 0x92,
	0x59, 0xf4, 0x63, 0xb8, 0xc8, 0xcc, 0x5a, 0xa1, 0xc2, 0x52, 0x7d, 0xeb, 0x5a, 0x5a, 0x98, 0x25,
	0x0a, 0x64, 0x97, 0xf1, 0x40, 0x77, 0x61, 0x2d, 0xb3, 0xf0, 0x3b, 0x9e, 0x38, 0x6a, 0x85, 0x83,
	0xef, 0x63, 0xdf, 0x73, 0x95, 0x34, 0x55, 0x50, 0x9b, 0xb7, 0x4f, 0x41, 0x59, 0xef, 0x57, 0xe1,
	0xda, 0x3e, 0x23, 0x2e, 0x11, 0x32, 0x5f, 0x08, 0x89, 0xbb, 0xc7, 0x5c, 0xc2, 0xb6, 0xb1, 0xef,
	0x44, 0xbe, 0x92, 0xc6, 0x03, 0x22, 0x8e, 0xa8, 0x2b, 0xc5, 0x10, 0x71, 0x22, 0xf9, 0x60, 0xdf,
	0xdf, 0x8d, 0x82, 0x51, 0x2a, 0x53, 0x89, 0xc5, 0x60, 0x9e, 0x45, 0xdf, 0x86, 0x97, 0x23, 0x2e,
	0x95, 0xee, 0x80, 0xea, 0x88, 0x9f, 0x21, 0x9e, 0x52, 0xc4, 0xe3, 0x20, 0x68, 0x07, 0xae, 0xc4,
	0xd3, 0xf2, 0x5c, 0x4c, 0x3c, 0xe2, 0xd4, 0x62, 0x3c, 0x08, 0xd9, 0x70, 0x3d, 0x06, 0x74, 0x46,
	0xee, 0xd7, 0xc4, 0x2c, 0x4e, 0x25, 0x27, 0xc2, 0xea, 0x77, 0xcb, 0x25, 0x56, 0x32, 0x31, 0xe9,
	0x84, 0x2e, 0x39, 0xd1, 0xfa, 0x31, 0x0e, 0x52, 0x92, 0x8e, 0xcc, 0x96, 0xa5, 0x23, 0xd6, 0x6f,
	0xa6, 0x60, 0x25, 0x73, 0x5a, 0x43, 0xb3, 0x6b, 0xcb, 0x04, 0x2a, 0xed, 0xc8, 0xb4, 0xc9, 0xae,
	0xa6, 0xb5, 0x2c, 0xeb, 0xea, 0xec, 0x1c, 0x05, 0xfa, 0x5e, 0xca, 0x74, 0x47, 0xac, 0xd5, 0x19,
	0xd5, 0xb7, 0xae, 0xe6, 0x3c, 0x71, 0x1e, 0x66, 0x9b, 0x68, 0x51, 0x0f, 0x2e, 0x50, 0xa3, 0x42,
	0xa9, 0x53, 0xab, 0x6f, 0x35, 0xd3, 0x5c, 0x27, 0xd0, 0x43, 0xbb, 0x84, 0x9d, 0xf5, 0xac, 0x02,
	0xe7, 0x5b, 0x91, 0xa0, 0x3b, 0xc4, 0x27, 0x72, 0x78, 0xaf, 0x2f, 0x7f, 0x39, 0x5a, 0x87, 0x3a,
	0xee, 0x0a, 0xc2, 0xf6, 0x42, 0xf2, 0x88, 0x13, 0xad, 0xac, 0xe9, 0x21, 0x79, 0x8a, 0xf1, 0xdf,
	0x58, 0x7b, 0x1f, 0xe0, 0x13, 0x93, 0x86, 0x8e, 0x81, 0x0c, 0x5d, 0xc4, 0x36, 0x8d, 0xa4, 0x73,
	0xee, 0x63, 0x26, 0x06, 0xfb, 0x11, 0xeb, 0x11, 0xad, 0x9a, 0x25, 0xb3, 0xe8, 0x16, 0x9c, 0x57,
	0x33, 0xea, 0x5f, 0xa7, 0x7b, 0xe7, 0xa4, 0xef, 0x31, 0xe2, 0x6a, 0x15, 0x34, 0x4d, 0x59, 0x7f,
	0xaa, 0xc2, 0x52, 0x12, 0xfd, 0x5a, 0x81, 0x64, 0x28, 0x4f, 0x7e, 0x85, 0xc6, 0xfb, 0xca, 0xce,
	0x18, 0xe3, 0x8d, 0x19, 0x8a, 0xee, 0xc3, 0x6a, 0x3f, 0x65, 0x7f, 0x39, 0x46, 0x26, 0xdf, 0x3d,
	0x06, 0x8f, 0xf6, 0xe1, 0x72, 0x3f, 0x63, 0x89, 0x39, 0x7e, 0x26, 0x2f, 0x3e, 0x96, 0x02, 0xfd,
	0x04, 0xae, 0xf5, 0x4d, 0xe6, 0x98, 0x63, 0x6c, 0x72, 0xeb, 0x93, 0x10, 0xa2, 0x9b, 0xb0, 0x84,
	0xd5, 0x53, 0xde, 0x08, 0xf3, 0xc3, 0x68, 0x17, 0x10, 0x23, 0x9c, 0xa8, 0x90, 0xdd, 0xd1, 0xa1,
	0x38, 0x29, 0xca, 0xd6, 0xb2, 0x1e, 0x3d, 0x8f, 0xb2, 0x0d, 0x94, 0xd6, 0x31, 0xa0, 0x22, 0xf2,
	0x8b, 0xcf, 0x1b, 0xac, 0x8f, 0xaa, 0xb0, 0x94, 0xd7, 0xe3, 0x1d, 0xb8, 0x40, 0xcd, 0x46, 0x60,
	0xda, 0x42, 0x09, 0x16, 0xed, 0xc2, 0xcb, 0x69, 0xdd, 0x30, 0xd9, 0x53, 0x9e, 0xd5, 0x38, 0x02,
	0x64, 0xc3, 0x95, 0xac, 0x6e, 0xe4, 0x39, 0x9a, 0xd4, 0x69, 0x3c, 0x09, 0xfa, 0x19, 0x5c, 0x37,
	0xaa, 0x45, 0x9e, 0xb5, 0x49, 0xa1, 0x26, 0xa2, 0xfc, 0x0f, 0x6a, 0xd4, 0x6f, 0x2b, 0x23, 0x1f,
	0xa1, 0x57, 0x41, 0xb7, 0xe0, 0x6c, 0x78, 0xda, 0x79, 0x66, 0x10, 0xe8, 0xcb, 0x30, 0x17, 0x6f,
	0x34, 0xe9, 0x0a, 0x19, 0x73, 0xbf, 0x04, 0x83, 0xb6, 0x60, 0xc1, 0xc7, 0x5c, 0x3c, 0xea, 0xbb,
	0x52, 0x2a, 0x2d, 0xb3, 0x8d, 0x67, 0x21, 0xd6, 0x9f, 0x2b, 0x70, 0x76, 0x9b, 0x7a, 0x61, 0xb2,
	0x28, 0x5a, 0x84, 0x29, 0x41, 0x75, 0x35, 0x35, 0x25, 0x28, 0x6a, 0xc2, 0x8c, 0x43, 0xbd, 0x30,
	0xd9, 0xc1, 0xa5, 0x8d, 0xb8, 0x33, 0xb6, 0x71, 0x88, 0x39, 0xd9, 0xd0, 0x9d, 0xb1, 0x0d, 0xc9,
	0xc1, 0x8e, 0x71, 0xe8, 0x1e, 0x5c, 0xa5, 0x3a, 0xd3, 0x91, 0x87, 0xaf, 0xb2, 0x9d, 0xb8, 0xbb,
	0x92, 0xb4, 0x1b, 0xb4, 0x47, 0x3e, 0x0d, 0x86, 0xde, 0x80, 0x8b, 0x09, 0xe4, 0x80, 0x4a, 0x80,
	0x3e, 0x71, 0xca, 0xb4, 0x7b, 0x2e, 0x9b, 0xb6, 0x3e, 0x99, 0x82, 0x85, 0x07, 0x11, 0x97, 0xc9,
	0xa8, 0xca, 0xb0, 0xb8, 0x14, 0xbe, 0x43, 0x7d, 0x9f, 0x38, 0x32, 0x22, 0x25, 0xe5, 0x62, 0x5e,
	0xf8, 0x69, 0x04, 0xfa, 0x1a, 0xd4, 0x63, 0xc1, 0xaa, 0x02, 0x4c, 0x07, 0xe0, 0x92, 0xea, 0x2c,
	0x8d, 0x34, 0x54, 0x76, 0xd5, 0x4f, 0x53, 0xd9, 0x3d, 0x47, 0x2d, 0x99, 0x12, 0x94, 0x94, 0xc3,
	0x76, 0xc4, 0x18, 0x09, 0x63, 0xbf, 0x35, 0x93, 0x15, 0x54, 0x6e, 0x5a, 0x52, 0x06, 0x11, 0x17,
	0x0f, 0xb1, 0xf0, 0x78, 0x77, 0x70, 0x97, 0xb2, 0x96, 0xef, 0xb7, 0x38, 0x27, 0x22, 0xe9, 0x8e,
	0x95, 0x4d, 0x5b, 0x6f, 0xc1, 0xca, 0xce, 0x20, 0xc4, 0x81, 0xe7, 0xa8, 0xe6, 0xe7, 0xa8, 0xa7,
	0x75, 0x03, 0xe6, 0xb8, 0x1c, 0x29, 0x11, 0x72, 0x32, 0x69, 0xbd, 0x5f, 0x83, 0xe5, 0x7c, 0x11,
	0x89, 0xbe, 0x03, 0xcb, 0x41, 0x36, 0x4f, 0x4b, 0x72, 0xa8, 0x4c, 0xb3, 0x2d, 0x97, 0xcb, 0xd9,
	0x05, 0x22, 0xf4, 0x0e, 0xac, 0xf4, 0x4d, 0x39, 0x9a, 0x3e, 0xc7, 0xff, 0x2b, 0x4d, 0x79, 0x86,
	0xa9, 0x94, 0x99, 0x1e, 0xdd, 0x81, 0x25, 0x9c, 0x0d, 0xfe, 0x3a, 0x8b, 0xca, 0x6c, 0x30, 0x97,
	0x1f, 0xd8, 0x79, 0x1a, 0xc9, 0x26, 0x30, 0xf8, 0xb9, 0xfc, 0x7b, 0x66, 0x21, 0x76, 0x9e, 0x06,
	0xdd, 0x86, 0x05, 0x27, 0x65, 0xbd, 0x49, 0x13, 0xa1, 0x91, 0x66, 0x92, 0x36, 0x6f, 0x3b, 0x0b,
	0x47, 0xb7, 0x61, 0x95, 0x91, 0x27, 0x91, 0xc7, 0xc8, 0x01, 0xbd, 0xf3, 0x24, 0xc2, 0x3e, 0x4f,
	0x79, 0x55, 0xad, 0x02, 0x63, 0x10, 0xa8, 0x0d, 0x97, 0xf5, 0xac, 0x34, 0xe2, 0x22, 0x87, 0xb8,
	0xfe, 0x19, 0x8b, 0x41, 0x6f, 0xc3, 0xfa, 0x70, 0x85, 0x1d, 0x4a, 0xf8, 0x2e, 0x15, 0x0a, 0x94,
	0xe6, 0x33, 0xaf, 0xf8, 0x9c, 0x8a, 0x43, 0xbb, 0x60, 0xa5, 0xd6, 0x2a, 0xe3, 0x56, 0x53, 0xdc,
	0x26, 0x40, 0xca, 0x0a, 0x2f, 0x31, 0x1d, 0x2e, 0x71, 0x7b, 0x85, 0x76, 0x3d, 0xc4, 0x15, 0xde,
	0x78, 0x94, 0x94, 0xd3, 0x10, 0x71, 0x40, 0x3b, 0x85, 0x26, 0x7d, 0x3d, 0x96, 0xd3, 0x38, 0x8c,
	0xac, 0x0c, 0x70, 0x31, 0xb9, 0x56, 0xad, 0x95, 0x5c, 0x65, 0x60, 0xc8, 0xc1, 0x6d, 0x13, 0x2d,
	0x7a, 0x0b, 0x16, 0x22, 0x4e, 0x98, 0x4d, 0x07, 0xd8, 0x17, 0x1e, 0xe1, 0x8d, 0x05, 0xc5, 0xec,
	0x52, 0xbe, 0xb1, 0x3d, 0x04, 0xd8, 0x59, 0xbc, 0x64, 0x10, 0xa4, 0xfd, 0x6c, 0x63, 0x51, 0x47,
	0x89, 0xb4, 0x12, 0xa7, 0x01, 0x76, 0x16, 0x8f, 0xde, 0x85, 0x0b, 0xae, 0xc9, 0x8d, 0xf0, 0xc6,
	0x92, 0xe2, 0x94, 0x31, 0x54, 0xa3, 0xc3, 0xb1, 0x4b, 0x18, 0xa0, 0xef, 0xc2, 0x39, 0xb9, 0xd9,
	0xfb, 0xe4, 0x98, 0xf8, 0xfb, 0x78, 0x20, 0x8b, 0x22, 0xde, 0x58, 0x56, 0x2f, 0x78, 0x25, 0xff,
	0x82, 0x19, 0x90, 0x5d, 0xa4, 0xb3, 0x1c, 0x58, 0xc8, 0x08, 0x02, 0xbd, 0x06, 0xd0, 0x27, 0xcc,
	0x21, 0xa1, 0xc0, 0x3d, 0x73, 0x7a, 0x98, 0x9a, 0x47, 0xd7, 0x61, 0xa1, 0x8f, 0x07, 0x34, 0x12,
	0x49, 0x08, 0x8c, 0xfb, 0x90, 0xd9, 0x41, 0x0b, 0xc3, 0xb9, 0xc2, 0x66, 0xd0, 0x0d, 0x58, 0x54,
	0x55, 0x48, 0xcb, 0xf7, 0x77, 0x48, 0x48, 0x83, 0xa4, 0xd8, 0xcf, 0x8d, 0xca, 0x25, 0xd4, 0x08,
	0x71, 0x35, 0x4c, 0x06, 0xec, 0x9a, 0x9d, 0x1d, 0xb4, 0x7e, 0x31, 0x0b, 0x8d, 0xb2, 0x26, 0xed,
	0x0b, 0xef, 0xfb, 0x5f, 0xe6, 0x7d, 0x27, 0xf1, 0x9c, 0x73, 0x13, 0x7a, 0xce, 0x12, 0xef, 0x32,
	0xff, 0xd9, 0xbc, 0x4b, 0xd6, 0x39, 0xd4, 0x3e, 0x37, 0xe7, 0x00, 0x9f, 0xd1, 0x39, 0x58, 0xbf,
	0x9c, 0x85, 0x46, 0x59, 0x2b, 0xfb, 0x85, 0x1d, 0xfc, 0x9b, 0xed, 0xe0, 0xb4, 0x2c, 0x62, 0x76,
	0x82, 0x2c, 0x62, 0xb2, 0xc8, 0x3f, 0x37, 0x71, 0xe4, 0xff, 0x1f, 0xb3, 0x87, 0x7f, 0x54, 0x01,
	0x6d, 0x0f, 0xcb, 0x9f, 0x89, 0xef, 0xd8, 0xd2, 0x37, 0xac, 0x53, 0x93, 0xdc, 0xb0, 0x56, 0x27,
	0xbe, 0x7f, 0x9b, 0x7e, 0xce, 0xfb, 0xb7, 0x99, 0xe7, 0xbd, 0x7f, 0x9b, 0x7d, 0x8e, 0xfb, 0xb7,
	0x5a, 0xd9, 0xfd, 0x1b, 0x9c, 0x72, 0xff, 0x56, 0x2f, 0xdc, 0xbf, 0xdd, 0x33, 0xdc, 0xbf, 0xc5,
	0xb9, 0xdd, 0x65, 0x93, 0x4d, 0x4f, 0x76, 0xef, 0xb6, 0x30, 0xee, 0xde, 0xed, 0xf7, 0x15, 0xb8,
	0xd4, 0x1a, 0x6e, 0x80, 0x84, 0xc2, 0xeb, 0x7a, 0x84, 0xed, 0x10, 0x81, 0x3d, 0x9f, 0xe7, 0xf6,
	0x5b, 0x29, 0xec, 0x57, 0xe6, 0x1b, 0xfa, 0x9f, 0x4a, 0x58, 0x92, 0x94, 0x26, 0x33, 0xa8, 0x5a,
	0x30, 0x86, 0xea, 0xbf, 0x66, 0xe7, 0x87, 0xd3, 0xbb, 0x9e, 0x1e, 0xb7, 0xeb, 0x3f, 0xce, 0xc2,
	0xfc, 0xb0, 0x5b, 0x81, 0x60, 0x5a, 0x6a, 0x63, 0xf2, 0x01, 0x85, 0x7c, 0x46, 0xeb, 0x50, 0x17,
	0x49, 0x1f, 0x8b, 0x24, 0x69, 0x50, 0x7a, 0x28, 0x73, 0xbd, 0x58, 0x9d, 0xe4, 0x43, 0x9d, 0x27,
	0xb0, 0xde, 0x67, 0xc4, 0xd1, 0x0d, 0x6f, 0x92, 0xb8, 0x61, 0xd5, 0xdc, 0xd2, 0xaf, 0xab, 0x1d,
	0xe7, 0x2b, 0xa6, 0xb3, 0x2a, 0x08, 0xd7, 0x3e, 0x95, 0x1d, 0x7a, 0x13, 0xce, 0xc6, 0xe1, 0x44,
	0x7d, 0xdb, 0x91, 0xa8, 0xf5, 0xc5, 0x62, 0xfc, 0x51, 0xf3, 0x76, 0x06, 0x2c, 0xc5, 0x12, 0x90,
	0x80, 0xea, 0x6e, 0x97, 0x7a, 0x46, 0xef, 0xc2, 0x4b, 0x7d, 0xe6, 0x51, 0xe6, 0x09, 0xef, 0xe7,
	0xc4, 0x1d, 0x95, 0x1e, 0x73, 0x8a, 0xf1, 0x84, 0xfb, 0x36, 0xb2, 0x40, 0x3f, 0x80, 0xff, 0xa7,
	0xa1, 0x3f, 0xd8, 0x3e, 0x22, 0xce, 0xe3, 0xfd, 0x11, 0xa0, 0xe8, 0x4f, 0xb8, 0x2e, 0xe4, 0x26,
	0x85, 0xa3, 0x03, 0x78, 0xc5, 0x04, 0x2d, 0x16, 0x50, 0x71, 0x49, 0x37, 0x19, 0xb8, 0x8c, 0x6b,
	0x59, 0x71, 0x37, 0x19, 0x58, 0x07, 0x7b, 0x67, 0x74, 0x2b, 0x92, 0xc4, 0x8c, 0xba, 0x31, 0xd8,
	0x17, 0x81, 0xb6, 0x99, 0x1e, 0xbd, 0x0a, 0xcb, 0xb8, 0xdb, 0xf5, 0x7c, 0xe9, 0x30, 0x13, 0x23,
	0x52, 0x17, 0xea, 0x76, 0x61, 0x1c, 0x6d, 0x40, 0x3d, 0x8c, 0x82, 0x96, 0x10, 0x24, 0xe8, 0x0b,
	0x6e, 0xb4, 0xff, 0x34, 0xc0, 0xfa, 0x75, 0x45, 0x5d, 0x66, 0x19, 0x56, 0xfd, 0x06, 0x9c, 0xa3,
	0x85, 0xeb, 0x56, 0x53, 0x9d, 0x53, 0x84, 0xa1, 0x16, 0x2c, 0x27, 0x8e, 0x36, 0xb9, 0xf5, 0xd4,
	0xfd, 0xc3, 0x12, 0xf7, 0x5a, 0x80, 0x5b, 0xb7, 0x61, 0x51, 0xeb, 0x37, 0x16, 0x47, 0x1d, 0x41,
	0x02, 0xa9, 0xd4, 0x78, 0x78, 0xa5, 0x62, 0xab, 0x67, 0xd4, 0x80, 0x39, 0x1a, 0xda, 0x5e, 0xef,
	0x48, 0xe8, 0x3b, 0xa2, 0xe4, 0xaf, 0x35, 0x80, 0x7a, 0xca, 0x3e, 0x24, 0xb1, 0x4f, 0x70, 0x37,
	0x21, 0x96, 0xcf, 0xe8, 0x16, 0xcc, 0xe0, 0x54, 0x73, 0x75, 0xd5, 0x60, 0x5b, 0x7a, 0x6d, 0x3b,
	0x06, 0x4a, 0x9f, 0x97, 0x7c, 0x77, 0x84, 0x45, 0xc4, 0x88, 0xf6, 0x65, 0xd9, 0xc1, 0xf6, 0xfe,
	0x07, 0x4f, 0xd7, 0x2a, 0x1f, 0x3e, 0x5d, 0xab, 0x7c, 0xf2, 0x74, 0xad, 0xf2, 0xab, 0x67, 0x6b,
	0x67, 0x3e, 0x7c, 0xb6, 0x76, 0xe6, 0x2f, 0xcf, 0xd6, 0xce, 0xfc, 0xf0, 0xf5, 0x9e, 0x27, 0x8e,
	0xa2, 0xc3, 0x0d, 0x87, 0x06, 0xcd, 0x43, 0x4f, 0xe8, 0xef, 0x0f, 0x87, 0x4f, 0xce, 0x11, 0xf6,
	0xc2, 0xe6, 0x49, 0x53, 0x8f, 0x8b, 0x41, 0x3f, 0xfe, 0x3a, 0xf1, 0x70, 0x56, 0x7d, 0x75, 0xf8,
	0x95, 0x7f, 0x05, 0x00, 0x00, 0xff, 0xff, 0xa1, 0xee, 0x9c, 0xdc, 0x2e, 0x29, 0x00, 0x00,
}

func (m *UserBalanceStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserBalanceStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserBalanceStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserPermissions != nil {
		{
			size, err := m.UserPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.AutoApproveAllIncomingTransfers {
		i--
		if m.AutoApproveAllIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		i--
		if m.AutoApproveSelfInitiatedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		i--
		if m.AutoApproveSelfInitiatedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.IncomingApprovals) > 0 {
		for iNdEx := len(m.IncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IncomingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OutgoingApprovals) > 0 {
		for iNdEx := len(m.OutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutgoingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MerkleChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerkleChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LeafSigner) > 0 {
		i -= len(m.LeafSigner)
		copy(dAtA[i:], m.LeafSigner)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.LeafSigner)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.MaxUsesPerLeaf.Size()
		i -= size
		if _, err := m.MaxUsesPerLeaf.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.UseCreatorAddressAsLeaf {
		i--
		if m.UseCreatorAddressAsLeaf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ExpectedProofLength.Size()
		i -= size
		if _, err := m.ExpectedProofLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserOutgoingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserOutgoingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserOutgoingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Version.Size()
		i -= size
		if _, err := m.Version.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.ApprovalCriteria != nil {
		{
			size, err := m.ApprovalCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToListId) > 0 {
		i -= len(m.ToListId)
		copy(dAtA[i:], m.ToListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserIncomingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIncomingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserIncomingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Version.Size()
		i -= size
		if _, err := m.Version.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.ApprovalCriteria != nil {
		{
			size, err := m.ApprovalCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromListId) > 0 {
		i -= len(m.FromListId)
		copy(dAtA[i:], m.FromListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.FromListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ManualBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManualBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ManualBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecurringOwnershipTimes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecurringOwnershipTimes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecurringOwnershipTimes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ChargePeriodLength.Size()
		i -= size
		if _, err := m.ChargePeriodLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.IntervalLength.Size()
		i -= size
		if _, err := m.IntervalLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.StartTime.Size()
		i -= size
		if _, err := m.StartTime.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IncrementedBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrementedBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrementedBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowOverrideWithAnyValidBadge {
		i--
		if m.AllowOverrideWithAnyValidBadge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RecurringOwnershipTimes != nil {
		{
			size, err := m.RecurringOwnershipTimes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.AllowOverrideTimestamp {
		i--
		if m.AllowOverrideTimestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.DurationFromTimestamp.Size()
		i -= size
		if _, err := m.DurationFromTimestamp.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.IncrementOwnershipTimesBy.Size()
		i -= size
		if _, err := m.IncrementOwnershipTimesBy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.IncrementBadgeIdsBy.Size()
		i -= size
		if _, err := m.IncrementBadgeIdsBy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.StartBalances) > 0 {
		for iNdEx := len(m.StartBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StartBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PredeterminedOrderCalculationMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredeterminedOrderCalculationMethod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredeterminedOrderCalculationMethod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	if m.UseMerkleChallengeLeafIndex {
		i--
		if m.UseMerkleChallengeLeafIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.UsePerInitiatedByAddressNumTransfers {
		i--
		if m.UsePerInitiatedByAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UsePerFromAddressNumTransfers {
		i--
		if m.UsePerFromAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UsePerToAddressNumTransfers {
		i--
		if m.UsePerToAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UseOverallNumTransfers {
		i--
		if m.UseOverallNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PredeterminedBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredeterminedBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredeterminedBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderCalculationMethod != nil {
		{
			size, err := m.OrderCalculationMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IncrementedBalances != nil {
		{
			size, err := m.IncrementedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ManualBalances) > 0 {
		for iNdEx := len(m.ManualBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManualBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AutoDeletionOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoDeletionOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutoDeletionOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowPurgeIfExpired {
		i--
		if m.AllowPurgeIfExpired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AllowCounterpartyPurge {
		i--
		if m.AllowCounterpartyPurge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AfterOverallMaxNumTransfers {
		i--
		if m.AfterOverallMaxNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.AfterOneUse {
		i--
		if m.AfterOneUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ApprovalAmounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalAmounts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalAmounts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResetTimeIntervals != nil {
		{
			size, err := m.ResetTimeIntervals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AmountTrackerId) > 0 {
		i -= len(m.AmountTrackerId)
		copy(dAtA[i:], m.AmountTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.AmountTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.PerInitiatedByAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerInitiatedByAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PerFromAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerFromAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PerToAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerToAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OverallApprovalAmount.Size()
		i -= size
		if _, err := m.OverallApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResetTimeIntervals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetTimeIntervals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetTimeIntervals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.IntervalLength.Size()
		i -= size
		if _, err := m.IntervalLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.StartTime.Size()
		i -= size
		if _, err := m.StartTime.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MaxNumTransfers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxNumTransfers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxNumTransfers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResetTimeIntervals != nil {
		{
			size, err := m.ResetTimeIntervals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AmountTrackerId) > 0 {
		i -= len(m.AmountTrackerId)
		copy(dAtA[i:], m.AmountTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.AmountTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.PerInitiatedByAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerInitiatedByAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PerFromAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerFromAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PerToAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerToAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OverallMaxNumTransfers.Size()
		i -= size
		if _, err := m.OverallMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApprovalTracker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalTracker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalTracker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.LastUpdatedAt.Size()
		i -= size
		if _, err := m.LastUpdatedAt.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Amounts) > 0 {
		for iNdEx := len(m.Amounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.NumTransfers.Size()
		i -= size
		if _, err := m.NumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CoinTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverrideToWithInitiator {
		i--
		if m.OverrideToWithInitiator {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.OverrideFromWithApproverAddress {
		i--
		if m.OverrideFromWithApproverAddress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MustOwnBadges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MustOwnBadges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MustOwnBadges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MustSatisfyForAllAssets {
		i--
		if m.MustSatisfyForAllAssets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.OverrideWithCurrentTime {
		i--
		if m.OverrideWithCurrentTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.AmountRange != nil {
		{
			size, err := m.AmountRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DynamicStoreChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DynamicStoreChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DynamicStoreChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserLevelPayments != nil {
		{
			size, err := m.UserLevelPayments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.MustOwnBadges) > 0 {
		for iNdEx := len(m.MustOwnBadges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnBadges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.UserRoyalties != nil {
		{
			size, err := m.UserRoyalties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.OverridesToIncomingApprovals {
		i--
		if m.OverridesToIncomingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.OverridesFromOutgoingApprovals {
		i--
		if m.OverridesFromOutgoingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserRoyalties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRoyalties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRoyalties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PayoutAddress) > 0 {
		i -= len(m.PayoutAddress)
		copy(dAtA[i:], m.PayoutAddress)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.PayoutAddress)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Percentage.Size()
		i -= size
		if _, err := m.Percentage.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UserLevelPayments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserLevelPayments) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserLevelPayments) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AllowedDenoms) > 0 {
		for iNdEx := len(m.AllowedDenoms) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedDenoms[iNdEx])
			copy(dAtA[i:], m.AllowedDenoms[iNdEx])
			i = encodeVarintTransfers(dAtA, i, uint64(len(m.AllowedDenoms[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.AllowAllDenoms {
		i--
		if m.AllowAllDenoms {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OutgoingApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutgoingApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutgoingApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.MustOwnBadges) > 0 {
		for iNdEx := len(m.MustOwnBadges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnBadges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IncomingApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomingApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncomingApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.MustOwnBadges) > 0 {
		for iNdEx := len(m.MustOwnBadges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnBadges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Version.Size()
		i -= size
		if _, err := m.Version.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if m.ApprovalCriteria != nil {
		{
			size, err := m.ApprovalCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ToListId) > 0 {
		i -= len(m.ToListId)
		copy(dAtA[i:], m.ToListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromListId) > 0 {
		i -= len(m.FromListId)
		copy(dAtA[i:], m.FromListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.FromListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApprovalIdentifierDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalIdentifierDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalIdentifierDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Version.Size()
		i -= size
		if _, err := m.Version.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ApproverAddress) > 0 {
		i -= len(m.ApproverAddress)
		copy(dAtA[i:], m.ApproverAddress)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApproverAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ApprovalLevel) > 0 {
		i -= len(m.ApprovalLevel)
		copy(dAtA[i:], m.ApprovalLevel)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalLevel)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Transfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NumAttempts.Size()
		i -= size
		if _, err := m.NumAttempts.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if len(m.AffiliateAddress) > 0 {
		i -= len(m.AffiliateAddress)
		copy(dAtA[i:], m.AffiliateAddress)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.AffiliateAddress)))
		i--
		dAtA[i] = 0x62
	}
	if m.PrecalculationOptions != nil {
		{
			size, err := m.PrecalculationOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.OnlyCheckPrioritizedOutgoingApprovals {
		i--
		if m.OnlyCheckPrioritizedOutgoingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.OnlyCheckPrioritizedIncomingApprovals {
		i--
		if m.OnlyCheckPrioritizedIncomingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.OnlyCheckPrioritizedCollectionApprovals {
		i--
		if m.OnlyCheckPrioritizedCollectionApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.PrioritizedApprovals) > 0 {
		for iNdEx := len(m.PrioritizedApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrioritizedApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MerkleProofs) > 0 {
		for iNdEx := len(m.MerkleProofs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleProofs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PrecalculateBalancesFromApproval != nil {
		{
			size, err := m.PrecalculateBalancesFromApproval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ToAddresses) > 0 {
		for iNdEx := len(m.ToAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ToAddresses[iNdEx])
			copy(dAtA[i:], m.ToAddresses[iNdEx])
			i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToAddresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrecalculationOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrecalculationOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrecalculationOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BadgeIdsOverride) > 0 {
		for iNdEx := len(m.BadgeIdsOverride) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIdsOverride[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.OverrideTimestamp.Size()
		i -= size
		if _, err := m.OverrideTimestamp.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MerklePathItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerklePathItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerklePathItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OnRight {
		i--
		if m.OnRight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Aunt) > 0 {
		i -= len(m.Aunt)
		copy(dAtA[i:], m.Aunt)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Aunt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MerkleProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerkleProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LeafSignature) > 0 {
		i -= len(m.LeafSignature)
		copy(dAtA[i:], m.LeafSignature)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.LeafSignature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Aunts) > 0 {
		for iNdEx := len(m.Aunts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Aunts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Leaf) > 0 {
		i -= len(m.Leaf)
		copy(dAtA[i:], m.Leaf)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Leaf)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTransfers(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransfers(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserBalanceStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OutgoingApprovals) > 0 {
		for _, e := range m.OutgoingApprovals {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.IncomingApprovals) > 0 {
		for _, e := range m.IncomingApprovals {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		n += 2
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		n += 2
	}
	if m.AutoApproveAllIncomingTransfers {
		n += 2
	}
	if m.UserPermissions != nil {
		l = m.UserPermissions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *MerkleChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.ExpectedProofLength.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if m.UseCreatorAddressAsLeaf {
		n += 2
	}
	l = m.MaxUsesPerLeaf.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.LeafSigner)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *UserOutgoingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalCriteria != nil {
		l = m.ApprovalCriteria.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.Version.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *UserIncomingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalCriteria != nil {
		l = m.ApprovalCriteria.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.Version.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *ManualBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *RecurringOwnershipTimes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StartTime.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.IntervalLength.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.ChargePeriodLength.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *IncrementedBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StartBalances) > 0 {
		for _, e := range m.StartBalances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = m.IncrementBadgeIdsBy.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.IncrementOwnershipTimesBy.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.DurationFromTimestamp.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if m.AllowOverrideTimestamp {
		n += 2
	}
	if m.RecurringOwnershipTimes != nil {
		l = m.RecurringOwnershipTimes.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.AllowOverrideWithAnyValidBadge {
		n += 2
	}
	return n
}

func (m *PredeterminedOrderCalculationMethod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseOverallNumTransfers {
		n += 2
	}
	if m.UsePerToAddressNumTransfers {
		n += 2
	}
	if m.UsePerFromAddressNumTransfers {
		n += 2
	}
	if m.UsePerInitiatedByAddressNumTransfers {
		n += 2
	}
	if m.UseMerkleChallengeLeafIndex {
		n += 2
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *PredeterminedBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ManualBalances) > 0 {
		for _, e := range m.ManualBalances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.IncrementedBalances != nil {
		l = m.IncrementedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.OrderCalculationMethod != nil {
		l = m.OrderCalculationMethod.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *AutoDeletionOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AfterOneUse {
		n += 2
	}
	if m.AfterOverallMaxNumTransfers {
		n += 2
	}
	if m.AllowCounterpartyPurge {
		n += 2
	}
	if m.AllowPurgeIfExpired {
		n += 2
	}
	return n
}

func (m *ApprovalAmounts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OverallApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerToAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerFromAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerInitiatedByAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = len(m.AmountTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ResetTimeIntervals != nil {
		l = m.ResetTimeIntervals.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *ResetTimeIntervals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StartTime.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.IntervalLength.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *MaxNumTransfers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OverallMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerToAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerFromAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerInitiatedByAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = len(m.AmountTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ResetTimeIntervals != nil {
		l = m.ResetTimeIntervals.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *ApprovalTracker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if len(m.Amounts) > 0 {
		for _, e := range m.Amounts {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = m.LastUpdatedAt.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *CoinTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.OverrideFromWithApproverAddress {
		n += 2
	}
	if m.OverrideToWithInitiator {
		n += 2
	}
	return n
}

func (m *MustOwnBadges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if m.AmountRange != nil {
		l = m.AmountRange.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.OverrideWithCurrentTime {
		n += 2
	}
	if m.MustSatisfyForAllAssets {
		n += 2
	}
	return n
}

func (m *DynamicStoreChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StoreId.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *ApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.OverridesFromOutgoingApprovals {
		n += 2
	}
	if m.OverridesToIncomingApprovals {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.UserRoyalties != nil {
		l = m.UserRoyalties.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.MustOwnBadges) > 0 {
		for _, e := range m.MustOwnBadges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.UserLevelPayments != nil {
		l = m.UserLevelPayments.Size()
		n += 2 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *UserRoyalties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Percentage.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = len(m.PayoutAddress)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *UserLevelPayments) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAllDenoms {
		n += 2
	}
	if len(m.AllowedDenoms) > 0 {
		for _, s := range m.AllowedDenoms {
			l = len(s)
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *OutgoingApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.MustOwnBadges) > 0 {
		for _, e := range m.MustOwnBadges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *IncomingApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.MustOwnBadges) > 0 {
		for _, e := range m.MustOwnBadges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *CollectionApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ToListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalCriteria != nil {
		l = m.ApprovalCriteria.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.Version.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *ApprovalIdentifierDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalLevel)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApproverAddress)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.Version.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *Transfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.ToAddresses) > 0 {
		for _, s := range m.ToAddresses {
			l = len(s)
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PrecalculateBalancesFromApproval != nil {
		l = m.PrecalculateBalancesFromApproval.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.MerkleProofs) > 0 {
		for _, e := range m.MerkleProofs {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.PrioritizedApprovals) > 0 {
		for _, e := range m.PrioritizedApprovals {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.OnlyCheckPrioritizedCollectionApprovals {
		n += 2
	}
	if m.OnlyCheckPrioritizedIncomingApprovals {
		n += 2
	}
	if m.OnlyCheckPrioritizedOutgoingApprovals {
		n += 2
	}
	if m.PrecalculationOptions != nil {
		l = m.PrecalculationOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.AffiliateAddress)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.NumAttempts.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *PrecalculationOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OverrideTimestamp.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if len(m.BadgeIdsOverride) > 0 {
		for _, e := range m.BadgeIdsOverride {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *MerklePathItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Aunt)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.OnRight {
		n += 2
	}
	return n
}

func (m *MerkleProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Leaf)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.Aunts) > 0 {
		for _, e := range m.Aunts {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.LeafSignature)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func sovTransfers(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransfers(x uint64) (n int) {
	return sovTransfers(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserBalanceStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserBalanceStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserBalanceStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutgoingApprovals = append(m.OutgoingApprovals, &UserOutgoingApproval{})
			if err := m.OutgoingApprovals[len(m.OutgoingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncomingApprovals = append(m.IncomingApprovals, &UserIncomingApproval{})
			if err := m.IncomingApprovals[len(m.IncomingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveAllIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveAllIncomingTransfers = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPermissions == nil {
				m.UserPermissions = &UserPermissions{}
			}
			if err := m.UserPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedProofLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpectedProofLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCreatorAddressAsLeaf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseCreatorAddressAsLeaf = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUsesPerLeaf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxUsesPerLeaf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafSigner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeafSigner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserOutgoingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserOutgoingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserOutgoingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalCriteria == nil {
				m.ApprovalCriteria = &OutgoingApprovalCriteria{}
			}
			if err := m.ApprovalCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIncomingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIncomingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIncomingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalCriteria == nil {
				m.ApprovalCriteria = &IncomingApprovalCriteria{}
			}
			if err := m.ApprovalCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManualBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManualBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManualBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecurringOwnershipTimes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecurringOwnershipTimes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecurringOwnershipTimes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IntervalLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargePeriodLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChargePeriodLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrementedBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrementedBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrementedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartBalances = append(m.StartBalances, &Balance{})
			if err := m.StartBalances[len(m.StartBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementBadgeIdsBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncrementBadgeIdsBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementOwnershipTimesBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncrementOwnershipTimesBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationFromTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DurationFromTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideTimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideTimestamp = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecurringOwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecurringOwnershipTimes == nil {
				m.RecurringOwnershipTimes = &RecurringOwnershipTimes{}
			}
			if err := m.RecurringOwnershipTimes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideWithAnyValidBadge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideWithAnyValidBadge = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredeterminedOrderCalculationMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredeterminedOrderCalculationMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredeterminedOrderCalculationMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseOverallNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseOverallNumTransfers = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerToAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerToAddressNumTransfers = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerFromAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerFromAddressNumTransfers = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerInitiatedByAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerInitiatedByAddressNumTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMerkleChallengeLeafIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMerkleChallengeLeafIndex = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredeterminedBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredeterminedBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredeterminedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManualBalances = append(m.ManualBalances, &ManualBalances{})
			if err := m.ManualBalances[len(m.ManualBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncrementedBalances == nil {
				m.IncrementedBalances = &IncrementedBalances{}
			}
			if err := m.IncrementedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderCalculationMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderCalculationMethod == nil {
				m.OrderCalculationMethod = &PredeterminedOrderCalculationMethod{}
			}
			if err := m.OrderCalculationMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoDeletionOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoDeletionOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoDeletionOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterOneUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AfterOneUse = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterOverallMaxNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AfterOverallMaxNumTransfers = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCounterpartyPurge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowCounterpartyPurge = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPurgeIfExpired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPurgeIfExpired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalAmounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalAmounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalAmounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverallApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerToAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerToAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerFromAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerFromAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerInitiatedByAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerInitiatedByAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetTimeIntervals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResetTimeIntervals == nil {
				m.ResetTimeIntervals = &ResetTimeIntervals{}
			}
			if err := m.ResetTimeIntervals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetTimeIntervals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetTimeIntervals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetTimeIntervals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IntervalLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxNumTransfers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxNumTransfers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxNumTransfers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverallMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerToAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerToAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerFromAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerFromAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerInitiatedByAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerInitiatedByAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetTimeIntervals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResetTimeIntervals == nil {
				m.ResetTimeIntervals = &ResetTimeIntervals{}
			}
			if err := m.ResetTimeIntervals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalTracker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalTracker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalTracker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amounts = append(m.Amounts, &Balance{})
			if err := m.Amounts[len(m.Amounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastUpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, &types.Coin{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideFromWithApproverAddress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideFromWithApproverAddress = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideToWithInitiator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideToWithInitiator = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MustOwnBadges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MustOwnBadges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MustOwnBadges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AmountRange == nil {
				m.AmountRange = &UintRange{}
			}
			if err := m.AmountRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideWithCurrentTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverrideWithCurrentTime = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustSatisfyForAllAssets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustSatisfyForAllAssets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DynamicStoreChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DynamicStoreChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DynamicStoreChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesFromOutgoingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesFromOutgoingApprovals = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesToIncomingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesToIncomingApprovals = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRoyalties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserRoyalties == nil {
				m.UserRoyalties = &UserRoyalties{}
			}
			if err := m.UserRoyalties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnBadges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnBadges = append(m.MustOwnBadges, &MustOwnBadges{})
			if err := m.MustOwnBadges[len(m.MustOwnBadges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserLevelPayments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserLevelPayments == nil {
				m.UserLevelPayments = &UserLevelPayments{}
			}
			if err := m.UserLevelPayments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRoyalties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRoyalties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRoyalties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayoutAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserLevelPayments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserLevelPayments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserLevelPayments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAllDenoms", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowAllDenoms = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedDenoms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedDenoms = append(m.AllowedDenoms, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutgoingApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutgoingApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutgoingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnBadges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnBadges = append(m.MustOwnBadges, &MustOwnBadges{})
			if err := m.MustOwnBadges[len(m.MustOwnBadges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomingApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomingApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnBadges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnBadges = append(m.MustOwnBadges, &MustOwnBadges{})
			if err := m.MustOwnBadges[len(m.MustOwnBadges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalCriteria == nil {
				m.ApprovalCriteria = &ApprovalCriteria{}
			}
			if err := m.ApprovalCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalIdentifierDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalIdentifierDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalIdentifierDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproverAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApproverAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Version.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddresses = append(m.ToAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecalculateBalancesFromApproval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrecalculateBalancesFromApproval == nil {
				m.PrecalculateBalancesFromApproval = &ApprovalIdentifierDetails{}
			}
			if err := m.PrecalculateBalancesFromApproval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleProofs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleProofs = append(m.MerkleProofs, &MerkleProof{})
			if err := m.MerkleProofs[len(m.MerkleProofs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrioritizedApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrioritizedApprovals = append(m.PrioritizedApprovals, &ApprovalIdentifierDetails{})
			if err := m.PrioritizedApprovals[len(m.PrioritizedApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedCollectionApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyCheckPrioritizedCollectionApprovals = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedIncomingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyCheckPrioritizedIncomingApprovals = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedOutgoingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyCheckPrioritizedOutgoingApprovals = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecalculationOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrecalculationOptions == nil {
				m.PrecalculationOptions = &PrecalculationOptions{}
			}
			if err := m.PrecalculationOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffiliateAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AffiliateAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAttempts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NumAttempts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrecalculationOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrecalculationOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrecalculationOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverrideTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOverride", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIdsOverride = append(m.BadgeIdsOverride, &UintRange{})
			if err := m.BadgeIdsOverride[len(m.BadgeIdsOverride)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerklePathItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerklePathItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerklePathItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aunt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aunt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnRight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnRight = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leaf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aunts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aunts = append(m.Aunts, &MerklePathItem{})
			if err := m.Aunts[len(m.Aunts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeafSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransfers(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransfers
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransfers
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransfers
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransfers        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransfers          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransfers = fmt.Errorf("proto: unexpected end of group")
)
