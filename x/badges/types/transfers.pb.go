// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/transfers.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UserBalanceStore is the store for the user balances
// It consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,
// and the permissions for updating the approved incoming/outgoing transfers.
//
// The default approved outgoing / incoming transfers are defined by the collection.
//
// The outgoing transfers can be used to allow / disallow transfers which are sent from this user.
// If a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user).
//
// The incoming transfers can be used to allow / disallow transfers which are sent to this user.
// If a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user).
//
// Note that the user approved transfers are only checked if the collection approved transfers do not specify to override
// the user approved transfers.
type UserBalanceStore struct {
	Balances                          []*Balance                              `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
	ApprovedOutgoingTransfersTimeline []*UserApprovedOutgoingTransferTimeline `protobuf:"bytes,2,rep,name=approvedOutgoingTransfersTimeline,proto3" json:"approvedOutgoingTransfersTimeline,omitempty"`
	ApprovedIncomingTransfersTimeline []*UserApprovedIncomingTransferTimeline `protobuf:"bytes,3,rep,name=approvedIncomingTransfersTimeline,proto3" json:"approvedIncomingTransfersTimeline,omitempty"`
	UserPermissions                   *UserPermissions                        `protobuf:"bytes,4,opt,name=userPermissions,proto3" json:"userPermissions,omitempty"`
}

func (m *UserBalanceStore) Reset()         { *m = UserBalanceStore{} }
func (m *UserBalanceStore) String() string { return proto.CompactTextString(m) }
func (*UserBalanceStore) ProtoMessage()    {}
func (*UserBalanceStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{0}
}
func (m *UserBalanceStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserBalanceStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserBalanceStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserBalanceStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserBalanceStore.Merge(m, src)
}
func (m *UserBalanceStore) XXX_Size() int {
	return m.Size()
}
func (m *UserBalanceStore) XXX_DiscardUnknown() {
	xxx_messageInfo_UserBalanceStore.DiscardUnknown(m)
}

var xxx_messageInfo_UserBalanceStore proto.InternalMessageInfo

func (m *UserBalanceStore) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *UserBalanceStore) GetApprovedOutgoingTransfersTimeline() []*UserApprovedOutgoingTransferTimeline {
	if m != nil {
		return m.ApprovedOutgoingTransfersTimeline
	}
	return nil
}

func (m *UserBalanceStore) GetApprovedIncomingTransfersTimeline() []*UserApprovedIncomingTransferTimeline {
	if m != nil {
		return m.ApprovedIncomingTransfersTimeline
	}
	return nil
}

func (m *UserBalanceStore) GetUserPermissions() *UserPermissions {
	if m != nil {
		return m.UserPermissions
	}
	return nil
}

type UserApprovedOutgoingTransferTimeline struct {
	ApprovedOutgoingTransfers []*UserApprovedOutgoingTransfer `protobuf:"bytes,1,rep,name=approvedOutgoingTransfers,proto3" json:"approvedOutgoingTransfers,omitempty"`
	TimelineTimes             []*UintRange                    `protobuf:"bytes,2,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
}

func (m *UserApprovedOutgoingTransferTimeline) Reset()         { *m = UserApprovedOutgoingTransferTimeline{} }
func (m *UserApprovedOutgoingTransferTimeline) String() string { return proto.CompactTextString(m) }
func (*UserApprovedOutgoingTransferTimeline) ProtoMessage()    {}
func (*UserApprovedOutgoingTransferTimeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{1}
}
func (m *UserApprovedOutgoingTransferTimeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedOutgoingTransferTimeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedOutgoingTransferTimeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedOutgoingTransferTimeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedOutgoingTransferTimeline.Merge(m, src)
}
func (m *UserApprovedOutgoingTransferTimeline) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedOutgoingTransferTimeline) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedOutgoingTransferTimeline.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedOutgoingTransferTimeline proto.InternalMessageInfo

func (m *UserApprovedOutgoingTransferTimeline) GetApprovedOutgoingTransfers() []*UserApprovedOutgoingTransfer {
	if m != nil {
		return m.ApprovedOutgoingTransfers
	}
	return nil
}

func (m *UserApprovedOutgoingTransferTimeline) GetTimelineTimes() []*UintRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

type UserApprovedIncomingTransferTimeline struct {
	ApprovedIncomingTransfers []*UserApprovedIncomingTransfer `protobuf:"bytes,1,rep,name=approvedIncomingTransfers,proto3" json:"approvedIncomingTransfers,omitempty"`
	TimelineTimes             []*UintRange                    `protobuf:"bytes,2,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
}

func (m *UserApprovedIncomingTransferTimeline) Reset()         { *m = UserApprovedIncomingTransferTimeline{} }
func (m *UserApprovedIncomingTransferTimeline) String() string { return proto.CompactTextString(m) }
func (*UserApprovedIncomingTransferTimeline) ProtoMessage()    {}
func (*UserApprovedIncomingTransferTimeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{2}
}
func (m *UserApprovedIncomingTransferTimeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedIncomingTransferTimeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedIncomingTransferTimeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedIncomingTransferTimeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedIncomingTransferTimeline.Merge(m, src)
}
func (m *UserApprovedIncomingTransferTimeline) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedIncomingTransferTimeline) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedIncomingTransferTimeline.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedIncomingTransferTimeline proto.InternalMessageInfo

func (m *UserApprovedIncomingTransferTimeline) GetApprovedIncomingTransfers() []*UserApprovedIncomingTransfer {
	if m != nil {
		return m.ApprovedIncomingTransfers
	}
	return nil
}

func (m *UserApprovedIncomingTransferTimeline) GetTimelineTimes() []*UintRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

// Challenges define the rules for the approval.
// If all challenge are not met with valid solutions, then the transfer is not approved.
//
// Currently, we only support Merkle tree challenges where the Merkle path must be to the provided root
// and be the expected length.
//
// We also support the following options:
// -useCreatorAddressAsLeaf: If true, then the leaf will be set to the creator address. Used for whitelist trees.
// -maxOneUsePerLeaf: If true, then each leaf can only be used once. If false, then the leaf can be used multiple times.
// This is very important to be set to true if you want to prevent replay attacks.
// -useLeafIndexForDistributionOrder: If true, we will use the leafIndex to determine the order of the distribution of badges.
// leafIndex 0 will be the leftmost leaf of the expectedProofLength layer
//
// IMPORTANT: We track the number of uses per leaf according to a challenge ID.
// Please use unique challenge IDs for different challenges of the same timeline.
// If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
// It is highly recommended to avoid updating a challenge without resetting the tally via a new challenge ID.
type MerkleChallenge struct {
	Root                         string `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty"`
	ExpectedProofLength          Uint   `protobuf:"bytes,2,opt,name=expectedProofLength,proto3,customtype=Uint" json:"expectedProofLength"`
	UseCreatorAddressAsLeaf      bool   `protobuf:"varint,3,opt,name=useCreatorAddressAsLeaf,proto3" json:"useCreatorAddressAsLeaf,omitempty"`
	MaxOneUsePerLeaf             bool   `protobuf:"varint,4,opt,name=maxOneUsePerLeaf,proto3" json:"maxOneUsePerLeaf,omitempty"`
	UseLeafIndexForTransferOrder bool   `protobuf:"varint,5,opt,name=useLeafIndexForTransferOrder,proto3" json:"useLeafIndexForTransferOrder,omitempty"`
	ChallengeId                  string `protobuf:"bytes,6,opt,name=challengeId,proto3" json:"challengeId,omitempty"`
}

func (m *MerkleChallenge) Reset()         { *m = MerkleChallenge{} }
func (m *MerkleChallenge) String() string { return proto.CompactTextString(m) }
func (*MerkleChallenge) ProtoMessage()    {}
func (*MerkleChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{3}
}
func (m *MerkleChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerkleChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerkleChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerkleChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerkleChallenge.Merge(m, src)
}
func (m *MerkleChallenge) XXX_Size() int {
	return m.Size()
}
func (m *MerkleChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_MerkleChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_MerkleChallenge proto.InternalMessageInfo

func (m *MerkleChallenge) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

func (m *MerkleChallenge) GetUseCreatorAddressAsLeaf() bool {
	if m != nil {
		return m.UseCreatorAddressAsLeaf
	}
	return false
}

func (m *MerkleChallenge) GetMaxOneUsePerLeaf() bool {
	if m != nil {
		return m.MaxOneUsePerLeaf
	}
	return false
}

func (m *MerkleChallenge) GetUseLeafIndexForTransferOrder() bool {
	if m != nil {
		return m.UseLeafIndexForTransferOrder
	}
	return false
}

func (m *MerkleChallenge) GetChallengeId() string {
	if m != nil {
		return m.ChallengeId
	}
	return ""
}

type IsUserOutgoingTransferAllowed struct {
	ToMappingOptions          *ValueOptions `protobuf:"bytes,2,opt,name=toMappingOptions,proto3" json:"toMappingOptions,omitempty"`
	InitiatedByMappingOptions *ValueOptions `protobuf:"bytes,3,opt,name=initiatedByMappingOptions,proto3" json:"initiatedByMappingOptions,omitempty"`
	TransferTimesOptions      *ValueOptions `protobuf:"bytes,4,opt,name=transferTimesOptions,proto3" json:"transferTimesOptions,omitempty"`
	BadgeIdsOptions           *ValueOptions `protobuf:"bytes,5,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	OwnedTimesOptions         *ValueOptions `protobuf:"bytes,6,opt,name=ownedTimesOptions,proto3" json:"ownedTimesOptions,omitempty"`
	IsAllowed                 bool          `protobuf:"varint,7,opt,name=isAllowed,proto3" json:"isAllowed,omitempty"`
}

func (m *IsUserOutgoingTransferAllowed) Reset()         { *m = IsUserOutgoingTransferAllowed{} }
func (m *IsUserOutgoingTransferAllowed) String() string { return proto.CompactTextString(m) }
func (*IsUserOutgoingTransferAllowed) ProtoMessage()    {}
func (*IsUserOutgoingTransferAllowed) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{4}
}
func (m *IsUserOutgoingTransferAllowed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsUserOutgoingTransferAllowed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsUserOutgoingTransferAllowed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsUserOutgoingTransferAllowed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsUserOutgoingTransferAllowed.Merge(m, src)
}
func (m *IsUserOutgoingTransferAllowed) XXX_Size() int {
	return m.Size()
}
func (m *IsUserOutgoingTransferAllowed) XXX_DiscardUnknown() {
	xxx_messageInfo_IsUserOutgoingTransferAllowed.DiscardUnknown(m)
}

var xxx_messageInfo_IsUserOutgoingTransferAllowed proto.InternalMessageInfo

func (m *IsUserOutgoingTransferAllowed) GetToMappingOptions() *ValueOptions {
	if m != nil {
		return m.ToMappingOptions
	}
	return nil
}

func (m *IsUserOutgoingTransferAllowed) GetInitiatedByMappingOptions() *ValueOptions {
	if m != nil {
		return m.InitiatedByMappingOptions
	}
	return nil
}

func (m *IsUserOutgoingTransferAllowed) GetTransferTimesOptions() *ValueOptions {
	if m != nil {
		return m.TransferTimesOptions
	}
	return nil
}

func (m *IsUserOutgoingTransferAllowed) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *IsUserOutgoingTransferAllowed) GetOwnedTimesOptions() *ValueOptions {
	if m != nil {
		return m.OwnedTimesOptions
	}
	return nil
}

func (m *IsUserOutgoingTransferAllowed) GetIsAllowed() bool {
	if m != nil {
		return m.IsAllowed
	}
	return false
}

type IsUserIncomingTransferAllowed struct {
	FromMappingOptions        *ValueOptions `protobuf:"bytes,2,opt,name=fromMappingOptions,proto3" json:"fromMappingOptions,omitempty"`
	InitiatedByMappingOptions *ValueOptions `protobuf:"bytes,3,opt,name=initiatedByMappingOptions,proto3" json:"initiatedByMappingOptions,omitempty"`
	TransferTimesOptions      *ValueOptions `protobuf:"bytes,4,opt,name=transferTimesOptions,proto3" json:"transferTimesOptions,omitempty"`
	BadgeIdsOptions           *ValueOptions `protobuf:"bytes,5,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	OwnedTimesOptions         *ValueOptions `protobuf:"bytes,6,opt,name=ownedTimesOptions,proto3" json:"ownedTimesOptions,omitempty"`
	IsAllowed                 bool          `protobuf:"varint,7,opt,name=isAllowed,proto3" json:"isAllowed,omitempty"`
}

func (m *IsUserIncomingTransferAllowed) Reset()         { *m = IsUserIncomingTransferAllowed{} }
func (m *IsUserIncomingTransferAllowed) String() string { return proto.CompactTextString(m) }
func (*IsUserIncomingTransferAllowed) ProtoMessage()    {}
func (*IsUserIncomingTransferAllowed) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{5}
}
func (m *IsUserIncomingTransferAllowed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsUserIncomingTransferAllowed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsUserIncomingTransferAllowed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsUserIncomingTransferAllowed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsUserIncomingTransferAllowed.Merge(m, src)
}
func (m *IsUserIncomingTransferAllowed) XXX_Size() int {
	return m.Size()
}
func (m *IsUserIncomingTransferAllowed) XXX_DiscardUnknown() {
	xxx_messageInfo_IsUserIncomingTransferAllowed.DiscardUnknown(m)
}

var xxx_messageInfo_IsUserIncomingTransferAllowed proto.InternalMessageInfo

func (m *IsUserIncomingTransferAllowed) GetFromMappingOptions() *ValueOptions {
	if m != nil {
		return m.FromMappingOptions
	}
	return nil
}

func (m *IsUserIncomingTransferAllowed) GetInitiatedByMappingOptions() *ValueOptions {
	if m != nil {
		return m.InitiatedByMappingOptions
	}
	return nil
}

func (m *IsUserIncomingTransferAllowed) GetTransferTimesOptions() *ValueOptions {
	if m != nil {
		return m.TransferTimesOptions
	}
	return nil
}

func (m *IsUserIncomingTransferAllowed) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *IsUserIncomingTransferAllowed) GetOwnedTimesOptions() *ValueOptions {
	if m != nil {
		return m.OwnedTimesOptions
	}
	return nil
}

func (m *IsUserIncomingTransferAllowed) GetIsAllowed() bool {
	if m != nil {
		return m.IsAllowed
	}
	return false
}

// UserApprovedOutgoingTransfer defines the rules for the approval of an outgoing transfer from a user.
// See CollectionApprovedTransfer for more details. This is the same minus a few fields.
type UserApprovedOutgoingTransfer struct {
	ToMappingId          string                           `protobuf:"bytes,1,opt,name=toMappingId,proto3" json:"toMappingId,omitempty"`
	InitiatedByMappingId string                           `protobuf:"bytes,2,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	TransferTimes        []*UintRange                     `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	BadgeIds             []*UintRange                     `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	OwnedTimes           []*UintRange                     `protobuf:"bytes,16,rep,name=ownedTimes,proto3" json:"ownedTimes,omitempty"`
	AllowedCombinations  []*IsUserOutgoingTransferAllowed `protobuf:"bytes,5,rep,name=allowedCombinations,proto3" json:"allowedCombinations,omitempty"`
	ApprovalDetails      []*OutgoingApprovalDetails       `protobuf:"bytes,6,rep,name=approvalDetails,proto3" json:"approvalDetails,omitempty"`
}

func (m *UserApprovedOutgoingTransfer) Reset()         { *m = UserApprovedOutgoingTransfer{} }
func (m *UserApprovedOutgoingTransfer) String() string { return proto.CompactTextString(m) }
func (*UserApprovedOutgoingTransfer) ProtoMessage()    {}
func (*UserApprovedOutgoingTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{6}
}
func (m *UserApprovedOutgoingTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedOutgoingTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedOutgoingTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedOutgoingTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedOutgoingTransfer.Merge(m, src)
}
func (m *UserApprovedOutgoingTransfer) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedOutgoingTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedOutgoingTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedOutgoingTransfer proto.InternalMessageInfo

func (m *UserApprovedOutgoingTransfer) GetToMappingId() string {
	if m != nil {
		return m.ToMappingId
	}
	return ""
}

func (m *UserApprovedOutgoingTransfer) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *UserApprovedOutgoingTransfer) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserApprovedOutgoingTransfer) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserApprovedOutgoingTransfer) GetOwnedTimes() []*UintRange {
	if m != nil {
		return m.OwnedTimes
	}
	return nil
}

func (m *UserApprovedOutgoingTransfer) GetAllowedCombinations() []*IsUserOutgoingTransferAllowed {
	if m != nil {
		return m.AllowedCombinations
	}
	return nil
}

func (m *UserApprovedOutgoingTransfer) GetApprovalDetails() []*OutgoingApprovalDetails {
	if m != nil {
		return m.ApprovalDetails
	}
	return nil
}

// UserApprovedIncomingTransfer defines the rules for the approval of an incoming transfer to a user.
// See CollectionApprovedTransfer for more details. This is the same minus a few fields.
type UserApprovedIncomingTransfer struct {
	FromMappingId        string                           `protobuf:"bytes,1,opt,name=fromMappingId,proto3" json:"fromMappingId,omitempty"`
	InitiatedByMappingId string                           `protobuf:"bytes,2,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	TransferTimes        []*UintRange                     `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	BadgeIds             []*UintRange                     `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	OwnedTimes           []*UintRange                     `protobuf:"bytes,16,rep,name=ownedTimes,proto3" json:"ownedTimes,omitempty"`
	AllowedCombinations  []*IsUserIncomingTransferAllowed `protobuf:"bytes,5,rep,name=allowedCombinations,proto3" json:"allowedCombinations,omitempty"`
	ApprovalDetails      []*IncomingApprovalDetails       `protobuf:"bytes,11,rep,name=approvalDetails,proto3" json:"approvalDetails,omitempty"`
}

func (m *UserApprovedIncomingTransfer) Reset()         { *m = UserApprovedIncomingTransfer{} }
func (m *UserApprovedIncomingTransfer) String() string { return proto.CompactTextString(m) }
func (*UserApprovedIncomingTransfer) ProtoMessage()    {}
func (*UserApprovedIncomingTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{7}
}
func (m *UserApprovedIncomingTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedIncomingTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedIncomingTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedIncomingTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedIncomingTransfer.Merge(m, src)
}
func (m *UserApprovedIncomingTransfer) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedIncomingTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedIncomingTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedIncomingTransfer proto.InternalMessageInfo

func (m *UserApprovedIncomingTransfer) GetFromMappingId() string {
	if m != nil {
		return m.FromMappingId
	}
	return ""
}

func (m *UserApprovedIncomingTransfer) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *UserApprovedIncomingTransfer) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserApprovedIncomingTransfer) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserApprovedIncomingTransfer) GetOwnedTimes() []*UintRange {
	if m != nil {
		return m.OwnedTimes
	}
	return nil
}

func (m *UserApprovedIncomingTransfer) GetAllowedCombinations() []*IsUserIncomingTransferAllowed {
	if m != nil {
		return m.AllowedCombinations
	}
	return nil
}

func (m *UserApprovedIncomingTransfer) GetApprovalDetails() []*IncomingApprovalDetails {
	if m != nil {
		return m.ApprovalDetails
	}
	return nil
}

type IsCollectionTransferAllowed struct {
	FromMappingOptions        *ValueOptions `protobuf:"bytes,1,opt,name=fromMappingOptions,proto3" json:"fromMappingOptions,omitempty"`
	ToMappingOptions          *ValueOptions `protobuf:"bytes,2,opt,name=toMappingOptions,proto3" json:"toMappingOptions,omitempty"`
	InitiatedByMappingOptions *ValueOptions `protobuf:"bytes,3,opt,name=initiatedByMappingOptions,proto3" json:"initiatedByMappingOptions,omitempty"`
	TransferTimesOptions      *ValueOptions `protobuf:"bytes,4,opt,name=transferTimesOptions,proto3" json:"transferTimesOptions,omitempty"`
	BadgeIdsOptions           *ValueOptions `protobuf:"bytes,5,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	OwnedTimesOptions         *ValueOptions `protobuf:"bytes,6,opt,name=ownedTimesOptions,proto3" json:"ownedTimesOptions,omitempty"`
	IsAllowed                 bool          `protobuf:"varint,7,opt,name=isAllowed,proto3" json:"isAllowed,omitempty"`
}

func (m *IsCollectionTransferAllowed) Reset()         { *m = IsCollectionTransferAllowed{} }
func (m *IsCollectionTransferAllowed) String() string { return proto.CompactTextString(m) }
func (*IsCollectionTransferAllowed) ProtoMessage()    {}
func (*IsCollectionTransferAllowed) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{8}
}
func (m *IsCollectionTransferAllowed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsCollectionTransferAllowed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsCollectionTransferAllowed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsCollectionTransferAllowed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsCollectionTransferAllowed.Merge(m, src)
}
func (m *IsCollectionTransferAllowed) XXX_Size() int {
	return m.Size()
}
func (m *IsCollectionTransferAllowed) XXX_DiscardUnknown() {
	xxx_messageInfo_IsCollectionTransferAllowed.DiscardUnknown(m)
}

var xxx_messageInfo_IsCollectionTransferAllowed proto.InternalMessageInfo

func (m *IsCollectionTransferAllowed) GetFromMappingOptions() *ValueOptions {
	if m != nil {
		return m.FromMappingOptions
	}
	return nil
}

func (m *IsCollectionTransferAllowed) GetToMappingOptions() *ValueOptions {
	if m != nil {
		return m.ToMappingOptions
	}
	return nil
}

func (m *IsCollectionTransferAllowed) GetInitiatedByMappingOptions() *ValueOptions {
	if m != nil {
		return m.InitiatedByMappingOptions
	}
	return nil
}

func (m *IsCollectionTransferAllowed) GetTransferTimesOptions() *ValueOptions {
	if m != nil {
		return m.TransferTimesOptions
	}
	return nil
}

func (m *IsCollectionTransferAllowed) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *IsCollectionTransferAllowed) GetOwnedTimesOptions() *ValueOptions {
	if m != nil {
		return m.OwnedTimesOptions
	}
	return nil
}

func (m *IsCollectionTransferAllowed) GetIsAllowed() bool {
	if m != nil {
		return m.IsAllowed
	}
	return false
}

type ManualBalances struct {
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
}

func (m *ManualBalances) Reset()         { *m = ManualBalances{} }
func (m *ManualBalances) String() string { return proto.CompactTextString(m) }
func (*ManualBalances) ProtoMessage()    {}
func (*ManualBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{9}
}
func (m *ManualBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ManualBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ManualBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ManualBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManualBalances.Merge(m, src)
}
func (m *ManualBalances) XXX_Size() int {
	return m.Size()
}
func (m *ManualBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_ManualBalances.DiscardUnknown(m)
}

var xxx_messageInfo_ManualBalances proto.InternalMessageInfo

func (m *ManualBalances) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

type IncrementedBalances struct {
	StartBalances         []*Balance `protobuf:"bytes,1,rep,name=startBalances,proto3" json:"startBalances,omitempty"`
	IncrementBadgeIdsBy   Uint       `protobuf:"bytes,2,opt,name=incrementBadgeIdsBy,proto3,customtype=Uint" json:"incrementBadgeIdsBy"`
	IncrementOwnedTimesBy Uint       `protobuf:"bytes,3,opt,name=incrementOwnedTimesBy,proto3,customtype=Uint" json:"incrementOwnedTimesBy"`
}

func (m *IncrementedBalances) Reset()         { *m = IncrementedBalances{} }
func (m *IncrementedBalances) String() string { return proto.CompactTextString(m) }
func (*IncrementedBalances) ProtoMessage()    {}
func (*IncrementedBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{10}
}
func (m *IncrementedBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrementedBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncrementedBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncrementedBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrementedBalances.Merge(m, src)
}
func (m *IncrementedBalances) XXX_Size() int {
	return m.Size()
}
func (m *IncrementedBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrementedBalances.DiscardUnknown(m)
}

var xxx_messageInfo_IncrementedBalances proto.InternalMessageInfo

func (m *IncrementedBalances) GetStartBalances() []*Balance {
	if m != nil {
		return m.StartBalances
	}
	return nil
}

type PredeterminedOrderCalculationMethod struct {
	UseOverallNumTransfers               bool `protobuf:"varint,1,opt,name=useOverallNumTransfers,proto3" json:"useOverallNumTransfers,omitempty"`
	UsePerToAddressNumTransfers          bool `protobuf:"varint,2,opt,name=usePerToAddressNumTransfers,proto3" json:"usePerToAddressNumTransfers,omitempty"`
	UsePerFromAddressNumTransfers        bool `protobuf:"varint,3,opt,name=usePerFromAddressNumTransfers,proto3" json:"usePerFromAddressNumTransfers,omitempty"`
	UsePerInitiatedByAddressNumTransfers bool `protobuf:"varint,4,opt,name=usePerInitiatedByAddressNumTransfers,proto3" json:"usePerInitiatedByAddressNumTransfers,omitempty"`
	UseMerkleChallengeLeafIndex          bool `protobuf:"varint,5,opt,name=useMerkleChallengeLeafIndex,proto3" json:"useMerkleChallengeLeafIndex,omitempty"`
}

func (m *PredeterminedOrderCalculationMethod) Reset()         { *m = PredeterminedOrderCalculationMethod{} }
func (m *PredeterminedOrderCalculationMethod) String() string { return proto.CompactTextString(m) }
func (*PredeterminedOrderCalculationMethod) ProtoMessage()    {}
func (*PredeterminedOrderCalculationMethod) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{11}
}
func (m *PredeterminedOrderCalculationMethod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredeterminedOrderCalculationMethod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredeterminedOrderCalculationMethod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredeterminedOrderCalculationMethod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredeterminedOrderCalculationMethod.Merge(m, src)
}
func (m *PredeterminedOrderCalculationMethod) XXX_Size() int {
	return m.Size()
}
func (m *PredeterminedOrderCalculationMethod) XXX_DiscardUnknown() {
	xxx_messageInfo_PredeterminedOrderCalculationMethod.DiscardUnknown(m)
}

var xxx_messageInfo_PredeterminedOrderCalculationMethod proto.InternalMessageInfo

func (m *PredeterminedOrderCalculationMethod) GetUseOverallNumTransfers() bool {
	if m != nil {
		return m.UseOverallNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerToAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerToAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerFromAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerFromAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerInitiatedByAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerInitiatedByAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUseMerkleChallengeLeafIndex() bool {
	if m != nil {
		return m.UseMerkleChallengeLeafIndex
	}
	return false
}

type PredeterminedBalances struct {
	ManualBalances         []*ManualBalances                    `protobuf:"bytes,1,rep,name=manualBalances,proto3" json:"manualBalances,omitempty"`
	IncrementedBalances    *IncrementedBalances                 `protobuf:"bytes,2,opt,name=incrementedBalances,proto3" json:"incrementedBalances,omitempty"`
	OrderCalculationMethod *PredeterminedOrderCalculationMethod `protobuf:"bytes,3,opt,name=orderCalculationMethod,proto3" json:"orderCalculationMethod,omitempty"`
}

func (m *PredeterminedBalances) Reset()         { *m = PredeterminedBalances{} }
func (m *PredeterminedBalances) String() string { return proto.CompactTextString(m) }
func (*PredeterminedBalances) ProtoMessage()    {}
func (*PredeterminedBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{12}
}
func (m *PredeterminedBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredeterminedBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredeterminedBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredeterminedBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredeterminedBalances.Merge(m, src)
}
func (m *PredeterminedBalances) XXX_Size() int {
	return m.Size()
}
func (m *PredeterminedBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_PredeterminedBalances.DiscardUnknown(m)
}

var xxx_messageInfo_PredeterminedBalances proto.InternalMessageInfo

func (m *PredeterminedBalances) GetManualBalances() []*ManualBalances {
	if m != nil {
		return m.ManualBalances
	}
	return nil
}

func (m *PredeterminedBalances) GetIncrementedBalances() *IncrementedBalances {
	if m != nil {
		return m.IncrementedBalances
	}
	return nil
}

func (m *PredeterminedBalances) GetOrderCalculationMethod() *PredeterminedOrderCalculationMethod {
	if m != nil {
		return m.OrderCalculationMethod
	}
	return nil
}

// PerAddressApprovals defines the approvals per unique from, to, and/or initiatedBy address.
type ApprovalAmounts struct {
	OverallApprovalAmount               Uint `protobuf:"bytes,1,opt,name=overallApprovalAmount,proto3,customtype=Uint" json:"overallApprovalAmount"`
	PerToAddressApprovalAmount          Uint `protobuf:"bytes,2,opt,name=perToAddressApprovalAmount,proto3,customtype=Uint" json:"perToAddressApprovalAmount"`
	PerFromAddressApprovalAmount        Uint `protobuf:"bytes,3,opt,name=perFromAddressApprovalAmount,proto3,customtype=Uint" json:"perFromAddressApprovalAmount"`
	PerInitiatedByAddressApprovalAmount Uint `protobuf:"bytes,4,opt,name=perInitiatedByAddressApprovalAmount,proto3,customtype=Uint" json:"perInitiatedByAddressApprovalAmount"`
}

func (m *ApprovalAmounts) Reset()         { *m = ApprovalAmounts{} }
func (m *ApprovalAmounts) String() string { return proto.CompactTextString(m) }
func (*ApprovalAmounts) ProtoMessage()    {}
func (*ApprovalAmounts) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{13}
}
func (m *ApprovalAmounts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalAmounts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalAmounts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalAmounts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalAmounts.Merge(m, src)
}
func (m *ApprovalAmounts) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalAmounts) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalAmounts.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalAmounts proto.InternalMessageInfo

type MaxNumTransfers struct {
	OverallMaxNumTransfers               Uint `protobuf:"bytes,1,opt,name=overallMaxNumTransfers,proto3,customtype=Uint" json:"overallMaxNumTransfers"`
	PerToAddressMaxNumTransfers          Uint `protobuf:"bytes,2,opt,name=perToAddressMaxNumTransfers,proto3,customtype=Uint" json:"perToAddressMaxNumTransfers"`
	PerFromAddressMaxNumTransfers        Uint `protobuf:"bytes,3,opt,name=perFromAddressMaxNumTransfers,proto3,customtype=Uint" json:"perFromAddressMaxNumTransfers"`
	PerInitiatedByAddressMaxNumTransfers Uint `protobuf:"bytes,4,opt,name=perInitiatedByAddressMaxNumTransfers,proto3,customtype=Uint" json:"perInitiatedByAddressMaxNumTransfers"`
}

func (m *MaxNumTransfers) Reset()         { *m = MaxNumTransfers{} }
func (m *MaxNumTransfers) String() string { return proto.CompactTextString(m) }
func (*MaxNumTransfers) ProtoMessage()    {}
func (*MaxNumTransfers) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{14}
}
func (m *MaxNumTransfers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxNumTransfers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxNumTransfers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxNumTransfers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxNumTransfers.Merge(m, src)
}
func (m *MaxNumTransfers) XXX_Size() int {
	return m.Size()
}
func (m *MaxNumTransfers) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxNumTransfers.DiscardUnknown(m)
}

var xxx_messageInfo_MaxNumTransfers proto.InternalMessageInfo

type ApprovalsTracker struct {
	NumTransfers Uint       `protobuf:"bytes,1,opt,name=numTransfers,proto3,customtype=Uint" json:"numTransfers"`
	Amounts      []*Balance `protobuf:"bytes,2,rep,name=amounts,proto3" json:"amounts,omitempty"`
}

func (m *ApprovalsTracker) Reset()         { *m = ApprovalsTracker{} }
func (m *ApprovalsTracker) String() string { return proto.CompactTextString(m) }
func (*ApprovalsTracker) ProtoMessage()    {}
func (*ApprovalsTracker) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{15}
}
func (m *ApprovalsTracker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalsTracker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalsTracker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalsTracker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalsTracker.Merge(m, src)
}
func (m *ApprovalsTracker) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalsTracker) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalsTracker.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalsTracker proto.InternalMessageInfo

func (m *ApprovalsTracker) GetAmounts() []*Balance {
	if m != nil {
		return m.Amounts
	}
	return nil
}

type ApprovalDetails struct {
	ApprovalId                             string                 `protobuf:"bytes,6,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	Uri                                    string                 `protobuf:"bytes,7,opt,name=uri,proto3" json:"uri,omitempty"`
	CustomData                             string                 `protobuf:"bytes,8,opt,name=customData,proto3" json:"customData,omitempty"`
	MustOwnBadges                          []*MustOwnBadges       `protobuf:"bytes,1,rep,name=mustOwnBadges,proto3" json:"mustOwnBadges,omitempty"`
	MerkleChallenges                       []*MerkleChallenge     `protobuf:"bytes,2,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	PredeterminedBalances                  *PredeterminedBalances `protobuf:"bytes,3,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	ApprovalAmounts                        *ApprovalAmounts       `protobuf:"bytes,4,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	MaxNumTransfers                        *MaxNumTransfers       `protobuf:"bytes,5,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	RequireToEqualsInitiatedBy             bool                   `protobuf:"varint,9,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	RequireFromEqualsInitiatedBy           bool                   `protobuf:"varint,10,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	RequireToDoesNotEqualInitiatedBy       bool                   `protobuf:"varint,11,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
	RequireFromDoesNotEqualInitiatedBy     bool                   `protobuf:"varint,12,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
	OverridesFromApprovedOutgoingTransfers bool                   `protobuf:"varint,13,opt,name=overridesFromApprovedOutgoingTransfers,proto3" json:"overridesFromApprovedOutgoingTransfers,omitempty"`
	OverridesToApprovedIncomingTransfers   bool                   `protobuf:"varint,14,opt,name=overridesToApprovedIncomingTransfers,proto3" json:"overridesToApprovedIncomingTransfers,omitempty"`
}

func (m *ApprovalDetails) Reset()         { *m = ApprovalDetails{} }
func (m *ApprovalDetails) String() string { return proto.CompactTextString(m) }
func (*ApprovalDetails) ProtoMessage()    {}
func (*ApprovalDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{16}
}
func (m *ApprovalDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalDetails.Merge(m, src)
}
func (m *ApprovalDetails) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalDetails proto.InternalMessageInfo

func (m *ApprovalDetails) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *ApprovalDetails) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *ApprovalDetails) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *ApprovalDetails) GetMustOwnBadges() []*MustOwnBadges {
	if m != nil {
		return m.MustOwnBadges
	}
	return nil
}

func (m *ApprovalDetails) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *ApprovalDetails) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *ApprovalDetails) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *ApprovalDetails) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *ApprovalDetails) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalDetails) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalDetails) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalDetails) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalDetails) GetOverridesFromApprovedOutgoingTransfers() bool {
	if m != nil {
		return m.OverridesFromApprovedOutgoingTransfers
	}
	return false
}

func (m *ApprovalDetails) GetOverridesToApprovedIncomingTransfers() bool {
	if m != nil {
		return m.OverridesToApprovedIncomingTransfers
	}
	return false
}

type OutgoingApprovalDetails struct {
	ApprovalId                       string                 `protobuf:"bytes,6,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	Uri                              string                 `protobuf:"bytes,7,opt,name=uri,proto3" json:"uri,omitempty"`
	CustomData                       string                 `protobuf:"bytes,8,opt,name=customData,proto3" json:"customData,omitempty"`
	MustOwnBadges                    []*MustOwnBadges       `protobuf:"bytes,1,rep,name=mustOwnBadges,proto3" json:"mustOwnBadges,omitempty"`
	MerkleChallenges                 []*MerkleChallenge     `protobuf:"bytes,2,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	PredeterminedBalances            *PredeterminedBalances `protobuf:"bytes,3,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	ApprovalAmounts                  *ApprovalAmounts       `protobuf:"bytes,4,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	MaxNumTransfers                  *MaxNumTransfers       `protobuf:"bytes,5,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	RequireToEqualsInitiatedBy       bool                   `protobuf:"varint,9,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	RequireToDoesNotEqualInitiatedBy bool                   `protobuf:"varint,11,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
}

func (m *OutgoingApprovalDetails) Reset()         { *m = OutgoingApprovalDetails{} }
func (m *OutgoingApprovalDetails) String() string { return proto.CompactTextString(m) }
func (*OutgoingApprovalDetails) ProtoMessage()    {}
func (*OutgoingApprovalDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{17}
}
func (m *OutgoingApprovalDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutgoingApprovalDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutgoingApprovalDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutgoingApprovalDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutgoingApprovalDetails.Merge(m, src)
}
func (m *OutgoingApprovalDetails) XXX_Size() int {
	return m.Size()
}
func (m *OutgoingApprovalDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_OutgoingApprovalDetails.DiscardUnknown(m)
}

var xxx_messageInfo_OutgoingApprovalDetails proto.InternalMessageInfo

func (m *OutgoingApprovalDetails) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *OutgoingApprovalDetails) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *OutgoingApprovalDetails) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *OutgoingApprovalDetails) GetMustOwnBadges() []*MustOwnBadges {
	if m != nil {
		return m.MustOwnBadges
	}
	return nil
}

func (m *OutgoingApprovalDetails) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *OutgoingApprovalDetails) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *OutgoingApprovalDetails) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *OutgoingApprovalDetails) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *OutgoingApprovalDetails) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *OutgoingApprovalDetails) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

type IncomingApprovalDetails struct {
	ApprovalId                         string                 `protobuf:"bytes,6,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	Uri                                string                 `protobuf:"bytes,7,opt,name=uri,proto3" json:"uri,omitempty"`
	CustomData                         string                 `protobuf:"bytes,8,opt,name=customData,proto3" json:"customData,omitempty"`
	MustOwnBadges                      []*MustOwnBadges       `protobuf:"bytes,1,rep,name=mustOwnBadges,proto3" json:"mustOwnBadges,omitempty"`
	MerkleChallenges                   []*MerkleChallenge     `protobuf:"bytes,2,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	PredeterminedBalances              *PredeterminedBalances `protobuf:"bytes,3,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	ApprovalAmounts                    *ApprovalAmounts       `protobuf:"bytes,4,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	MaxNumTransfers                    *MaxNumTransfers       `protobuf:"bytes,5,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	RequireFromEqualsInitiatedBy       bool                   `protobuf:"varint,10,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	RequireFromDoesNotEqualInitiatedBy bool                   `protobuf:"varint,12,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
}

func (m *IncomingApprovalDetails) Reset()         { *m = IncomingApprovalDetails{} }
func (m *IncomingApprovalDetails) String() string { return proto.CompactTextString(m) }
func (*IncomingApprovalDetails) ProtoMessage()    {}
func (*IncomingApprovalDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{18}
}
func (m *IncomingApprovalDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncomingApprovalDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncomingApprovalDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncomingApprovalDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncomingApprovalDetails.Merge(m, src)
}
func (m *IncomingApprovalDetails) XXX_Size() int {
	return m.Size()
}
func (m *IncomingApprovalDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_IncomingApprovalDetails.DiscardUnknown(m)
}

var xxx_messageInfo_IncomingApprovalDetails proto.InternalMessageInfo

func (m *IncomingApprovalDetails) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *IncomingApprovalDetails) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *IncomingApprovalDetails) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *IncomingApprovalDetails) GetMustOwnBadges() []*MustOwnBadges {
	if m != nil {
		return m.MustOwnBadges
	}
	return nil
}

func (m *IncomingApprovalDetails) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *IncomingApprovalDetails) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *IncomingApprovalDetails) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *IncomingApprovalDetails) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *IncomingApprovalDetails) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *IncomingApprovalDetails) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

type CollectionApprovedTransfer struct {
	// Match Criteria
	FromMappingId        string                         `protobuf:"bytes,4,opt,name=fromMappingId,proto3" json:"fromMappingId,omitempty"`
	ToMappingId          string                         `protobuf:"bytes,5,opt,name=toMappingId,proto3" json:"toMappingId,omitempty"`
	InitiatedByMappingId string                         `protobuf:"bytes,6,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	TransferTimes        []*UintRange                   `protobuf:"bytes,7,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	BadgeIds             []*UintRange                   `protobuf:"bytes,8,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	OwnedTimes           []*UintRange                   `protobuf:"bytes,9,rep,name=ownedTimes,proto3" json:"ownedTimes,omitempty"`
	AllowedCombinations  []*IsCollectionTransferAllowed `protobuf:"bytes,10,rep,name=allowedCombinations,proto3" json:"allowedCombinations,omitempty"`
	// Restrictions (Challenges, Amounts, MaxNumTransfers)
	ApprovalDetails []*ApprovalDetails `protobuf:"bytes,11,rep,name=approvalDetails,proto3" json:"approvalDetails,omitempty"`
}

func (m *CollectionApprovedTransfer) Reset()         { *m = CollectionApprovedTransfer{} }
func (m *CollectionApprovedTransfer) String() string { return proto.CompactTextString(m) }
func (*CollectionApprovedTransfer) ProtoMessage()    {}
func (*CollectionApprovedTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{19}
}
func (m *CollectionApprovedTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApprovedTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApprovedTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApprovedTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApprovedTransfer.Merge(m, src)
}
func (m *CollectionApprovedTransfer) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApprovedTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApprovedTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApprovedTransfer proto.InternalMessageInfo

func (m *CollectionApprovedTransfer) GetFromMappingId() string {
	if m != nil {
		return m.FromMappingId
	}
	return ""
}

func (m *CollectionApprovedTransfer) GetToMappingId() string {
	if m != nil {
		return m.ToMappingId
	}
	return ""
}

func (m *CollectionApprovedTransfer) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *CollectionApprovedTransfer) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *CollectionApprovedTransfer) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *CollectionApprovedTransfer) GetOwnedTimes() []*UintRange {
	if m != nil {
		return m.OwnedTimes
	}
	return nil
}

func (m *CollectionApprovedTransfer) GetAllowedCombinations() []*IsCollectionTransferAllowed {
	if m != nil {
		return m.AllowedCombinations
	}
	return nil
}

func (m *CollectionApprovedTransfer) GetApprovalDetails() []*ApprovalDetails {
	if m != nil {
		return m.ApprovalDetails
	}
	return nil
}

type ApprovalIdDetails struct {
	ApprovalId    string `protobuf:"bytes,1,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	ApprovalLevel string `protobuf:"bytes,2,opt,name=approvalLevel,proto3" json:"approvalLevel,omitempty"`
	Address       string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *ApprovalIdDetails) Reset()         { *m = ApprovalIdDetails{} }
func (m *ApprovalIdDetails) String() string { return proto.CompactTextString(m) }
func (*ApprovalIdDetails) ProtoMessage()    {}
func (*ApprovalIdDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{20}
}
func (m *ApprovalIdDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalIdDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalIdDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalIdDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalIdDetails.Merge(m, src)
}
func (m *ApprovalIdDetails) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalIdDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalIdDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalIdDetails proto.InternalMessageInfo

func (m *ApprovalIdDetails) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *ApprovalIdDetails) GetApprovalLevel() string {
	if m != nil {
		return m.ApprovalLevel
	}
	return ""
}

func (m *ApprovalIdDetails) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type Transfer struct {
	From                     string             `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	ToAddresses              []string           `protobuf:"bytes,2,rep,name=toAddresses,proto3" json:"toAddresses,omitempty"`
	Balances                 []*Balance         `protobuf:"bytes,3,rep,name=balances,proto3" json:"balances,omitempty"`
	PrecalculateFromApproval *ApprovalIdDetails `protobuf:"bytes,4,opt,name=precalculateFromApproval,proto3" json:"precalculateFromApproval,omitempty"`
	MerkleProofs             []*MerkleProof     `protobuf:"bytes,5,rep,name=merkleProofs,proto3" json:"merkleProofs,omitempty"`
	Memo                     string             `protobuf:"bytes,6,opt,name=memo,proto3" json:"memo,omitempty"`
}

func (m *Transfer) Reset()         { *m = Transfer{} }
func (m *Transfer) String() string { return proto.CompactTextString(m) }
func (*Transfer) ProtoMessage()    {}
func (*Transfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{21}
}
func (m *Transfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transfer.Merge(m, src)
}
func (m *Transfer) XXX_Size() int {
	return m.Size()
}
func (m *Transfer) XXX_DiscardUnknown() {
	xxx_messageInfo_Transfer.DiscardUnknown(m)
}

var xxx_messageInfo_Transfer proto.InternalMessageInfo

func (m *Transfer) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Transfer) GetToAddresses() []string {
	if m != nil {
		return m.ToAddresses
	}
	return nil
}

func (m *Transfer) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *Transfer) GetPrecalculateFromApproval() *ApprovalIdDetails {
	if m != nil {
		return m.PrecalculateFromApproval
	}
	return nil
}

func (m *Transfer) GetMerkleProofs() []*MerkleProof {
	if m != nil {
		return m.MerkleProofs
	}
	return nil
}

func (m *Transfer) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

type MerklePathItem struct {
	Aunt    string `protobuf:"bytes,1,opt,name=aunt,proto3" json:"aunt,omitempty"`
	OnRight bool   `protobuf:"varint,2,opt,name=onRight,proto3" json:"onRight,omitempty"`
}

func (m *MerklePathItem) Reset()         { *m = MerklePathItem{} }
func (m *MerklePathItem) String() string { return proto.CompactTextString(m) }
func (*MerklePathItem) ProtoMessage()    {}
func (*MerklePathItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{22}
}
func (m *MerklePathItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerklePathItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerklePathItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerklePathItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerklePathItem.Merge(m, src)
}
func (m *MerklePathItem) XXX_Size() int {
	return m.Size()
}
func (m *MerklePathItem) XXX_DiscardUnknown() {
	xxx_messageInfo_MerklePathItem.DiscardUnknown(m)
}

var xxx_messageInfo_MerklePathItem proto.InternalMessageInfo

func (m *MerklePathItem) GetAunt() string {
	if m != nil {
		return m.Aunt
	}
	return ""
}

func (m *MerklePathItem) GetOnRight() bool {
	if m != nil {
		return m.OnRight
	}
	return false
}

// Consistent with tendermint/crypto merkle tree
type MerkleProof struct {
	Leaf  string            `protobuf:"bytes,1,opt,name=leaf,proto3" json:"leaf,omitempty"`
	Aunts []*MerklePathItem `protobuf:"bytes,2,rep,name=aunts,proto3" json:"aunts,omitempty"`
}

func (m *MerkleProof) Reset()         { *m = MerkleProof{} }
func (m *MerkleProof) String() string { return proto.CompactTextString(m) }
func (*MerkleProof) ProtoMessage()    {}
func (*MerkleProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{23}
}
func (m *MerkleProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerkleProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerkleProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerkleProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerkleProof.Merge(m, src)
}
func (m *MerkleProof) XXX_Size() int {
	return m.Size()
}
func (m *MerkleProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MerkleProof.DiscardUnknown(m)
}

var xxx_messageInfo_MerkleProof proto.InternalMessageInfo

func (m *MerkleProof) GetLeaf() string {
	if m != nil {
		return m.Leaf
	}
	return ""
}

func (m *MerkleProof) GetAunts() []*MerklePathItem {
	if m != nil {
		return m.Aunts
	}
	return nil
}

func init() {
	proto.RegisterType((*UserBalanceStore)(nil), "bitbadges.bitbadgeschain.badges.UserBalanceStore")
	proto.RegisterType((*UserApprovedOutgoingTransferTimeline)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedOutgoingTransferTimeline")
	proto.RegisterType((*UserApprovedIncomingTransferTimeline)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedIncomingTransferTimeline")
	proto.RegisterType((*MerkleChallenge)(nil), "bitbadges.bitbadgeschain.badges.MerkleChallenge")
	proto.RegisterType((*IsUserOutgoingTransferAllowed)(nil), "bitbadges.bitbadgeschain.badges.IsUserOutgoingTransferAllowed")
	proto.RegisterType((*IsUserIncomingTransferAllowed)(nil), "bitbadges.bitbadgeschain.badges.IsUserIncomingTransferAllowed")
	proto.RegisterType((*UserApprovedOutgoingTransfer)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedOutgoingTransfer")
	proto.RegisterType((*UserApprovedIncomingTransfer)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedIncomingTransfer")
	proto.RegisterType((*IsCollectionTransferAllowed)(nil), "bitbadges.bitbadgeschain.badges.IsCollectionTransferAllowed")
	proto.RegisterType((*ManualBalances)(nil), "bitbadges.bitbadgeschain.badges.ManualBalances")
	proto.RegisterType((*IncrementedBalances)(nil), "bitbadges.bitbadgeschain.badges.IncrementedBalances")
	proto.RegisterType((*PredeterminedOrderCalculationMethod)(nil), "bitbadges.bitbadgeschain.badges.PredeterminedOrderCalculationMethod")
	proto.RegisterType((*PredeterminedBalances)(nil), "bitbadges.bitbadgeschain.badges.PredeterminedBalances")
	proto.RegisterType((*ApprovalAmounts)(nil), "bitbadges.bitbadgeschain.badges.ApprovalAmounts")
	proto.RegisterType((*MaxNumTransfers)(nil), "bitbadges.bitbadgeschain.badges.MaxNumTransfers")
	proto.RegisterType((*ApprovalsTracker)(nil), "bitbadges.bitbadgeschain.badges.ApprovalsTracker")
	proto.RegisterType((*ApprovalDetails)(nil), "bitbadges.bitbadgeschain.badges.ApprovalDetails")
	proto.RegisterType((*OutgoingApprovalDetails)(nil), "bitbadges.bitbadgeschain.badges.OutgoingApprovalDetails")
	proto.RegisterType((*IncomingApprovalDetails)(nil), "bitbadges.bitbadgeschain.badges.IncomingApprovalDetails")
	proto.RegisterType((*CollectionApprovedTransfer)(nil), "bitbadges.bitbadgeschain.badges.CollectionApprovedTransfer")
	proto.RegisterType((*ApprovalIdDetails)(nil), "bitbadges.bitbadgeschain.badges.ApprovalIdDetails")
	proto.RegisterType((*Transfer)(nil), "bitbadges.bitbadgeschain.badges.Transfer")
	proto.RegisterType((*MerklePathItem)(nil), "bitbadges.bitbadgeschain.badges.MerklePathItem")
	proto.RegisterType((*MerkleProof)(nil), "bitbadges.bitbadgeschain.badges.MerkleProof")
}

func init() { proto.RegisterFile("badges/transfers.proto", fileDescriptor_db7d8388ebf2a03f) }

var fileDescriptor_db7d8388ebf2a03f = []byte{
	// 1817 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x5b, 0x6f, 0xdc, 0xc4,
	0x17, 0xcf, 0x6e, 0x36, 0xb7, 0x93, 0x6b, 0xa7, 0x4d, 0xea, 0xa6, 0x49, 0x9a, 0xbf, 0x1b, 0xfd,
	0x15, 0x55, 0x90, 0xad, 0x02, 0xaa, 0xfa, 0x00, 0x11, 0xbb, 0x49, 0x2b, 0x6d, 0x95, 0x9b, 0x4c,
	0xda, 0x8a, 0x70, 0x9d, 0xac, 0x27, 0xbb, 0x56, 0x6d, 0xcf, 0xd6, 0x97, 0x36, 0x11, 0x7c, 0x00,
	0x78, 0x43, 0xe2, 0x9d, 0x07, 0x3e, 0x01, 0x48, 0x7c, 0x88, 0x8a, 0xa7, 0xf2, 0x00, 0x02, 0x04,
	0x55, 0xd5, 0x3e, 0xf1, 0x01, 0x78, 0xea, 0x0b, 0x9a, 0xf1, 0xd8, 0x6b, 0x7b, 0xed, 0x5d, 0x67,
	0xbb, 0x45, 0x42, 0xe4, 0x6d, 0x3c, 0x73, 0xce, 0xef, 0x8c, 0xcf, 0xfc, 0xce, 0x99, 0x99, 0x63,
	0xc3, 0xcc, 0x01, 0x56, 0x6b, 0xc4, 0x2e, 0x3a, 0x16, 0x36, 0xed, 0x43, 0x62, 0xd9, 0x2b, 0x0d,
	0x8b, 0x3a, 0x14, 0x5d, 0x3a, 0xd0, 0x1c, 0x6f, 0x68, 0x25, 0x68, 0x55, 0xeb, 0x58, 0x33, 0x57,
	0xbc, 0xf6, 0xec, 0xb9, 0x1a, 0xad, 0x51, 0x2e, 0x5b, 0x64, 0x2d, 0x4f, 0x6d, 0x56, 0x12, 0x70,
	0x0d, 0x62, 0x19, 0x9a, 0x6d, 0x6b, 0xd4, 0x14, 0x80, 0xb3, 0xf3, 0x62, 0x04, 0xab, 0xaa, 0x45,
	0x6c, 0xfb, 0x63, 0x03, 0x37, 0x1a, 0x9a, 0x59, 0xf3, 0x87, 0xa7, 0xc5, 0xf0, 0x01, 0xd6, 0xb1,
	0x59, 0x25, 0xa2, 0x5b, 0x7e, 0xda, 0x0f, 0x53, 0xb7, 0x6d, 0x62, 0x95, 0xbd, 0xee, 0x77, 0x1d,
	0x6a, 0x11, 0xb4, 0x01, 0xc3, 0xbe, 0x98, 0x94, 0x5b, 0xec, 0x5f, 0x1e, 0x5d, 0x5d, 0x5e, 0xe9,
	0x30, 0xdd, 0x15, 0x01, 0xa0, 0x04, 0x9a, 0xe8, 0xab, 0x1c, 0xfc, 0x0f, 0x37, 0x1a, 0x16, 0x7d,
	0x40, 0xd4, 0x1d, 0xd7, 0xa9, 0x51, 0xcd, 0xac, 0xed, 0xf9, 0x5e, 0xd8, 0xd3, 0x0c, 0xa2, 0x6b,
	0x26, 0x91, 0xf2, 0x1c, 0xff, 0x46, 0x47, 0x7c, 0x36, 0xc9, 0x52, 0x0a, 0x9a, 0x0f, 0xa6, 0x74,
	0xb6, 0x17, 0x99, 0x55, 0xc5, 0xac, 0x52, 0x23, 0x71, 0x56, 0xfd, 0x5d, 0xcc, 0x2a, 0x8e, 0xd6,
	0x3a, 0xab, 0x54, 0x7b, 0x68, 0x1f, 0x26, 0x5d, 0x9b, 0x58, 0xbb, 0xcd, 0x55, 0x95, 0x0a, 0x8b,
	0xb9, 0xe5, 0xd1, 0xd5, 0xab, 0x99, 0xa6, 0x10, 0xd2, 0x53, 0xe2, 0x40, 0xf2, 0x5f, 0x39, 0x58,
	0xca, 0xe2, 0x3d, 0xf4, 0x29, 0x5c, 0x48, 0xf5, 0x9f, 0xe0, 0xc1, 0xdb, 0x2f, 0xb5, 0x4e, 0x4a,
	0x3a, 0x3e, 0xda, 0x85, 0x71, 0x47, 0x4c, 0x84, 0x4d, 0xc8, 0x16, 0xc4, 0xb8, 0xd2, 0xd9, 0xa0,
	0x66, 0x3a, 0x0a, 0x36, 0x6b, 0x44, 0x89, 0x02, 0xb4, 0xbc, 0x77, 0xda, 0xfa, 0x84, 0xdf, 0xbb,
	0x65, 0x85, 0xba, 0x7a, 0xef, 0x38, 0x8a, 0x92, 0x8e, 0xff, 0x0a, 0xde, 0xfb, 0xbb, 0x3c, 0x4c,
	0x6e, 0x11, 0xeb, 0x9e, 0x4e, 0xd6, 0xeb, 0x58, 0xd7, 0x89, 0x59, 0x23, 0x08, 0x41, 0xc1, 0xa2,
	0xd4, 0x91, 0x72, 0x8b, 0xb9, 0xe5, 0x11, 0x85, 0xb7, 0xd1, 0x1a, 0x9c, 0x25, 0x47, 0x0d, 0x52,
	0x75, 0x88, 0xba, 0x6b, 0x51, 0x7a, 0xb8, 0x49, 0xcc, 0x9a, 0x53, 0x97, 0xf2, 0x4c, 0xa4, 0x3c,
	0xf6, 0xe8, 0xc9, 0xa5, 0xbe, 0xdf, 0x9e, 0x5c, 0x2a, 0x70, 0x33, 0x49, 0x82, 0xe8, 0x3a, 0x9c,
	0x77, 0x6d, 0xb2, 0x6e, 0x11, 0xec, 0x50, 0xab, 0xe4, 0x65, 0x9d, 0x92, 0xbd, 0x49, 0xf0, 0xa1,
	0xd4, 0xbf, 0x98, 0x5b, 0x1e, 0x56, 0xd2, 0x86, 0xd1, 0x15, 0x98, 0x32, 0xf0, 0xd1, 0x8e, 0x49,
	0x6e, 0xdb, 0x64, 0x97, 0x58, 0x5c, 0xa5, 0xc0, 0x55, 0x5a, 0xfa, 0x51, 0x19, 0xe6, 0x5c, 0x9b,
	0xb0, 0x66, 0xc5, 0x54, 0xc9, 0xd1, 0x4d, 0x6a, 0xf9, 0xbe, 0xdb, 0xb1, 0x54, 0x62, 0x49, 0x03,
	0x5c, 0xaf, 0xad, 0x0c, 0x5a, 0x84, 0xd1, 0xaa, 0xef, 0x8a, 0x8a, 0x2a, 0x0d, 0x72, 0x27, 0x84,
	0xbb, 0xe4, 0xaf, 0x0b, 0x30, 0x5f, 0xb1, 0xd9, 0x1a, 0xc6, 0x99, 0x59, 0xd2, 0x75, 0xfa, 0x90,
	0xa8, 0xe8, 0x3d, 0x98, 0x72, 0xe8, 0x96, 0x97, 0x53, 0x77, 0x1a, 0x0e, 0x0f, 0xd1, 0x3c, 0x0f,
	0xd1, 0xd7, 0x3b, 0x2e, 0xd5, 0x1d, 0xac, 0xbb, 0x44, 0x28, 0x29, 0x2d, 0x30, 0xe8, 0x1e, 0x5c,
	0xd0, 0x4c, 0xcd, 0xd1, 0xb0, 0x43, 0xd4, 0xf2, 0x71, 0xcc, 0x46, 0x7f, 0x37, 0x36, 0xd2, 0xf1,
	0x10, 0x86, 0x73, 0x4e, 0x28, 0x00, 0x6c, 0xdf, 0x4e, 0xa1, 0x1b, 0x3b, 0x89, 0x50, 0xe8, 0x2e,
	0x4c, 0x72, 0xe1, 0x8a, 0x1a, 0xa0, 0x0f, 0x74, 0x83, 0x1e, 0x47, 0x41, 0xef, 0xc3, 0x19, 0xfa,
	0xd0, 0x24, 0x6a, 0x64, 0xe2, 0x83, 0xdd, 0x40, 0xb7, 0xe2, 0xa0, 0x39, 0x18, 0xd1, 0x6c, 0xb1,
	0xda, 0xd2, 0x10, 0x67, 0x55, 0xb3, 0x43, 0xfe, 0x26, 0x20, 0x48, 0x3c, 0x84, 0x7d, 0x82, 0x7c,
	0x08, 0xe8, 0xd0, 0xa2, 0x46, 0x2f, 0x28, 0x92, 0x00, 0x74, 0x4a, 0x92, 0x7f, 0x01, 0x49, 0xbe,
	0x2d, 0xc0, 0x5c, 0xbb, 0xfd, 0x8f, 0x25, 0xa2, 0x20, 0xfa, 0x2b, 0xaa, 0xc8, 0xc6, 0xe1, 0x2e,
	0xb4, 0x0a, 0xe7, 0x5a, 0x97, 0xa5, 0xa2, 0x7a, 0x59, 0x59, 0x49, 0x1c, 0xe3, 0x5b, 0x48, 0xd8,
	0xc5, 0xe2, 0xf4, 0x72, 0xb2, 0x2d, 0x24, 0x0c, 0x80, 0x6e, 0xb2, 0x03, 0xa0, 0xe7, 0x56, 0xa9,
	0x70, 0x62, 0xb0, 0x40, 0x17, 0xdd, 0x02, 0x68, 0xfa, 0x50, 0x9a, 0x3a, 0x31, 0x52, 0x48, 0x1b,
	0x35, 0xe0, 0x2c, 0xf6, 0xfc, 0xbc, 0x4e, 0x8d, 0x03, 0xcd, 0xc4, 0x3e, 0x69, 0x18, 0xe8, 0x5a,
	0x47, 0xd0, 0xb6, 0xd9, 0x5d, 0x49, 0x82, 0x46, 0x07, 0x30, 0xe9, 0xed, 0xdb, 0x58, 0xdf, 0x20,
	0x0e, 0xd6, 0x74, 0xc6, 0x23, 0x66, 0xed, 0x7a, 0x47, 0x6b, 0xbe, 0x9d, 0x52, 0x54, 0x5f, 0x89,
	0x03, 0xca, 0xdf, 0xc7, 0x28, 0x13, 0xcf, 0x2e, 0x68, 0x09, 0xc6, 0x43, 0xd9, 0x20, 0x20, 0x4d,
	0xb4, 0xf3, 0x94, 0x36, 0xaf, 0x96, 0x36, 0x29, 0x39, 0x3f, 0x33, 0x6d, 0x46, 0x33, 0xd2, 0xc6,
	0xb7, 0xd3, 0x91, 0x36, 0x2f, 0x0a, 0x70, 0xb1, 0x62, 0xaf, 0x53, 0x5d, 0x27, 0x55, 0x66, 0x35,
	0xdb, 0x66, 0x94, 0xeb, 0xd5, 0x66, 0x74, 0x7a, 0x18, 0xfa, 0x4f, 0xef, 0x73, 0x77, 0x60, 0x62,
	0x0b, 0x9b, 0x2e, 0xd6, 0xcb, 0xfe, 0x5d, 0xbf, 0x27, 0x15, 0x03, 0xf9, 0xcf, 0x1c, 0x9c, 0xad,
	0x98, 0x55, 0x8b, 0x18, 0xc4, 0x64, 0xcb, 0xe5, 0xa3, 0x6f, 0xc3, 0xb8, 0xed, 0x60, 0xcb, 0x29,
	0x77, 0x6b, 0x22, 0xaa, 0xce, 0x6e, 0x3e, 0x9a, 0x6f, 0xa6, 0x2c, 0xdc, 0x5a, 0x3e, 0x4e, 0xbe,
	0xf9, 0x24, 0x08, 0xa2, 0x32, 0x4c, 0x07, 0xdd, 0x3b, 0x81, 0xef, 0xca, 0xc7, 0x9c, 0x9f, 0x71,
	0x84, 0x64, 0x51, 0xf9, 0x45, 0x1e, 0x2e, 0xef, 0x5a, 0x44, 0x25, 0x0e, 0xbb, 0xaa, 0x9b, 0x44,
	0xe5, 0x57, 0x95, 0x75, 0xac, 0x57, 0x5d, 0x9d, 0x27, 0x92, 0x2d, 0xe2, 0xd4, 0xa9, 0x8a, 0xae,
	0xc1, 0x8c, 0x6b, 0x93, 0x9d, 0x07, 0xc4, 0xc2, 0xba, 0xbe, 0xed, 0x1a, 0xe1, 0x9b, 0x29, 0x5b,
	0x96, 0x94, 0x51, 0xf4, 0x0e, 0x5c, 0x74, 0xf9, 0x2d, 0x6a, 0x8f, 0x8a, 0xcb, 0x57, 0x44, 0x39,
	0xcf, 0x95, 0xdb, 0x89, 0xa0, 0x0d, 0x98, 0xf7, 0x86, 0x6f, 0x5a, 0xd4, 0x48, 0xc2, 0xf0, 0x6e,
	0x79, 0xed, 0x85, 0x90, 0x02, 0x4b, 0x9e, 0x40, 0xa5, 0x19, 0x85, 0x49, 0x60, 0xde, 0xfd, 0x2f,
	0x93, 0xac, 0x78, 0xb7, 0xd8, 0x1d, 0x37, 0xb8, 0xfe, 0x89, 0x2b, 0x61, 0x3b, 0x11, 0xf9, 0xe7,
	0x3c, 0x4c, 0x47, 0xbc, 0x1f, 0x70, 0xe3, 0x2e, 0x4c, 0x18, 0x11, 0x6e, 0x0b, 0xb2, 0x15, 0x3b,
	0x92, 0x2d, 0x1a, 0x12, 0x4a, 0x0c, 0x06, 0x1d, 0x86, 0x48, 0xd7, 0xb4, 0x27, 0xd2, 0xe6, 0x9b,
	0x59, 0xb6, 0x86, 0xb8, 0xae, 0x92, 0x04, 0x88, 0x3e, 0x83, 0x19, 0x9a, 0x48, 0x25, 0x91, 0x3d,
	0x37, 0x3a, 0x9a, 0xca, 0x40, 0x4b, 0x25, 0xc5, 0x86, 0xfc, 0x53, 0x1e, 0x26, 0xfd, 0xdd, 0xab,
	0x64, 0x50, 0xd7, 0x74, 0x6c, 0x16, 0x2e, 0xd4, 0x63, 0x68, 0x74, 0xc4, 0x3b, 0xca, 0xc4, 0xc3,
	0x25, 0x51, 0x14, 0x6d, 0xc2, 0x6c, 0x23, 0x44, 0xd4, 0x18, 0x50, 0x52, 0xe4, 0xb6, 0x91, 0x47,
	0xbb, 0x30, 0xd7, 0x88, 0x50, 0x36, 0x86, 0x97, 0x14, 0xc7, 0x6d, 0x35, 0xd0, 0x47, 0x70, 0xb9,
	0x91, 0xc4, 0xdb, 0x18, 0x70, 0x21, 0x01, 0x38, 0x8b, 0xa2, 0xfc, 0x47, 0x1e, 0x26, 0xb7, 0xf0,
	0x51, 0x2c, 0x40, 0x67, 0x84, 0xb3, 0x62, 0x23, 0x89, 0x8e, 0x4d, 0x91, 0x45, 0xdb, 0x70, 0x31,
	0xec, 0xa9, 0x38, 0x54, 0x92, 0x6b, 0xdb, 0x29, 0x20, 0x05, 0xe6, 0xa3, 0x9e, 0x8a, 0x23, 0x26,
	0x39, 0xb7, 0xbd, 0x0a, 0xfa, 0x04, 0x96, 0x12, 0x9d, 0x14, 0x87, 0x4e, 0x72, 0x6f, 0x26, 0x4d,
	0xf9, 0xf3, 0x1c, 0x4c, 0xf9, 0x2e, 0xb7, 0xf7, 0x2c, 0x5c, 0xbd, 0x47, 0x2c, 0x74, 0x15, 0xc6,
	0xcc, 0x4e, 0x6e, 0x8d, 0x48, 0xa0, 0x32, 0x0c, 0x61, 0x8f, 0xf5, 0xa2, 0x8e, 0x97, 0x7d, 0x8f,
	0xf2, 0x15, 0xe5, 0x2f, 0x86, 0x9b, 0x21, 0x24, 0xce, 0x7b, 0x68, 0x01, 0xc0, 0x3f, 0x02, 0x06,
	0x05, 0xac, 0x50, 0x0f, 0x9a, 0x82, 0x7e, 0xd7, 0xd2, 0xf8, 0x4e, 0x3d, 0xa2, 0xb0, 0x26, 0xd3,
	0xa8, 0xba, 0xb6, 0x43, 0x8d, 0x0d, 0xec, 0x60, 0x69, 0xd8, 0xd3, 0x68, 0xf6, 0xa0, 0x3d, 0x18,
	0x37, 0x5c, 0x9b, 0xed, 0x49, 0x7c, 0x63, 0xf3, 0xd3, 0xdc, 0x4a, 0xe7, 0x34, 0x17, 0xd6, 0x52,
	0xa2, 0x20, 0xe8, 0x03, 0x98, 0x32, 0xa2, 0x39, 0xd7, 0x77, 0x44, 0xe7, 0x42, 0x76, 0x2c, 0x59,
	0x2b, 0x2d, 0x48, 0x48, 0x87, 0xe9, 0x46, 0x52, 0xd2, 0x16, 0x99, 0xed, 0xda, 0xc9, 0x32, 0x5b,
	0x90, 0x46, 0x93, 0x41, 0xd1, 0x7e, 0xf3, 0x1c, 0x2f, 0x32, 0x59, 0xe6, 0x9a, 0x7c, 0x2c, 0x03,
	0x2a, 0x71, 0x20, 0x86, 0x6d, 0xc4, 0xb8, 0x3b, 0x90, 0x11, 0x3b, 0xc6, 0x5c, 0x25, 0x0e, 0x84,
	0xd6, 0x60, 0xd6, 0x22, 0xf7, 0x5d, 0xcd, 0x22, 0x7b, 0xf4, 0xc6, 0x7d, 0x17, 0xeb, 0x76, 0x88,
	0xfe, 0xd2, 0x08, 0xdf, 0x1c, 0xdb, 0x48, 0xa0, 0x32, 0xcc, 0x89, 0x51, 0x16, 0x91, 0xad, 0x08,
	0xe0, 0x55, 0x5c, 0xdb, 0xc9, 0xa0, 0x5b, 0xb0, 0x18, 0x58, 0xd8, 0xa0, 0xc4, 0xde, 0xa6, 0x0e,
	0x17, 0x0a, 0xe3, 0x8c, 0x72, 0x9c, 0x8e, 0x72, 0x68, 0x1b, 0xe4, 0x90, 0xad, 0x34, 0xb4, 0x31,
	0x8e, 0x96, 0x41, 0x12, 0xdd, 0x81, 0xff, 0xb3, 0x54, 0x68, 0x69, 0x2a, 0xb1, 0x79, 0xce, 0x49,
	0xfd, 0xe6, 0x31, 0xce, 0x31, 0x33, 0x4a, 0xb3, 0x93, 0x4e, 0x20, 0xb9, 0x47, 0x4b, 0xa9, 0x5f,
	0x14, 0x26, 0xbc, 0x93, 0x4e, 0x16, 0x59, 0xf9, 0xc7, 0x01, 0x38, 0x9f, 0x52, 0x4b, 0x38, 0xcd,
	0x09, 0xa7, 0x39, 0xe1, 0x1f, 0xcb, 0x09, 0x3d, 0x8c, 0x67, 0xf9, 0xd7, 0x01, 0x38, 0x9f, 0x52,
	0xe8, 0x38, 0xe5, 0xf4, 0x29, 0xa7, 0x33, 0x73, 0xba, 0x17, 0xfb, 0x54, 0x8f, 0xf7, 0x16, 0xf9,
	0x87, 0x02, 0xcc, 0x36, 0xab, 0x72, 0x7e, 0x5e, 0x4f, 0x2f, 0xe6, 0x16, 0x92, 0x8a, 0xb9, 0xb1,
	0xaf, 0x04, 0x03, 0xd9, 0xbf, 0x12, 0x0c, 0x9e, 0xa4, 0xdc, 0x3b, 0xd4, 0xcb, 0x72, 0xef, 0x70,
	0xcf, 0xca, 0xbd, 0x23, 0x2f, 0x55, 0xee, 0x35, 0x93, 0xcb, 0xbd, 0xc0, 0x41, 0xdf, 0xca, 0x50,
	0xee, 0x4d, 0xad, 0xa9, 0x26, 0x17, 0x7b, 0xf7, 0xd3, 0x8a, 0xbd, 0xd9, 0x83, 0x27, 0xb5, 0xc8,
	0x6b, 0xc3, 0x99, 0x52, 0x90, 0xfa, 0x92, 0x33, 0x64, 0xae, 0x25, 0x43, 0x2e, 0xc1, 0xb8, 0xff,
	0xb4, 0x49, 0x1e, 0x10, 0x5d, 0x7c, 0x02, 0x88, 0x76, 0x22, 0x09, 0x86, 0xc4, 0x7f, 0x42, 0xde,
	0x75, 0x4c, 0xf1, 0x1f, 0xe5, 0xdf, 0xf3, 0x30, 0x1c, 0xf0, 0x15, 0x41, 0x81, 0x51, 0xd3, 0xff,
	0x6d, 0x80, 0xb5, 0x3d, 0x76, 0x8a, 0x5b, 0x94, 0xc8, 0x7a, 0x9c, 0x9d, 0x41, 0x57, 0xa4, 0x18,
	0xd8, 0xdf, 0xf5, 0xef, 0x43, 0x26, 0x48, 0x0d, 0x8b, 0x54, 0x45, 0x85, 0x81, 0x34, 0xcf, 0x5e,
	0x58, 0x17, 0xf9, 0x69, 0x35, 0xb3, 0x8b, 0x03, 0xf7, 0x29, 0xa9, 0x98, 0x68, 0x17, 0xc6, 0xbc,
	0x44, 0xcc, 0xff, 0x71, 0xf0, 0xbf, 0x10, 0xbc, 0x96, 0x31, 0x9d, 0x73, 0x25, 0x25, 0x82, 0xc0,
	0xbc, 0x67, 0x10, 0x83, 0x8a, 0xa8, 0xe4, 0x6d, 0x79, 0x0d, 0x26, 0x84, 0x02, 0x76, 0xea, 0x15,
	0x87, 0x18, 0x4c, 0x0a, 0x07, 0xc5, 0x10, 0x85, 0xb7, 0xd9, 0xf2, 0x50, 0x53, 0xd1, 0x6a, 0x75,
	0x47, 0x14, 0xea, 0xfc, 0x47, 0xb9, 0x0e, 0xa3, 0x21, 0x83, 0x4c, 0x59, 0x27, 0xf8, 0xd0, 0x57,
	0x66, 0x6d, 0x74, 0x03, 0x06, 0x70, 0xe8, 0x06, 0x5a, 0xcc, 0xfa, 0x06, 0x62, 0x42, 0x8a, 0xa7,
	0x5d, 0xde, 0x7c, 0xf4, 0x6c, 0x21, 0xf7, 0xf8, 0xd9, 0x42, 0xee, 0xe9, 0xb3, 0x85, 0xdc, 0x97,
	0xcf, 0x17, 0xfa, 0x1e, 0x3f, 0x5f, 0xe8, 0xfb, 0xe5, 0xf9, 0x42, 0xdf, 0xfe, 0x6a, 0x4d, 0x73,
	0xea, 0xee, 0xc1, 0x4a, 0x95, 0x1a, 0xc5, 0x00, 0xb1, 0x18, 0xc5, 0x2e, 0x1e, 0x15, 0xfd, 0x1f,
	0xdf, 0x8e, 0x1b, 0xc4, 0x3e, 0x18, 0xe4, 0xbf, 0x9b, 0xbd, 0xf1, 0x77, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x4b, 0x86, 0x22, 0x2d, 0x0f, 0x27, 0x00, 0x00,
}

func (m *UserBalanceStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserBalanceStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserBalanceStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserPermissions != nil {
		{
			size, err := m.UserPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ApprovedIncomingTransfersTimeline) > 0 {
		for iNdEx := len(m.ApprovedIncomingTransfersTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApprovedIncomingTransfersTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ApprovedOutgoingTransfersTimeline) > 0 {
		for iNdEx := len(m.ApprovedOutgoingTransfersTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApprovedOutgoingTransfersTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedOutgoingTransferTimeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedOutgoingTransferTimeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedOutgoingTransferTimeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ApprovedOutgoingTransfers) > 0 {
		for iNdEx := len(m.ApprovedOutgoingTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApprovedOutgoingTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedIncomingTransferTimeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedIncomingTransferTimeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedIncomingTransferTimeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ApprovedIncomingTransfers) > 0 {
		for iNdEx := len(m.ApprovedIncomingTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApprovedIncomingTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MerkleChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerkleChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChallengeId) > 0 {
		i -= len(m.ChallengeId)
		copy(dAtA[i:], m.ChallengeId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ChallengeId)))
		i--
		dAtA[i] = 0x32
	}
	if m.UseLeafIndexForTransferOrder {
		i--
		if m.UseLeafIndexForTransferOrder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.MaxOneUsePerLeaf {
		i--
		if m.MaxOneUsePerLeaf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UseCreatorAddressAsLeaf {
		i--
		if m.UseCreatorAddressAsLeaf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ExpectedProofLength.Size()
		i -= size
		if _, err := m.ExpectedProofLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IsUserOutgoingTransferAllowed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsUserOutgoingTransferAllowed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsUserOutgoingTransferAllowed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsAllowed {
		i--
		if m.IsAllowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.OwnedTimesOptions != nil {
		{
			size, err := m.OwnedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TransferTimesOptions != nil {
		{
			size, err := m.TransferTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.InitiatedByMappingOptions != nil {
		{
			size, err := m.InitiatedByMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ToMappingOptions != nil {
		{
			size, err := m.ToMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *IsUserIncomingTransferAllowed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsUserIncomingTransferAllowed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsUserIncomingTransferAllowed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsAllowed {
		i--
		if m.IsAllowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.OwnedTimesOptions != nil {
		{
			size, err := m.OwnedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TransferTimesOptions != nil {
		{
			size, err := m.TransferTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.InitiatedByMappingOptions != nil {
		{
			size, err := m.InitiatedByMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.FromMappingOptions != nil {
		{
			size, err := m.FromMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedOutgoingTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedOutgoingTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedOutgoingTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OwnedTimes) > 0 {
		for iNdEx := len(m.OwnedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.ApprovalDetails) > 0 {
		for iNdEx := len(m.ApprovalDetails) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApprovalDetails[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AllowedCombinations) > 0 {
		for iNdEx := len(m.AllowedCombinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllowedCombinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToMappingId) > 0 {
		i -= len(m.ToMappingId)
		copy(dAtA[i:], m.ToMappingId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToMappingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedIncomingTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedIncomingTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedIncomingTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OwnedTimes) > 0 {
		for iNdEx := len(m.OwnedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.ApprovalDetails) > 0 {
		for iNdEx := len(m.ApprovalDetails) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApprovalDetails[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.AllowedCombinations) > 0 {
		for iNdEx := len(m.AllowedCombinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllowedCombinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromMappingId) > 0 {
		i -= len(m.FromMappingId)
		copy(dAtA[i:], m.FromMappingId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.FromMappingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IsCollectionTransferAllowed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsCollectionTransferAllowed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsCollectionTransferAllowed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsAllowed {
		i--
		if m.IsAllowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.OwnedTimesOptions != nil {
		{
			size, err := m.OwnedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TransferTimesOptions != nil {
		{
			size, err := m.TransferTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.InitiatedByMappingOptions != nil {
		{
			size, err := m.InitiatedByMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ToMappingOptions != nil {
		{
			size, err := m.ToMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FromMappingOptions != nil {
		{
			size, err := m.FromMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ManualBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManualBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ManualBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IncrementedBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrementedBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrementedBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.IncrementOwnedTimesBy.Size()
		i -= size
		if _, err := m.IncrementOwnedTimesBy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.IncrementBadgeIdsBy.Size()
		i -= size
		if _, err := m.IncrementBadgeIdsBy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.StartBalances) > 0 {
		for iNdEx := len(m.StartBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StartBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PredeterminedOrderCalculationMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredeterminedOrderCalculationMethod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredeterminedOrderCalculationMethod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseMerkleChallengeLeafIndex {
		i--
		if m.UseMerkleChallengeLeafIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.UsePerInitiatedByAddressNumTransfers {
		i--
		if m.UsePerInitiatedByAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UsePerFromAddressNumTransfers {
		i--
		if m.UsePerFromAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UsePerToAddressNumTransfers {
		i--
		if m.UsePerToAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UseOverallNumTransfers {
		i--
		if m.UseOverallNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PredeterminedBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredeterminedBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredeterminedBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderCalculationMethod != nil {
		{
			size, err := m.OrderCalculationMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IncrementedBalances != nil {
		{
			size, err := m.IncrementedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ManualBalances) > 0 {
		for iNdEx := len(m.ManualBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManualBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ApprovalAmounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalAmounts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalAmounts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PerInitiatedByAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerInitiatedByAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PerFromAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerFromAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PerToAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerToAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OverallApprovalAmount.Size()
		i -= size
		if _, err := m.OverallApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MaxNumTransfers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxNumTransfers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxNumTransfers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PerInitiatedByAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerInitiatedByAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PerFromAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerFromAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PerToAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerToAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OverallMaxNumTransfers.Size()
		i -= size
		if _, err := m.OverallMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApprovalsTracker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalsTracker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalsTracker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amounts) > 0 {
		for iNdEx := len(m.Amounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.NumTransfers.Size()
		i -= size
		if _, err := m.NumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApprovalDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverridesToApprovedIncomingTransfers {
		i--
		if m.OverridesToApprovedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.OverridesFromApprovedOutgoingTransfers {
		i--
		if m.OverridesFromApprovedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x32
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MustOwnBadges) > 0 {
		for iNdEx := len(m.MustOwnBadges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnBadges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OutgoingApprovalDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutgoingApprovalDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutgoingApprovalDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x32
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MustOwnBadges) > 0 {
		for iNdEx := len(m.MustOwnBadges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnBadges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IncomingApprovalDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomingApprovalDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncomingApprovalDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x32
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MustOwnBadges) > 0 {
		for iNdEx := len(m.MustOwnBadges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnBadges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApprovedTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApprovedTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApprovedTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalDetails) > 0 {
		for iNdEx := len(m.ApprovalDetails) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApprovalDetails[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.AllowedCombinations) > 0 {
		for iNdEx := len(m.AllowedCombinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllowedCombinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.OwnedTimes) > 0 {
		for iNdEx := len(m.OwnedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ToMappingId) > 0 {
		i -= len(m.ToMappingId)
		copy(dAtA[i:], m.ToMappingId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToMappingId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FromMappingId) > 0 {
		i -= len(m.FromMappingId)
		copy(dAtA[i:], m.FromMappingId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.FromMappingId)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}

func (m *ApprovalIdDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalIdDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalIdDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ApprovalLevel) > 0 {
		i -= len(m.ApprovalLevel)
		copy(dAtA[i:], m.ApprovalLevel)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalLevel)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Transfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MerkleProofs) > 0 {
		for iNdEx := len(m.MerkleProofs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleProofs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PrecalculateFromApproval != nil {
		{
			size, err := m.PrecalculateFromApproval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ToAddresses) > 0 {
		for iNdEx := len(m.ToAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ToAddresses[iNdEx])
			copy(dAtA[i:], m.ToAddresses[iNdEx])
			i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToAddresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MerklePathItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerklePathItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerklePathItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OnRight {
		i--
		if m.OnRight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Aunt) > 0 {
		i -= len(m.Aunt)
		copy(dAtA[i:], m.Aunt)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Aunt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MerkleProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerkleProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aunts) > 0 {
		for iNdEx := len(m.Aunts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Aunts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Leaf) > 0 {
		i -= len(m.Leaf)
		copy(dAtA[i:], m.Leaf)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Leaf)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTransfers(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransfers(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserBalanceStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.ApprovedOutgoingTransfersTimeline) > 0 {
		for _, e := range m.ApprovedOutgoingTransfersTimeline {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.ApprovedIncomingTransfersTimeline) > 0 {
		for _, e := range m.ApprovedIncomingTransfersTimeline {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.UserPermissions != nil {
		l = m.UserPermissions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *UserApprovedOutgoingTransferTimeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApprovedOutgoingTransfers) > 0 {
		for _, e := range m.ApprovedOutgoingTransfers {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *UserApprovedIncomingTransferTimeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ApprovedIncomingTransfers) > 0 {
		for _, e := range m.ApprovedIncomingTransfers {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *MerkleChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.ExpectedProofLength.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if m.UseCreatorAddressAsLeaf {
		n += 2
	}
	if m.MaxOneUsePerLeaf {
		n += 2
	}
	if m.UseLeafIndexForTransferOrder {
		n += 2
	}
	l = len(m.ChallengeId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *IsUserOutgoingTransferAllowed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToMappingOptions != nil {
		l = m.ToMappingOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.InitiatedByMappingOptions != nil {
		l = m.InitiatedByMappingOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.TransferTimesOptions != nil {
		l = m.TransferTimesOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.OwnedTimesOptions != nil {
		l = m.OwnedTimesOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.IsAllowed {
		n += 2
	}
	return n
}

func (m *IsUserIncomingTransferAllowed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FromMappingOptions != nil {
		l = m.FromMappingOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.InitiatedByMappingOptions != nil {
		l = m.InitiatedByMappingOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.TransferTimesOptions != nil {
		l = m.TransferTimesOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.OwnedTimesOptions != nil {
		l = m.OwnedTimesOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.IsAllowed {
		n += 2
	}
	return n
}

func (m *UserApprovedOutgoingTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToMappingId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.AllowedCombinations) > 0 {
		for _, e := range m.AllowedCombinations {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.ApprovalDetails) > 0 {
		for _, e := range m.ApprovalDetails {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnedTimes) > 0 {
		for _, e := range m.OwnedTimes {
			l = e.Size()
			n += 2 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *UserApprovedIncomingTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromMappingId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.AllowedCombinations) > 0 {
		for _, e := range m.AllowedCombinations {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.ApprovalDetails) > 0 {
		for _, e := range m.ApprovalDetails {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnedTimes) > 0 {
		for _, e := range m.OwnedTimes {
			l = e.Size()
			n += 2 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *IsCollectionTransferAllowed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FromMappingOptions != nil {
		l = m.FromMappingOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ToMappingOptions != nil {
		l = m.ToMappingOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.InitiatedByMappingOptions != nil {
		l = m.InitiatedByMappingOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.TransferTimesOptions != nil {
		l = m.TransferTimesOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.OwnedTimesOptions != nil {
		l = m.OwnedTimesOptions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.IsAllowed {
		n += 2
	}
	return n
}

func (m *ManualBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *IncrementedBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StartBalances) > 0 {
		for _, e := range m.StartBalances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = m.IncrementBadgeIdsBy.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.IncrementOwnedTimesBy.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *PredeterminedOrderCalculationMethod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseOverallNumTransfers {
		n += 2
	}
	if m.UsePerToAddressNumTransfers {
		n += 2
	}
	if m.UsePerFromAddressNumTransfers {
		n += 2
	}
	if m.UsePerInitiatedByAddressNumTransfers {
		n += 2
	}
	if m.UseMerkleChallengeLeafIndex {
		n += 2
	}
	return n
}

func (m *PredeterminedBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ManualBalances) > 0 {
		for _, e := range m.ManualBalances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.IncrementedBalances != nil {
		l = m.IncrementedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.OrderCalculationMethod != nil {
		l = m.OrderCalculationMethod.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *ApprovalAmounts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OverallApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerToAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerFromAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerInitiatedByAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *MaxNumTransfers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OverallMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerToAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerFromAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerInitiatedByAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *ApprovalsTracker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if len(m.Amounts) > 0 {
		for _, e := range m.Amounts {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *ApprovalDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MustOwnBadges) > 0 {
		for _, e := range m.MustOwnBadges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.OverridesFromApprovedOutgoingTransfers {
		n += 2
	}
	if m.OverridesToApprovedIncomingTransfers {
		n += 2
	}
	return n
}

func (m *OutgoingApprovalDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MustOwnBadges) > 0 {
		for _, e := range m.MustOwnBadges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	return n
}

func (m *IncomingApprovalDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MustOwnBadges) > 0 {
		for _, e := range m.MustOwnBadges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	return n
}

func (m *CollectionApprovedTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromMappingId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ToMappingId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnedTimes) > 0 {
		for _, e := range m.OwnedTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.AllowedCombinations) > 0 {
		for _, e := range m.AllowedCombinations {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.ApprovalDetails) > 0 {
		for _, e := range m.ApprovalDetails {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *ApprovalIdDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalLevel)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *Transfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.ToAddresses) > 0 {
		for _, s := range m.ToAddresses {
			l = len(s)
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PrecalculateFromApproval != nil {
		l = m.PrecalculateFromApproval.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.MerkleProofs) > 0 {
		for _, e := range m.MerkleProofs {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *MerklePathItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Aunt)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.OnRight {
		n += 2
	}
	return n
}

func (m *MerkleProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Leaf)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.Aunts) > 0 {
		for _, e := range m.Aunts {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func sovTransfers(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransfers(x uint64) (n int) {
	return sovTransfers(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserBalanceStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserBalanceStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserBalanceStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedOutgoingTransfersTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovedOutgoingTransfersTimeline = append(m.ApprovedOutgoingTransfersTimeline, &UserApprovedOutgoingTransferTimeline{})
			if err := m.ApprovedOutgoingTransfersTimeline[len(m.ApprovedOutgoingTransfersTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedIncomingTransfersTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovedIncomingTransfersTimeline = append(m.ApprovedIncomingTransfersTimeline, &UserApprovedIncomingTransferTimeline{})
			if err := m.ApprovedIncomingTransfersTimeline[len(m.ApprovedIncomingTransfersTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPermissions == nil {
				m.UserPermissions = &UserPermissions{}
			}
			if err := m.UserPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedOutgoingTransferTimeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedOutgoingTransferTimeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedOutgoingTransferTimeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedOutgoingTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovedOutgoingTransfers = append(m.ApprovedOutgoingTransfers, &UserApprovedOutgoingTransfer{})
			if err := m.ApprovedOutgoingTransfers[len(m.ApprovedOutgoingTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &UintRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedIncomingTransferTimeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedIncomingTransferTimeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedIncomingTransferTimeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedIncomingTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovedIncomingTransfers = append(m.ApprovedIncomingTransfers, &UserApprovedIncomingTransfer{})
			if err := m.ApprovedIncomingTransfers[len(m.ApprovedIncomingTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &UintRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedProofLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpectedProofLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCreatorAddressAsLeaf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseCreatorAddressAsLeaf = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOneUsePerLeaf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxOneUsePerLeaf = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLeafIndexForTransferOrder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseLeafIndexForTransferOrder = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsUserOutgoingTransferAllowed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsUserOutgoingTransferAllowed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsUserOutgoingTransferAllowed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToMappingOptions == nil {
				m.ToMappingOptions = &ValueOptions{}
			}
			if err := m.ToMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedByMappingOptions == nil {
				m.InitiatedByMappingOptions = &ValueOptions{}
			}
			if err := m.InitiatedByMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTimesOptions == nil {
				m.TransferTimesOptions = &ValueOptions{}
			}
			if err := m.TransferTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnedTimesOptions == nil {
				m.OwnedTimesOptions = &ValueOptions{}
			}
			if err := m.OwnedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAllowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAllowed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsUserIncomingTransferAllowed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsUserIncomingTransferAllowed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsUserIncomingTransferAllowed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FromMappingOptions == nil {
				m.FromMappingOptions = &ValueOptions{}
			}
			if err := m.FromMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedByMappingOptions == nil {
				m.InitiatedByMappingOptions = &ValueOptions{}
			}
			if err := m.InitiatedByMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTimesOptions == nil {
				m.TransferTimesOptions = &ValueOptions{}
			}
			if err := m.TransferTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnedTimesOptions == nil {
				m.OwnedTimesOptions = &ValueOptions{}
			}
			if err := m.OwnedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAllowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAllowed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedOutgoingTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedOutgoingTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedOutgoingTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCombinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedCombinations = append(m.AllowedCombinations, &IsUserOutgoingTransferAllowed{})
			if err := m.AllowedCombinations[len(m.AllowedCombinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalDetails = append(m.ApprovalDetails, &OutgoingApprovalDetails{})
			if err := m.ApprovalDetails[len(m.ApprovalDetails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnedTimes = append(m.OwnedTimes, &UintRange{})
			if err := m.OwnedTimes[len(m.OwnedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedIncomingTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedIncomingTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedIncomingTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCombinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedCombinations = append(m.AllowedCombinations, &IsUserIncomingTransferAllowed{})
			if err := m.AllowedCombinations[len(m.AllowedCombinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalDetails = append(m.ApprovalDetails, &IncomingApprovalDetails{})
			if err := m.ApprovalDetails[len(m.ApprovalDetails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnedTimes = append(m.OwnedTimes, &UintRange{})
			if err := m.OwnedTimes[len(m.OwnedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsCollectionTransferAllowed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsCollectionTransferAllowed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsCollectionTransferAllowed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FromMappingOptions == nil {
				m.FromMappingOptions = &ValueOptions{}
			}
			if err := m.FromMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToMappingOptions == nil {
				m.ToMappingOptions = &ValueOptions{}
			}
			if err := m.ToMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedByMappingOptions == nil {
				m.InitiatedByMappingOptions = &ValueOptions{}
			}
			if err := m.InitiatedByMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTimesOptions == nil {
				m.TransferTimesOptions = &ValueOptions{}
			}
			if err := m.TransferTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnedTimesOptions == nil {
				m.OwnedTimesOptions = &ValueOptions{}
			}
			if err := m.OwnedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAllowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAllowed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManualBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManualBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManualBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrementedBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrementedBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrementedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartBalances = append(m.StartBalances, &Balance{})
			if err := m.StartBalances[len(m.StartBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementBadgeIdsBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncrementBadgeIdsBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementOwnedTimesBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncrementOwnedTimesBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredeterminedOrderCalculationMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredeterminedOrderCalculationMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredeterminedOrderCalculationMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseOverallNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseOverallNumTransfers = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerToAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerToAddressNumTransfers = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerFromAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerFromAddressNumTransfers = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerInitiatedByAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerInitiatedByAddressNumTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMerkleChallengeLeafIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMerkleChallengeLeafIndex = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredeterminedBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredeterminedBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredeterminedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManualBalances = append(m.ManualBalances, &ManualBalances{})
			if err := m.ManualBalances[len(m.ManualBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncrementedBalances == nil {
				m.IncrementedBalances = &IncrementedBalances{}
			}
			if err := m.IncrementedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderCalculationMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderCalculationMethod == nil {
				m.OrderCalculationMethod = &PredeterminedOrderCalculationMethod{}
			}
			if err := m.OrderCalculationMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalAmounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalAmounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalAmounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverallApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerToAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerToAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerFromAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerFromAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerInitiatedByAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerInitiatedByAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxNumTransfers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxNumTransfers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxNumTransfers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverallMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerToAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerToAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerFromAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerFromAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerInitiatedByAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerInitiatedByAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalsTracker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalsTracker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalsTracker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amounts = append(m.Amounts, &Balance{})
			if err := m.Amounts[len(m.Amounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnBadges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnBadges = append(m.MustOwnBadges, &MustOwnBadges{})
			if err := m.MustOwnBadges[len(m.MustOwnBadges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesFromApprovedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesFromApprovedOutgoingTransfers = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesToApprovedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesToApprovedIncomingTransfers = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutgoingApprovalDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutgoingApprovalDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutgoingApprovalDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnBadges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnBadges = append(m.MustOwnBadges, &MustOwnBadges{})
			if err := m.MustOwnBadges[len(m.MustOwnBadges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomingApprovalDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomingApprovalDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomingApprovalDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnBadges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnBadges = append(m.MustOwnBadges, &MustOwnBadges{})
			if err := m.MustOwnBadges[len(m.MustOwnBadges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApprovedTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApprovedTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApprovedTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnedTimes = append(m.OwnedTimes, &UintRange{})
			if err := m.OwnedTimes[len(m.OwnedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCombinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedCombinations = append(m.AllowedCombinations, &IsCollectionTransferAllowed{})
			if err := m.AllowedCombinations[len(m.AllowedCombinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalDetails = append(m.ApprovalDetails, &ApprovalDetails{})
			if err := m.ApprovalDetails[len(m.ApprovalDetails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalIdDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalIdDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalIdDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddresses = append(m.ToAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecalculateFromApproval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrecalculateFromApproval == nil {
				m.PrecalculateFromApproval = &ApprovalIdDetails{}
			}
			if err := m.PrecalculateFromApproval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleProofs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleProofs = append(m.MerkleProofs, &MerkleProof{})
			if err := m.MerkleProofs[len(m.MerkleProofs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerklePathItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerklePathItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerklePathItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aunt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aunt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnRight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnRight = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leaf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aunts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aunts = append(m.Aunts, &MerklePathItem{})
			if err := m.Aunts[len(m.Aunts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransfers(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransfers
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransfers
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransfers
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransfers        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransfers          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransfers = fmt.Errorf("proto: unexpected end of group")
)
