// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/transfers.proto

package types

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UserBalanceStore is the store for the user balances for a collection.
//
// It consists of a list of balances, a list of approved outgoing transfers, and a list of approved incoming transfers,
// as well as the permissions for updating the approved incoming/outgoing transfers.
//
// Upon initialization, all fields (minus the balances) are set to the defaults specified by the collection.
//
// The outgoing transfers can be used to allow / disallow transfers which are sent from this user.
// If a transfer has no match, then it is disallowed by default, unless from == initiatedBy (i.e. initiated by this user)
// and autoApproveSelfInitiatedOutgoingTransfers is set to true.
//
// The incoming transfers can be used to allow / disallow transfers which are sent to this user.
// If a transfer has no match, then it is disallowed by default, unless to == initiatedBy (i.e. initiated by this user)
// and autoApproveSelfInitiatedIncomingTransfers is set to true.
//
// Note that the user approved transfers are only checked if the collection approved transfers do not specify to override
// the user approved transfers.
//
// The permissions are used to determine whether the user can update the approved incoming/outgoing transfers and auto approvals.
type UserBalanceStore struct {
	// The list of balances associated with this user.
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
	// The list of approved outgoing transfers for this user.
	OutgoingApprovals []*UserOutgoingApproval `protobuf:"bytes,2,rep,name=outgoingApprovals,proto3" json:"outgoingApprovals,omitempty"`
	// The list of approved incoming transfers for this user.
	IncomingApprovals []*UserIncomingApproval `protobuf:"bytes,3,rep,name=incomingApprovals,proto3" json:"incomingApprovals,omitempty"`
	// Whether to auto-approve self-initiated outgoing transfers for this user (i.e. from == initiatedBy).
	AutoApproveSelfInitiatedOutgoingTransfers bool `protobuf:"varint,4,opt,name=autoApproveSelfInitiatedOutgoingTransfers,proto3" json:"autoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Whether to auto-approve self-initiated incoming transfers for this user (i.e. to == initiatedBy).
	AutoApproveSelfInitiatedIncomingTransfers bool `protobuf:"varint,5,opt,name=autoApproveSelfInitiatedIncomingTransfers,proto3" json:"autoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// The permissions for this user's actions and transfers.
	UserPermissions *UserPermissions `protobuf:"bytes,6,opt,name=userPermissions,proto3" json:"userPermissions,omitempty"`
}

func (m *UserBalanceStore) Reset()         { *m = UserBalanceStore{} }
func (m *UserBalanceStore) String() string { return proto.CompactTextString(m) }
func (*UserBalanceStore) ProtoMessage()    {}
func (*UserBalanceStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{0}
}
func (m *UserBalanceStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserBalanceStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserBalanceStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserBalanceStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserBalanceStore.Merge(m, src)
}
func (m *UserBalanceStore) XXX_Size() int {
	return m.Size()
}
func (m *UserBalanceStore) XXX_DiscardUnknown() {
	xxx_messageInfo_UserBalanceStore.DiscardUnknown(m)
}

var xxx_messageInfo_UserBalanceStore proto.InternalMessageInfo

func (m *UserBalanceStore) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *UserBalanceStore) GetOutgoingApprovals() []*UserOutgoingApproval {
	if m != nil {
		return m.OutgoingApprovals
	}
	return nil
}

func (m *UserBalanceStore) GetIncomingApprovals() []*UserIncomingApproval {
	if m != nil {
		return m.IncomingApprovals
	}
	return nil
}

func (m *UserBalanceStore) GetAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (m *UserBalanceStore) GetAutoApproveSelfInitiatedIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (m *UserBalanceStore) GetUserPermissions() *UserPermissions {
	if m != nil {
		return m.UserPermissions
	}
	return nil
}

// Challenges define a rule for the approval in the form of a Merkle challenge.
//
// A Merkle challenge is a challenge where the user must provide a Merkle proof to a Merkle tree. If they provide a valid proof,
// then the challenge is met. All challenges must be met with valid solutions for the transfer to be approved.
//
// IMPORTANT: Merkle challenges currently are limited to SHA256 hashes. See documentation for MerkleChallenge for more details and tutorials.
//
// IMPORTANT: We track the number of uses per leaf according to the challengeTrackerId specified by the parent approval of this challenge.
// If you update the challenge ID, then the used leaves tracker will reset and start a new tally.
// We recommend using a unique challenge ID for each challenge to prevent overlap and unexpected behavior.
type MerkleChallenge struct {
	// The root hash of the Merkle tree to which the Merkle path must lead for verification.
	Root string `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty"`
	// The expected length of the Merkle path for verification. Used to prevent Merkle path truncation attacks.
	ExpectedProofLength Uint `protobuf:"bytes,2,opt,name=expectedProofLength,proto3,customtype=Uint" json:"expectedProofLength"`
	// If true, we will override the user's leaf for their proof with their creator address. Used for whitelist trees where all leaves are valid BitBadges addresses.
	UseCreatorAddressAsLeaf bool `protobuf:"varint,3,opt,name=useCreatorAddressAsLeaf,proto3" json:"useCreatorAddressAsLeaf,omitempty"`
	// The maximum number of times each leaf can be used. Must be 1 if useCreatorAddressAsLeaf is false to prevent replay attacks.
	MaxUsesPerLeaf Uint `protobuf:"bytes,4,opt,name=maxUsesPerLeaf,proto3,customtype=Uint" json:"maxUsesPerLeaf"`
	// The URI associated with this Merkle challenge, optionally providing metadata about the challenge.
	Uri string `protobuf:"bytes,5,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this Merkle challenge.
	CustomData string `protobuf:"bytes,6,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this Merkle challenge for tracking the number of uses per leaf.
	ChallengeTrackerId string `protobuf:"bytes,7,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
}

func (m *MerkleChallenge) Reset()         { *m = MerkleChallenge{} }
func (m *MerkleChallenge) String() string { return proto.CompactTextString(m) }
func (*MerkleChallenge) ProtoMessage()    {}
func (*MerkleChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{1}
}
func (m *MerkleChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerkleChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerkleChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerkleChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerkleChallenge.Merge(m, src)
}
func (m *MerkleChallenge) XXX_Size() int {
	return m.Size()
}
func (m *MerkleChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_MerkleChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_MerkleChallenge proto.InternalMessageInfo

func (m *MerkleChallenge) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

func (m *MerkleChallenge) GetUseCreatorAddressAsLeaf() bool {
	if m != nil {
		return m.UseCreatorAddressAsLeaf
	}
	return false
}

func (m *MerkleChallenge) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *MerkleChallenge) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *MerkleChallenge) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

// UserOutgoingApproval defines the rules for the approval of an outgoing transfer from a user.
type UserOutgoingApproval struct {
	// The list ID for the recipient of the transfer.
	ToListId string `protobuf:"bytes,1,opt,name=toListId,proto3" json:"toListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,2,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of badge IDs for approval.
	BadgeIds []*UintRange `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,8,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,9,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,10,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *OutgoingApprovalCriteria `protobuf:"bytes,11,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
}

func (m *UserOutgoingApproval) Reset()         { *m = UserOutgoingApproval{} }
func (m *UserOutgoingApproval) String() string { return proto.CompactTextString(m) }
func (*UserOutgoingApproval) ProtoMessage()    {}
func (*UserOutgoingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{2}
}
func (m *UserOutgoingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserOutgoingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserOutgoingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserOutgoingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserOutgoingApproval.Merge(m, src)
}
func (m *UserOutgoingApproval) XXX_Size() int {
	return m.Size()
}
func (m *UserOutgoingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_UserOutgoingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_UserOutgoingApproval proto.InternalMessageInfo

func (m *UserOutgoingApproval) GetToListId() string {
	if m != nil {
		return m.ToListId
	}
	return ""
}

func (m *UserOutgoingApproval) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *UserOutgoingApproval) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserOutgoingApproval) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserOutgoingApproval) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserOutgoingApproval) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *UserOutgoingApproval) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *UserOutgoingApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *UserOutgoingApproval) GetApprovalCriteria() *OutgoingApprovalCriteria {
	if m != nil {
		return m.ApprovalCriteria
	}
	return nil
}

// UserIncomingApproval defines the rules for the approval of an incoming transfer to a user.
type UserIncomingApproval struct {
	// The list ID for the sender of the transfer.
	FromListId string `protobuf:"bytes,1,opt,name=fromListId,proto3" json:"fromListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,2,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of badge IDs for approval.
	BadgeIds []*UintRange `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,8,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,9,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,10,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *IncomingApprovalCriteria `protobuf:"bytes,11,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
}

func (m *UserIncomingApproval) Reset()         { *m = UserIncomingApproval{} }
func (m *UserIncomingApproval) String() string { return proto.CompactTextString(m) }
func (*UserIncomingApproval) ProtoMessage()    {}
func (*UserIncomingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{3}
}
func (m *UserIncomingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserIncomingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserIncomingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserIncomingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserIncomingApproval.Merge(m, src)
}
func (m *UserIncomingApproval) XXX_Size() int {
	return m.Size()
}
func (m *UserIncomingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_UserIncomingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_UserIncomingApproval proto.InternalMessageInfo

func (m *UserIncomingApproval) GetFromListId() string {
	if m != nil {
		return m.FromListId
	}
	return ""
}

func (m *UserIncomingApproval) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *UserIncomingApproval) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserIncomingApproval) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserIncomingApproval) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserIncomingApproval) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *UserIncomingApproval) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *UserIncomingApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *UserIncomingApproval) GetApprovalCriteria() *IncomingApprovalCriteria {
	if m != nil {
		return m.ApprovalCriteria
	}
	return nil
}

// ManualBalances represents a list of manual balances entered for the predetermined balances criteria. Order is calculated according to the calculation method set.
type ManualBalances struct {
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances,proto3" json:"balances,omitempty"`
}

func (m *ManualBalances) Reset()         { *m = ManualBalances{} }
func (m *ManualBalances) String() string { return proto.CompactTextString(m) }
func (*ManualBalances) ProtoMessage()    {}
func (*ManualBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{4}
}
func (m *ManualBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ManualBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ManualBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ManualBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManualBalances.Merge(m, src)
}
func (m *ManualBalances) XXX_Size() int {
	return m.Size()
}
func (m *ManualBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_ManualBalances.DiscardUnknown(m)
}

var xxx_messageInfo_ManualBalances proto.InternalMessageInfo

func (m *ManualBalances) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

// IncrementedBalances represents balances that are incremented by specific amounts, according to the order calculation method.
type IncrementedBalances struct {
	StartBalances []*Balance `protobuf:"bytes,1,rep,name=startBalances,proto3" json:"startBalances,omitempty"`
	// The amount by which to increment badge IDs.
	IncrementBadgeIdsBy Uint `protobuf:"bytes,2,opt,name=incrementBadgeIdsBy,proto3,customtype=Uint" json:"incrementBadgeIdsBy"`
	// The amount by which to increment ownership times.
	IncrementOwnershipTimesBy Uint `protobuf:"bytes,3,opt,name=incrementOwnershipTimesBy,proto3,customtype=Uint" json:"incrementOwnershipTimesBy"`
}

func (m *IncrementedBalances) Reset()         { *m = IncrementedBalances{} }
func (m *IncrementedBalances) String() string { return proto.CompactTextString(m) }
func (*IncrementedBalances) ProtoMessage()    {}
func (*IncrementedBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{5}
}
func (m *IncrementedBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrementedBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncrementedBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncrementedBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrementedBalances.Merge(m, src)
}
func (m *IncrementedBalances) XXX_Size() int {
	return m.Size()
}
func (m *IncrementedBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrementedBalances.DiscardUnknown(m)
}

var xxx_messageInfo_IncrementedBalances proto.InternalMessageInfo

func (m *IncrementedBalances) GetStartBalances() []*Balance {
	if m != nil {
		return m.StartBalances
	}
	return nil
}

// PredeterminedOrderCalculationMethod defines the method to calculate predetermined balances order.
type PredeterminedOrderCalculationMethod struct {
	// Use the overall number of transfers to calculate the order. Ex: First transfer gets the first balance, second transfer gets the second balance, etc.
	UseOverallNumTransfers bool `protobuf:"varint,1,opt,name=useOverallNumTransfers,proto3" json:"useOverallNumTransfers,omitempty"`
	// Use the number of transfers per "to" address to calculate the order. Ex: First transfer to address A gets the first balance, second transfer to address A gets the second balance, etc.
	UsePerToAddressNumTransfers bool `protobuf:"varint,2,opt,name=usePerToAddressNumTransfers,proto3" json:"usePerToAddressNumTransfers,omitempty"`
	// Use the number of transfers per "from" address to calculate the order. Ex: First transfer from address A gets the first balance, second transfer from address A gets the second balance, etc.
	UsePerFromAddressNumTransfers bool `protobuf:"varint,3,opt,name=usePerFromAddressNumTransfers,proto3" json:"usePerFromAddressNumTransfers,omitempty"`
	// Use the number of transfers per "initiated by" address to calculate the order. Ex: First transfer initiated by address A gets the first balance, second transfer initiated by address A gets the second balance, etc.
	UsePerInitiatedByAddressNumTransfers bool `protobuf:"varint,4,opt,name=usePerInitiatedByAddressNumTransfers,proto3" json:"usePerInitiatedByAddressNumTransfers,omitempty"`
	// Use the Merkle challenge leaf index to calculate the order. Ex: Transfer that uses leaf index 0 gets the first balance, transfer that uses leaf index 1 gets the second balance, etc.
	UseMerkleChallengeLeafIndex bool `protobuf:"varint,5,opt,name=useMerkleChallengeLeafIndex,proto3" json:"useMerkleChallengeLeafIndex,omitempty"`
	// If useMerkleChallengeLeafIndex is set, then this is the ID of the challenge tracker associated with this calculation method.
	ChallengeTrackerId string `protobuf:"bytes,6,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
}

func (m *PredeterminedOrderCalculationMethod) Reset()         { *m = PredeterminedOrderCalculationMethod{} }
func (m *PredeterminedOrderCalculationMethod) String() string { return proto.CompactTextString(m) }
func (*PredeterminedOrderCalculationMethod) ProtoMessage()    {}
func (*PredeterminedOrderCalculationMethod) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{6}
}
func (m *PredeterminedOrderCalculationMethod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredeterminedOrderCalculationMethod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredeterminedOrderCalculationMethod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredeterminedOrderCalculationMethod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredeterminedOrderCalculationMethod.Merge(m, src)
}
func (m *PredeterminedOrderCalculationMethod) XXX_Size() int {
	return m.Size()
}
func (m *PredeterminedOrderCalculationMethod) XXX_DiscardUnknown() {
	xxx_messageInfo_PredeterminedOrderCalculationMethod.DiscardUnknown(m)
}

var xxx_messageInfo_PredeterminedOrderCalculationMethod proto.InternalMessageInfo

func (m *PredeterminedOrderCalculationMethod) GetUseOverallNumTransfers() bool {
	if m != nil {
		return m.UseOverallNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerToAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerToAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerFromAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerFromAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUsePerInitiatedByAddressNumTransfers() bool {
	if m != nil {
		return m.UsePerInitiatedByAddressNumTransfers
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetUseMerkleChallengeLeafIndex() bool {
	if m != nil {
		return m.UseMerkleChallengeLeafIndex
	}
	return false
}

func (m *PredeterminedOrderCalculationMethod) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

// PredeterminedBalances represents balances with predetermined order calculation.
type PredeterminedBalances struct {
	// Manual balances that can be entered. If this is nil, then we use the incremented balances.
	ManualBalances []*ManualBalances `protobuf:"bytes,1,rep,name=manualBalances,proto3" json:"manualBalances,omitempty"`
	// Balances that have a starting amount and increment. If this is nil, then we use the manual balances.
	IncrementedBalances *IncrementedBalances `protobuf:"bytes,2,opt,name=incrementedBalances,proto3" json:"incrementedBalances,omitempty"`
	// The method to calculate the order of predetermined balances.
	OrderCalculationMethod *PredeterminedOrderCalculationMethod `protobuf:"bytes,3,opt,name=orderCalculationMethod,proto3" json:"orderCalculationMethod,omitempty"`
}

func (m *PredeterminedBalances) Reset()         { *m = PredeterminedBalances{} }
func (m *PredeterminedBalances) String() string { return proto.CompactTextString(m) }
func (*PredeterminedBalances) ProtoMessage()    {}
func (*PredeterminedBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{7}
}
func (m *PredeterminedBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredeterminedBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredeterminedBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredeterminedBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredeterminedBalances.Merge(m, src)
}
func (m *PredeterminedBalances) XXX_Size() int {
	return m.Size()
}
func (m *PredeterminedBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_PredeterminedBalances.DiscardUnknown(m)
}

var xxx_messageInfo_PredeterminedBalances proto.InternalMessageInfo

func (m *PredeterminedBalances) GetManualBalances() []*ManualBalances {
	if m != nil {
		return m.ManualBalances
	}
	return nil
}

func (m *PredeterminedBalances) GetIncrementedBalances() *IncrementedBalances {
	if m != nil {
		return m.IncrementedBalances
	}
	return nil
}

func (m *PredeterminedBalances) GetOrderCalculationMethod() *PredeterminedOrderCalculationMethod {
	if m != nil {
		return m.OrderCalculationMethod
	}
	return nil
}

// ApprovalAmounts defines approval amounts per unique "from," "to," and/or "initiated by" address.
// If any of these are nil or "0", we assume unlimited approvals.
// If they are set to a value, then the running tally of the amounts transferred for the specified badge IDs and ownership times
// must not exceed the corresponding value.
type ApprovalAmounts struct {
	// Overall approval amount.
	OverallApprovalAmount Uint `protobuf:"bytes,1,opt,name=overallApprovalAmount,proto3,customtype=Uint" json:"overallApprovalAmount"`
	// Approval amount per "to" address.
	PerToAddressApprovalAmount Uint `protobuf:"bytes,2,opt,name=perToAddressApprovalAmount,proto3,customtype=Uint" json:"perToAddressApprovalAmount"`
	// Approval amount per "from" address.
	PerFromAddressApprovalAmount Uint `protobuf:"bytes,3,opt,name=perFromAddressApprovalAmount,proto3,customtype=Uint" json:"perFromAddressApprovalAmount"`
	// Approval amount per "initiated by" address.
	PerInitiatedByAddressApprovalAmount Uint `protobuf:"bytes,4,opt,name=perInitiatedByAddressApprovalAmount,proto3,customtype=Uint" json:"perInitiatedByAddressApprovalAmount"`
	// The ID of the amount tracker associated with this approval.
	// We use this ID to track the number of transfers and amounts transferred.
	AmountTrackerId string `protobuf:"bytes,6,opt,name=amountTrackerId,proto3" json:"amountTrackerId,omitempty"`
}

func (m *ApprovalAmounts) Reset()         { *m = ApprovalAmounts{} }
func (m *ApprovalAmounts) String() string { return proto.CompactTextString(m) }
func (*ApprovalAmounts) ProtoMessage()    {}
func (*ApprovalAmounts) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{8}
}
func (m *ApprovalAmounts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalAmounts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalAmounts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalAmounts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalAmounts.Merge(m, src)
}
func (m *ApprovalAmounts) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalAmounts) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalAmounts.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalAmounts proto.InternalMessageInfo

func (m *ApprovalAmounts) GetAmountTrackerId() string {
	if m != nil {
		return m.AmountTrackerId
	}
	return ""
}

// MaxNumTransfers defines the maximum number of transfers per unique "from," "to," and/or "initiated by" address.
// If any of these are nil or "0", we assume unlimited approvals.
// If they are set to a value, then the running tally of the number of transfers for the specified badge IDs and ownership times
// must not exceed the corresponding value.
type MaxNumTransfers struct {
	// Overall maximum number of transfers.
	OverallMaxNumTransfers Uint `protobuf:"bytes,1,opt,name=overallMaxNumTransfers,proto3,customtype=Uint" json:"overallMaxNumTransfers"`
	// Maximum number of transfers per "to" address.
	PerToAddressMaxNumTransfers Uint `protobuf:"bytes,2,opt,name=perToAddressMaxNumTransfers,proto3,customtype=Uint" json:"perToAddressMaxNumTransfers"`
	// Maximum number of transfers per "from" address.
	PerFromAddressMaxNumTransfers Uint `protobuf:"bytes,3,opt,name=perFromAddressMaxNumTransfers,proto3,customtype=Uint" json:"perFromAddressMaxNumTransfers"`
	// Maximum number of transfers per "initiated by" address.
	PerInitiatedByAddressMaxNumTransfers Uint `protobuf:"bytes,4,opt,name=perInitiatedByAddressMaxNumTransfers,proto3,customtype=Uint" json:"perInitiatedByAddressMaxNumTransfers"`
	// The ID of the amount tracker associated with this approval.
	// We use this ID to track the number of transfers and amounts transferred.
	AmountTrackerId string `protobuf:"bytes,6,opt,name=amountTrackerId,proto3" json:"amountTrackerId,omitempty"`
}

func (m *MaxNumTransfers) Reset()         { *m = MaxNumTransfers{} }
func (m *MaxNumTransfers) String() string { return proto.CompactTextString(m) }
func (*MaxNumTransfers) ProtoMessage()    {}
func (*MaxNumTransfers) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{9}
}
func (m *MaxNumTransfers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxNumTransfers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxNumTransfers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxNumTransfers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxNumTransfers.Merge(m, src)
}
func (m *MaxNumTransfers) XXX_Size() int {
	return m.Size()
}
func (m *MaxNumTransfers) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxNumTransfers.DiscardUnknown(m)
}

var xxx_messageInfo_MaxNumTransfers proto.InternalMessageInfo

func (m *MaxNumTransfers) GetAmountTrackerId() string {
	if m != nil {
		return m.AmountTrackerId
	}
	return ""
}

// ApprovalTracker defines the tracker for approvals. This tracks the cumulative number of transfers and associated balances transferred.
type ApprovalTracker struct {
	// The number of transfers that have been processed.
	NumTransfers Uint `protobuf:"bytes,1,opt,name=numTransfers,proto3,customtype=Uint" json:"numTransfers"`
	// Cumulative balances associated with the transfers that have been processed.
	Amounts []*Balance `protobuf:"bytes,2,rep,name=amounts,proto3" json:"amounts,omitempty"`
}

func (m *ApprovalTracker) Reset()         { *m = ApprovalTracker{} }
func (m *ApprovalTracker) String() string { return proto.CompactTextString(m) }
func (*ApprovalTracker) ProtoMessage()    {}
func (*ApprovalTracker) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{10}
}
func (m *ApprovalTracker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalTracker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalTracker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalTracker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalTracker.Merge(m, src)
}
func (m *ApprovalTracker) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalTracker) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalTracker.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalTracker proto.InternalMessageInfo

func (m *ApprovalTracker) GetAmounts() []*Balance {
	if m != nil {
		return m.Amounts
	}
	return nil
}

type CoinTransfer struct {
	// The address of the recipient of the transfer.
	To string `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	// The sdk.Coins to be transferred.
	Coins []*types.Coin `protobuf:"bytes,2,rep,name=coins,proto3" json:"coins,omitempty"`
}

func (m *CoinTransfer) Reset()         { *m = CoinTransfer{} }
func (m *CoinTransfer) String() string { return proto.CompactTextString(m) }
func (*CoinTransfer) ProtoMessage()    {}
func (*CoinTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{11}
}
func (m *CoinTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoinTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinTransfer.Merge(m, src)
}
func (m *CoinTransfer) XXX_Size() int {
	return m.Size()
}
func (m *CoinTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_CoinTransfer proto.InternalMessageInfo

func (m *CoinTransfer) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *CoinTransfer) GetCoins() []*types.Coin {
	if m != nil {
		return m.Coins
	}
	return nil
}

// ApprovalCriteria defines the criteria for approving transfers.
type ApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,7,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,8,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,9,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
	// Overrides the user's outgoing approvals for approval.
	OverridesFromOutgoingApprovals bool `protobuf:"varint,10,opt,name=overridesFromOutgoingApprovals,proto3" json:"overridesFromOutgoingApprovals,omitempty"`
	// Overrides the user's incoming approvals for approval.
	OverridesToIncomingApprovals bool `protobuf:"varint,11,opt,name=overridesToIncomingApprovals,proto3" json:"overridesToIncomingApprovals,omitempty"`
}

func (m *ApprovalCriteria) Reset()         { *m = ApprovalCriteria{} }
func (m *ApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*ApprovalCriteria) ProtoMessage()    {}
func (*ApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{12}
}
func (m *ApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalCriteria.Merge(m, src)
}
func (m *ApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalCriteria proto.InternalMessageInfo

func (m *ApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *ApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *ApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *ApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *ApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetOverridesFromOutgoingApprovals() bool {
	if m != nil {
		return m.OverridesFromOutgoingApprovals
	}
	return false
}

func (m *ApprovalCriteria) GetOverridesToIncomingApprovals() bool {
	if m != nil {
		return m.OverridesToIncomingApprovals
	}
	return false
}

// OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.
type OutgoingApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,7,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
}

func (m *OutgoingApprovalCriteria) Reset()         { *m = OutgoingApprovalCriteria{} }
func (m *OutgoingApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*OutgoingApprovalCriteria) ProtoMessage()    {}
func (*OutgoingApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{13}
}
func (m *OutgoingApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutgoingApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutgoingApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutgoingApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutgoingApprovalCriteria.Merge(m, src)
}
func (m *OutgoingApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *OutgoingApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_OutgoingApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_OutgoingApprovalCriteria proto.InternalMessageInfo

func (m *OutgoingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *OutgoingApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

// IncomingApprovalCriteria defines the criteria for approving incoming transfers.
type IncomingApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,7,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
}

func (m *IncomingApprovalCriteria) Reset()         { *m = IncomingApprovalCriteria{} }
func (m *IncomingApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*IncomingApprovalCriteria) ProtoMessage()    {}
func (*IncomingApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{14}
}
func (m *IncomingApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncomingApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncomingApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncomingApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncomingApprovalCriteria.Merge(m, src)
}
func (m *IncomingApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *IncomingApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_IncomingApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_IncomingApprovalCriteria proto.InternalMessageInfo

func (m *IncomingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *IncomingApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

// CollectionApproval defines the rules for the approval of a transfer on the collection level
type CollectionApproval struct {
	// The list ID for the sender of the transfer.
	FromListId string `protobuf:"bytes,1,opt,name=fromListId,proto3" json:"fromListId,omitempty"`
	// The list ID for the recipient of the transfer.
	ToListId string `protobuf:"bytes,2,opt,name=toListId,proto3" json:"toListId,omitempty"`
	// The list ID for the user who initiated the transfer.
	InitiatedByListId string `protobuf:"bytes,3,opt,name=initiatedByListId,proto3" json:"initiatedByListId,omitempty"`
	// The allowed range of transfer times for approval.
	TransferTimes []*UintRange `protobuf:"bytes,4,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// The allowed range of badge IDs for approval.
	BadgeIds []*UintRange `protobuf:"bytes,5,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// The allowed range of ownership times for approval.
	OwnershipTimes []*UintRange `protobuf:"bytes,6,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// The URI associated with this approval, optionally providing metadata about the approval.
	Uri string `protobuf:"bytes,9,opt,name=uri,proto3" json:"uri,omitempty"`
	// Arbitrary custom data associated with this approval.
	CustomData string `protobuf:"bytes,10,opt,name=customData,proto3" json:"customData,omitempty"`
	// The ID of this approval. Must be unique per level (i.e. collection, outgoing, incoming).
	ApprovalId string `protobuf:"bytes,11,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The criteria that must be met for this approval to be considered.
	ApprovalCriteria *ApprovalCriteria `protobuf:"bytes,12,opt,name=approvalCriteria,proto3" json:"approvalCriteria,omitempty"`
}

func (m *CollectionApproval) Reset()         { *m = CollectionApproval{} }
func (m *CollectionApproval) String() string { return proto.CompactTextString(m) }
func (*CollectionApproval) ProtoMessage()    {}
func (*CollectionApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{15}
}
func (m *CollectionApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApproval.Merge(m, src)
}
func (m *CollectionApproval) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApproval.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApproval proto.InternalMessageInfo

func (m *CollectionApproval) GetFromListId() string {
	if m != nil {
		return m.FromListId
	}
	return ""
}

func (m *CollectionApproval) GetToListId() string {
	if m != nil {
		return m.ToListId
	}
	return ""
}

func (m *CollectionApproval) GetInitiatedByListId() string {
	if m != nil {
		return m.InitiatedByListId
	}
	return ""
}

func (m *CollectionApproval) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *CollectionApproval) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *CollectionApproval) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *CollectionApproval) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *CollectionApproval) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *CollectionApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *CollectionApproval) GetApprovalCriteria() *ApprovalCriteria {
	if m != nil {
		return m.ApprovalCriteria
	}
	return nil
}

// ApprovalIdentifierDetails defines the details to identify a specific approval.
type ApprovalIdentifierDetails struct {
	// The ID of the approval.
	ApprovalId string `protobuf:"bytes,1,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
	// The level of the approval. Can be "collection", "incoming", or "outgoing".
	ApprovalLevel string `protobuf:"bytes,2,opt,name=approvalLevel,proto3" json:"approvalLevel,omitempty"`
	// The address of the approver. Leave blank "" if approvalLevel == "collection".
	ApproverAddress string `protobuf:"bytes,3,opt,name=approverAddress,proto3" json:"approverAddress,omitempty"`
}

func (m *ApprovalIdentifierDetails) Reset()         { *m = ApprovalIdentifierDetails{} }
func (m *ApprovalIdentifierDetails) String() string { return proto.CompactTextString(m) }
func (*ApprovalIdentifierDetails) ProtoMessage()    {}
func (*ApprovalIdentifierDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{16}
}
func (m *ApprovalIdentifierDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalIdentifierDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalIdentifierDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalIdentifierDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalIdentifierDetails.Merge(m, src)
}
func (m *ApprovalIdentifierDetails) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalIdentifierDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalIdentifierDetails.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalIdentifierDetails proto.InternalMessageInfo

func (m *ApprovalIdentifierDetails) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

func (m *ApprovalIdentifierDetails) GetApprovalLevel() string {
	if m != nil {
		return m.ApprovalLevel
	}
	return ""
}

func (m *ApprovalIdentifierDetails) GetApproverAddress() string {
	if m != nil {
		return m.ApproverAddress
	}
	return ""
}

// Transfer defines the details of a transfer of badges.
type Transfer struct {
	// The address of the sender of the transfer.
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// The addresses of the recipients of the transfer.
	ToAddresses []string `protobuf:"bytes,2,rep,name=toAddresses,proto3" json:"toAddresses,omitempty"`
	// The balances to be transferred.
	Balances []*Balance `protobuf:"bytes,3,rep,name=balances,proto3" json:"balances,omitempty"`
	// If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.
	// We will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.
	PrecalculateBalancesFromApproval *ApprovalIdentifierDetails `protobuf:"bytes,4,opt,name=precalculateBalancesFromApproval,proto3" json:"precalculateBalancesFromApproval,omitempty"`
	// The Merkle proofs / solutions for all Merkle challenges required for the transfer.
	MerkleProofs []*MerkleProof `protobuf:"bytes,5,rep,name=merkleProofs,proto3" json:"merkleProofs,omitempty"`
	// The memo for the transfer.
	Memo string `protobuf:"bytes,6,opt,name=memo,proto3" json:"memo,omitempty"`
	// The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.
	// This field can be used to prioritize specific approvals and scan through them first.
	PrioritizedApprovals []*ApprovalIdentifierDetails `protobuf:"bytes,7,rep,name=prioritizedApprovals,proto3" json:"prioritizedApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedCollectionApprovals bool `protobuf:"varint,8,opt,name=onlyCheckPrioritizedCollectionApprovals,proto3" json:"onlyCheckPrioritizedCollectionApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedIncomingApprovals bool `protobuf:"varint,9,opt,name=onlyCheckPrioritizedIncomingApprovals,proto3" json:"onlyCheckPrioritizedIncomingApprovals,omitempty"`
	// Whether to only check prioritized approvals for the transfer.
	// If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
	// If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
	OnlyCheckPrioritizedOutgoingApprovals bool `protobuf:"varint,10,opt,name=onlyCheckPrioritizedOutgoingApprovals,proto3" json:"onlyCheckPrioritizedOutgoingApprovals,omitempty"`
}

func (m *Transfer) Reset()         { *m = Transfer{} }
func (m *Transfer) String() string { return proto.CompactTextString(m) }
func (*Transfer) ProtoMessage()    {}
func (*Transfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{17}
}
func (m *Transfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transfer.Merge(m, src)
}
func (m *Transfer) XXX_Size() int {
	return m.Size()
}
func (m *Transfer) XXX_DiscardUnknown() {
	xxx_messageInfo_Transfer.DiscardUnknown(m)
}

var xxx_messageInfo_Transfer proto.InternalMessageInfo

func (m *Transfer) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Transfer) GetToAddresses() []string {
	if m != nil {
		return m.ToAddresses
	}
	return nil
}

func (m *Transfer) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *Transfer) GetPrecalculateBalancesFromApproval() *ApprovalIdentifierDetails {
	if m != nil {
		return m.PrecalculateBalancesFromApproval
	}
	return nil
}

func (m *Transfer) GetMerkleProofs() []*MerkleProof {
	if m != nil {
		return m.MerkleProofs
	}
	return nil
}

func (m *Transfer) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *Transfer) GetPrioritizedApprovals() []*ApprovalIdentifierDetails {
	if m != nil {
		return m.PrioritizedApprovals
	}
	return nil
}

func (m *Transfer) GetOnlyCheckPrioritizedCollectionApprovals() bool {
	if m != nil {
		return m.OnlyCheckPrioritizedCollectionApprovals
	}
	return false
}

func (m *Transfer) GetOnlyCheckPrioritizedIncomingApprovals() bool {
	if m != nil {
		return m.OnlyCheckPrioritizedIncomingApprovals
	}
	return false
}

func (m *Transfer) GetOnlyCheckPrioritizedOutgoingApprovals() bool {
	if m != nil {
		return m.OnlyCheckPrioritizedOutgoingApprovals
	}
	return false
}

// MerklePathItem represents an item in a Merkle path.
type MerklePathItem struct {
	// The hash of the sibling node (aunt) in the Merkle path.
	Aunt string `protobuf:"bytes,1,opt,name=aunt,proto3" json:"aunt,omitempty"`
	// Indicates whether the aunt node is on the right side of the path.
	OnRight bool `protobuf:"varint,2,opt,name=onRight,proto3" json:"onRight,omitempty"`
}

func (m *MerklePathItem) Reset()         { *m = MerklePathItem{} }
func (m *MerklePathItem) String() string { return proto.CompactTextString(m) }
func (*MerklePathItem) ProtoMessage()    {}
func (*MerklePathItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{18}
}
func (m *MerklePathItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerklePathItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerklePathItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerklePathItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerklePathItem.Merge(m, src)
}
func (m *MerklePathItem) XXX_Size() int {
	return m.Size()
}
func (m *MerklePathItem) XXX_DiscardUnknown() {
	xxx_messageInfo_MerklePathItem.DiscardUnknown(m)
}

var xxx_messageInfo_MerklePathItem proto.InternalMessageInfo

func (m *MerklePathItem) GetAunt() string {
	if m != nil {
		return m.Aunt
	}
	return ""
}

func (m *MerklePathItem) GetOnRight() bool {
	if m != nil {
		return m.OnRight
	}
	return false
}

// MerkleProof represents a Merkle proof, consistent with Tendermint/Crypto Merkle tree.
type MerkleProof struct {
	// The hash of the leaf node for which the proof is generated.
	Leaf string `protobuf:"bytes,1,opt,name=leaf,proto3" json:"leaf,omitempty"`
	// List of Merkle path items (aunts) that make up the proof.
	Aunts []*MerklePathItem `protobuf:"bytes,2,rep,name=aunts,proto3" json:"aunts,omitempty"`
}

func (m *MerkleProof) Reset()         { *m = MerkleProof{} }
func (m *MerkleProof) String() string { return proto.CompactTextString(m) }
func (*MerkleProof) ProtoMessage()    {}
func (*MerkleProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_db7d8388ebf2a03f, []int{19}
}
func (m *MerkleProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerkleProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerkleProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerkleProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerkleProof.Merge(m, src)
}
func (m *MerkleProof) XXX_Size() int {
	return m.Size()
}
func (m *MerkleProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MerkleProof.DiscardUnknown(m)
}

var xxx_messageInfo_MerkleProof proto.InternalMessageInfo

func (m *MerkleProof) GetLeaf() string {
	if m != nil {
		return m.Leaf
	}
	return ""
}

func (m *MerkleProof) GetAunts() []*MerklePathItem {
	if m != nil {
		return m.Aunts
	}
	return nil
}

func init() {
	proto.RegisterType((*UserBalanceStore)(nil), "badges.UserBalanceStore")
	proto.RegisterType((*MerkleChallenge)(nil), "badges.MerkleChallenge")
	proto.RegisterType((*UserOutgoingApproval)(nil), "badges.UserOutgoingApproval")
	proto.RegisterType((*UserIncomingApproval)(nil), "badges.UserIncomingApproval")
	proto.RegisterType((*ManualBalances)(nil), "badges.ManualBalances")
	proto.RegisterType((*IncrementedBalances)(nil), "badges.IncrementedBalances")
	proto.RegisterType((*PredeterminedOrderCalculationMethod)(nil), "badges.PredeterminedOrderCalculationMethod")
	proto.RegisterType((*PredeterminedBalances)(nil), "badges.PredeterminedBalances")
	proto.RegisterType((*ApprovalAmounts)(nil), "badges.ApprovalAmounts")
	proto.RegisterType((*MaxNumTransfers)(nil), "badges.MaxNumTransfers")
	proto.RegisterType((*ApprovalTracker)(nil), "badges.ApprovalTracker")
	proto.RegisterType((*CoinTransfer)(nil), "badges.CoinTransfer")
	proto.RegisterType((*ApprovalCriteria)(nil), "badges.ApprovalCriteria")
	proto.RegisterType((*OutgoingApprovalCriteria)(nil), "badges.OutgoingApprovalCriteria")
	proto.RegisterType((*IncomingApprovalCriteria)(nil), "badges.IncomingApprovalCriteria")
	proto.RegisterType((*CollectionApproval)(nil), "badges.CollectionApproval")
	proto.RegisterType((*ApprovalIdentifierDetails)(nil), "badges.ApprovalIdentifierDetails")
	proto.RegisterType((*Transfer)(nil), "badges.Transfer")
	proto.RegisterType((*MerklePathItem)(nil), "badges.MerklePathItem")
	proto.RegisterType((*MerkleProof)(nil), "badges.MerkleProof")
}

func init() { proto.RegisterFile("badges/transfers.proto", fileDescriptor_db7d8388ebf2a03f) }

var fileDescriptor_db7d8388ebf2a03f = []byte{
	// 1726 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x4f, 0x6f, 0x1c, 0x49,
	0x15, 0xcf, 0xcc, 0xf8, 0xef, 0x1b, 0xc7, 0xf6, 0x56, 0x12, 0xef, 0xc4, 0x49, 0x66, 0x4d, 0x6f,
	0x10, 0x5e, 0xed, 0x32, 0xc3, 0x66, 0x81, 0x05, 0x24, 0x22, 0x3c, 0x36, 0x2b, 0x4d, 0x64, 0xc7,
	0x56, 0xc7, 0x96, 0x10, 0x42, 0x40, 0xb9, 0xfb, 0x79, 0xa6, 0x95, 0xee, 0xae, 0xd9, 0xea, 0x1a,
	0x63, 0x73, 0xe4, 0x00, 0x12, 0x7b, 0xe1, 0xcc, 0x95, 0x03, 0x07, 0x3e, 0x00, 0xe2, 0x1b, 0xec,
	0x71, 0x4f, 0x68, 0xc5, 0x61, 0x85, 0x92, 0x0f, 0x02, 0xea, 0xea, 0xaa, 0x99, 0xee, 0xea, 0xee,
	0x99, 0x4e, 0x04, 0xd2, 0x1e, 0x72, 0xab, 0xa9, 0xf7, 0x7b, 0xbf, 0xee, 0x7e, 0xef, 0x57, 0xaf,
	0xaa, 0xde, 0xc0, 0xd6, 0x39, 0x75, 0x07, 0x18, 0x75, 0x05, 0xa7, 0x61, 0x74, 0x81, 0x3c, 0xea,
	0x8c, 0x38, 0x13, 0x8c, 0x2c, 0x25, 0xf3, 0xdb, 0xb7, 0x07, 0x6c, 0xc0, 0xe4, 0x54, 0x37, 0x1e,
	0x25, 0xd6, 0xed, 0x96, 0xf2, 0x1a, 0x21, 0x0f, 0xbc, 0x28, 0xf2, 0x58, 0xa8, 0xfc, 0xb6, 0xb7,
	0x95, 0x85, 0xba, 0x2e, 0xc7, 0x28, 0xfa, 0x95, 0xef, 0x45, 0x42, 0xdb, 0xee, 0x28, 0xdb, 0x39,
	0xf5, 0x69, 0xe8, 0xa0, 0x9e, 0x6e, 0x3b, 0x2c, 0x0a, 0x58, 0x3c, 0x1d, 0x61, 0xf7, 0xf2, 0xc3,
	0x73, 0x14, 0xf4, 0xc3, 0xae, 0xc3, 0xbc, 0x30, 0xb1, 0x5b, 0xff, 0x6c, 0xc0, 0xe6, 0x59, 0x84,
	0xbc, 0x97, 0xb8, 0x3d, 0x13, 0x8c, 0x23, 0x79, 0x1f, 0x56, 0x34, 0x4d, 0xab, 0xb6, 0xd3, 0xd8,
	0x6d, 0x3e, 0xda, 0xe8, 0x24, 0xf4, 0x1d, 0x85, 0xb3, 0x27, 0x00, 0xf2, 0x04, 0xde, 0x62, 0x63,
	0x31, 0x60, 0x5e, 0x38, 0xd8, 0x1b, 0x8d, 0x38, 0xbb, 0xa4, 0x7e, 0xd4, 0xaa, 0x4b, 0xaf, 0xfb,
	0xda, 0x2b, 0x7e, 0xc2, 0xb1, 0x01, 0xb2, 0xf3, 0x6e, 0x31, 0x97, 0x17, 0x3a, 0x2c, 0xc8, 0x70,
	0x35, 0xf2, 0x5c, 0x7d, 0x03, 0x64, 0xe7, 0xdd, 0xc8, 0x2f, 0xe0, 0x3d, 0x3a, 0x16, 0x2c, 0x99,
	0xc0, 0x67, 0xe8, 0x5f, 0xf4, 0x43, 0x4f, 0x78, 0x54, 0xa0, 0xab, 0x5f, 0xe5, 0x54, 0xe7, 0xa5,
	0xb5, 0xb0, 0x53, 0xdb, 0x5d, 0xb1, 0xab, 0x3b, 0xcc, 0x62, 0xd7, 0x2f, 0x37, 0x65, 0x5f, 0x9c,
	0xcd, 0x9e, 0x73, 0x20, 0x7b, 0xb0, 0x31, 0x8e, 0x90, 0x9f, 0x4c, 0x15, 0xd0, 0x5a, 0xda, 0xa9,
	0xed, 0x36, 0x1f, 0xbd, 0x9d, 0x8e, 0x42, 0xca, 0x6c, 0x9b, 0x78, 0xeb, 0xef, 0x75, 0xd8, 0x38,
	0x42, 0xfe, 0xdc, 0xc7, 0xfd, 0x21, 0xf5, 0x7d, 0x0c, 0x07, 0x48, 0x08, 0x2c, 0x70, 0xc6, 0x44,
	0xab, 0xb6, 0x53, 0xdb, 0x5d, 0xb5, 0xe5, 0x98, 0x3c, 0x86, 0x5b, 0x78, 0x35, 0x42, 0x47, 0xa0,
	0x7b, 0xc2, 0x19, 0xbb, 0x38, 0xc4, 0x70, 0x20, 0x86, 0xad, 0x7a, 0x0c, 0xe9, 0xad, 0x7d, 0xfe,
	0xd5, 0x3b, 0x37, 0xfe, 0xf5, 0xd5, 0x3b, 0x0b, 0x67, 0x5e, 0x28, 0xec, 0x22, 0x20, 0xf9, 0x01,
	0xbc, 0x3d, 0x8e, 0x70, 0x9f, 0x23, 0x15, 0x8c, 0xef, 0x25, 0xc2, 0xdc, 0x8b, 0x0e, 0x91, 0x5e,
	0xb4, 0x1a, 0xf2, 0xb3, 0xcb, 0xcc, 0xe4, 0xbb, 0xb0, 0x1e, 0xd0, 0xab, 0xb3, 0x08, 0xa3, 0x13,
	0xe4, 0xd2, 0x61, 0xa1, 0xe0, 0xa1, 0x06, 0x86, 0x6c, 0x42, 0x63, 0xcc, 0x3d, 0x19, 0xd2, 0x55,
	0x3b, 0x1e, 0x92, 0x36, 0x80, 0x33, 0x8e, 0x04, 0x0b, 0x0e, 0xa8, 0xa0, 0x32, 0x4e, 0xab, 0x76,
	0x6a, 0x86, 0x74, 0x80, 0x38, 0x3a, 0x04, 0xa7, 0x9c, 0x3a, 0xcf, 0x91, 0xf7, 0xdd, 0xd6, 0xb2,
	0xc4, 0x15, 0x58, 0xac, 0xbf, 0x34, 0xe0, 0x76, 0x91, 0x60, 0xc9, 0x36, 0xac, 0x08, 0x76, 0xe8,
	0x45, 0xa2, 0xef, 0xaa, 0x10, 0x4e, 0x7e, 0x93, 0x0f, 0x62, 0xe5, 0xaa, 0x7c, 0xf6, 0xae, 0x15,
	0x48, 0x06, 0xd1, 0xce, 0x1b, 0xc8, 0xc7, 0x70, 0x53, 0xd7, 0x84, 0x53, 0x2f, 0x40, 0xad, 0xf1,
	0xb7, 0x26, 0xd9, 0x8d, 0xbf, 0x9c, 0x86, 0x03, 0xb4, 0xb3, 0x38, 0xf2, 0xed, 0x78, 0x65, 0xba,
	0x03, 0xec, 0xbb, 0xb1, 0x66, 0x4b, 0x7c, 0x26, 0x10, 0xf2, 0x43, 0x58, 0x67, 0xbf, 0x09, 0x91,
	0x47, 0x43, 0x6f, 0x94, 0x3c, 0x68, 0xb1, 0xcc, 0xc9, 0x00, 0xea, 0x38, 0xaf, 0x94, 0xc5, 0x79,
	0x35, 0x17, 0xe7, 0x36, 0x00, 0x55, 0xa1, 0xea, 0xbb, 0x2d, 0x48, 0xec, 0xd3, 0x19, 0x72, 0x08,
	0x9b, 0xfa, 0xd7, 0x3e, 0xf7, 0x04, 0x72, 0x8f, 0xb6, 0x9a, 0x52, 0xd5, 0x3b, 0xfa, 0x75, 0xcc,
	0x90, 0x6b, 0x9c, 0x9d, 0xf3, 0xb4, 0xfe, 0xaa, 0xb2, 0x64, 0x96, 0x82, 0xf8, 0x35, 0x2e, 0x38,
	0x0b, 0x32, 0x79, 0x4a, 0xcd, 0xbc, 0xc9, 0xd4, 0xff, 0x24, 0x53, 0x66, 0xd8, 0x67, 0x64, 0xea,
	0xc7, 0xb0, 0x7e, 0x44, 0xc3, 0x31, 0xf5, 0x7b, 0x7a, 0xcb, 0x78, 0x95, 0xfd, 0xc5, 0xfa, 0xb2,
	0x06, 0xb7, 0xfa, 0xa1, 0xc3, 0x31, 0xc0, 0x30, 0xce, 0x8c, 0x26, 0xf9, 0x1e, 0xdc, 0x8c, 0x04,
	0xe5, 0xa2, 0x37, 0x87, 0x29, 0x8b, 0x8a, 0xeb, 0x9d, 0xa7, 0xd9, 0x7a, 0x2a, 0xfa, 0xbd, 0xeb,
	0xe2, 0x7a, 0x57, 0x00, 0x24, 0x4f, 0xe0, 0xee, 0x64, 0xfa, 0x38, 0x93, 0x88, 0xde, 0xb5, 0xac,
	0x78, 0x26, 0x4b, 0x39, 0xdc, 0xfa, 0x5b, 0x03, 0xde, 0x3d, 0xe1, 0xe8, 0xa2, 0x88, 0x0b, 0x77,
	0x88, 0xee, 0x31, 0x77, 0x91, 0xef, 0x53, 0xdf, 0x19, 0xfb, 0x54, 0x78, 0x2c, 0x3c, 0x42, 0x31,
	0x64, 0x2e, 0xf9, 0x3e, 0x6c, 0x8d, 0x23, 0x3c, 0xbe, 0x44, 0x4e, 0x7d, 0xff, 0xe9, 0x38, 0x98,
	0xee, 0x2c, 0x35, 0x59, 0x62, 0x4b, 0xac, 0xe4, 0x27, 0x70, 0x6f, 0x1c, 0xe1, 0x09, 0xf2, 0x53,
	0xa6, 0x4a, 0x6f, 0xc6, 0xb9, 0x2e, 0x9d, 0x67, 0x41, 0xc8, 0x01, 0x3c, 0x48, 0xcc, 0x9f, 0x70,
	0x16, 0x14, 0x71, 0x24, 0x35, 0x7e, 0x36, 0x88, 0xd8, 0xf0, 0x30, 0x01, 0xf4, 0xa7, 0xeb, 0xab,
	0x88, 0x2c, 0xd9, 0x85, 0x2b, 0x61, 0xd5, 0xb7, 0x19, 0x3b, 0x5c, 0xbc, 0x43, 0xf4, 0x43, 0x17,
	0xaf, 0xd4, 0x96, 0x3b, 0x0b, 0x52, 0xb2, 0x2f, 0x2c, 0x95, 0xee, 0x0b, 0x9f, 0xd5, 0xe1, 0x4e,
	0x26, 0x5b, 0x29, 0x4d, 0xad, 0x07, 0x19, 0x85, 0x2b, 0x2d, 0x6e, 0x69, 0x2d, 0x66, 0xf5, 0x6f,
	0x1b, 0x68, 0x72, 0x94, 0xd2, 0xe4, 0x94, 0x56, 0xe6, 0xa7, 0xf9, 0xe8, 0x5e, 0x6a, 0xc9, 0x99,
	0x10, 0xbb, 0xc8, 0x8f, 0x38, 0xb0, 0xc5, 0x0a, 0x85, 0x24, 0xb3, 0xd5, 0x7c, 0xf4, 0xbe, 0x66,
	0xac, 0xa0, 0x3d, 0xbb, 0x84, 0xca, 0xfa, 0x4f, 0x1d, 0x36, 0xf4, 0xe2, 0xdf, 0x0b, 0xd8, 0x38,
	0x14, 0x11, 0xe9, 0xc1, 0x1d, 0x96, 0xc8, 0x30, 0x6b, 0x49, 0xaa, 0xb0, 0xb1, 0x2e, 0x8a, 0xa1,
	0xe4, 0x10, 0xb6, 0x47, 0x29, 0x35, 0x1a, 0x44, 0x45, 0xcb, 0x74, 0x06, 0x9e, 0x9c, 0xc0, 0xfd,
	0x51, 0x46, 0x97, 0x06, 0x5f, 0xd1, 0x82, 0x9d, 0xe9, 0x41, 0x7e, 0x09, 0xef, 0x8e, 0x8a, 0xc4,
	0x69, 0x10, 0x17, 0x1d, 0x65, 0xaa, 0x38, 0x92, 0x5d, 0xd8, 0xa0, 0x72, 0x64, 0x4a, 0xd2, 0x9c,
	0xb6, 0xfe, 0xd0, 0x80, 0x8d, 0x23, 0x7a, 0x65, 0xac, 0xd7, 0x2d, 0x15, 0x56, 0xc3, 0x52, 0x98,
	0x82, 0x12, 0x2c, 0x79, 0x0a, 0xf7, 0xd2, 0x31, 0x35, 0xa9, 0x8a, 0x92, 0x30, 0xcb, 0x81, 0xd8,
	0xf0, 0x20, 0x1b, 0x53, 0x93, 0xb1, 0x28, 0x0d, 0xb3, 0x5d, 0xc8, 0xaf, 0xe1, 0x61, 0x61, 0x38,
	0x4d, 0xea, 0xa2, 0x44, 0x54, 0xf2, 0x7c, 0x85, 0x4c, 0x84, 0xd3, 0xa5, 0xa0, 0x26, 0xc9, 0x77,
	0x60, 0x2d, 0x9c, 0x17, 0xfe, 0x0c, 0x82, 0xbc, 0x07, 0xcb, 0x09, 0xaf, 0xbe, 0x3d, 0xe5, 0x76,
	0x32, 0x6d, 0xb7, 0x8e, 0x61, 0x6d, 0x9f, 0x79, 0xa1, 0xf6, 0x25, 0xeb, 0x50, 0x17, 0x4c, 0x1d,
	0x75, 0xea, 0x82, 0x91, 0x2e, 0x2c, 0xc6, 0x57, 0x3c, 0x4d, 0x74, 0xb7, 0x93, 0x5c, 0x02, 0x3b,
	0xf1, 0x25, 0xb0, 0xa3, 0x2e, 0x81, 0x9d, 0x98, 0xc1, 0x4e, 0x70, 0xd6, 0x9f, 0x97, 0x60, 0xd3,
	0xdc, 0xc9, 0xc9, 0x3e, 0x6c, 0x06, 0xd9, 0xda, 0xa9, 0xeb, 0xda, 0xe4, 0x16, 0x62, 0xd4, 0x56,
	0x3b, 0xe7, 0x40, 0x9e, 0xc1, 0x9d, 0x51, 0x51, 0xcd, 0x54, 0xc5, 0xed, 0x41, 0x61, 0x29, 0x9a,
	0x94, 0xb7, 0x62, 0xdf, 0xf8, 0x7a, 0x44, 0xb3, 0xa5, 0x47, 0x55, 0xb6, 0xc9, 0x8b, 0x19, 0x95,
	0xc9, 0x36, 0xf1, 0x31, 0x45, 0x50, 0xa0, 0x94, 0xf4, 0xb7, 0x65, 0xcd, 0xb6, 0x89, 0x27, 0x3f,
	0x82, 0x9b, 0x4e, 0x2a, 0x0b, 0xfa, 0xc4, 0x76, 0x5b, 0x13, 0xa4, 0x53, 0x64, 0x67, 0xa1, 0xe4,
	0x31, 0x6c, 0x73, 0xfc, 0x74, 0xec, 0x71, 0x3c, 0x65, 0x3f, 0xfd, 0x74, 0x4c, 0xfd, 0x28, 0xa5,
	0x47, 0x29, 0xb3, 0x15, 0x7b, 0x06, 0x82, 0xf4, 0xe0, 0xbe, 0xb2, 0xc6, 0x4b, 0x24, 0xcf, 0xb0,
	0x2c, 0x19, 0x66, 0x62, 0xc8, 0x13, 0xd8, 0x99, 0x3c, 0xe1, 0x80, 0x61, 0xf4, 0x94, 0x09, 0x09,
	0x4a, 0xf3, 0xac, 0x48, 0x9e, 0xb9, 0x38, 0xf2, 0x14, 0xac, 0xd4, 0xb3, 0xca, 0xd8, 0x56, 0x25,
	0x5b, 0x05, 0x24, 0xf9, 0x04, 0xda, 0x71, 0x6d, 0xe2, 0x9e, 0x8b, 0x51, 0x8c, 0x3b, 0xce, 0x75,
	0x18, 0x40, 0x72, 0xcd, 0x41, 0xc5, 0x71, 0x9a, 0x20, 0x4e, 0x59, 0x3f, 0xd7, 0x5b, 0x68, 0x26,
	0x71, 0x9a, 0x85, 0xb1, 0x7e, 0xb7, 0x00, 0xad, 0xb2, 0x8b, 0xc9, 0x9b, 0x45, 0xf2, 0x35, 0x5e,
	0x24, 0x55, 0x04, 0xbe, 0x5c, 0x4d, 0xe0, 0xd6, 0x1f, 0x17, 0xa0, 0x55, 0x76, 0xe7, 0x79, 0x23,
	0x82, 0xff, 0xa3, 0x08, 0xe6, 0x55, 0xba, 0xa5, 0x0a, 0x95, 0xae, 0x5a, 0x75, 0x5a, 0xae, 0x5a,
	0x9d, 0xac, 0x7f, 0x34, 0x80, 0xec, 0x33, 0xdf, 0x47, 0x27, 0x3e, 0x10, 0x57, 0xee, 0x3c, 0xa4,
	0xfb, 0x47, 0xf5, 0x2a, 0xfd, 0xa3, 0x46, 0xe5, 0xae, 0xc4, 0xc2, 0x6b, 0x74, 0x25, 0x16, 0x5f,
	0xa7, 0x2b, 0xb1, 0xf4, 0x8a, 0x5d, 0x89, 0xd5, 0xb2, 0xae, 0x04, 0xcc, 0xe9, 0x4a, 0x34, 0x73,
	0x5d, 0x89, 0x83, 0x82, 0xae, 0xc4, 0x9a, 0x54, 0x62, 0xcb, 0x14, 0xf3, 0x8c, 0x6e, 0xc4, 0x67,
	0x35, 0xb8, 0xbb, 0x37, 0x21, 0xc5, 0x50, 0x78, 0x17, 0x1e, 0xf2, 0x03, 0x14, 0xd4, 0xf3, 0x23,
	0xe3, 0x1d, 0x6a, 0xb9, 0x77, 0x78, 0x08, 0x37, 0xf5, 0xaf, 0x43, 0xbc, 0x44, 0x5f, 0xe5, 0x31,
	0x3b, 0x29, 0x4f, 0x8e, 0x49, 0x9f, 0x57, 0xb7, 0x3c, 0x55, 0x2a, 0xcd, 0x69, 0xeb, 0xf7, 0x8b,
	0xb0, 0x32, 0x39, 0xc6, 0x11, 0x58, 0x88, 0xd5, 0xa2, 0xdb, 0xb3, 0xf1, 0x98, 0xec, 0x40, 0x53,
	0xe8, 0x63, 0x35, 0x26, 0x07, 0xba, 0x55, 0x3b, 0x3d, 0x95, 0x69, 0xa6, 0x34, 0xe6, 0x35, 0xeb,
	0x03, 0xd8, 0x19, 0x71, 0x74, 0xd4, 0x6d, 0x0e, 0x75, 0x9d, 0x90, 0xe7, 0x6c, 0xf5, 0x09, 0x6a,
	0x75, 0x7f, 0xc3, 0x8c, 0x69, 0x2e, 0x58, 0xf6, 0x5c, 0x2a, 0xf2, 0x31, 0xac, 0x25, 0x75, 0x4e,
	0x76, 0x8c, 0xb5, 0xe4, 0x6e, 0x65, 0x8b, 0xa2, 0xb4, 0xd9, 0x19, 0x60, 0x1c, 0x8a, 0x00, 0x03,
	0xa6, 0x0e, 0xdc, 0x72, 0x4c, 0xce, 0xe0, 0xf6, 0x88, 0x7b, 0x8c, 0x7b, 0xc2, 0xfb, 0x2d, 0xba,
	0xd3, 0x3d, 0x7c, 0x59, 0x92, 0x56, 0x78, 0xdf, 0x42, 0x77, 0xf2, 0x33, 0xf8, 0x16, 0x0b, 0xfd,
	0xeb, 0xfd, 0x21, 0x3a, 0xcf, 0x4f, 0xa6, 0x80, 0xfc, 0xfa, 0x8e, 0xd4, 0x69, 0xa8, 0x2a, 0x9c,
	0x9c, 0xc2, 0x37, 0x8b, 0xa0, 0xf9, 0x53, 0x48, 0x72, 0x2e, 0xaa, 0x06, 0x2e, 0x63, 0x2d, 0x3b,
	0x21, 0x55, 0x03, 0x5b, 0x8f, 0x61, 0x5d, 0x65, 0x83, 0x8a, 0x61, 0x5f, 0x60, 0x10, 0xa7, 0x80,
	0x4e, 0xee, 0xee, 0xb6, 0x1c, 0x93, 0x16, 0x2c, 0xb3, 0xd0, 0xf6, 0x06, 0x43, 0xa1, 0x9a, 0x47,
	0xfa, 0xa7, 0x75, 0x0c, 0xcd, 0x54, 0x36, 0x63, 0x67, 0x1f, 0xe9, 0x85, 0x76, 0x8e, 0xc7, 0xe4,
	0x03, 0x58, 0xa4, 0xa9, 0xeb, 0xcd, 0x96, 0xa1, 0x02, 0xf5, 0x5c, 0x3b, 0x01, 0xf5, 0xfa, 0x9f,
	0xbf, 0x68, 0xd7, 0xbe, 0x78, 0xd1, 0xae, 0xfd, 0xfb, 0x45, 0xbb, 0xf6, 0xa7, 0x97, 0xed, 0x1b,
	0x5f, 0xbc, 0x6c, 0xdf, 0xf8, 0xf2, 0x65, 0xfb, 0xc6, 0xcf, 0xbb, 0x03, 0x4f, 0xf8, 0xf4, 0xbc,
	0xe3, 0xb0, 0xa0, 0x2b, 0x86, 0x8c, 0x3b, 0x43, 0xea, 0x85, 0x72, 0x14, 0x32, 0x17, 0xbb, 0x97,
	0x1f, 0x75, 0xaf, 0xba, 0xfa, 0x8f, 0xb7, 0xeb, 0x11, 0x46, 0xe7, 0x4b, 0xf2, 0xaf, 0xae, 0x8f,
	0xfe, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x45, 0x94, 0x18, 0xf5, 0x8f, 0x1b, 0x00, 0x00,
}

func (m *UserBalanceStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserBalanceStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserBalanceStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserPermissions != nil {
		{
			size, err := m.UserPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		i--
		if m.AutoApproveSelfInitiatedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		i--
		if m.AutoApproveSelfInitiatedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.IncomingApprovals) > 0 {
		for iNdEx := len(m.IncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IncomingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OutgoingApprovals) > 0 {
		for iNdEx := len(m.OutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutgoingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MerkleChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerkleChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.MaxUsesPerLeaf.Size()
		i -= size
		if _, err := m.MaxUsesPerLeaf.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.UseCreatorAddressAsLeaf {
		i--
		if m.UseCreatorAddressAsLeaf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.ExpectedProofLength.Size()
		i -= size
		if _, err := m.ExpectedProofLength.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserOutgoingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserOutgoingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserOutgoingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApprovalCriteria != nil {
		{
			size, err := m.ApprovalCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToListId) > 0 {
		i -= len(m.ToListId)
		copy(dAtA[i:], m.ToListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserIncomingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIncomingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserIncomingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApprovalCriteria != nil {
		{
			size, err := m.ApprovalCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromListId) > 0 {
		i -= len(m.FromListId)
		copy(dAtA[i:], m.FromListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.FromListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ManualBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManualBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ManualBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IncrementedBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrementedBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrementedBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.IncrementOwnershipTimesBy.Size()
		i -= size
		if _, err := m.IncrementOwnershipTimesBy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.IncrementBadgeIdsBy.Size()
		i -= size
		if _, err := m.IncrementBadgeIdsBy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.StartBalances) > 0 {
		for iNdEx := len(m.StartBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StartBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PredeterminedOrderCalculationMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredeterminedOrderCalculationMethod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredeterminedOrderCalculationMethod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	if m.UseMerkleChallengeLeafIndex {
		i--
		if m.UseMerkleChallengeLeafIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.UsePerInitiatedByAddressNumTransfers {
		i--
		if m.UsePerInitiatedByAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UsePerFromAddressNumTransfers {
		i--
		if m.UsePerFromAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UsePerToAddressNumTransfers {
		i--
		if m.UsePerToAddressNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.UseOverallNumTransfers {
		i--
		if m.UseOverallNumTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PredeterminedBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredeterminedBalances) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredeterminedBalances) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderCalculationMethod != nil {
		{
			size, err := m.OrderCalculationMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IncrementedBalances != nil {
		{
			size, err := m.IncrementedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ManualBalances) > 0 {
		for iNdEx := len(m.ManualBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManualBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ApprovalAmounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalAmounts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalAmounts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AmountTrackerId) > 0 {
		i -= len(m.AmountTrackerId)
		copy(dAtA[i:], m.AmountTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.AmountTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.PerInitiatedByAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerInitiatedByAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PerFromAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerFromAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PerToAddressApprovalAmount.Size()
		i -= size
		if _, err := m.PerToAddressApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OverallApprovalAmount.Size()
		i -= size
		if _, err := m.OverallApprovalAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MaxNumTransfers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxNumTransfers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxNumTransfers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AmountTrackerId) > 0 {
		i -= len(m.AmountTrackerId)
		copy(dAtA[i:], m.AmountTrackerId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.AmountTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.PerInitiatedByAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerInitiatedByAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.PerFromAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerFromAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.PerToAddressMaxNumTransfers.Size()
		i -= size
		if _, err := m.PerToAddressMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.OverallMaxNumTransfers.Size()
		i -= size
		if _, err := m.OverallMaxNumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ApprovalTracker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalTracker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalTracker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amounts) > 0 {
		for iNdEx := len(m.Amounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.NumTransfers.Size()
		i -= size
		if _, err := m.NumTransfers.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTransfers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CoinTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoinTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverridesToIncomingApprovals {
		i--
		if m.OverridesToIncomingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.OverridesFromOutgoingApprovals {
		i--
		if m.OverridesFromOutgoingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OutgoingApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutgoingApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutgoingApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IncomingApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomingApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncomingApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApprovalCriteria != nil {
		{
			size, err := m.ApprovalCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.InitiatedByListId) > 0 {
		i -= len(m.InitiatedByListId)
		copy(dAtA[i:], m.InitiatedByListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.InitiatedByListId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ToListId) > 0 {
		i -= len(m.ToListId)
		copy(dAtA[i:], m.ToListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToListId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromListId) > 0 {
		i -= len(m.FromListId)
		copy(dAtA[i:], m.FromListId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.FromListId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApprovalIdentifierDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalIdentifierDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalIdentifierDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApproverAddress) > 0 {
		i -= len(m.ApproverAddress)
		copy(dAtA[i:], m.ApproverAddress)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApproverAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ApprovalLevel) > 0 {
		i -= len(m.ApprovalLevel)
		copy(dAtA[i:], m.ApprovalLevel)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalLevel)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Transfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OnlyCheckPrioritizedOutgoingApprovals {
		i--
		if m.OnlyCheckPrioritizedOutgoingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.OnlyCheckPrioritizedIncomingApprovals {
		i--
		if m.OnlyCheckPrioritizedIncomingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.OnlyCheckPrioritizedCollectionApprovals {
		i--
		if m.OnlyCheckPrioritizedCollectionApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.PrioritizedApprovals) > 0 {
		for iNdEx := len(m.PrioritizedApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrioritizedApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MerkleProofs) > 0 {
		for iNdEx := len(m.MerkleProofs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleProofs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PrecalculateBalancesFromApproval != nil {
		{
			size, err := m.PrecalculateBalancesFromApproval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransfers(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ToAddresses) > 0 {
		for iNdEx := len(m.ToAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ToAddresses[iNdEx])
			copy(dAtA[i:], m.ToAddresses[iNdEx])
			i = encodeVarintTransfers(dAtA, i, uint64(len(m.ToAddresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MerklePathItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerklePathItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerklePathItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OnRight {
		i--
		if m.OnRight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Aunt) > 0 {
		i -= len(m.Aunt)
		copy(dAtA[i:], m.Aunt)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Aunt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MerkleProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerkleProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aunts) > 0 {
		for iNdEx := len(m.Aunts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Aunts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransfers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Leaf) > 0 {
		i -= len(m.Leaf)
		copy(dAtA[i:], m.Leaf)
		i = encodeVarintTransfers(dAtA, i, uint64(len(m.Leaf)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTransfers(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransfers(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UserBalanceStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OutgoingApprovals) > 0 {
		for _, e := range m.OutgoingApprovals {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.IncomingApprovals) > 0 {
		for _, e := range m.IncomingApprovals {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		n += 2
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		n += 2
	}
	if m.UserPermissions != nil {
		l = m.UserPermissions.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *MerkleChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = m.ExpectedProofLength.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if m.UseCreatorAddressAsLeaf {
		n += 2
	}
	l = m.MaxUsesPerLeaf.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *UserOutgoingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalCriteria != nil {
		l = m.ApprovalCriteria.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *UserIncomingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalCriteria != nil {
		l = m.ApprovalCriteria.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *ManualBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *IncrementedBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StartBalances) > 0 {
		for _, e := range m.StartBalances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = m.IncrementBadgeIdsBy.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.IncrementOwnershipTimesBy.Size()
	n += 1 + l + sovTransfers(uint64(l))
	return n
}

func (m *PredeterminedOrderCalculationMethod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseOverallNumTransfers {
		n += 2
	}
	if m.UsePerToAddressNumTransfers {
		n += 2
	}
	if m.UsePerFromAddressNumTransfers {
		n += 2
	}
	if m.UsePerInitiatedByAddressNumTransfers {
		n += 2
	}
	if m.UseMerkleChallengeLeafIndex {
		n += 2
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *PredeterminedBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ManualBalances) > 0 {
		for _, e := range m.ManualBalances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.IncrementedBalances != nil {
		l = m.IncrementedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.OrderCalculationMethod != nil {
		l = m.OrderCalculationMethod.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *ApprovalAmounts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OverallApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerToAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerFromAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerInitiatedByAddressApprovalAmount.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = len(m.AmountTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *MaxNumTransfers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OverallMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerToAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerFromAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = m.PerInitiatedByAddressMaxNumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	l = len(m.AmountTrackerId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *ApprovalTracker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NumTransfers.Size()
	n += 1 + l + sovTransfers(uint64(l))
	if len(m.Amounts) > 0 {
		for _, e := range m.Amounts {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *CoinTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func (m *ApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.OverridesFromOutgoingApprovals {
		n += 2
	}
	if m.OverridesToIncomingApprovals {
		n += 2
	}
	return n
}

func (m *OutgoingApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	return n
}

func (m *IncomingApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	return n
}

func (m *CollectionApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ToListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.InitiatedByListId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.ApprovalCriteria != nil {
		l = m.ApprovalCriteria.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *ApprovalIdentifierDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApprovalLevel)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	l = len(m.ApproverAddress)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	return n
}

func (m *Transfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.ToAddresses) > 0 {
		for _, s := range m.ToAddresses {
			l = len(s)
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.PrecalculateBalancesFromApproval != nil {
		l = m.PrecalculateBalancesFromApproval.Size()
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.MerkleProofs) > 0 {
		for _, e := range m.MerkleProofs {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.PrioritizedApprovals) > 0 {
		for _, e := range m.PrioritizedApprovals {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	if m.OnlyCheckPrioritizedCollectionApprovals {
		n += 2
	}
	if m.OnlyCheckPrioritizedIncomingApprovals {
		n += 2
	}
	if m.OnlyCheckPrioritizedOutgoingApprovals {
		n += 2
	}
	return n
}

func (m *MerklePathItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Aunt)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if m.OnRight {
		n += 2
	}
	return n
}

func (m *MerkleProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Leaf)
	if l > 0 {
		n += 1 + l + sovTransfers(uint64(l))
	}
	if len(m.Aunts) > 0 {
		for _, e := range m.Aunts {
			l = e.Size()
			n += 1 + l + sovTransfers(uint64(l))
		}
	}
	return n
}

func sovTransfers(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransfers(x uint64) (n int) {
	return sovTransfers(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserBalanceStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserBalanceStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserBalanceStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutgoingApprovals = append(m.OutgoingApprovals, &UserOutgoingApproval{})
			if err := m.OutgoingApprovals[len(m.OutgoingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncomingApprovals = append(m.IncomingApprovals, &UserIncomingApproval{})
			if err := m.IncomingApprovals[len(m.IncomingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPermissions == nil {
				m.UserPermissions = &UserPermissions{}
			}
			if err := m.UserPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedProofLength", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExpectedProofLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCreatorAddressAsLeaf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseCreatorAddressAsLeaf = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUsesPerLeaf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxUsesPerLeaf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserOutgoingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserOutgoingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserOutgoingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalCriteria == nil {
				m.ApprovalCriteria = &OutgoingApprovalCriteria{}
			}
			if err := m.ApprovalCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIncomingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIncomingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIncomingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalCriteria == nil {
				m.ApprovalCriteria = &IncomingApprovalCriteria{}
			}
			if err := m.ApprovalCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManualBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManualBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManualBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrementedBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrementedBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrementedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartBalances = append(m.StartBalances, &Balance{})
			if err := m.StartBalances[len(m.StartBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementBadgeIdsBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncrementBadgeIdsBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementOwnershipTimesBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IncrementOwnershipTimesBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredeterminedOrderCalculationMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredeterminedOrderCalculationMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredeterminedOrderCalculationMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseOverallNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseOverallNumTransfers = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerToAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerToAddressNumTransfers = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerFromAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerFromAddressNumTransfers = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerInitiatedByAddressNumTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerInitiatedByAddressNumTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseMerkleChallengeLeafIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseMerkleChallengeLeafIndex = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredeterminedBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredeterminedBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredeterminedBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManualBalances = append(m.ManualBalances, &ManualBalances{})
			if err := m.ManualBalances[len(m.ManualBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncrementedBalances == nil {
				m.IncrementedBalances = &IncrementedBalances{}
			}
			if err := m.IncrementedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderCalculationMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderCalculationMethod == nil {
				m.OrderCalculationMethod = &PredeterminedOrderCalculationMethod{}
			}
			if err := m.OrderCalculationMethod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalAmounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalAmounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalAmounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverallApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerToAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerToAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerFromAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerFromAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerInitiatedByAddressApprovalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerInitiatedByAddressApprovalAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxNumTransfers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxNumTransfers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxNumTransfers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverallMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerToAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerToAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerFromAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerFromAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerInitiatedByAddressMaxNumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PerInitiatedByAddressMaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalTracker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalTracker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalTracker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTransfers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amounts = append(m.Amounts, &Balance{})
			if err := m.Amounts[len(m.Amounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, &types.Coin{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesFromOutgoingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesFromOutgoingApprovals = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesToIncomingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesToIncomingApprovals = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutgoingApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutgoingApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutgoingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomingApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomingApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByListId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByListId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalCriteria == nil {
				m.ApprovalCriteria = &ApprovalCriteria{}
			}
			if err := m.ApprovalCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovalIdentifierDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalIdentifierDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalIdentifierDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproverAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApproverAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddresses = append(m.ToAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecalculateBalancesFromApproval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrecalculateBalancesFromApproval == nil {
				m.PrecalculateBalancesFromApproval = &ApprovalIdentifierDetails{}
			}
			if err := m.PrecalculateBalancesFromApproval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleProofs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleProofs = append(m.MerkleProofs, &MerkleProof{})
			if err := m.MerkleProofs[len(m.MerkleProofs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrioritizedApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrioritizedApprovals = append(m.PrioritizedApprovals, &ApprovalIdentifierDetails{})
			if err := m.PrioritizedApprovals[len(m.PrioritizedApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedCollectionApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyCheckPrioritizedCollectionApprovals = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedIncomingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyCheckPrioritizedIncomingApprovals = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyCheckPrioritizedOutgoingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyCheckPrioritizedOutgoingApprovals = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerklePathItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerklePathItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerklePathItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aunt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aunt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnRight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnRight = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leaf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aunts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransfers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransfers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aunts = append(m.Aunts, &MerklePathItem{})
			if err := m.Aunts[len(m.Aunts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransfers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransfers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransfers(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransfers
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransfers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransfers
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransfers
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransfers
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransfers        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransfers          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransfers = fmt.Errorf("proto: unexpected end of group")
)
