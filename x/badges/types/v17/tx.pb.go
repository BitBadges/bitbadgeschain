// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/v17/tx.proto

package v17

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Used for WASM bindings and JSON parsing
type BadgeCustomMsgType struct {
	CreateAddressListsMsg        *MsgCreateAddressLists        `protobuf:"bytes,1,opt,name=createAddressListsMsg,proto3" json:"createAddressListsMsg,omitempty"`
	UniversalUpdateCollectionMsg *MsgUniversalUpdateCollection `protobuf:"bytes,2,opt,name=universalUpdateCollectionMsg,proto3" json:"universalUpdateCollectionMsg,omitempty"`
	DeleteCollectionMsg          *MsgDeleteCollection          `protobuf:"bytes,3,opt,name=deleteCollectionMsg,proto3" json:"deleteCollectionMsg,omitempty"`
	TransferBadgesMsg            *MsgTransferBadges            `protobuf:"bytes,4,opt,name=transferBadgesMsg,proto3" json:"transferBadgesMsg,omitempty"`
	UpdateUserApprovalsMsg       *MsgUpdateUserApprovals       `protobuf:"bytes,5,opt,name=updateUserApprovalsMsg,proto3" json:"updateUserApprovalsMsg,omitempty"`
	UpdateCollectionMsg          *MsgUpdateCollection          `protobuf:"bytes,6,opt,name=updateCollectionMsg,proto3" json:"updateCollectionMsg,omitempty"`
	CreateCollectionMsg          *MsgCreateCollection          `protobuf:"bytes,7,opt,name=createCollectionMsg,proto3" json:"createCollectionMsg,omitempty"`
	CreateDynamicStoreMsg        *MsgCreateDynamicStore        `protobuf:"bytes,8,opt,name=createDynamicStoreMsg,proto3" json:"createDynamicStoreMsg,omitempty"`
	UpdateDynamicStoreMsg        *MsgUpdateDynamicStore        `protobuf:"bytes,9,opt,name=updateDynamicStoreMsg,proto3" json:"updateDynamicStoreMsg,omitempty"`
	DeleteDynamicStoreMsg        *MsgDeleteDynamicStore        `protobuf:"bytes,10,opt,name=deleteDynamicStoreMsg,proto3" json:"deleteDynamicStoreMsg,omitempty"`
	SetDynamicStoreValueMsg      *MsgSetDynamicStoreValue      `protobuf:"bytes,11,opt,name=setDynamicStoreValueMsg,proto3" json:"setDynamicStoreValueMsg,omitempty"`
	IncrementStoreValueMsg       *MsgIncrementStoreValue       `protobuf:"bytes,12,opt,name=incrementStoreValueMsg,proto3" json:"incrementStoreValueMsg,omitempty"`
	DecrementStoreValueMsg       *MsgDecrementStoreValue       `protobuf:"bytes,13,opt,name=decrementStoreValueMsg,proto3" json:"decrementStoreValueMsg,omitempty"`
	SetIncomingApprovalMsg       *MsgSetIncomingApproval       `protobuf:"bytes,14,opt,name=setIncomingApprovalMsg,proto3" json:"setIncomingApprovalMsg,omitempty"`
	DeleteIncomingApprovalMsg    *MsgDeleteIncomingApproval    `protobuf:"bytes,15,opt,name=deleteIncomingApprovalMsg,proto3" json:"deleteIncomingApprovalMsg,omitempty"`
	SetOutgoingApprovalMsg       *MsgSetOutgoingApproval       `protobuf:"bytes,16,opt,name=setOutgoingApprovalMsg,proto3" json:"setOutgoingApprovalMsg,omitempty"`
	DeleteOutgoingApprovalMsg    *MsgDeleteOutgoingApproval    `protobuf:"bytes,17,opt,name=deleteOutgoingApprovalMsg,proto3" json:"deleteOutgoingApprovalMsg,omitempty"`
	PurgeApprovalsMsg            *MsgPurgeApprovals            `protobuf:"bytes,18,opt,name=purgeApprovalsMsg,proto3" json:"purgeApprovalsMsg,omitempty"`
	// Helper message types for UniversalUpdateCollection subsets
	SetValidBadgeIdsMsg       *MsgSetValidBadgeIds       `protobuf:"bytes,19,opt,name=setValidBadgeIdsMsg,proto3" json:"setValidBadgeIdsMsg,omitempty"`
	SetManagerMsg             *MsgSetManager             `protobuf:"bytes,20,opt,name=setManagerMsg,proto3" json:"setManagerMsg,omitempty"`
	SetCollectionMetadataMsg  *MsgSetCollectionMetadata  `protobuf:"bytes,21,opt,name=setCollectionMetadataMsg,proto3" json:"setCollectionMetadataMsg,omitempty"`
	SetBadgeMetadataMsg       *MsgSetBadgeMetadata       `protobuf:"bytes,22,opt,name=setBadgeMetadataMsg,proto3" json:"setBadgeMetadataMsg,omitempty"`
	SetCustomDataMsg          *MsgSetCustomData          `protobuf:"bytes,23,opt,name=setCustomDataMsg,proto3" json:"setCustomDataMsg,omitempty"`
	SetStandardsMsg           *MsgSetStandards           `protobuf:"bytes,24,opt,name=setStandardsMsg,proto3" json:"setStandardsMsg,omitempty"`
	SetCollectionApprovalsMsg *MsgSetCollectionApprovals `protobuf:"bytes,25,opt,name=setCollectionApprovalsMsg,proto3" json:"setCollectionApprovalsMsg,omitempty"`
	SetIsArchivedMsg          *MsgSetIsArchived          `protobuf:"bytes,26,opt,name=setIsArchivedMsg,proto3" json:"setIsArchivedMsg,omitempty"`
}

func (m *BadgeCustomMsgType) Reset()         { *m = BadgeCustomMsgType{} }
func (m *BadgeCustomMsgType) String() string { return proto.CompactTextString(m) }
func (*BadgeCustomMsgType) ProtoMessage()    {}
func (*BadgeCustomMsgType) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{0}
}
func (m *BadgeCustomMsgType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadgeCustomMsgType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BadgeCustomMsgType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BadgeCustomMsgType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadgeCustomMsgType.Merge(m, src)
}
func (m *BadgeCustomMsgType) XXX_Size() int {
	return m.Size()
}
func (m *BadgeCustomMsgType) XXX_DiscardUnknown() {
	xxx_messageInfo_BadgeCustomMsgType.DiscardUnknown(m)
}

var xxx_messageInfo_BadgeCustomMsgType proto.InternalMessageInfo

func (m *BadgeCustomMsgType) GetCreateAddressListsMsg() *MsgCreateAddressLists {
	if m != nil {
		return m.CreateAddressListsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetUniversalUpdateCollectionMsg() *MsgUniversalUpdateCollection {
	if m != nil {
		return m.UniversalUpdateCollectionMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetDeleteCollectionMsg() *MsgDeleteCollection {
	if m != nil {
		return m.DeleteCollectionMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetTransferBadgesMsg() *MsgTransferBadges {
	if m != nil {
		return m.TransferBadgesMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetUpdateUserApprovalsMsg() *MsgUpdateUserApprovals {
	if m != nil {
		return m.UpdateUserApprovalsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetUpdateCollectionMsg() *MsgUpdateCollection {
	if m != nil {
		return m.UpdateCollectionMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetCreateCollectionMsg() *MsgCreateCollection {
	if m != nil {
		return m.CreateCollectionMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetCreateDynamicStoreMsg() *MsgCreateDynamicStore {
	if m != nil {
		return m.CreateDynamicStoreMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetUpdateDynamicStoreMsg() *MsgUpdateDynamicStore {
	if m != nil {
		return m.UpdateDynamicStoreMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetDeleteDynamicStoreMsg() *MsgDeleteDynamicStore {
	if m != nil {
		return m.DeleteDynamicStoreMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetDynamicStoreValueMsg() *MsgSetDynamicStoreValue {
	if m != nil {
		return m.SetDynamicStoreValueMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetIncrementStoreValueMsg() *MsgIncrementStoreValue {
	if m != nil {
		return m.IncrementStoreValueMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetDecrementStoreValueMsg() *MsgDecrementStoreValue {
	if m != nil {
		return m.DecrementStoreValueMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetIncomingApprovalMsg() *MsgSetIncomingApproval {
	if m != nil {
		return m.SetIncomingApprovalMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetDeleteIncomingApprovalMsg() *MsgDeleteIncomingApproval {
	if m != nil {
		return m.DeleteIncomingApprovalMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetOutgoingApprovalMsg() *MsgSetOutgoingApproval {
	if m != nil {
		return m.SetOutgoingApprovalMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetDeleteOutgoingApprovalMsg() *MsgDeleteOutgoingApproval {
	if m != nil {
		return m.DeleteOutgoingApprovalMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetPurgeApprovalsMsg() *MsgPurgeApprovals {
	if m != nil {
		return m.PurgeApprovalsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetValidBadgeIdsMsg() *MsgSetValidBadgeIds {
	if m != nil {
		return m.SetValidBadgeIdsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetManagerMsg() *MsgSetManager {
	if m != nil {
		return m.SetManagerMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetCollectionMetadataMsg() *MsgSetCollectionMetadata {
	if m != nil {
		return m.SetCollectionMetadataMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetBadgeMetadataMsg() *MsgSetBadgeMetadata {
	if m != nil {
		return m.SetBadgeMetadataMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetCustomDataMsg() *MsgSetCustomData {
	if m != nil {
		return m.SetCustomDataMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetStandardsMsg() *MsgSetStandards {
	if m != nil {
		return m.SetStandardsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetCollectionApprovalsMsg() *MsgSetCollectionApprovals {
	if m != nil {
		return m.SetCollectionApprovalsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetIsArchivedMsg() *MsgSetIsArchived {
	if m != nil {
		return m.SetIsArchivedMsg
	}
	return nil
}

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the module parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{1}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{2}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

type CosmosCoinWrapperPathAddObject struct {
	Denom                          string       `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Balances                       []*Balance   `protobuf:"bytes,2,rep,name=balances,proto3" json:"balances,omitempty"`
	Symbol                         string       `protobuf:"bytes,3,opt,name=symbol,proto3" json:"symbol,omitempty"`
	DenomUnits                     []*DenomUnit `protobuf:"bytes,4,rep,name=denomUnits,proto3" json:"denomUnits,omitempty"`
	AllowOverrideWithAnyValidToken bool         `protobuf:"varint,5,opt,name=allowOverrideWithAnyValidToken,proto3" json:"allowOverrideWithAnyValidToken,omitempty"`
	AllowCosmosWrapping            bool         `protobuf:"varint,6,opt,name=allowCosmosWrapping,proto3" json:"allowCosmosWrapping,omitempty"`
}

func (m *CosmosCoinWrapperPathAddObject) Reset()         { *m = CosmosCoinWrapperPathAddObject{} }
func (m *CosmosCoinWrapperPathAddObject) String() string { return proto.CompactTextString(m) }
func (*CosmosCoinWrapperPathAddObject) ProtoMessage()    {}
func (*CosmosCoinWrapperPathAddObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{3}
}
func (m *CosmosCoinWrapperPathAddObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosCoinWrapperPathAddObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosCoinWrapperPathAddObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosCoinWrapperPathAddObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosCoinWrapperPathAddObject.Merge(m, src)
}
func (m *CosmosCoinWrapperPathAddObject) XXX_Size() int {
	return m.Size()
}
func (m *CosmosCoinWrapperPathAddObject) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosCoinWrapperPathAddObject.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosCoinWrapperPathAddObject proto.InternalMessageInfo

func (m *CosmosCoinWrapperPathAddObject) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *CosmosCoinWrapperPathAddObject) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *CosmosCoinWrapperPathAddObject) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CosmosCoinWrapperPathAddObject) GetDenomUnits() []*DenomUnit {
	if m != nil {
		return m.DenomUnits
	}
	return nil
}

func (m *CosmosCoinWrapperPathAddObject) GetAllowOverrideWithAnyValidToken() bool {
	if m != nil {
		return m.AllowOverrideWithAnyValidToken
	}
	return false
}

func (m *CosmosCoinWrapperPathAddObject) GetAllowCosmosWrapping() bool {
	if m != nil {
		return m.AllowCosmosWrapping
	}
	return false
}

// MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.
// It is a universal interface that can be used for both creating and updating collections.
// We have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.
type MsgUniversalUpdateCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection (0 for new collection).
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	//The default balances for the user
	DefaultBalances *UserBalanceStore `protobuf:"bytes,3,opt,name=defaultBalances,proto3" json:"defaultBalances,omitempty"`
	// Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateValidBadgeIds bool `protobuf:"varint,4,opt,name=updateValidBadgeIds,proto3" json:"updateValidBadgeIds,omitempty"`
	// New token IDs to add to this collection
	ValidBadgeIds []*UintRange `protobuf:"bytes,5,rep,name=validBadgeIds,proto3" json:"validBadgeIds,omitempty"`
	// Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionPermissions bool `protobuf:"varint,6,opt,name=updateCollectionPermissions,proto3" json:"updateCollectionPermissions,omitempty"`
	// New collection permissions to set.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,7,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateManagerTimeline bool `protobuf:"varint,8,opt,name=updateManagerTimeline,proto3" json:"updateManagerTimeline,omitempty"`
	// New manager timeline to set.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,9,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionMetadataTimeline bool `protobuf:"varint,10,opt,name=updateCollectionMetadataTimeline,proto3" json:"updateCollectionMetadataTimeline,omitempty"`
	// New collection metadata timeline to set.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,11,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateBadgeMetadataTimeline bool `protobuf:"varint,12,opt,name=updateBadgeMetadataTimeline,proto3" json:"updateBadgeMetadataTimeline,omitempty"`
	// New token metadata timeline to set.
	BadgeMetadataTimeline []*BadgeMetadataTimeline `protobuf:"bytes,13,rep,name=badgeMetadataTimeline,proto3" json:"badgeMetadataTimeline,omitempty"`
	// Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCustomDataTimeline bool `protobuf:"varint,14,opt,name=updateCustomDataTimeline,proto3" json:"updateCustomDataTimeline,omitempty"`
	// New custom data timeline to set.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,15,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionApprovals bool `protobuf:"varint,16,opt,name=updateCollectionApprovals,proto3" json:"updateCollectionApprovals,omitempty"`
	// New collection approvals to set.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,17,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateStandardsTimeline bool `protobuf:"varint,18,opt,name=updateStandardsTimeline,proto3" json:"updateStandardsTimeline,omitempty"`
	// New standards timeline to set.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,19,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateIsArchivedTimeline bool `protobuf:"varint,20,opt,name=updateIsArchivedTimeline,proto3" json:"updateIsArchivedTimeline,omitempty"`
	// New isArchived timeline to set.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,21,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// Coins to be transferred to the mint escrow address.
	MintEscrowCoinsToTransfer []*types.Coin `protobuf:"bytes,22,rep,name=mintEscrowCoinsToTransfer,proto3" json:"mintEscrowCoinsToTransfer,omitempty"`
	// IBC wrapper paths to add.
	CosmosCoinWrapperPathsToAdd []*CosmosCoinWrapperPathAddObject `protobuf:"bytes,23,rep,name=cosmosCoinWrapperPathsToAdd,proto3" json:"cosmosCoinWrapperPathsToAdd,omitempty"`
	// Collection-level invariants that cannot be broken.
	// These are set upon genesis and cannot be modified.
	Invariants *CollectionInvariants `protobuf:"bytes,24,opt,name=invariants,proto3" json:"invariants,omitempty"`
}

func (m *MsgUniversalUpdateCollection) Reset()         { *m = MsgUniversalUpdateCollection{} }
func (m *MsgUniversalUpdateCollection) String() string { return proto.CompactTextString(m) }
func (*MsgUniversalUpdateCollection) ProtoMessage()    {}
func (*MsgUniversalUpdateCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{4}
}
func (m *MsgUniversalUpdateCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUniversalUpdateCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUniversalUpdateCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUniversalUpdateCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUniversalUpdateCollection.Merge(m, src)
}
func (m *MsgUniversalUpdateCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgUniversalUpdateCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUniversalUpdateCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUniversalUpdateCollection proto.InternalMessageInfo

func (m *MsgUniversalUpdateCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUniversalUpdateCollection) GetDefaultBalances() *UserBalanceStore {
	if m != nil {
		return m.DefaultBalances
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateValidBadgeIds() bool {
	if m != nil {
		return m.UpdateValidBadgeIds
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetValidBadgeIds() []*UintRange {
	if m != nil {
		return m.ValidBadgeIds
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCollectionPermissions() bool {
	if m != nil {
		return m.UpdateCollectionPermissions
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateManagerTimeline() bool {
	if m != nil {
		return m.UpdateManagerTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCollectionMetadataTimeline() bool {
	if m != nil {
		return m.UpdateCollectionMetadataTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateBadgeMetadataTimeline() bool {
	if m != nil {
		return m.UpdateBadgeMetadataTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetBadgeMetadataTimeline() []*BadgeMetadataTimeline {
	if m != nil {
		return m.BadgeMetadataTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCustomDataTimeline() bool {
	if m != nil {
		return m.UpdateCustomDataTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCollectionApprovals() bool {
	if m != nil {
		return m.UpdateCollectionApprovals
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateStandardsTimeline() bool {
	if m != nil {
		return m.UpdateStandardsTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateIsArchivedTimeline() bool {
	if m != nil {
		return m.UpdateIsArchivedTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetMintEscrowCoinsToTransfer() []*types.Coin {
	if m != nil {
		return m.MintEscrowCoinsToTransfer
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetCosmosCoinWrapperPathsToAdd() []*CosmosCoinWrapperPathAddObject {
	if m != nil {
		return m.CosmosCoinWrapperPathsToAdd
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetInvariants() *CollectionInvariants {
	if m != nil {
		return m.Invariants
	}
	return nil
}

// MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.
type MsgUniversalUpdateCollectionResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgUniversalUpdateCollectionResponse) Reset()         { *m = MsgUniversalUpdateCollectionResponse{} }
func (m *MsgUniversalUpdateCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUniversalUpdateCollectionResponse) ProtoMessage()    {}
func (*MsgUniversalUpdateCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{5}
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUniversalUpdateCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUniversalUpdateCollectionResponse.Merge(m, src)
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUniversalUpdateCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUniversalUpdateCollectionResponse proto.InternalMessageInfo

// MsgUpdateCollection is used to update a collection.
type MsgUpdateCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection (0 for new collection).
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateValidBadgeIds bool `protobuf:"varint,3,opt,name=updateValidBadgeIds,proto3" json:"updateValidBadgeIds,omitempty"`
	// New token IDs to add to this collection
	ValidBadgeIds []*UintRange `protobuf:"bytes,4,rep,name=validBadgeIds,proto3" json:"validBadgeIds,omitempty"`
	// Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionPermissions bool `protobuf:"varint,5,opt,name=updateCollectionPermissions,proto3" json:"updateCollectionPermissions,omitempty"`
	// New collection permissions to set.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,6,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateManagerTimeline bool `protobuf:"varint,7,opt,name=updateManagerTimeline,proto3" json:"updateManagerTimeline,omitempty"`
	// New manager timeline to set.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,8,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionMetadataTimeline bool `protobuf:"varint,9,opt,name=updateCollectionMetadataTimeline,proto3" json:"updateCollectionMetadataTimeline,omitempty"`
	// New collection metadata timeline to set.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,10,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateBadgeMetadataTimeline bool `protobuf:"varint,11,opt,name=updateBadgeMetadataTimeline,proto3" json:"updateBadgeMetadataTimeline,omitempty"`
	// New token metadata timeline to set.
	BadgeMetadataTimeline []*BadgeMetadataTimeline `protobuf:"bytes,12,rep,name=badgeMetadataTimeline,proto3" json:"badgeMetadataTimeline,omitempty"`
	// Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCustomDataTimeline bool `protobuf:"varint,13,opt,name=updateCustomDataTimeline,proto3" json:"updateCustomDataTimeline,omitempty"`
	// New custom data timeline to set.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,14,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionApprovals bool `protobuf:"varint,15,opt,name=updateCollectionApprovals,proto3" json:"updateCollectionApprovals,omitempty"`
	// New collection approvals to set.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,16,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateStandardsTimeline bool `protobuf:"varint,17,opt,name=updateStandardsTimeline,proto3" json:"updateStandardsTimeline,omitempty"`
	// New standards timeline to set.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,18,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateIsArchivedTimeline bool `protobuf:"varint,19,opt,name=updateIsArchivedTimeline,proto3" json:"updateIsArchivedTimeline,omitempty"`
	// New isArchived timeline to set.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,20,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// Coins to be transferred to the mint escrow address.
	MintEscrowCoinsToTransfer []*types.Coin `protobuf:"bytes,21,rep,name=mintEscrowCoinsToTransfer,proto3" json:"mintEscrowCoinsToTransfer,omitempty"`
	// IBC wrapper paths to add.
	CosmosCoinWrapperPathsToAdd []*CosmosCoinWrapperPathAddObject `protobuf:"bytes,22,rep,name=cosmosCoinWrapperPathsToAdd,proto3" json:"cosmosCoinWrapperPathsToAdd,omitempty"`
	// Collection-level invariants that cannot be broken.
	// These are set upon genesis and cannot be modified.
	Invariants *CollectionInvariants `protobuf:"bytes,23,opt,name=invariants,proto3" json:"invariants,omitempty"`
}

func (m *MsgUpdateCollection) Reset()         { *m = MsgUpdateCollection{} }
func (m *MsgUpdateCollection) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCollection) ProtoMessage()    {}
func (*MsgUpdateCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{6}
}
func (m *MsgUpdateCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCollection.Merge(m, src)
}
func (m *MsgUpdateCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCollection proto.InternalMessageInfo

func (m *MsgUpdateCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUpdateCollection) GetUpdateValidBadgeIds() bool {
	if m != nil {
		return m.UpdateValidBadgeIds
	}
	return false
}

func (m *MsgUpdateCollection) GetValidBadgeIds() []*UintRange {
	if m != nil {
		return m.ValidBadgeIds
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCollectionPermissions() bool {
	if m != nil {
		return m.UpdateCollectionPermissions
	}
	return false
}

func (m *MsgUpdateCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateManagerTimeline() bool {
	if m != nil {
		return m.UpdateManagerTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCollectionMetadataTimeline() bool {
	if m != nil {
		return m.UpdateCollectionMetadataTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateBadgeMetadataTimeline() bool {
	if m != nil {
		return m.UpdateBadgeMetadataTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetBadgeMetadataTimeline() []*BadgeMetadataTimeline {
	if m != nil {
		return m.BadgeMetadataTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCustomDataTimeline() bool {
	if m != nil {
		return m.UpdateCustomDataTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCollectionApprovals() bool {
	if m != nil {
		return m.UpdateCollectionApprovals
	}
	return false
}

func (m *MsgUpdateCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateStandardsTimeline() bool {
	if m != nil {
		return m.UpdateStandardsTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateIsArchivedTimeline() bool {
	if m != nil {
		return m.UpdateIsArchivedTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetMintEscrowCoinsToTransfer() []*types.Coin {
	if m != nil {
		return m.MintEscrowCoinsToTransfer
	}
	return nil
}

func (m *MsgUpdateCollection) GetCosmosCoinWrapperPathsToAdd() []*CosmosCoinWrapperPathAddObject {
	if m != nil {
		return m.CosmosCoinWrapperPathsToAdd
	}
	return nil
}

func (m *MsgUpdateCollection) GetInvariants() *CollectionInvariants {
	if m != nil {
		return m.Invariants
	}
	return nil
}

// MsgUpdateCollectionResponse is the response to MsgUpdateCollection.
type MsgUpdateCollectionResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgUpdateCollectionResponse) Reset()         { *m = MsgUpdateCollectionResponse{} }
func (m *MsgUpdateCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCollectionResponse) ProtoMessage()    {}
func (*MsgUpdateCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{7}
}
func (m *MsgUpdateCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCollectionResponse.Merge(m, src)
}
func (m *MsgUpdateCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCollectionResponse proto.InternalMessageInfo

// MsgCreateCollection is used to create a new collection.
type MsgCreateCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	//The default balances for the user
	DefaultBalances *UserBalanceStore `protobuf:"bytes,2,opt,name=defaultBalances,proto3" json:"defaultBalances,omitempty"`
	// New token IDs to add to this collection
	ValidBadgeIds []*UintRange `protobuf:"bytes,3,rep,name=validBadgeIds,proto3" json:"validBadgeIds,omitempty"`
	// Collection permissions.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,4,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Manager timeline entries.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,5,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Collection metadata timeline entries.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,6,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// Token metadata timeline entries.
	BadgeMetadataTimeline []*BadgeMetadataTimeline `protobuf:"bytes,7,rep,name=badgeMetadataTimeline,proto3" json:"badgeMetadataTimeline,omitempty"`
	// Custom data timeline entries.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,8,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// Collection approvals.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,9,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Standards timeline entries.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,10,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// isArchived timeline entries.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,11,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// Coins to be transferred to the mint escrow address.
	MintEscrowCoinsToTransfer []*types.Coin `protobuf:"bytes,12,rep,name=mintEscrowCoinsToTransfer,proto3" json:"mintEscrowCoinsToTransfer,omitempty"`
	// IBC wrapper paths to add.
	CosmosCoinWrapperPathsToAdd []*CosmosCoinWrapperPathAddObject `protobuf:"bytes,13,rep,name=cosmosCoinWrapperPathsToAdd,proto3" json:"cosmosCoinWrapperPathsToAdd,omitempty"`
	// Collection-level invariants that cannot be broken.
	Invariants *CollectionInvariants `protobuf:"bytes,14,opt,name=invariants,proto3" json:"invariants,omitempty"`
}

func (m *MsgCreateCollection) Reset()         { *m = MsgCreateCollection{} }
func (m *MsgCreateCollection) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCollection) ProtoMessage()    {}
func (*MsgCreateCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{8}
}
func (m *MsgCreateCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCollection.Merge(m, src)
}
func (m *MsgCreateCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCollection proto.InternalMessageInfo

func (m *MsgCreateCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateCollection) GetDefaultBalances() *UserBalanceStore {
	if m != nil {
		return m.DefaultBalances
	}
	return nil
}

func (m *MsgCreateCollection) GetValidBadgeIds() []*UintRange {
	if m != nil {
		return m.ValidBadgeIds
	}
	return nil
}

func (m *MsgCreateCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *MsgCreateCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetBadgeMetadataTimeline() []*BadgeMetadataTimeline {
	if m != nil {
		return m.BadgeMetadataTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *MsgCreateCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetMintEscrowCoinsToTransfer() []*types.Coin {
	if m != nil {
		return m.MintEscrowCoinsToTransfer
	}
	return nil
}

func (m *MsgCreateCollection) GetCosmosCoinWrapperPathsToAdd() []*CosmosCoinWrapperPathAddObject {
	if m != nil {
		return m.CosmosCoinWrapperPathsToAdd
	}
	return nil
}

func (m *MsgCreateCollection) GetInvariants() *CollectionInvariants {
	if m != nil {
		return m.Invariants
	}
	return nil
}

// MsgCreateCollectionResponse is the response to MsgCreateCollection.
type MsgCreateCollectionResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgCreateCollectionResponse) Reset()         { *m = MsgCreateCollectionResponse{} }
func (m *MsgCreateCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCollectionResponse) ProtoMessage()    {}
func (*MsgCreateCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{9}
}
func (m *MsgCreateCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCollectionResponse.Merge(m, src)
}
func (m *MsgCreateCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCollectionResponse proto.InternalMessageInfo

// MsgCreateAddressLists is used to create address lists.
type MsgCreateAddressLists struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// Address lists to create.
	AddressLists []*AddressList `protobuf:"bytes,2,rep,name=addressLists,proto3" json:"addressLists,omitempty"`
}

func (m *MsgCreateAddressLists) Reset()         { *m = MsgCreateAddressLists{} }
func (m *MsgCreateAddressLists) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAddressLists) ProtoMessage()    {}
func (*MsgCreateAddressLists) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{10}
}
func (m *MsgCreateAddressLists) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAddressLists) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAddressLists.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAddressLists) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAddressLists.Merge(m, src)
}
func (m *MsgCreateAddressLists) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAddressLists) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAddressLists.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAddressLists proto.InternalMessageInfo

func (m *MsgCreateAddressLists) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateAddressLists) GetAddressLists() []*AddressList {
	if m != nil {
		return m.AddressLists
	}
	return nil
}

// MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.
type MsgCreateAddressListsResponse struct {
}

func (m *MsgCreateAddressListsResponse) Reset()         { *m = MsgCreateAddressListsResponse{} }
func (m *MsgCreateAddressListsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAddressListsResponse) ProtoMessage()    {}
func (*MsgCreateAddressListsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{11}
}
func (m *MsgCreateAddressListsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAddressListsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAddressListsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAddressListsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAddressListsResponse.Merge(m, src)
}
func (m *MsgCreateAddressListsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAddressListsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAddressListsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAddressListsResponse proto.InternalMessageInfo

// MsgTransferBadges is used to transfer tokens.
type MsgTransferBadges struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// Transfers to execute.
	Transfers []*Transfer `protobuf:"bytes,3,rep,name=transfers,proto3" json:"transfers,omitempty"`
}

func (m *MsgTransferBadges) Reset()         { *m = MsgTransferBadges{} }
func (m *MsgTransferBadges) String() string { return proto.CompactTextString(m) }
func (*MsgTransferBadges) ProtoMessage()    {}
func (*MsgTransferBadges) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{12}
}
func (m *MsgTransferBadges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferBadges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferBadges.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferBadges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferBadges.Merge(m, src)
}
func (m *MsgTransferBadges) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferBadges) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferBadges.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferBadges proto.InternalMessageInfo

func (m *MsgTransferBadges) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgTransferBadges) GetTransfers() []*Transfer {
	if m != nil {
		return m.Transfers
	}
	return nil
}

// MsgTransferBadgesResponse is the response to MsgTransferBadges.
type MsgTransferBadgesResponse struct {
}

func (m *MsgTransferBadgesResponse) Reset()         { *m = MsgTransferBadgesResponse{} }
func (m *MsgTransferBadgesResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTransferBadgesResponse) ProtoMessage()    {}
func (*MsgTransferBadgesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{13}
}
func (m *MsgTransferBadgesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferBadgesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferBadgesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferBadgesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferBadgesResponse.Merge(m, src)
}
func (m *MsgTransferBadgesResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferBadgesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferBadgesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferBadgesResponse proto.InternalMessageInfo

// MsgDeleteCollection is used to delete a collection.
type MsgDeleteCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgDeleteCollection) Reset()         { *m = MsgDeleteCollection{} }
func (m *MsgDeleteCollection) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteCollection) ProtoMessage()    {}
func (*MsgDeleteCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{14}
}
func (m *MsgDeleteCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteCollection.Merge(m, src)
}
func (m *MsgDeleteCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteCollection proto.InternalMessageInfo

func (m *MsgDeleteCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

// MsgDeleteCollectionResponse is the response to MsgDeleteCollection.
type MsgDeleteCollectionResponse struct {
}

func (m *MsgDeleteCollectionResponse) Reset()         { *m = MsgDeleteCollectionResponse{} }
func (m *MsgDeleteCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteCollectionResponse) ProtoMessage()    {}
func (*MsgDeleteCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{15}
}
func (m *MsgDeleteCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteCollectionResponse.Merge(m, src)
}
func (m *MsgDeleteCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteCollectionResponse proto.InternalMessageInfo

// MsgUpdateUserApprovals is used to update user approvals.
type MsgUpdateUserApprovals struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateOutgoingApprovals bool `protobuf:"varint,3,opt,name=updateOutgoingApprovals,proto3" json:"updateOutgoingApprovals,omitempty"`
	// New outgoing approvals to set.
	OutgoingApprovals []*UserOutgoingApproval `protobuf:"bytes,4,rep,name=outgoingApprovals,proto3" json:"outgoingApprovals,omitempty"`
	// Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateIncomingApprovals bool `protobuf:"varint,5,opt,name=updateIncomingApprovals,proto3" json:"updateIncomingApprovals,omitempty"`
	// New incoming approvals to set.
	IncomingApprovals []*UserIncomingApproval `protobuf:"bytes,6,rep,name=incomingApprovals,proto3" json:"incomingApprovals,omitempty"`
	// Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateAutoApproveSelfInitiatedOutgoingTransfers bool `protobuf:"varint,7,opt,name=updateAutoApproveSelfInitiatedOutgoingTransfers,proto3" json:"updateAutoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Auto-approve setting for self-initiated outgoing transfers.
	AutoApproveSelfInitiatedOutgoingTransfers bool `protobuf:"varint,8,opt,name=autoApproveSelfInitiatedOutgoingTransfers,proto3" json:"autoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateAutoApproveSelfInitiatedIncomingTransfers bool `protobuf:"varint,9,opt,name=updateAutoApproveSelfInitiatedIncomingTransfers,proto3" json:"updateAutoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// Auto-approve setting for self-initiated incoming transfers.
	AutoApproveSelfInitiatedIncomingTransfers bool `protobuf:"varint,10,opt,name=autoApproveSelfInitiatedIncomingTransfers,proto3" json:"autoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateAutoApproveAllIncomingTransfers bool `protobuf:"varint,11,opt,name=updateAutoApproveAllIncomingTransfers,proto3" json:"updateAutoApproveAllIncomingTransfers,omitempty"`
	// Auto-approve setting for all incoming transfers.
	AutoApproveAllIncomingTransfers bool `protobuf:"varint,12,opt,name=autoApproveAllIncomingTransfers,proto3" json:"autoApproveAllIncomingTransfers,omitempty"`
	// Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateUserPermissions bool `protobuf:"varint,13,opt,name=updateUserPermissions,proto3" json:"updateUserPermissions,omitempty"`
	// New user permissions to set.
	UserPermissions *UserPermissions `protobuf:"bytes,14,opt,name=userPermissions,proto3" json:"userPermissions,omitempty"`
}

func (m *MsgUpdateUserApprovals) Reset()         { *m = MsgUpdateUserApprovals{} }
func (m *MsgUpdateUserApprovals) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateUserApprovals) ProtoMessage()    {}
func (*MsgUpdateUserApprovals) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{16}
}
func (m *MsgUpdateUserApprovals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateUserApprovals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateUserApprovals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateUserApprovals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateUserApprovals.Merge(m, src)
}
func (m *MsgUpdateUserApprovals) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateUserApprovals) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateUserApprovals.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateUserApprovals proto.InternalMessageInfo

func (m *MsgUpdateUserApprovals) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUpdateUserApprovals) GetUpdateOutgoingApprovals() bool {
	if m != nil {
		return m.UpdateOutgoingApprovals
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetOutgoingApprovals() []*UserOutgoingApproval {
	if m != nil {
		return m.OutgoingApprovals
	}
	return nil
}

func (m *MsgUpdateUserApprovals) GetUpdateIncomingApprovals() bool {
	if m != nil {
		return m.UpdateIncomingApprovals
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetIncomingApprovals() []*UserIncomingApproval {
	if m != nil {
		return m.IncomingApprovals
	}
	return nil
}

func (m *MsgUpdateUserApprovals) GetUpdateAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if m != nil {
		return m.UpdateAutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetUpdateAutoApproveSelfInitiatedIncomingTransfers() bool {
	if m != nil {
		return m.UpdateAutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetAutoApproveSelfInitiatedIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetUpdateAutoApproveAllIncomingTransfers() bool {
	if m != nil {
		return m.UpdateAutoApproveAllIncomingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetAutoApproveAllIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveAllIncomingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetUpdateUserPermissions() bool {
	if m != nil {
		return m.UpdateUserPermissions
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetUserPermissions() *UserPermissions {
	if m != nil {
		return m.UserPermissions
	}
	return nil
}

// MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.
type MsgUpdateUserApprovalsResponse struct {
}

func (m *MsgUpdateUserApprovalsResponse) Reset()         { *m = MsgUpdateUserApprovalsResponse{} }
func (m *MsgUpdateUserApprovalsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateUserApprovalsResponse) ProtoMessage()    {}
func (*MsgUpdateUserApprovalsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{17}
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateUserApprovalsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateUserApprovalsResponse.Merge(m, src)
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateUserApprovalsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateUserApprovalsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateUserApprovalsResponse proto.InternalMessageInfo

// MsgSetIncomingApproval is a helper message to set a single incoming approval.
type MsgSetIncomingApproval struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The incoming approval to set.
	Approval *UserIncomingApproval `protobuf:"bytes,3,opt,name=approval,proto3" json:"approval,omitempty"`
}

func (m *MsgSetIncomingApproval) Reset()         { *m = MsgSetIncomingApproval{} }
func (m *MsgSetIncomingApproval) String() string { return proto.CompactTextString(m) }
func (*MsgSetIncomingApproval) ProtoMessage()    {}
func (*MsgSetIncomingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{18}
}
func (m *MsgSetIncomingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetIncomingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetIncomingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetIncomingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetIncomingApproval.Merge(m, src)
}
func (m *MsgSetIncomingApproval) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetIncomingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetIncomingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetIncomingApproval proto.InternalMessageInfo

func (m *MsgSetIncomingApproval) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetIncomingApproval) GetApproval() *UserIncomingApproval {
	if m != nil {
		return m.Approval
	}
	return nil
}

// MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.
type MsgSetIncomingApprovalResponse struct {
}

func (m *MsgSetIncomingApprovalResponse) Reset()         { *m = MsgSetIncomingApprovalResponse{} }
func (m *MsgSetIncomingApprovalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetIncomingApprovalResponse) ProtoMessage()    {}
func (*MsgSetIncomingApprovalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{19}
}
func (m *MsgSetIncomingApprovalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetIncomingApprovalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetIncomingApprovalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetIncomingApprovalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetIncomingApprovalResponse.Merge(m, src)
}
func (m *MsgSetIncomingApprovalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetIncomingApprovalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetIncomingApprovalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetIncomingApprovalResponse proto.InternalMessageInfo

// MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.
type MsgDeleteIncomingApproval struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The ID of the approval to delete.
	ApprovalId string `protobuf:"bytes,3,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
}

func (m *MsgDeleteIncomingApproval) Reset()         { *m = MsgDeleteIncomingApproval{} }
func (m *MsgDeleteIncomingApproval) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteIncomingApproval) ProtoMessage()    {}
func (*MsgDeleteIncomingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{20}
}
func (m *MsgDeleteIncomingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteIncomingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteIncomingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteIncomingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteIncomingApproval.Merge(m, src)
}
func (m *MsgDeleteIncomingApproval) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteIncomingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteIncomingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteIncomingApproval proto.InternalMessageInfo

func (m *MsgDeleteIncomingApproval) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgDeleteIncomingApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

// MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.
type MsgDeleteIncomingApprovalResponse struct {
}

func (m *MsgDeleteIncomingApprovalResponse) Reset()         { *m = MsgDeleteIncomingApprovalResponse{} }
func (m *MsgDeleteIncomingApprovalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteIncomingApprovalResponse) ProtoMessage()    {}
func (*MsgDeleteIncomingApprovalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{21}
}
func (m *MsgDeleteIncomingApprovalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteIncomingApprovalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteIncomingApprovalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteIncomingApprovalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteIncomingApprovalResponse.Merge(m, src)
}
func (m *MsgDeleteIncomingApprovalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteIncomingApprovalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteIncomingApprovalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteIncomingApprovalResponse proto.InternalMessageInfo

// MsgSetOutgoingApproval is a helper message to set a single outgoing approval.
type MsgSetOutgoingApproval struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The outgoing approval to set.
	Approval *UserOutgoingApproval `protobuf:"bytes,3,opt,name=approval,proto3" json:"approval,omitempty"`
}

func (m *MsgSetOutgoingApproval) Reset()         { *m = MsgSetOutgoingApproval{} }
func (m *MsgSetOutgoingApproval) String() string { return proto.CompactTextString(m) }
func (*MsgSetOutgoingApproval) ProtoMessage()    {}
func (*MsgSetOutgoingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{22}
}
func (m *MsgSetOutgoingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetOutgoingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetOutgoingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetOutgoingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetOutgoingApproval.Merge(m, src)
}
func (m *MsgSetOutgoingApproval) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetOutgoingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetOutgoingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetOutgoingApproval proto.InternalMessageInfo

func (m *MsgSetOutgoingApproval) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetOutgoingApproval) GetApproval() *UserOutgoingApproval {
	if m != nil {
		return m.Approval
	}
	return nil
}

// MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.
type MsgSetOutgoingApprovalResponse struct {
}

func (m *MsgSetOutgoingApprovalResponse) Reset()         { *m = MsgSetOutgoingApprovalResponse{} }
func (m *MsgSetOutgoingApprovalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetOutgoingApprovalResponse) ProtoMessage()    {}
func (*MsgSetOutgoingApprovalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{23}
}
func (m *MsgSetOutgoingApprovalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetOutgoingApprovalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetOutgoingApprovalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetOutgoingApprovalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetOutgoingApprovalResponse.Merge(m, src)
}
func (m *MsgSetOutgoingApprovalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetOutgoingApprovalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetOutgoingApprovalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetOutgoingApprovalResponse proto.InternalMessageInfo

// MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.
type MsgDeleteOutgoingApproval struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The ID of the approval to delete.
	ApprovalId string `protobuf:"bytes,3,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
}

func (m *MsgDeleteOutgoingApproval) Reset()         { *m = MsgDeleteOutgoingApproval{} }
func (m *MsgDeleteOutgoingApproval) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteOutgoingApproval) ProtoMessage()    {}
func (*MsgDeleteOutgoingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{24}
}
func (m *MsgDeleteOutgoingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteOutgoingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteOutgoingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteOutgoingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteOutgoingApproval.Merge(m, src)
}
func (m *MsgDeleteOutgoingApproval) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteOutgoingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteOutgoingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteOutgoingApproval proto.InternalMessageInfo

func (m *MsgDeleteOutgoingApproval) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgDeleteOutgoingApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

// MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.
type MsgDeleteOutgoingApprovalResponse struct {
}

func (m *MsgDeleteOutgoingApprovalResponse) Reset()         { *m = MsgDeleteOutgoingApprovalResponse{} }
func (m *MsgDeleteOutgoingApprovalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteOutgoingApprovalResponse) ProtoMessage()    {}
func (*MsgDeleteOutgoingApprovalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{25}
}
func (m *MsgDeleteOutgoingApprovalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteOutgoingApprovalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteOutgoingApprovalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteOutgoingApprovalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteOutgoingApprovalResponse.Merge(m, src)
}
func (m *MsgDeleteOutgoingApprovalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteOutgoingApprovalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteOutgoingApprovalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteOutgoingApprovalResponse proto.InternalMessageInfo

// MsgPurgeApprovals is a helper message to purge expired approvals.
type MsgPurgeApprovals struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// Whether to purge expired approvals (approvals with no future valid transfer times).
	PurgeExpired bool `protobuf:"varint,3,opt,name=purgeExpired,proto3" json:"purgeExpired,omitempty"`
	// Address of the user whose approvals to purge. If empty, defaults to creator.
	ApproverAddress string `protobuf:"bytes,4,opt,name=approverAddress,proto3" json:"approverAddress,omitempty"`
	// Whether to purge counterparty approvals (approvals where the creator is the only initiator).
	PurgeCounterpartyApprovals bool `protobuf:"varint,5,opt,name=purgeCounterpartyApprovals,proto3" json:"purgeCounterpartyApprovals,omitempty"`
	// Specific approvals to purge. If empty, purges all applicable approvals based on other flags.
	ApprovalsToPurge []*ApprovalIdentifierDetails `protobuf:"bytes,6,rep,name=approvalsToPurge,proto3" json:"approvalsToPurge,omitempty"`
}

func (m *MsgPurgeApprovals) Reset()         { *m = MsgPurgeApprovals{} }
func (m *MsgPurgeApprovals) String() string { return proto.CompactTextString(m) }
func (*MsgPurgeApprovals) ProtoMessage()    {}
func (*MsgPurgeApprovals) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{26}
}
func (m *MsgPurgeApprovals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPurgeApprovals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPurgeApprovals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPurgeApprovals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPurgeApprovals.Merge(m, src)
}
func (m *MsgPurgeApprovals) XXX_Size() int {
	return m.Size()
}
func (m *MsgPurgeApprovals) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPurgeApprovals.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPurgeApprovals proto.InternalMessageInfo

func (m *MsgPurgeApprovals) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgPurgeApprovals) GetPurgeExpired() bool {
	if m != nil {
		return m.PurgeExpired
	}
	return false
}

func (m *MsgPurgeApprovals) GetApproverAddress() string {
	if m != nil {
		return m.ApproverAddress
	}
	return ""
}

func (m *MsgPurgeApprovals) GetPurgeCounterpartyApprovals() bool {
	if m != nil {
		return m.PurgeCounterpartyApprovals
	}
	return false
}

func (m *MsgPurgeApprovals) GetApprovalsToPurge() []*ApprovalIdentifierDetails {
	if m != nil {
		return m.ApprovalsToPurge
	}
	return nil
}

// MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.
type MsgPurgeApprovalsResponse struct {
	// Number of approvals purged.
	NumPurged Uint `protobuf:"bytes,1,opt,name=numPurged,proto3,customtype=Uint" json:"numPurged"`
}

func (m *MsgPurgeApprovalsResponse) Reset()         { *m = MsgPurgeApprovalsResponse{} }
func (m *MsgPurgeApprovalsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPurgeApprovalsResponse) ProtoMessage()    {}
func (*MsgPurgeApprovalsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{27}
}
func (m *MsgPurgeApprovalsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPurgeApprovalsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPurgeApprovalsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPurgeApprovalsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPurgeApprovalsResponse.Merge(m, src)
}
func (m *MsgPurgeApprovalsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPurgeApprovalsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPurgeApprovalsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPurgeApprovalsResponse proto.InternalMessageInfo

// MsgCreateDynamicStore is used to create a new dynamic store.
type MsgCreateDynamicStore struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// The default value for uninitialized addresses (number of uses).
	DefaultValue Uint `protobuf:"bytes,2,opt,name=defaultValue,proto3,customtype=Uint" json:"defaultValue"`
}

func (m *MsgCreateDynamicStore) Reset()         { *m = MsgCreateDynamicStore{} }
func (m *MsgCreateDynamicStore) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDynamicStore) ProtoMessage()    {}
func (*MsgCreateDynamicStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{28}
}
func (m *MsgCreateDynamicStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDynamicStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDynamicStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDynamicStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDynamicStore.Merge(m, src)
}
func (m *MsgCreateDynamicStore) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDynamicStore) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDynamicStore.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDynamicStore proto.InternalMessageInfo

func (m *MsgCreateDynamicStore) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

// MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.
type MsgCreateDynamicStoreResponse struct {
	// ID of the dynamic store.
	StoreId Uint `protobuf:"bytes,1,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
}

func (m *MsgCreateDynamicStoreResponse) Reset()         { *m = MsgCreateDynamicStoreResponse{} }
func (m *MsgCreateDynamicStoreResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDynamicStoreResponse) ProtoMessage()    {}
func (*MsgCreateDynamicStoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{29}
}
func (m *MsgCreateDynamicStoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDynamicStoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDynamicStoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDynamicStoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDynamicStoreResponse.Merge(m, src)
}
func (m *MsgCreateDynamicStoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDynamicStoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDynamicStoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDynamicStoreResponse proto.InternalMessageInfo

// MsgUpdateDynamicStore is used to update an existing dynamic store.
type MsgUpdateDynamicStore struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the dynamic store to update.
	StoreId Uint `protobuf:"bytes,2,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
	// The new default value for uninitialized addresses (optional, only set if updating).
	DefaultValue Uint `protobuf:"bytes,3,opt,name=defaultValue,proto3,customtype=Uint" json:"defaultValue"`
}

func (m *MsgUpdateDynamicStore) Reset()         { *m = MsgUpdateDynamicStore{} }
func (m *MsgUpdateDynamicStore) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDynamicStore) ProtoMessage()    {}
func (*MsgUpdateDynamicStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{30}
}
func (m *MsgUpdateDynamicStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDynamicStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDynamicStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDynamicStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDynamicStore.Merge(m, src)
}
func (m *MsgUpdateDynamicStore) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDynamicStore) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDynamicStore.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDynamicStore proto.InternalMessageInfo

func (m *MsgUpdateDynamicStore) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

// MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.
type MsgUpdateDynamicStoreResponse struct {
}

func (m *MsgUpdateDynamicStoreResponse) Reset()         { *m = MsgUpdateDynamicStoreResponse{} }
func (m *MsgUpdateDynamicStoreResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDynamicStoreResponse) ProtoMessage()    {}
func (*MsgUpdateDynamicStoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{31}
}
func (m *MsgUpdateDynamicStoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDynamicStoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDynamicStoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDynamicStoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDynamicStoreResponse.Merge(m, src)
}
func (m *MsgUpdateDynamicStoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDynamicStoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDynamicStoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDynamicStoreResponse proto.InternalMessageInfo

// MsgDeleteDynamicStore is used to delete a dynamic store.
type MsgDeleteDynamicStore struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the dynamic store to delete.
	StoreId Uint `protobuf:"bytes,2,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
}

func (m *MsgDeleteDynamicStore) Reset()         { *m = MsgDeleteDynamicStore{} }
func (m *MsgDeleteDynamicStore) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteDynamicStore) ProtoMessage()    {}
func (*MsgDeleteDynamicStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{32}
}
func (m *MsgDeleteDynamicStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteDynamicStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteDynamicStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteDynamicStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteDynamicStore.Merge(m, src)
}
func (m *MsgDeleteDynamicStore) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteDynamicStore) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteDynamicStore.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteDynamicStore proto.InternalMessageInfo

func (m *MsgDeleteDynamicStore) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

// MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.
type MsgDeleteDynamicStoreResponse struct {
}

func (m *MsgDeleteDynamicStoreResponse) Reset()         { *m = MsgDeleteDynamicStoreResponse{} }
func (m *MsgDeleteDynamicStoreResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteDynamicStoreResponse) ProtoMessage()    {}
func (*MsgDeleteDynamicStoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{33}
}
func (m *MsgDeleteDynamicStoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteDynamicStoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteDynamicStoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteDynamicStoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteDynamicStoreResponse.Merge(m, src)
}
func (m *MsgDeleteDynamicStoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteDynamicStoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteDynamicStoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteDynamicStoreResponse proto.InternalMessageInfo

// MsgSetDynamicStoreValue is used to set a usage count for a specific address in a dynamic store.
type MsgSetDynamicStoreValue struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the dynamic store.
	StoreId Uint `protobuf:"bytes,2,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
	// The address for which to set the value.
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	// The usage count to set (number of times this address can use the approval).
	Value Uint `protobuf:"bytes,4,opt,name=value,proto3,customtype=Uint" json:"value"`
}

func (m *MsgSetDynamicStoreValue) Reset()         { *m = MsgSetDynamicStoreValue{} }
func (m *MsgSetDynamicStoreValue) String() string { return proto.CompactTextString(m) }
func (*MsgSetDynamicStoreValue) ProtoMessage()    {}
func (*MsgSetDynamicStoreValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{34}
}
func (m *MsgSetDynamicStoreValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetDynamicStoreValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetDynamicStoreValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetDynamicStoreValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetDynamicStoreValue.Merge(m, src)
}
func (m *MsgSetDynamicStoreValue) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetDynamicStoreValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetDynamicStoreValue.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetDynamicStoreValue proto.InternalMessageInfo

func (m *MsgSetDynamicStoreValue) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetDynamicStoreValue) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.
type MsgSetDynamicStoreValueResponse struct {
}

func (m *MsgSetDynamicStoreValueResponse) Reset()         { *m = MsgSetDynamicStoreValueResponse{} }
func (m *MsgSetDynamicStoreValueResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetDynamicStoreValueResponse) ProtoMessage()    {}
func (*MsgSetDynamicStoreValueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{35}
}
func (m *MsgSetDynamicStoreValueResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetDynamicStoreValueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetDynamicStoreValueResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetDynamicStoreValueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetDynamicStoreValueResponse.Merge(m, src)
}
func (m *MsgSetDynamicStoreValueResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetDynamicStoreValueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetDynamicStoreValueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetDynamicStoreValueResponse proto.InternalMessageInfo

// MsgIncrementStoreValue is used to increment a usage count for a specific address in a dynamic store.
type MsgIncrementStoreValue struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the dynamic store.
	StoreId Uint `protobuf:"bytes,2,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
	// The address for which to increment the value.
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	// The amount to increment by.
	Amount Uint `protobuf:"bytes,4,opt,name=amount,proto3,customtype=Uint" json:"amount"`
}

func (m *MsgIncrementStoreValue) Reset()         { *m = MsgIncrementStoreValue{} }
func (m *MsgIncrementStoreValue) String() string { return proto.CompactTextString(m) }
func (*MsgIncrementStoreValue) ProtoMessage()    {}
func (*MsgIncrementStoreValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{36}
}
func (m *MsgIncrementStoreValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIncrementStoreValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIncrementStoreValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIncrementStoreValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIncrementStoreValue.Merge(m, src)
}
func (m *MsgIncrementStoreValue) XXX_Size() int {
	return m.Size()
}
func (m *MsgIncrementStoreValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIncrementStoreValue.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIncrementStoreValue proto.InternalMessageInfo

func (m *MsgIncrementStoreValue) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgIncrementStoreValue) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// MsgIncrementStoreValueResponse is the response to MsgIncrementStoreValue.
type MsgIncrementStoreValueResponse struct {
}

func (m *MsgIncrementStoreValueResponse) Reset()         { *m = MsgIncrementStoreValueResponse{} }
func (m *MsgIncrementStoreValueResponse) String() string { return proto.CompactTextString(m) }
func (*MsgIncrementStoreValueResponse) ProtoMessage()    {}
func (*MsgIncrementStoreValueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{37}
}
func (m *MsgIncrementStoreValueResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIncrementStoreValueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIncrementStoreValueResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIncrementStoreValueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIncrementStoreValueResponse.Merge(m, src)
}
func (m *MsgIncrementStoreValueResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgIncrementStoreValueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIncrementStoreValueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIncrementStoreValueResponse proto.InternalMessageInfo

// MsgDecrementStoreValue is used to decrement a usage count for a specific address in a dynamic store.
type MsgDecrementStoreValue struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the dynamic store.
	StoreId Uint `protobuf:"bytes,2,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
	// The address for which to decrement the value.
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	// The amount to decrement by.
	Amount Uint `protobuf:"bytes,4,opt,name=amount,proto3,customtype=Uint" json:"amount"`
	// If true, set to zero on underflow. If false, throw error on underflow.
	SetToZeroOnUnderflow bool `protobuf:"varint,5,opt,name=setToZeroOnUnderflow,proto3" json:"setToZeroOnUnderflow,omitempty"`
}

func (m *MsgDecrementStoreValue) Reset()         { *m = MsgDecrementStoreValue{} }
func (m *MsgDecrementStoreValue) String() string { return proto.CompactTextString(m) }
func (*MsgDecrementStoreValue) ProtoMessage()    {}
func (*MsgDecrementStoreValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{38}
}
func (m *MsgDecrementStoreValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDecrementStoreValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDecrementStoreValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDecrementStoreValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDecrementStoreValue.Merge(m, src)
}
func (m *MsgDecrementStoreValue) XXX_Size() int {
	return m.Size()
}
func (m *MsgDecrementStoreValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDecrementStoreValue.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDecrementStoreValue proto.InternalMessageInfo

func (m *MsgDecrementStoreValue) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgDecrementStoreValue) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *MsgDecrementStoreValue) GetSetToZeroOnUnderflow() bool {
	if m != nil {
		return m.SetToZeroOnUnderflow
	}
	return false
}

// MsgDecrementStoreValueResponse is the response to MsgDecrementStoreValue.
type MsgDecrementStoreValueResponse struct {
}

func (m *MsgDecrementStoreValueResponse) Reset()         { *m = MsgDecrementStoreValueResponse{} }
func (m *MsgDecrementStoreValueResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDecrementStoreValueResponse) ProtoMessage()    {}
func (*MsgDecrementStoreValueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{39}
}
func (m *MsgDecrementStoreValueResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDecrementStoreValueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDecrementStoreValueResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDecrementStoreValueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDecrementStoreValueResponse.Merge(m, src)
}
func (m *MsgDecrementStoreValueResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDecrementStoreValueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDecrementStoreValueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDecrementStoreValueResponse proto.InternalMessageInfo

// MsgSetValidBadgeIds sets the validBadgeIds and canUpdateValidBadgeIds permission
type MsgSetValidBadgeIds struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New token IDs to add to this collection
	ValidBadgeIds []*UintRange `protobuf:"bytes,3,rep,name=validBadgeIds,proto3" json:"validBadgeIds,omitempty"`
	// Permission to update valid token IDs
	CanUpdateValidBadgeIds []*BadgeIdsActionPermission `protobuf:"bytes,4,rep,name=canUpdateValidBadgeIds,proto3" json:"canUpdateValidBadgeIds,omitempty"`
}

func (m *MsgSetValidBadgeIds) Reset()         { *m = MsgSetValidBadgeIds{} }
func (m *MsgSetValidBadgeIds) String() string { return proto.CompactTextString(m) }
func (*MsgSetValidBadgeIds) ProtoMessage()    {}
func (*MsgSetValidBadgeIds) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{40}
}
func (m *MsgSetValidBadgeIds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetValidBadgeIds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetValidBadgeIds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetValidBadgeIds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetValidBadgeIds.Merge(m, src)
}
func (m *MsgSetValidBadgeIds) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetValidBadgeIds) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetValidBadgeIds.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetValidBadgeIds proto.InternalMessageInfo

func (m *MsgSetValidBadgeIds) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetValidBadgeIds) GetValidBadgeIds() []*UintRange {
	if m != nil {
		return m.ValidBadgeIds
	}
	return nil
}

func (m *MsgSetValidBadgeIds) GetCanUpdateValidBadgeIds() []*BadgeIdsActionPermission {
	if m != nil {
		return m.CanUpdateValidBadgeIds
	}
	return nil
}

// MsgSetValidBadgeIdsResponse is the response to MsgSetValidBadgeIds.
type MsgSetValidBadgeIdsResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetValidBadgeIdsResponse) Reset()         { *m = MsgSetValidBadgeIdsResponse{} }
func (m *MsgSetValidBadgeIdsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetValidBadgeIdsResponse) ProtoMessage()    {}
func (*MsgSetValidBadgeIdsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{41}
}
func (m *MsgSetValidBadgeIdsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetValidBadgeIdsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetValidBadgeIdsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetValidBadgeIdsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetValidBadgeIdsResponse.Merge(m, src)
}
func (m *MsgSetValidBadgeIdsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetValidBadgeIdsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetValidBadgeIdsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetValidBadgeIdsResponse proto.InternalMessageInfo

// MsgSetManager sets the manager timeline and canUpdateManager permission
type MsgSetManager struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New manager timeline to set.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,3,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Permission to update manager timeline
	CanUpdateManager []*TimedUpdatePermission `protobuf:"bytes,4,rep,name=canUpdateManager,proto3" json:"canUpdateManager,omitempty"`
}

func (m *MsgSetManager) Reset()         { *m = MsgSetManager{} }
func (m *MsgSetManager) String() string { return proto.CompactTextString(m) }
func (*MsgSetManager) ProtoMessage()    {}
func (*MsgSetManager) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{42}
}
func (m *MsgSetManager) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetManager) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetManager.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetManager) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetManager.Merge(m, src)
}
func (m *MsgSetManager) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetManager) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetManager.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetManager proto.InternalMessageInfo

func (m *MsgSetManager) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetManager) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *MsgSetManager) GetCanUpdateManager() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateManager
	}
	return nil
}

// MsgSetManagerResponse is the response to MsgSetManager.
type MsgSetManagerResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetManagerResponse) Reset()         { *m = MsgSetManagerResponse{} }
func (m *MsgSetManagerResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetManagerResponse) ProtoMessage()    {}
func (*MsgSetManagerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{43}
}
func (m *MsgSetManagerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetManagerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetManagerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetManagerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetManagerResponse.Merge(m, src)
}
func (m *MsgSetManagerResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetManagerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetManagerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetManagerResponse proto.InternalMessageInfo

// MsgSetCollectionMetadata sets the collection metadata timeline and canUpdateCollectionMetadata permission
type MsgSetCollectionMetadata struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New collection metadata timeline to set.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,3,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// Permission to update collection metadata timeline
	CanUpdateCollectionMetadata []*TimedUpdatePermission `protobuf:"bytes,4,rep,name=canUpdateCollectionMetadata,proto3" json:"canUpdateCollectionMetadata,omitempty"`
}

func (m *MsgSetCollectionMetadata) Reset()         { *m = MsgSetCollectionMetadata{} }
func (m *MsgSetCollectionMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgSetCollectionMetadata) ProtoMessage()    {}
func (*MsgSetCollectionMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{44}
}
func (m *MsgSetCollectionMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCollectionMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCollectionMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCollectionMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCollectionMetadata.Merge(m, src)
}
func (m *MsgSetCollectionMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCollectionMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCollectionMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCollectionMetadata proto.InternalMessageInfo

func (m *MsgSetCollectionMetadata) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetCollectionMetadata) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *MsgSetCollectionMetadata) GetCanUpdateCollectionMetadata() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCollectionMetadata
	}
	return nil
}

// MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.
type MsgSetCollectionMetadataResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetCollectionMetadataResponse) Reset()         { *m = MsgSetCollectionMetadataResponse{} }
func (m *MsgSetCollectionMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetCollectionMetadataResponse) ProtoMessage()    {}
func (*MsgSetCollectionMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{45}
}
func (m *MsgSetCollectionMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCollectionMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCollectionMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCollectionMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCollectionMetadataResponse.Merge(m, src)
}
func (m *MsgSetCollectionMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCollectionMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCollectionMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCollectionMetadataResponse proto.InternalMessageInfo

// MsgSetBadgeMetadata sets the token metadata timeline and canUpdateBadgeMetadata permission
type MsgSetBadgeMetadata struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New token metadata timeline to set.
	BadgeMetadataTimeline []*BadgeMetadataTimeline `protobuf:"bytes,3,rep,name=badgeMetadataTimeline,proto3" json:"badgeMetadataTimeline,omitempty"`
	// Permission to update token metadata timeline
	CanUpdateBadgeMetadata []*TimedUpdateWithBadgeIdsPermission `protobuf:"bytes,4,rep,name=canUpdateBadgeMetadata,proto3" json:"canUpdateBadgeMetadata,omitempty"`
}

func (m *MsgSetBadgeMetadata) Reset()         { *m = MsgSetBadgeMetadata{} }
func (m *MsgSetBadgeMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgSetBadgeMetadata) ProtoMessage()    {}
func (*MsgSetBadgeMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{46}
}
func (m *MsgSetBadgeMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetBadgeMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetBadgeMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetBadgeMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetBadgeMetadata.Merge(m, src)
}
func (m *MsgSetBadgeMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetBadgeMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetBadgeMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetBadgeMetadata proto.InternalMessageInfo

func (m *MsgSetBadgeMetadata) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetBadgeMetadata) GetBadgeMetadataTimeline() []*BadgeMetadataTimeline {
	if m != nil {
		return m.BadgeMetadataTimeline
	}
	return nil
}

func (m *MsgSetBadgeMetadata) GetCanUpdateBadgeMetadata() []*TimedUpdateWithBadgeIdsPermission {
	if m != nil {
		return m.CanUpdateBadgeMetadata
	}
	return nil
}

// MsgSetBadgeMetadataResponse is the response to MsgSetBadgeMetadata.
type MsgSetBadgeMetadataResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetBadgeMetadataResponse) Reset()         { *m = MsgSetBadgeMetadataResponse{} }
func (m *MsgSetBadgeMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetBadgeMetadataResponse) ProtoMessage()    {}
func (*MsgSetBadgeMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{47}
}
func (m *MsgSetBadgeMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetBadgeMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetBadgeMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetBadgeMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetBadgeMetadataResponse.Merge(m, src)
}
func (m *MsgSetBadgeMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetBadgeMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetBadgeMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetBadgeMetadataResponse proto.InternalMessageInfo

// MsgSetCustomData sets the custom data timeline and canUpdateCustomData permission
type MsgSetCustomData struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New custom data timeline to set.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,3,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// Permission to update custom data timeline
	CanUpdateCustomData []*TimedUpdatePermission `protobuf:"bytes,4,rep,name=canUpdateCustomData,proto3" json:"canUpdateCustomData,omitempty"`
}

func (m *MsgSetCustomData) Reset()         { *m = MsgSetCustomData{} }
func (m *MsgSetCustomData) String() string { return proto.CompactTextString(m) }
func (*MsgSetCustomData) ProtoMessage()    {}
func (*MsgSetCustomData) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{48}
}
func (m *MsgSetCustomData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCustomData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCustomData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCustomData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCustomData.Merge(m, src)
}
func (m *MsgSetCustomData) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCustomData) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCustomData.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCustomData proto.InternalMessageInfo

func (m *MsgSetCustomData) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetCustomData) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *MsgSetCustomData) GetCanUpdateCustomData() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCustomData
	}
	return nil
}

// MsgSetCustomDataResponse is the response to MsgSetCustomData.
type MsgSetCustomDataResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetCustomDataResponse) Reset()         { *m = MsgSetCustomDataResponse{} }
func (m *MsgSetCustomDataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetCustomDataResponse) ProtoMessage()    {}
func (*MsgSetCustomDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{49}
}
func (m *MsgSetCustomDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCustomDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCustomDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCustomDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCustomDataResponse.Merge(m, src)
}
func (m *MsgSetCustomDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCustomDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCustomDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCustomDataResponse proto.InternalMessageInfo

// MsgSetStandards sets the standards timeline and canUpdateStandards permission
type MsgSetStandards struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New standards timeline to set.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,3,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// Permission to update standards timeline
	CanUpdateStandards []*TimedUpdatePermission `protobuf:"bytes,4,rep,name=canUpdateStandards,proto3" json:"canUpdateStandards,omitempty"`
}

func (m *MsgSetStandards) Reset()         { *m = MsgSetStandards{} }
func (m *MsgSetStandards) String() string { return proto.CompactTextString(m) }
func (*MsgSetStandards) ProtoMessage()    {}
func (*MsgSetStandards) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{50}
}
func (m *MsgSetStandards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetStandards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetStandards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetStandards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetStandards.Merge(m, src)
}
func (m *MsgSetStandards) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetStandards) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetStandards.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetStandards proto.InternalMessageInfo

func (m *MsgSetStandards) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetStandards) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *MsgSetStandards) GetCanUpdateStandards() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateStandards
	}
	return nil
}

// MsgSetStandardsResponse is the response to MsgSetStandards.
type MsgSetStandardsResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetStandardsResponse) Reset()         { *m = MsgSetStandardsResponse{} }
func (m *MsgSetStandardsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetStandardsResponse) ProtoMessage()    {}
func (*MsgSetStandardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{51}
}
func (m *MsgSetStandardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetStandardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetStandardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetStandardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetStandardsResponse.Merge(m, src)
}
func (m *MsgSetStandardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetStandardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetStandardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetStandardsResponse proto.InternalMessageInfo

// MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission
type MsgSetCollectionApprovals struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New collection approvals to set.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,3,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Permission to update collection approvals
	CanUpdateCollectionApprovals []*CollectionApprovalPermission `protobuf:"bytes,4,rep,name=canUpdateCollectionApprovals,proto3" json:"canUpdateCollectionApprovals,omitempty"`
}

func (m *MsgSetCollectionApprovals) Reset()         { *m = MsgSetCollectionApprovals{} }
func (m *MsgSetCollectionApprovals) String() string { return proto.CompactTextString(m) }
func (*MsgSetCollectionApprovals) ProtoMessage()    {}
func (*MsgSetCollectionApprovals) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{52}
}
func (m *MsgSetCollectionApprovals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCollectionApprovals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCollectionApprovals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCollectionApprovals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCollectionApprovals.Merge(m, src)
}
func (m *MsgSetCollectionApprovals) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCollectionApprovals) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCollectionApprovals.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCollectionApprovals proto.InternalMessageInfo

func (m *MsgSetCollectionApprovals) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetCollectionApprovals) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *MsgSetCollectionApprovals) GetCanUpdateCollectionApprovals() []*CollectionApprovalPermission {
	if m != nil {
		return m.CanUpdateCollectionApprovals
	}
	return nil
}

// MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.
type MsgSetCollectionApprovalsResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetCollectionApprovalsResponse) Reset()         { *m = MsgSetCollectionApprovalsResponse{} }
func (m *MsgSetCollectionApprovalsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetCollectionApprovalsResponse) ProtoMessage()    {}
func (*MsgSetCollectionApprovalsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{53}
}
func (m *MsgSetCollectionApprovalsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCollectionApprovalsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCollectionApprovalsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCollectionApprovalsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCollectionApprovalsResponse.Merge(m, src)
}
func (m *MsgSetCollectionApprovalsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCollectionApprovalsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCollectionApprovalsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCollectionApprovalsResponse proto.InternalMessageInfo

// MsgSetIsArchived sets the isArchived timeline and canArchiveCollection permission
type MsgSetIsArchived struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New isArchived timeline to set.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,3,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// Permission to archive collection
	CanArchiveCollection []*TimedUpdatePermission `protobuf:"bytes,4,rep,name=canArchiveCollection,proto3" json:"canArchiveCollection,omitempty"`
}

func (m *MsgSetIsArchived) Reset()         { *m = MsgSetIsArchived{} }
func (m *MsgSetIsArchived) String() string { return proto.CompactTextString(m) }
func (*MsgSetIsArchived) ProtoMessage()    {}
func (*MsgSetIsArchived) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{54}
}
func (m *MsgSetIsArchived) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetIsArchived) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetIsArchived.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetIsArchived) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetIsArchived.Merge(m, src)
}
func (m *MsgSetIsArchived) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetIsArchived) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetIsArchived.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetIsArchived proto.InternalMessageInfo

func (m *MsgSetIsArchived) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetIsArchived) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *MsgSetIsArchived) GetCanArchiveCollection() []*TimedUpdatePermission {
	if m != nil {
		return m.CanArchiveCollection
	}
	return nil
}

// MsgSetIsArchivedResponse is the response to MsgSetIsArchived.
type MsgSetIsArchivedResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetIsArchivedResponse) Reset()         { *m = MsgSetIsArchivedResponse{} }
func (m *MsgSetIsArchivedResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetIsArchivedResponse) ProtoMessage()    {}
func (*MsgSetIsArchivedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e65fb1d3d25b6215, []int{55}
}
func (m *MsgSetIsArchivedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetIsArchivedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetIsArchivedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetIsArchivedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetIsArchivedResponse.Merge(m, src)
}
func (m *MsgSetIsArchivedResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetIsArchivedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetIsArchivedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetIsArchivedResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*BadgeCustomMsgType)(nil), "badges.v17.BadgeCustomMsgType")
	proto.RegisterType((*MsgUpdateParams)(nil), "badges.v17.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "badges.v17.MsgUpdateParamsResponse")
	proto.RegisterType((*CosmosCoinWrapperPathAddObject)(nil), "badges.v17.CosmosCoinWrapperPathAddObject")
	proto.RegisterType((*MsgUniversalUpdateCollection)(nil), "badges.v17.MsgUniversalUpdateCollection")
	proto.RegisterType((*MsgUniversalUpdateCollectionResponse)(nil), "badges.v17.MsgUniversalUpdateCollectionResponse")
	proto.RegisterType((*MsgUpdateCollection)(nil), "badges.v17.MsgUpdateCollection")
	proto.RegisterType((*MsgUpdateCollectionResponse)(nil), "badges.v17.MsgUpdateCollectionResponse")
	proto.RegisterType((*MsgCreateCollection)(nil), "badges.v17.MsgCreateCollection")
	proto.RegisterType((*MsgCreateCollectionResponse)(nil), "badges.v17.MsgCreateCollectionResponse")
	proto.RegisterType((*MsgCreateAddressLists)(nil), "badges.v17.MsgCreateAddressLists")
	proto.RegisterType((*MsgCreateAddressListsResponse)(nil), "badges.v17.MsgCreateAddressListsResponse")
	proto.RegisterType((*MsgTransferBadges)(nil), "badges.v17.MsgTransferBadges")
	proto.RegisterType((*MsgTransferBadgesResponse)(nil), "badges.v17.MsgTransferBadgesResponse")
	proto.RegisterType((*MsgDeleteCollection)(nil), "badges.v17.MsgDeleteCollection")
	proto.RegisterType((*MsgDeleteCollectionResponse)(nil), "badges.v17.MsgDeleteCollectionResponse")
	proto.RegisterType((*MsgUpdateUserApprovals)(nil), "badges.v17.MsgUpdateUserApprovals")
	proto.RegisterType((*MsgUpdateUserApprovalsResponse)(nil), "badges.v17.MsgUpdateUserApprovalsResponse")
	proto.RegisterType((*MsgSetIncomingApproval)(nil), "badges.v17.MsgSetIncomingApproval")
	proto.RegisterType((*MsgSetIncomingApprovalResponse)(nil), "badges.v17.MsgSetIncomingApprovalResponse")
	proto.RegisterType((*MsgDeleteIncomingApproval)(nil), "badges.v17.MsgDeleteIncomingApproval")
	proto.RegisterType((*MsgDeleteIncomingApprovalResponse)(nil), "badges.v17.MsgDeleteIncomingApprovalResponse")
	proto.RegisterType((*MsgSetOutgoingApproval)(nil), "badges.v17.MsgSetOutgoingApproval")
	proto.RegisterType((*MsgSetOutgoingApprovalResponse)(nil), "badges.v17.MsgSetOutgoingApprovalResponse")
	proto.RegisterType((*MsgDeleteOutgoingApproval)(nil), "badges.v17.MsgDeleteOutgoingApproval")
	proto.RegisterType((*MsgDeleteOutgoingApprovalResponse)(nil), "badges.v17.MsgDeleteOutgoingApprovalResponse")
	proto.RegisterType((*MsgPurgeApprovals)(nil), "badges.v17.MsgPurgeApprovals")
	proto.RegisterType((*MsgPurgeApprovalsResponse)(nil), "badges.v17.MsgPurgeApprovalsResponse")
	proto.RegisterType((*MsgCreateDynamicStore)(nil), "badges.v17.MsgCreateDynamicStore")
	proto.RegisterType((*MsgCreateDynamicStoreResponse)(nil), "badges.v17.MsgCreateDynamicStoreResponse")
	proto.RegisterType((*MsgUpdateDynamicStore)(nil), "badges.v17.MsgUpdateDynamicStore")
	proto.RegisterType((*MsgUpdateDynamicStoreResponse)(nil), "badges.v17.MsgUpdateDynamicStoreResponse")
	proto.RegisterType((*MsgDeleteDynamicStore)(nil), "badges.v17.MsgDeleteDynamicStore")
	proto.RegisterType((*MsgDeleteDynamicStoreResponse)(nil), "badges.v17.MsgDeleteDynamicStoreResponse")
	proto.RegisterType((*MsgSetDynamicStoreValue)(nil), "badges.v17.MsgSetDynamicStoreValue")
	proto.RegisterType((*MsgSetDynamicStoreValueResponse)(nil), "badges.v17.MsgSetDynamicStoreValueResponse")
	proto.RegisterType((*MsgIncrementStoreValue)(nil), "badges.v17.MsgIncrementStoreValue")
	proto.RegisterType((*MsgIncrementStoreValueResponse)(nil), "badges.v17.MsgIncrementStoreValueResponse")
	proto.RegisterType((*MsgDecrementStoreValue)(nil), "badges.v17.MsgDecrementStoreValue")
	proto.RegisterType((*MsgDecrementStoreValueResponse)(nil), "badges.v17.MsgDecrementStoreValueResponse")
	proto.RegisterType((*MsgSetValidBadgeIds)(nil), "badges.v17.MsgSetValidBadgeIds")
	proto.RegisterType((*MsgSetValidBadgeIdsResponse)(nil), "badges.v17.MsgSetValidBadgeIdsResponse")
	proto.RegisterType((*MsgSetManager)(nil), "badges.v17.MsgSetManager")
	proto.RegisterType((*MsgSetManagerResponse)(nil), "badges.v17.MsgSetManagerResponse")
	proto.RegisterType((*MsgSetCollectionMetadata)(nil), "badges.v17.MsgSetCollectionMetadata")
	proto.RegisterType((*MsgSetCollectionMetadataResponse)(nil), "badges.v17.MsgSetCollectionMetadataResponse")
	proto.RegisterType((*MsgSetBadgeMetadata)(nil), "badges.v17.MsgSetBadgeMetadata")
	proto.RegisterType((*MsgSetBadgeMetadataResponse)(nil), "badges.v17.MsgSetBadgeMetadataResponse")
	proto.RegisterType((*MsgSetCustomData)(nil), "badges.v17.MsgSetCustomData")
	proto.RegisterType((*MsgSetCustomDataResponse)(nil), "badges.v17.MsgSetCustomDataResponse")
	proto.RegisterType((*MsgSetStandards)(nil), "badges.v17.MsgSetStandards")
	proto.RegisterType((*MsgSetStandardsResponse)(nil), "badges.v17.MsgSetStandardsResponse")
	proto.RegisterType((*MsgSetCollectionApprovals)(nil), "badges.v17.MsgSetCollectionApprovals")
	proto.RegisterType((*MsgSetCollectionApprovalsResponse)(nil), "badges.v17.MsgSetCollectionApprovalsResponse")
	proto.RegisterType((*MsgSetIsArchived)(nil), "badges.v17.MsgSetIsArchived")
	proto.RegisterType((*MsgSetIsArchivedResponse)(nil), "badges.v17.MsgSetIsArchivedResponse")
}

func init() { proto.RegisterFile("badges/v17/tx.proto", fileDescriptor_e65fb1d3d25b6215) }

var fileDescriptor_e65fb1d3d25b6215 = []byte{
	// 3310 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5c, 0x4b, 0x6c, 0x1c, 0xc7,
	0xd1, 0xd6, 0x72, 0xc5, 0xc7, 0x96, 0xf8, 0x6c, 0xbe, 0x97, 0xd2, 0x92, 0x5a, 0xc9, 0xfe, 0x65,
	0xfe, 0x16, 0x57, 0xd2, 0xff, 0xdb, 0xfe, 0x41, 0x1b, 0x7f, 0xcc, 0x87, 0x1f, 0xb4, 0x2d, 0x8b,
	0x6e, 0x92, 0x52, 0x60, 0x28, 0x70, 0x86, 0xbb, 0xad, 0xe5, 0xc4, 0xbb, 0x33, 0x8b, 0x99, 0x59,
	0xda, 0xbc, 0x05, 0xb9, 0x25, 0x39, 0x24, 0x40, 0x4e, 0x39, 0x24, 0xd7, 0x04, 0x39, 0x24, 0x3a,
	0xe4, 0x96, 0x43, 0xae, 0x06, 0x72, 0x88, 0x91, 0x00, 0x41, 0x90, 0x00, 0x4e, 0x60, 0x03, 0xd1,
	0x25, 0x77, 0x1f, 0x13, 0x4c, 0x4f, 0xcf, 0xab, 0xbb, 0x7a, 0x76, 0xb5, 0xdc, 0x75, 0x2e, 0x89,
	0xb8, 0x5d, 0xf5, 0x75, 0x57, 0x75, 0x4f, 0x55, 0x75, 0x75, 0x95, 0x61, 0xf6, 0xd8, 0xa8, 0xd5,
	0x99, 0x5b, 0x39, 0xbd, 0xfd, 0x52, 0xc5, 0xfb, 0x78, 0xa3, 0xe5, 0xd8, 0x9e, 0x4d, 0x20, 0xf8,
	0x71, 0xe3, 0xf4, 0xf6, 0x4b, 0xc5, 0x19, 0xa3, 0x69, 0x5a, 0x76, 0x85, 0xff, 0x6f, 0x30, 0x5c,
	0x5c, 0xac, 0xda, 0x6e, 0xd3, 0x76, 0x2b, 0x4d, 0xb7, 0x5e, 0x39, 0xbd, 0xed, 0xff, 0x9f, 0x18,
	0x58, 0x0e, 0x06, 0x3e, 0xe0, 0x7f, 0x55, 0x82, 0x3f, 0xc4, 0xd0, 0x5c, 0xdd, 0xae, 0xdb, 0xc1,
	0xef, 0xfe, 0xbf, 0x42, 0xa4, 0xc4, 0xec, 0x2d, 0xc3, 0x31, 0x9a, 0x21, 0x79, 0x31, 0xb9, 0x2c,
	0xc7, 0xb0, 0xdc, 0x47, 0xcc, 0x09, 0xc7, 0x96, 0x13, 0x63, 0xc7, 0x46, 0xc3, 0xb0, 0xaa, 0x2c,
	0x1c, 0xba, 0x9c, 0xc4, 0x63, 0x4e, 0xd3, 0x74, 0x5d, 0xd3, 0xb6, 0x30, 0xc6, 0x26, 0xf3, 0x8c,
	0x9a, 0xe1, 0x19, 0x08, 0x63, 0xd5, 0x6e, 0x34, 0x58, 0xd5, 0x4b, 0x30, 0x96, 0x12, 0xa3, 0x46,
	0xad, 0xe6, 0x30, 0xd7, 0xfd, 0xa0, 0x61, 0xba, 0x1e, 0xba, 0x5a, 0xb3, 0xc9, 0x1a, 0xa6, 0x15,
	0x2d, 0x69, 0x35, 0x31, 0x56, 0x3b, 0xb3, 0x8c, 0xa6, 0x59, 0xfd, 0xc0, 0xf5, 0x6c, 0x27, 0x22,
	0x28, 0x09, 0x6d, 0x1e, 0x1b, 0x2e, 0xab, 0x9c, 0xde, 0x3e, 0x66, 0x9e, 0x71, 0xbb, 0x52, 0xb5,
	0x4d, 0x2b, 0x18, 0x2f, 0x7f, 0x39, 0x03, 0x64, 0xdb, 0xc7, 0xd8, 0x69, 0xbb, 0x9e, 0xdd, 0xbc,
	0xeb, 0xd6, 0x0f, 0xcf, 0x5a, 0x8c, 0x3c, 0x80, 0xf9, 0xaa, 0xc3, 0x0c, 0x8f, 0x6d, 0x05, 0x0b,
	0x7a, 0xc7, 0x5f, 0xcf, 0x5d, 0xb7, 0xbe, 0x94, 0x5b, 0xcb, 0xdd, 0xb8, 0x74, 0xe7, 0xea, 0x46,
	0xbc, 0x87, 0x1b, 0x77, 0xdd, 0xfa, 0x8e, 0x42, 0x4b, 0x71, 0x7e, 0xd2, 0x80, 0xcb, 0x6d, 0xcb,
	0x3c, 0x65, 0x8e, 0x6b, 0x34, 0x8e, 0x5a, 0x35, 0xc3, 0x63, 0x3b, 0x91, 0x42, 0x7c, 0xfc, 0x21,
	0x8e, 0x7f, 0x43, 0xc2, 0x3f, 0xd2, 0xb1, 0xd0, 0x4c, 0x34, 0xf2, 0x1e, 0xcc, 0xd6, 0x58, 0x83,
	0xc9, 0x93, 0xe4, 0xf9, 0x24, 0xab, 0xd2, 0x24, 0xbb, 0x12, 0x25, 0xc5, 0x78, 0xc9, 0xdb, 0x30,
	0x13, 0x1e, 0x19, 0xae, 0x37, 0xae, 0x95, 0x8b, 0x1c, 0xf0, 0x8a, 0x04, 0x78, 0x98, 0xa2, 0xa3,
	0x2a, 0x1f, 0x79, 0x1f, 0x16, 0xda, 0x7c, 0xd9, 0x47, 0x2e, 0x73, 0xb6, 0x5a, 0x2d, 0xc7, 0x3e,
	0x35, 0x1a, 0x1c, 0x71, 0x98, 0x23, 0x96, 0x65, 0x3d, 0xa8, 0xc4, 0x54, 0x83, 0xe0, 0xcb, 0xde,
	0x46, 0x14, 0x3c, 0x82, 0xca, 0xae, 0xe8, 0x15, 0xe3, 0xf5, 0x21, 0x83, 0x5d, 0x4d, 0x43, 0x8e,
	0xa2, 0x90, 0x3b, 0x12, 0x25, 0xc5, 0x78, 0xe3, 0x83, 0xb6, 0x1b, 0x9c, 0xde, 0x03, 0xff, 0xf0,
	0xfa, 0xa0, 0x63, 0x19, 0x07, 0x2d, 0x49, 0x4b, 0x71, 0x7e, 0x1f, 0x38, 0x10, 0x41, 0x06, 0x2e,
	0xa0, 0xc0, 0x47, 0x0a, 0x2d, 0xc5, 0xf9, 0x7d, 0xe0, 0xe0, 0x5c, 0xc8, 0xc0, 0x80, 0x02, 0xef,
	0x2a, 0xb4, 0x14, 0xe7, 0x27, 0xdf, 0x80, 0x45, 0x97, 0x79, 0xc9, 0x5f, 0xef, 0x1b, 0x8d, 0x36,
	0x87, 0xbe, 0xc4, 0xa1, 0xaf, 0x49, 0xd0, 0x07, 0x08, 0x35, 0xd5, 0x61, 0xf8, 0x67, 0xcd, 0xb4,
	0xaa, 0x0e, 0x6b, 0x32, 0xcb, 0x4b, 0xa3, 0x8f, 0xa3, 0x67, 0x6d, 0x4f, 0x25, 0xa6, 0x1a, 0x04,
	0x1f, 0xbb, 0xc6, 0x50, 0xec, 0x09, 0x14, 0x7b, 0x97, 0x21, 0xd8, 0x38, 0x82, 0x8f, 0xed, 0x32,
	0x6f, 0xcf, 0xaa, 0xda, 0x4d, 0xd3, 0xaa, 0x87, 0x47, 0xdc, 0xc7, 0x9e, 0x44, 0xb1, 0x0f, 0x54,
	0x62, 0xaa, 0x41, 0x20, 0x55, 0x58, 0x0e, 0xf6, 0x02, 0x83, 0x9f, 0xe2, 0xf0, 0xcf, 0xa0, 0xfb,
	0xa9, 0xcc, 0xa0, 0xc7, 0x11, 0x02, 0xdc, 0x6b, 0x7b, 0x75, 0x5b, 0x9a, 0x61, 0x5a, 0x27, 0x80,
	0x4c, 0x4c, 0x35, 0x08, 0xb1, 0x00, 0x18, 0xfc, 0x4c, 0x86, 0x00, 0xca, 0x0c, 0x7a, 0x1c, 0xdf,
	0xe4, 0xb5, 0xda, 0x4e, 0x9d, 0xa5, 0x0c, 0x14, 0x41, 0x4d, 0xde, 0x7e, 0x8a, 0x8e, 0xaa, 0x7c,
	0xbe, 0x0d, 0x71, 0x99, 0x77, 0xdf, 0x68, 0x98, 0x35, 0x6e, 0x07, 0xf7, 0x6a, 0x1c, 0x6e, 0x16,
	0xb5, 0x21, 0x07, 0x12, 0x25, 0xc5, 0x78, 0xc9, 0xd7, 0x60, 0xc2, 0x65, 0xde, 0x5d, 0xc3, 0x32,
	0xea, 0xcc, 0xf1, 0xc1, 0xe6, 0x38, 0xd8, 0xb2, 0x0a, 0x26, 0x68, 0x68, 0x9a, 0x9e, 0x7c, 0x13,
	0x96, 0x5c, 0xe6, 0x25, 0x0c, 0x93, 0x70, 0xdf, 0x3e, 0xd6, 0x3c, 0xc7, 0xba, 0xae, 0x62, 0xa9,
	0xe4, 0x54, 0x8b, 0x22, 0xa4, 0xe6, 0x8b, 0x4e, 0x82, 0x2f, 0xe8, 0xa4, 0x4e, 0x51, 0x52, 0x8c,
	0x97, 0xbc, 0x09, 0xd3, 0xfe, 0x74, 0xdc, 0x6d, 0xef, 0x0a, 0xbc, 0x45, 0x8e, 0x77, 0x19, 0x59,
	0x6c, 0x44, 0x46, 0x15, 0x2e, 0xf2, 0x1a, 0x4c, 0xb9, 0xcc, 0x3b, 0xf0, 0x0c, 0xab, 0x66, 0x38,
	0xc1, 0x76, 0x2c, 0x71, 0xa0, 0x15, 0x15, 0x28, 0xa2, 0xa2, 0x32, 0x8f, 0x7f, 0x16, 0x53, 0xf2,
	0xa7, 0x8e, 0xcb, 0x32, 0x7a, 0x16, 0x0f, 0x50, 0x7a, 0xaa, 0xc7, 0x11, 0x52, 0xef, 0xb9, 0x5b,
	0x4e, 0xf5, 0xc4, 0x3c, 0x65, 0x35, 0x1f, 0xbb, 0xa8, 0x93, 0x3a, 0x26, 0xa3, 0x0a, 0x57, 0xf9,
	0x57, 0x39, 0x98, 0x8a, 0x0c, 0xff, 0x3e, 0x0f, 0x0f, 0xc9, 0x8b, 0x50, 0x30, 0xda, 0xde, 0x89,
	0xed, 0x98, 0xde, 0x19, 0x0f, 0x75, 0x0a, 0xdb, 0x4b, 0x7f, 0xf8, 0xf5, 0xcd, 0x39, 0x11, 0x6c,
	0x8a, 0x60, 0xe6, 0xc0, 0x73, 0x4c, 0xab, 0x4e, 0x63, 0x52, 0xf2, 0x02, 0x8c, 0x04, 0x01, 0xa6,
	0x88, 0x5f, 0x48, 0x72, 0x2d, 0x01, 0xf6, 0x76, 0xe1, 0x93, 0xcf, 0x56, 0x2f, 0xfc, 0xfc, 0xc9,
	0xe3, 0xf5, 0x1c, 0x15, 0xc4, 0x9b, 0x37, 0xbf, 0xf3, 0xe4, 0xf1, 0x7a, 0x0c, 0xf3, 0xbd, 0x27,
	0x8f, 0xd7, 0x93, 0xc1, 0x9e, 0xb4, 0xba, 0xf2, 0x32, 0x2c, 0x4a, 0x3f, 0x51, 0xe6, 0xb6, 0x6c,
	0xcb, 0x65, 0xe5, 0xc7, 0x43, 0x50, 0xda, 0xe1, 0x8b, 0xdc, 0xb1, 0x4d, 0xeb, 0x81, 0x63, 0xb4,
	0x5a, 0xcc, 0xd9, 0x37, 0xbc, 0x93, 0xad, 0x5a, 0xed, 0xde, 0xf1, 0xb7, 0x58, 0xd5, 0x23, 0x73,
	0x30, 0x5c, 0x63, 0x96, 0xdd, 0x0c, 0xe4, 0xa2, 0xc1, 0x1f, 0xa4, 0x02, 0x63, 0x61, 0x94, 0xbb,
	0x34, 0xb4, 0x96, 0xbf, 0x71, 0xe9, 0xce, 0x6c, 0x72, 0xed, 0xdb, 0xc1, 0x18, 0x8d, 0x88, 0xc8,
	0x02, 0x8c, 0xb8, 0x67, 0xcd, 0x63, 0xbb, 0xc1, 0xa3, 0xa8, 0x02, 0x15, 0x7f, 0x91, 0x17, 0x00,
	0x38, 0xe2, 0x91, 0x65, 0x7a, 0xee, 0xd2, 0x45, 0x0e, 0x35, 0x9f, 0x84, 0xda, 0x0d, 0x47, 0x69,
	0x82, 0x90, 0xbc, 0x0e, 0x25, 0xa3, 0xd1, 0xb0, 0x3f, 0xba, 0x77, 0xca, 0x1c, 0xc7, 0xac, 0xb1,
	0x07, 0xa6, 0x77, 0xb2, 0x65, 0x9d, 0xf1, 0x6f, 0xfc, 0xd0, 0xfe, 0x90, 0x59, 0x3c, 0x12, 0x1a,
	0xa3, 0x1d, 0xa8, 0xc8, 0x2d, 0x98, 0xe5, 0x14, 0x81, 0x12, 0xb8, 0x02, 0x4c, 0x2b, 0x88, 0x76,
	0xc6, 0x28, 0x36, 0x54, 0xfe, 0x72, 0x02, 0x2e, 0x67, 0x85, 0x96, 0x64, 0x09, 0x46, 0x79, 0x68,
	0x61, 0x3b, 0x42, 0x65, 0xe1, 0x9f, 0xe4, 0x16, 0x8c, 0xc7, 0x61, 0xfc, 0x5e, 0x8d, 0x6f, 0x7a,
	0x61, 0x7b, 0xdc, 0xdf, 0xe0, 0xbf, 0x7c, 0xb6, 0x7a, 0xf1, 0xc8, 0xb4, 0x3c, 0x9a, 0xa2, 0x20,
	0xaf, 0xc3, 0x54, 0x8d, 0x3d, 0x32, 0xda, 0x0d, 0x6f, 0x3b, 0xd4, 0x76, 0x5e, 0x3d, 0xb5, 0x7e,
	0x0c, 0x27, 0xc6, 0x83, 0x48, 0x41, 0x66, 0xf2, 0xc5, 0x0c, 0xa2, 0x92, 0x94, 0x11, 0xe4, 0xf1,
	0xe7, 0x18, 0xc5, 0x86, 0xc8, 0xcb, 0x30, 0x71, 0x9a, 0xa2, 0x1d, 0x56, 0xb7, 0x86, 0x2f, 0xd8,
	0xb0, 0xea, 0x8c, 0xa6, 0x69, 0xc9, 0xab, 0xb0, 0x22, 0xc7, 0x81, 0xfb, 0xf1, 0xc5, 0x47, 0x68,
	0x37, 0x8b, 0x84, 0xc7, 0x77, 0x28, 0xef, 0xa8, 0x1a, 0x2d, 0xa1, 0x08, 0x14, 0xe7, 0x27, 0xff,
	0x1b, 0xc6, 0x77, 0xc2, 0x8e, 0x1f, 0x8a, 0x9b, 0x11, 0x0f, 0x1c, 0xc7, 0x28, 0x3e, 0xe8, 0x9b,
	0xba, 0xa6, 0x44, 0x5f, 0xe0, 0xfa, 0x48, 0x9b, 0xba, 0x34, 0x09, 0x95, 0x79, 0xc8, 0x5b, 0xb0,
	0xa6, 0xc4, 0xc7, 0xc2, 0x34, 0x47, 0xb8, 0xc0, 0xd7, 0xd1, 0x91, 0x8e, 0x3c, 0x82, 0x62, 0x55,
	0x8f, 0x72, 0x89, 0xaf, 0xee, 0x59, 0x5c, 0x4d, 0x32, 0x35, 0xcd, 0x40, 0x8a, 0xf7, 0x32, 0xe5,
	0x49, 0xa2, 0x89, 0xc6, 0x93, 0x7b, 0x89, 0x92, 0xf8, 0x7b, 0x79, 0x8c, 0xf2, 0x4e, 0xf0, 0x45,
	0x5e, 0x4d, 0x1b, 0x0e, 0x84, 0x90, 0xe2, 0xfc, 0x64, 0x13, 0x96, 0x84, 0x9a, 0x22, 0xbf, 0x14,
	0x61, 0x4f, 0xf2, 0x75, 0x69, 0xc7, 0xc9, 0xbb, 0x40, 0xaa, 0x2a, 0xd7, 0x14, 0x5f, 0x51, 0x29,
	0xa5, 0x36, 0x85, 0x8a, 0x22, 0x9c, 0xe4, 0x15, 0x58, 0x96, 0xb7, 0x2c, 0x72, 0x40, 0x3c, 0x60,
	0x1b, 0xa3, 0x7a, 0x02, 0xb2, 0x0f, 0xb3, 0x55, 0x84, 0x6f, 0x06, 0x59, 0x8e, 0x42, 0x46, 0x31,
	0x56, 0xf2, 0x7f, 0xb0, 0x18, 0x4c, 0x17, 0xf9, 0xda, 0x48, 0x48, 0xc2, 0x57, 0xa3, 0x1b, 0xf6,
	0xc3, 0x36, 0x57, 0xe1, 0x99, 0xe5, 0x2b, 0x49, 0x85, 0x6d, 0x0a, 0x27, 0x55, 0xf9, 0xe2, 0x2d,
	0x8a, 0x9d, 0x68, 0x84, 0x39, 0x97, 0xdc, 0x22, 0x75, 0xdc, 0xdf, 0x22, 0x53, 0xe5, 0x9a, 0x57,
	0x75, 0xa2, 0xf2, 0x52, 0x84, 0x93, 0x3c, 0x80, 0xe5, 0xa6, 0x69, 0x79, 0xaf, 0xb9, 0x55, 0xc7,
	0xb7, 0xea, 0xa6, 0xe5, 0x1e, 0xda, 0xe1, 0x5d, 0x7b, 0x69, 0x81, 0xc3, 0x2e, 0x6f, 0x08, 0x97,
	0x7d, 0x6c, 0xb8, 0x6c, 0x43, 0xe4, 0x3d, 0x36, 0x7c, 0x5a, 0xaa, 0xe7, 0x25, 0x0d, 0x58, 0xa9,
	0x62, 0x4e, 0xd4, 0x3d, 0xb4, 0xb7, 0x6a, 0xb5, 0xa5, 0x45, 0x0e, 0xbd, 0x9e, 0xde, 0xc5, 0x2c,
	0x9f, 0x4b, 0xb3, 0xe0, 0xc8, 0xab, 0x00, 0xa6, 0x75, 0x6a, 0x38, 0xa6, 0x61, 0x79, 0xae, 0x88,
	0xb8, 0xd6, 0xf0, 0x23, 0xb2, 0x17, 0xd1, 0xd1, 0x04, 0xcf, 0xe6, 0x0b, 0x7e, 0xfc, 0x10, 0x7a,
	0x25, 0x3f, 0x7a, 0xb8, 0x9e, 0x88, 0x1e, 0xb4, 0x8e, 0xad, 0xfc, 0x75, 0xb8, 0x9e, 0x99, 0x53,
	0x11, 0x41, 0x85, 0xe2, 0xe6, 0x72, 0x9d, 0xdc, 0x5c, 0xf9, 0x27, 0x13, 0x30, 0x8b, 0x64, 0x13,
	0xfa, 0xea, 0x4a, 0x35, 0x2e, 0x30, 0xff, 0x14, 0x2e, 0xf0, 0x62, 0xff, 0x5c, 0xe0, 0xf0, 0x39,
	0x5c, 0xe0, 0xc8, 0xa0, 0x5c, 0xe0, 0xe8, 0x53, 0xba, 0xc0, 0xb1, 0x01, 0xb9, 0xc0, 0x42, 0x5f,
	0x5c, 0x20, 0x7c, 0x55, 0x2e, 0xf0, 0xd2, 0x39, 0x5c, 0xe0, 0xf8, 0x00, 0x5d, 0xe0, 0x44, 0x4f,
	0x2e, 0x70, 0x72, 0x30, 0x2e, 0x70, 0xaa, 0x47, 0x17, 0x38, 0x3d, 0x10, 0x17, 0x38, 0xd3, 0x83,
	0x0b, 0x24, 0x03, 0x70, 0x81, 0xb3, 0x3d, 0xb9, 0xc0, 0xb9, 0xc1, 0xb8, 0xc0, 0xf9, 0xc1, 0xb9,
	0xc0, 0x85, 0x41, 0xba, 0xc0, 0xc5, 0x1e, 0x5c, 0xe0, 0xf3, 0xb2, 0x0b, 0x5c, 0x49, 0xba, 0x40,
	0xd9, 0xf3, 0xdd, 0x83, 0x15, 0x2c, 0xd9, 0xdd, 0xbb, 0xc3, 0xfb, 0x7e, 0x81, 0x3b, 0x3c, 0x39,
	0xd7, 0x9d, 0xe1, 0xf0, 0x90, 0x9b, 0xe0, 0x50, 0x2f, 0x37, 0x41, 0xc5, 0xa9, 0xe5, 0x9f, 0xc2,
	0xa9, 0x69, 0x5d, 0xd2, 0xc5, 0x73, 0xba, 0x24, 0xc4, 0xb9, 0x0c, 0xf7, 0xe0, 0x5c, 0xb2, 0x1d,
	0xc2, 0x48, 0xdf, 0x1c, 0x82, 0xd6, 0x9c, 0x8f, 0x9e, 0xd3, 0x9c, 0xe3, 0x26, 0x79, 0xac, 0x67,
	0x93, 0xac, 0x31, 0xaa, 0x85, 0xde, 0x8d, 0x2a, 0x6a, 0x1a, 0xa1, 0x47, 0xd3, 0x88, 0x9b, 0xb7,
	0x4b, 0x83, 0x31, 0x6f, 0xe3, 0x83, 0x33, 0x6f, 0x13, 0x83, 0x34, 0x6f, 0x93, 0xfd, 0x36, 0x6f,
	0xb2, 0xd5, 0x11, 0xe6, 0x4d, 0x79, 0x78, 0xeb, 0xdd, 0xbc, 0xfd, 0x34, 0x07, 0xf3, 0xe8, 0xf3,
	0x6e, 0x86, 0x81, 0x7b, 0x19, 0xc6, 0x8d, 0x04, 0xa5, 0xc8, 0x2a, 0x2e, 0x26, 0xc5, 0x4e, 0x20,
	0xd1, 0x14, 0xf1, 0xe6, 0x86, 0x2c, 0xef, 0x15, 0x45, 0xde, 0xe4, 0x32, 0xca, 0xab, 0x70, 0x05,
	0x7f, 0x7e, 0x0e, 0x13, 0xa3, 0xbf, 0xcd, 0xc1, 0x8c, 0xf2, 0x14, 0xdb, 0xd7, 0xfb, 0xc8, 0x1d,
	0x28, 0x44, 0x35, 0x04, 0xc2, 0x08, 0xcf, 0x25, 0x85, 0x0d, 0xa7, 0xa6, 0x31, 0xd9, 0xe6, 0xba,
	0x2c, 0x66, 0xb2, 0x78, 0x20, 0xbd, 0xd6, 0xf2, 0x0a, 0x2c, 0xab, 0x6f, 0xc9, 0xa1, 0x78, 0x3f,
	0xc8, 0x71, 0xff, 0x23, 0x3f, 0x5d, 0xf7, 0x53, 0xc0, 0xec, 0x33, 0x28, 0xcf, 0x5c, 0xbe, 0xc2,
	0xcf, 0xa0, 0xf2, 0x96, 0x1e, 0x2e, 0xf8, 0x4f, 0x63, 0xb0, 0x80, 0x3f, 0x64, 0xf7, 0x75, 0x53,
	0xa2, 0x90, 0x51, 0x7e, 0xcf, 0x0a, 0x2f, 0x8a, 0xba, 0x61, 0xf2, 0x2e, 0xcc, 0xd8, 0x0a, 0x4f,
	0x70, 0x61, 0x5c, 0x93, 0x3d, 0xb4, 0xf2, 0x88, 0xa6, 0xb2, 0xc6, 0x2b, 0x91, 0x9f, 0x06, 0xc3,
	0xbb, 0xa3, 0x6e, 0xd8, 0x5f, 0x89, 0xa9, 0xf0, 0x8c, 0xe0, 0x2b, 0x51, 0xde, 0x23, 0x55, 0x56,
	0x72, 0x02, 0x95, 0x60, 0xaa, 0xad, 0xb6, 0x67, 0x07, 0x3f, 0xb3, 0x03, 0xd6, 0x78, 0xb4, 0x67,
	0x99, 0x9e, 0x69, 0x78, 0xac, 0x16, 0x8a, 0x73, 0x18, 0x1d, 0xe7, 0xe0, 0x22, 0xf9, 0xb4, 0x6c,
	0xe4, 0x21, 0x3c, 0x67, 0x74, 0x3d, 0x47, 0x90, 0xaf, 0xed, 0x9e, 0xa1, 0xb3, 0x1c, 0xa1, 0x32,
	0xe2, 0x39, 0x0a, 0xdd, 0xc8, 0xa1, 0xb0, 0x65, 0xc9, 0xa1, 0xce, 0x01, 0xd9, 0x72, 0xa8, 0xe8,
	0x87, 0xf0, 0x8c, 0xb2, 0xa0, 0xad, 0x46, 0x43, 0x45, 0x0e, 0xee, 0xa5, 0xdd, 0x11, 0x93, 0x37,
	0x61, 0xd5, 0xe8, 0x80, 0x17, 0xa4, 0x7a, 0x3b, 0x91, 0xc5, 0xe9, 0x05, 0xff, 0x80, 0x25, 0x83,
	0xc4, 0x89, 0x64, 0x7a, 0x41, 0x1a, 0xf4, 0x23, 0xc0, 0xb6, 0x44, 0x3f, 0xa9, 0x3e, 0x26, 0x4a,
	0x5c, 0x54, 0xe6, 0xd9, 0xac, 0xc8, 0x46, 0xa7, 0xa4, 0xc4, 0xf5, 0x29, 0xeb, 0x51, 0x5e, 0x83,
	0x92, 0xa6, 0x40, 0x26, 0x34, 0x3d, 0x7f, 0xcc, 0x71, 0xd3, 0x83, 0xd4, 0x07, 0xf4, 0xd5, 0xf4,
	0xbc, 0x02, 0x63, 0x86, 0xc0, 0x15, 0x6f, 0x3c, 0x9d, 0xbf, 0xd6, 0x88, 0x23, 0x5b, 0x6e, 0x64,
	0xe9, 0x42, 0x6e, 0xac, 0xe8, 0x21, 0x94, 0xfb, 0x37, 0x39, 0xee, 0x41, 0xf0, 0xc2, 0x85, 0xbe,
	0x8a, 0x5e, 0x02, 0x08, 0x05, 0xd9, 0xab, 0x89, 0xf7, 0xc1, 0xc4, 0x2f, 0x9b, 0x77, 0x64, 0xe1,
	0xae, 0x2a, 0x9e, 0x44, 0x91, 0xef, 0x1a, 0x5c, 0xd5, 0x57, 0x5d, 0xa8, 0x5b, 0x2b, 0x9b, 0xe4,
	0xaf, 0x7a, 0x6b, 0x15, 0x97, 0xd0, 0xfd, 0xd6, 0xca, 0xac, 0xf1, 0xd6, 0x2a, 0xa0, 0xe8, 0xd6,
	0x0e, 0x54, 0xf4, 0x3e, 0x6c, 0xad, 0x22, 0x5f, 0x72, 0x6b, 0xb5, 0x22, 0xfe, 0x73, 0x88, 0x07,
	0x70, 0xe9, 0xc2, 0x92, 0xbe, 0x8a, 0x56, 0x86, 0x71, 0x5e, 0xa6, 0xf2, 0xda, 0xc7, 0x2d, 0xd3,
	0x61, 0x35, 0x11, 0x20, 0xa4, 0x7e, 0x23, 0x37, 0x60, 0x2a, 0x10, 0x96, 0x39, 0x22, 0xcc, 0xe4,
	0x57, 0xe5, 0x02, 0x95, 0x7f, 0x26, 0xff, 0x0f, 0x45, 0xce, 0xb9, 0x63, 0xb7, 0x2d, 0x8f, 0x39,
	0x2d, 0xc3, 0xf1, 0xce, 0x64, 0x97, 0x9f, 0x41, 0x41, 0xde, 0x83, 0xe9, 0x50, 0xad, 0xee, 0xa1,
	0xcd, 0xc5, 0x16, 0x4e, 0x3f, 0x55, 0x3c, 0xb1, 0x15, 0xa9, 0x9e, 0x59, 0x9e, 0xf9, 0xc8, 0x64,
	0xce, 0x2e, 0xf3, 0x0c, 0xb3, 0xe1, 0x52, 0x85, 0x3d, 0x3b, 0xda, 0x4c, 0x2b, 0xb6, 0xfc, 0x06,
	0x3f, 0x50, 0x52, 0x19, 0x4f, 0x78, 0x81, 0x58, 0x87, 0x82, 0xd5, 0x6e, 0xf2, 0x41, 0xfc, 0xf6,
	0x10, 0x0f, 0x97, 0x7f, 0x94, 0xbc, 0x3a, 0x24, 0x0b, 0xd2, 0xb2, 0xf7, 0x4e, 0xa4, 0x39, 0x78,
	0xf5, 0x17, 0xbe, 0x77, 0x49, 0x8a, 0x6e, 0xee, 0x0b, 0xc9, 0xb9, 0xcb, 0x6f, 0x24, 0xee, 0x0b,
	0xa9, 0x9a, 0xbc, 0x50, 0xc4, 0x67, 0x61, 0x94, 0xd7, 0xcf, 0x6a, 0xae, 0x47, 0xe1, 0xa0, 0xff,
	0xe5, 0xcd, 0xa3, 0x65, 0x83, 0x19, 0xe2, 0x25, 0xb0, 0x87, 0x32, 0xb0, 0x15, 0x35, 0xe4, 0xcf,
	0xa7, 0x06, 0x75, 0x8d, 0xe2, 0xda, 0x84, 0xd4, 0x3c, 0x86, 0x5f, 0xdd, 0x77, 0x03, 0xf1, 0xd4,
	0xe2, 0xc5, 0xf3, 0x8b, 0x97, 0xbd, 0x58, 0x75, 0x46, 0xb1, 0x58, 0xa4, 0x8e, 0x32, 0x5c, 0xec,
	0xef, 0x72, 0xbc, 0x30, 0x06, 0x2b, 0x87, 0xec, 0xc3, 0x6e, 0x2c, 0xc1, 0xa8, 0xb8, 0xa2, 0x0a,
	0xb3, 0x17, 0xfe, 0x49, 0xca, 0x30, 0x7c, 0xca, 0x37, 0xe8, 0x22, 0xc2, 0x1f, 0x0c, 0x6d, 0xde,
	0x92, 0x85, 0x5d, 0x4d, 0x1b, 0x7d, 0x65, 0xc5, 0xe5, 0xab, 0xb0, 0xaa, 0xab, 0xed, 0x4c, 0x08,
	0xbc, 0x80, 0x57, 0x68, 0x0e, 0x54, 0xde, 0xeb, 0x30, 0x62, 0x34, 0x7d, 0xa3, 0x85, 0x0a, 0x2c,
	0xc6, 0xb2, 0xdd, 0x1c, 0xb2, 0x64, 0xe1, 0xe6, 0xb0, 0x72, 0xd3, 0x50, 0xde, 0x7f, 0x05, 0xf2,
	0x22, 0x55, 0xa3, 0xff, 0x79, 0x79, 0xc9, 0x1d, 0x98, 0x73, 0x99, 0x77, 0x68, 0xbf, 0xcf, 0x1c,
	0xfb, 0x9e, 0x75, 0x64, 0xd5, 0x98, 0xf3, 0xa8, 0x61, 0x7f, 0x24, 0x4c, 0x3d, 0x3a, 0x96, 0xad,
	0x23, 0x44, 0x4c, 0xa1, 0x23, 0xac, 0x6c, 0x36, 0xd4, 0xd1, 0x2f, 0x86, 0x78, 0x26, 0x40, 0xae,
	0x98, 0xec, 0xab, 0xa7, 0x3c, 0x57, 0xce, 0xf9, 0x21, 0x2c, 0x54, 0x0d, 0xeb, 0x08, 0xad, 0x5e,
	0xca, 0xcb, 0x25, 0x96, 0xe1, 0xd8, 0x96, 0x94, 0x61, 0xa6, 0x1a, 0x8c, 0xec, 0x24, 0x85, 0xac,
	0x14, 0x91, 0x28, 0x53, 0xaa, 0x4b, 0x7b, 0x4f, 0x94, 0xfd, 0x78, 0x08, 0x26, 0x52, 0x25, 0xa6,
	0x7d, 0xd5, 0x3b, 0x92, 0x55, 0xcf, 0xf7, 0x90, 0x55, 0xbf, 0x0b, 0xd3, 0x91, 0xf6, 0x04, 0xb1,
	0xd0, 0x7d, 0x2a, 0xd1, 0xed, 0xd3, 0xd7, 0x44, 0x95, 0x61, 0xac, 0x78, 0x85, 0x75, 0xf3, 0x59,
	0x59, 0xe5, 0xf3, 0x69, 0x95, 0x0b, 0xba, 0xf2, 0x1e, 0x77, 0x25, 0x89, 0xea, 0xdb, 0xde, 0xd5,
	0xfc, 0x8f, 0x21, 0x58, 0xd2, 0x55, 0xdf, 0xf6, 0x55, 0xe3, 0xd9, 0x0f, 0x10, 0xf9, 0xbe, 0x3d,
	0x40, 0x54, 0x61, 0x25, 0xd2, 0xab, 0x0a, 0xd1, 0xfd, 0xee, 0x64, 0xa1, 0x6c, 0xde, 0x96, 0x37,
	0x6a, 0x2d, 0xbd, 0x51, 0x2a, 0x4b, 0xf9, 0x10, 0xd6, 0xb4, 0x55, 0xce, 0xbd, 0x6f, 0xdf, 0xef,
	0x23, 0x1b, 0x95, 0x7a, 0x4c, 0xe9, 0xeb, 0xce, 0x69, 0x9f, 0x74, 0xf2, 0xe7, 0x7c, 0xd2, 0x61,
	0x09, 0xfb, 0x95, 0x62, 0x14, 0xbb, 0x74, 0x53, 0xb3, 0x4b, 0x0f, 0x4c, 0xef, 0x24, 0xb4, 0x30,
	0xa8, 0x21, 0x4b, 0x81, 0x75, 0x34, 0x64, 0x29, 0xea, 0xd8, 0x90, 0xa5, 0x0b, 0xc6, 0x7b, 0xdf,
	0xa2, 0x5f, 0x0e, 0xc1, 0xb4, 0x5c, 0x32, 0xde, 0xd7, 0xfd, 0xc1, 0x5f, 0xc6, 0xf2, 0x3d, 0xbf,
	0x8c, 0x1d, 0xc0, 0x6c, 0x7c, 0xf6, 0xa3, 0xe1, 0xee, 0xbf, 0x1c, 0x8c, 0x7b, 0xf3, 0x39, 0x79,
	0x13, 0x96, 0xa4, 0x2f, 0x26, 0x22, 0x2d, 0xbf, 0x13, 0x59, 0xa4, 0xb8, 0xc4, 0xbe, 0x77, 0xf5,
	0xff, 0x6c, 0x88, 0x17, 0xa5, 0x27, 0x0b, 0xed, 0xfb, 0xaa, 0x7d, 0xf4, 0xd5, 0x2f, 0xdf, 0xe3,
	0xab, 0xdf, 0x7b, 0x40, 0x22, 0xe5, 0x45, 0x0c, 0xdd, 0x6b, 0x1e, 0x61, 0xde, 0xbc, 0x21, 0x2b,
	0x7e, 0x31, 0xad, 0xf8, 0x88, 0xb2, 0xfc, 0x76, 0x18, 0xf3, 0xc7, 0x1d, 0x09, 0xbd, 0xab, 0xfd,
	0xaf, 0x43, 0xfc, 0xda, 0x8b, 0xb7, 0x23, 0xf4, 0x75, 0x03, 0x34, 0x0f, 0xb9, 0xf9, 0xde, 0x1f,
	0x72, 0x1b, 0x70, 0x19, 0x31, 0xfe, 0xf2, 0xdb, 0xc5, 0x8d, 0x6c, 0xe8, 0xc4, 0xb6, 0x64, 0xa2,
	0x65, 0xe7, 0x79, 0x70, 0xfd, 0x95, 0x8f, 0x78, 0x9e, 0x47, 0xd3, 0xeb, 0xd1, 0xfb, 0xa6, 0x3d,
	0x8e, 0x4c, 0x55, 0xfc, 0xaa, 0xdc, 0x6f, 0x53, 0x85, 0xbc, 0x6a, 0xe7, 0x7b, 0x7e, 0xd5, 0x3e,
	0x82, 0xb9, 0xaa, 0x61, 0x89, 0x9f, 0x63, 0x5d, 0x74, 0xff, 0xc5, 0xa0, 0xec, 0x1d, 0x8d, 0x55,
	0xbc, 0xba, 0xd8, 0x58, 0x25, 0x3a, 0x63, 0x7a, 0xde, 0x80, 0x3b, 0x7f, 0x9b, 0x83, 0xfc, 0x5d,
	0xb7, 0x4e, 0xf6, 0x61, 0x3c, 0xd5, 0x45, 0xb3, 0x82, 0xf6, 0x56, 0x06, 0x83, 0xc5, 0x6b, 0x19,
	0x83, 0xd1, 0x5a, 0x3e, 0x82, 0x65, 0x7d, 0x5f, 0x46, 0xd7, 0xcd, 0xc1, 0xc5, 0x5b, 0x5d, 0xb7,
	0x11, 0x87, 0x13, 0x1f, 0x03, 0x41, 0x1e, 0xbb, 0x3b, 0xb7, 0x3b, 0x17, 0x9f, 0xeb, 0xdc, 0x11,
	0x1d, 0xce, 0x71, 0x1f, 0x26, 0xa5, 0xe7, 0xe8, 0xec, 0xc6, 0xe1, 0xe2, 0x33, 0xd9, 0x7d, 0xc5,
	0x21, 0x2e, 0x83, 0x59, 0xec, 0x59, 0xb5, 0x8b, 0x1e, 0xe2, 0xe2, 0x7a, 0x17, 0x7d, 0xc6, 0x89,
	0x69, 0xb0, 0x27, 0x94, 0x2e, 0xda, 0x30, 0x95, 0x69, 0x32, 0x5e, 0x2d, 0x88, 0x05, 0x0b, 0x9a,
	0x17, 0x8b, 0xee, 0x3a, 0x32, 0x8b, 0x37, 0xbb, 0x6b, 0xdc, 0x4c, 0x8b, 0xa5, 0xe4, 0xd0, 0xbb,
	0x68, 0xce, 0xc4, 0xc4, 0xd2, 0xa5, 0xb3, 0x63, 0xb1, 0x94, 0x99, 0xba, 0xeb, 0xd3, 0xd4, 0x88,
	0xa5, 0x9d, 0xef, 0x3e, 0x4c, 0x4a, 0xa9, 0xf3, 0xec, 0x96, 0x4d, 0xe5, 0xb0, 0x69, 0x52, 0xc1,
	0x0f, 0x61, 0x5a, 0x29, 0x3a, 0xe8, 0xd4, 0x50, 0x5f, 0xfc, 0xaf, 0x4e, 0x1d, 0xf7, 0x09, 0x74,
	0xe5, 0xb3, 0xef, 0xd4, 0xb2, 0xae, 0xa0, 0x6b, 0x3f, 0xf2, 0x87, 0x30, 0xad, 0x14, 0xec, 0x75,
	0xea, 0x5e, 0x57, 0xd0, 0xb5, 0x55, 0x36, 0x91, 0x09, 0x49, 0xa5, 0x4d, 0x3b, 0x37, 0xb2, 0x6b,
	0x4c, 0x08, 0x9a, 0xa5, 0x3e, 0x06, 0x82, 0x64, 0x9e, 0x3b, 0xf7, 0xb4, 0x2b, 0x73, 0xe8, 0x53,
	0xc0, 0xfe, 0x1c, 0x48, 0xfa, 0xb7, 0x73, 0x7b, 0xbb, 0x32, 0x87, 0x3e, 0x73, 0x4b, 0x4e, 0x60,
	0x0e, 0xcd, 0xda, 0x76, 0xd3, 0xe9, 0x5e, 0xfc, 0xef, 0x6e, 0xda, 0xe1, 0x13, 0x9f, 0x37, 0x96,
	0x2e, 0xed, 0xa2, 0xe9, 0x5d, 0xf9, 0xbc, 0x33, 0x32, 0x95, 0xfe, 0x34, 0x58, 0x96, 0xb2, 0x8b,
	0xfe, 0x77, 0x65, 0x9a, 0x8c, 0x64, 0x9f, 0x7f, 0x82, 0x95, 0x44, 0x5f, 0xa7, 0xde, 0x69, 0xe5,
	0x04, 0x6b, 0xd3, 0x5f, 0x6f, 0x01, 0x24, 0x12, 0x59, 0xfa, 0x36, 0xea, 0xe2, 0x55, 0x7d, 0x87,
	0x75, 0x88, 0xf5, 0x21, 0xcc, 0xe3, 0xd9, 0x9a, 0xae, 0x3a, 0xaa, 0x8b, 0xcf, 0x77, 0xd5, 0x77,
	0x9d, 0x56, 0x4b, 0x3a, 0xb7, 0xd0, 0xa9, 0xb9, 0x1a, 0x53, 0x0b, 0x7e, 0x99, 0x3e, 0x80, 0x89,
	0xf4, 0xb5, 0x38, 0xb3, 0xcf, 0xba, 0x78, 0x3d, 0xb3, 0x0b, 0x3b, 0x04, 0xdd, 0x87, 0xf1, 0xd4,
	0x65, 0x2f, 0xab, 0xe5, 0xba, 0x78, 0x2d, 0xab, 0x1f, 0x3b, 0xe1, 0x61, 0x34, 0xf7, 0x98, 0xee,
	0xba, 0xaf, 0x15, 0x0f, 0xd3, 0x21, 0x70, 0x0f, 0xd4, 0x92, 0x08, 0xc1, 0x33, 0x1b, 0xb1, 0x31,
	0xb5, 0xa8, 0xc1, 0x68, 0x71, 0xf8, 0xdb, 0x4f, 0x1e, 0xaf, 0xe7, 0xb6, 0xf7, 0x3f, 0xf9, 0xbc,
	0x94, 0xfb, 0xf4, 0xf3, 0x52, 0xee, 0xef, 0x9f, 0x97, 0x72, 0x3f, 0xfc, 0xa2, 0x74, 0xe1, 0xd3,
	0x2f, 0x4a, 0x17, 0xfe, 0xfc, 0x45, 0xe9, 0xc2, 0xfb, 0x2f, 0xd6, 0x4d, 0xef, 0xa4, 0x7d, 0xbc,
	0x51, 0xb5, 0x9b, 0x95, 0x63, 0xd3, 0x13, 0x11, 0x6f, 0xf4, 0xaf, 0xea, 0x89, 0x61, 0x5a, 0x95,
	0x8f, 0x2b, 0xe2, 0x77, 0xef, 0xac, 0x15, 0xc4, 0xc3, 0xc7, 0x23, 0xfc, 0x3f, 0x7b, 0xf3, 0x3f,
	0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x3e, 0xf3, 0xb0, 0xc6, 0x9a, 0x48, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	UniversalUpdateCollection(ctx context.Context, in *MsgUniversalUpdateCollection, opts ...grpc.CallOption) (*MsgUniversalUpdateCollectionResponse, error)
	CreateAddressLists(ctx context.Context, in *MsgCreateAddressLists, opts ...grpc.CallOption) (*MsgCreateAddressListsResponse, error)
	TransferBadges(ctx context.Context, in *MsgTransferBadges, opts ...grpc.CallOption) (*MsgTransferBadgesResponse, error)
	UpdateUserApprovals(ctx context.Context, in *MsgUpdateUserApprovals, opts ...grpc.CallOption) (*MsgUpdateUserApprovalsResponse, error)
	SetIncomingApproval(ctx context.Context, in *MsgSetIncomingApproval, opts ...grpc.CallOption) (*MsgSetIncomingApprovalResponse, error)
	DeleteIncomingApproval(ctx context.Context, in *MsgDeleteIncomingApproval, opts ...grpc.CallOption) (*MsgDeleteIncomingApprovalResponse, error)
	SetOutgoingApproval(ctx context.Context, in *MsgSetOutgoingApproval, opts ...grpc.CallOption) (*MsgSetOutgoingApprovalResponse, error)
	DeleteOutgoingApproval(ctx context.Context, in *MsgDeleteOutgoingApproval, opts ...grpc.CallOption) (*MsgDeleteOutgoingApprovalResponse, error)
	PurgeApprovals(ctx context.Context, in *MsgPurgeApprovals, opts ...grpc.CallOption) (*MsgPurgeApprovalsResponse, error)
	DeleteCollection(ctx context.Context, in *MsgDeleteCollection, opts ...grpc.CallOption) (*MsgDeleteCollectionResponse, error)
	UpdateCollection(ctx context.Context, in *MsgUpdateCollection, opts ...grpc.CallOption) (*MsgUpdateCollectionResponse, error)
	CreateCollection(ctx context.Context, in *MsgCreateCollection, opts ...grpc.CallOption) (*MsgCreateCollectionResponse, error)
	CreateDynamicStore(ctx context.Context, in *MsgCreateDynamicStore, opts ...grpc.CallOption) (*MsgCreateDynamicStoreResponse, error)
	UpdateDynamicStore(ctx context.Context, in *MsgUpdateDynamicStore, opts ...grpc.CallOption) (*MsgUpdateDynamicStoreResponse, error)
	DeleteDynamicStore(ctx context.Context, in *MsgDeleteDynamicStore, opts ...grpc.CallOption) (*MsgDeleteDynamicStoreResponse, error)
	SetDynamicStoreValue(ctx context.Context, in *MsgSetDynamicStoreValue, opts ...grpc.CallOption) (*MsgSetDynamicStoreValueResponse, error)
	IncrementStoreValue(ctx context.Context, in *MsgIncrementStoreValue, opts ...grpc.CallOption) (*MsgIncrementStoreValueResponse, error)
	DecrementStoreValue(ctx context.Context, in *MsgDecrementStoreValue, opts ...grpc.CallOption) (*MsgDecrementStoreValueResponse, error)
	// Helper message types for UniversalUpdateCollection subsets
	SetValidBadgeIds(ctx context.Context, in *MsgSetValidBadgeIds, opts ...grpc.CallOption) (*MsgSetValidBadgeIdsResponse, error)
	SetManager(ctx context.Context, in *MsgSetManager, opts ...grpc.CallOption) (*MsgSetManagerResponse, error)
	SetCollectionMetadata(ctx context.Context, in *MsgSetCollectionMetadata, opts ...grpc.CallOption) (*MsgSetCollectionMetadataResponse, error)
	SetBadgeMetadata(ctx context.Context, in *MsgSetBadgeMetadata, opts ...grpc.CallOption) (*MsgSetBadgeMetadataResponse, error)
	SetCustomData(ctx context.Context, in *MsgSetCustomData, opts ...grpc.CallOption) (*MsgSetCustomDataResponse, error)
	SetStandards(ctx context.Context, in *MsgSetStandards, opts ...grpc.CallOption) (*MsgSetStandardsResponse, error)
	SetCollectionApprovals(ctx context.Context, in *MsgSetCollectionApprovals, opts ...grpc.CallOption) (*MsgSetCollectionApprovalsResponse, error)
	SetIsArchived(ctx context.Context, in *MsgSetIsArchived, opts ...grpc.CallOption) (*MsgSetIsArchivedResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UniversalUpdateCollection(ctx context.Context, in *MsgUniversalUpdateCollection, opts ...grpc.CallOption) (*MsgUniversalUpdateCollectionResponse, error) {
	out := new(MsgUniversalUpdateCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/UniversalUpdateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateAddressLists(ctx context.Context, in *MsgCreateAddressLists, opts ...grpc.CallOption) (*MsgCreateAddressListsResponse, error) {
	out := new(MsgCreateAddressListsResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/CreateAddressLists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TransferBadges(ctx context.Context, in *MsgTransferBadges, opts ...grpc.CallOption) (*MsgTransferBadgesResponse, error) {
	out := new(MsgTransferBadgesResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/TransferBadges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateUserApprovals(ctx context.Context, in *MsgUpdateUserApprovals, opts ...grpc.CallOption) (*MsgUpdateUserApprovalsResponse, error) {
	out := new(MsgUpdateUserApprovalsResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/UpdateUserApprovals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetIncomingApproval(ctx context.Context, in *MsgSetIncomingApproval, opts ...grpc.CallOption) (*MsgSetIncomingApprovalResponse, error) {
	out := new(MsgSetIncomingApprovalResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/SetIncomingApproval", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeleteIncomingApproval(ctx context.Context, in *MsgDeleteIncomingApproval, opts ...grpc.CallOption) (*MsgDeleteIncomingApprovalResponse, error) {
	out := new(MsgDeleteIncomingApprovalResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/DeleteIncomingApproval", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetOutgoingApproval(ctx context.Context, in *MsgSetOutgoingApproval, opts ...grpc.CallOption) (*MsgSetOutgoingApprovalResponse, error) {
	out := new(MsgSetOutgoingApprovalResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/SetOutgoingApproval", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeleteOutgoingApproval(ctx context.Context, in *MsgDeleteOutgoingApproval, opts ...grpc.CallOption) (*MsgDeleteOutgoingApprovalResponse, error) {
	out := new(MsgDeleteOutgoingApprovalResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/DeleteOutgoingApproval", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PurgeApprovals(ctx context.Context, in *MsgPurgeApprovals, opts ...grpc.CallOption) (*MsgPurgeApprovalsResponse, error) {
	out := new(MsgPurgeApprovalsResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/PurgeApprovals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeleteCollection(ctx context.Context, in *MsgDeleteCollection, opts ...grpc.CallOption) (*MsgDeleteCollectionResponse, error) {
	out := new(MsgDeleteCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/DeleteCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateCollection(ctx context.Context, in *MsgUpdateCollection, opts ...grpc.CallOption) (*MsgUpdateCollectionResponse, error) {
	out := new(MsgUpdateCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/UpdateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateCollection(ctx context.Context, in *MsgCreateCollection, opts ...grpc.CallOption) (*MsgCreateCollectionResponse, error) {
	out := new(MsgCreateCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/CreateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateDynamicStore(ctx context.Context, in *MsgCreateDynamicStore, opts ...grpc.CallOption) (*MsgCreateDynamicStoreResponse, error) {
	out := new(MsgCreateDynamicStoreResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/CreateDynamicStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDynamicStore(ctx context.Context, in *MsgUpdateDynamicStore, opts ...grpc.CallOption) (*MsgUpdateDynamicStoreResponse, error) {
	out := new(MsgUpdateDynamicStoreResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/UpdateDynamicStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeleteDynamicStore(ctx context.Context, in *MsgDeleteDynamicStore, opts ...grpc.CallOption) (*MsgDeleteDynamicStoreResponse, error) {
	out := new(MsgDeleteDynamicStoreResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/DeleteDynamicStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetDynamicStoreValue(ctx context.Context, in *MsgSetDynamicStoreValue, opts ...grpc.CallOption) (*MsgSetDynamicStoreValueResponse, error) {
	out := new(MsgSetDynamicStoreValueResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/SetDynamicStoreValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) IncrementStoreValue(ctx context.Context, in *MsgIncrementStoreValue, opts ...grpc.CallOption) (*MsgIncrementStoreValueResponse, error) {
	out := new(MsgIncrementStoreValueResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/IncrementStoreValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DecrementStoreValue(ctx context.Context, in *MsgDecrementStoreValue, opts ...grpc.CallOption) (*MsgDecrementStoreValueResponse, error) {
	out := new(MsgDecrementStoreValueResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/DecrementStoreValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetValidBadgeIds(ctx context.Context, in *MsgSetValidBadgeIds, opts ...grpc.CallOption) (*MsgSetValidBadgeIdsResponse, error) {
	out := new(MsgSetValidBadgeIdsResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/SetValidBadgeIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetManager(ctx context.Context, in *MsgSetManager, opts ...grpc.CallOption) (*MsgSetManagerResponse, error) {
	out := new(MsgSetManagerResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/SetManager", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetCollectionMetadata(ctx context.Context, in *MsgSetCollectionMetadata, opts ...grpc.CallOption) (*MsgSetCollectionMetadataResponse, error) {
	out := new(MsgSetCollectionMetadataResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/SetCollectionMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetBadgeMetadata(ctx context.Context, in *MsgSetBadgeMetadata, opts ...grpc.CallOption) (*MsgSetBadgeMetadataResponse, error) {
	out := new(MsgSetBadgeMetadataResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/SetBadgeMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetCustomData(ctx context.Context, in *MsgSetCustomData, opts ...grpc.CallOption) (*MsgSetCustomDataResponse, error) {
	out := new(MsgSetCustomDataResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/SetCustomData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetStandards(ctx context.Context, in *MsgSetStandards, opts ...grpc.CallOption) (*MsgSetStandardsResponse, error) {
	out := new(MsgSetStandardsResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/SetStandards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetCollectionApprovals(ctx context.Context, in *MsgSetCollectionApprovals, opts ...grpc.CallOption) (*MsgSetCollectionApprovalsResponse, error) {
	out := new(MsgSetCollectionApprovalsResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/SetCollectionApprovals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetIsArchived(ctx context.Context, in *MsgSetIsArchived, opts ...grpc.CallOption) (*MsgSetIsArchivedResponse, error) {
	out := new(MsgSetIsArchivedResponse)
	err := c.cc.Invoke(ctx, "/badges.v17.Msg/SetIsArchived", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	UniversalUpdateCollection(context.Context, *MsgUniversalUpdateCollection) (*MsgUniversalUpdateCollectionResponse, error)
	CreateAddressLists(context.Context, *MsgCreateAddressLists) (*MsgCreateAddressListsResponse, error)
	TransferBadges(context.Context, *MsgTransferBadges) (*MsgTransferBadgesResponse, error)
	UpdateUserApprovals(context.Context, *MsgUpdateUserApprovals) (*MsgUpdateUserApprovalsResponse, error)
	SetIncomingApproval(context.Context, *MsgSetIncomingApproval) (*MsgSetIncomingApprovalResponse, error)
	DeleteIncomingApproval(context.Context, *MsgDeleteIncomingApproval) (*MsgDeleteIncomingApprovalResponse, error)
	SetOutgoingApproval(context.Context, *MsgSetOutgoingApproval) (*MsgSetOutgoingApprovalResponse, error)
	DeleteOutgoingApproval(context.Context, *MsgDeleteOutgoingApproval) (*MsgDeleteOutgoingApprovalResponse, error)
	PurgeApprovals(context.Context, *MsgPurgeApprovals) (*MsgPurgeApprovalsResponse, error)
	DeleteCollection(context.Context, *MsgDeleteCollection) (*MsgDeleteCollectionResponse, error)
	UpdateCollection(context.Context, *MsgUpdateCollection) (*MsgUpdateCollectionResponse, error)
	CreateCollection(context.Context, *MsgCreateCollection) (*MsgCreateCollectionResponse, error)
	CreateDynamicStore(context.Context, *MsgCreateDynamicStore) (*MsgCreateDynamicStoreResponse, error)
	UpdateDynamicStore(context.Context, *MsgUpdateDynamicStore) (*MsgUpdateDynamicStoreResponse, error)
	DeleteDynamicStore(context.Context, *MsgDeleteDynamicStore) (*MsgDeleteDynamicStoreResponse, error)
	SetDynamicStoreValue(context.Context, *MsgSetDynamicStoreValue) (*MsgSetDynamicStoreValueResponse, error)
	IncrementStoreValue(context.Context, *MsgIncrementStoreValue) (*MsgIncrementStoreValueResponse, error)
	DecrementStoreValue(context.Context, *MsgDecrementStoreValue) (*MsgDecrementStoreValueResponse, error)
	// Helper message types for UniversalUpdateCollection subsets
	SetValidBadgeIds(context.Context, *MsgSetValidBadgeIds) (*MsgSetValidBadgeIdsResponse, error)
	SetManager(context.Context, *MsgSetManager) (*MsgSetManagerResponse, error)
	SetCollectionMetadata(context.Context, *MsgSetCollectionMetadata) (*MsgSetCollectionMetadataResponse, error)
	SetBadgeMetadata(context.Context, *MsgSetBadgeMetadata) (*MsgSetBadgeMetadataResponse, error)
	SetCustomData(context.Context, *MsgSetCustomData) (*MsgSetCustomDataResponse, error)
	SetStandards(context.Context, *MsgSetStandards) (*MsgSetStandardsResponse, error)
	SetCollectionApprovals(context.Context, *MsgSetCollectionApprovals) (*MsgSetCollectionApprovalsResponse, error)
	SetIsArchived(context.Context, *MsgSetIsArchived) (*MsgSetIsArchivedResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) UniversalUpdateCollection(ctx context.Context, req *MsgUniversalUpdateCollection) (*MsgUniversalUpdateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UniversalUpdateCollection not implemented")
}
func (*UnimplementedMsgServer) CreateAddressLists(ctx context.Context, req *MsgCreateAddressLists) (*MsgCreateAddressListsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAddressLists not implemented")
}
func (*UnimplementedMsgServer) TransferBadges(ctx context.Context, req *MsgTransferBadges) (*MsgTransferBadgesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferBadges not implemented")
}
func (*UnimplementedMsgServer) UpdateUserApprovals(ctx context.Context, req *MsgUpdateUserApprovals) (*MsgUpdateUserApprovalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserApprovals not implemented")
}
func (*UnimplementedMsgServer) SetIncomingApproval(ctx context.Context, req *MsgSetIncomingApproval) (*MsgSetIncomingApprovalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIncomingApproval not implemented")
}
func (*UnimplementedMsgServer) DeleteIncomingApproval(ctx context.Context, req *MsgDeleteIncomingApproval) (*MsgDeleteIncomingApprovalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIncomingApproval not implemented")
}
func (*UnimplementedMsgServer) SetOutgoingApproval(ctx context.Context, req *MsgSetOutgoingApproval) (*MsgSetOutgoingApprovalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOutgoingApproval not implemented")
}
func (*UnimplementedMsgServer) DeleteOutgoingApproval(ctx context.Context, req *MsgDeleteOutgoingApproval) (*MsgDeleteOutgoingApprovalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOutgoingApproval not implemented")
}
func (*UnimplementedMsgServer) PurgeApprovals(ctx context.Context, req *MsgPurgeApprovals) (*MsgPurgeApprovalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PurgeApprovals not implemented")
}
func (*UnimplementedMsgServer) DeleteCollection(ctx context.Context, req *MsgDeleteCollection) (*MsgDeleteCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCollection not implemented")
}
func (*UnimplementedMsgServer) UpdateCollection(ctx context.Context, req *MsgUpdateCollection) (*MsgUpdateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCollection not implemented")
}
func (*UnimplementedMsgServer) CreateCollection(ctx context.Context, req *MsgCreateCollection) (*MsgCreateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCollection not implemented")
}
func (*UnimplementedMsgServer) CreateDynamicStore(ctx context.Context, req *MsgCreateDynamicStore) (*MsgCreateDynamicStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDynamicStore not implemented")
}
func (*UnimplementedMsgServer) UpdateDynamicStore(ctx context.Context, req *MsgUpdateDynamicStore) (*MsgUpdateDynamicStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDynamicStore not implemented")
}
func (*UnimplementedMsgServer) DeleteDynamicStore(ctx context.Context, req *MsgDeleteDynamicStore) (*MsgDeleteDynamicStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDynamicStore not implemented")
}
func (*UnimplementedMsgServer) SetDynamicStoreValue(ctx context.Context, req *MsgSetDynamicStoreValue) (*MsgSetDynamicStoreValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDynamicStoreValue not implemented")
}
func (*UnimplementedMsgServer) IncrementStoreValue(ctx context.Context, req *MsgIncrementStoreValue) (*MsgIncrementStoreValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementStoreValue not implemented")
}
func (*UnimplementedMsgServer) DecrementStoreValue(ctx context.Context, req *MsgDecrementStoreValue) (*MsgDecrementStoreValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecrementStoreValue not implemented")
}
func (*UnimplementedMsgServer) SetValidBadgeIds(ctx context.Context, req *MsgSetValidBadgeIds) (*MsgSetValidBadgeIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetValidBadgeIds not implemented")
}
func (*UnimplementedMsgServer) SetManager(ctx context.Context, req *MsgSetManager) (*MsgSetManagerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetManager not implemented")
}
func (*UnimplementedMsgServer) SetCollectionMetadata(ctx context.Context, req *MsgSetCollectionMetadata) (*MsgSetCollectionMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCollectionMetadata not implemented")
}
func (*UnimplementedMsgServer) SetBadgeMetadata(ctx context.Context, req *MsgSetBadgeMetadata) (*MsgSetBadgeMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBadgeMetadata not implemented")
}
func (*UnimplementedMsgServer) SetCustomData(ctx context.Context, req *MsgSetCustomData) (*MsgSetCustomDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCustomData not implemented")
}
func (*UnimplementedMsgServer) SetStandards(ctx context.Context, req *MsgSetStandards) (*MsgSetStandardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetStandards not implemented")
}
func (*UnimplementedMsgServer) SetCollectionApprovals(ctx context.Context, req *MsgSetCollectionApprovals) (*MsgSetCollectionApprovalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCollectionApprovals not implemented")
}
func (*UnimplementedMsgServer) SetIsArchived(ctx context.Context, req *MsgSetIsArchived) (*MsgSetIsArchivedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIsArchived not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UniversalUpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUniversalUpdateCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UniversalUpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/UniversalUpdateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UniversalUpdateCollection(ctx, req.(*MsgUniversalUpdateCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateAddressLists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateAddressLists)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateAddressLists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/CreateAddressLists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateAddressLists(ctx, req.(*MsgCreateAddressLists))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TransferBadges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransferBadges)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TransferBadges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/TransferBadges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TransferBadges(ctx, req.(*MsgTransferBadges))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateUserApprovals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateUserApprovals)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateUserApprovals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/UpdateUserApprovals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateUserApprovals(ctx, req.(*MsgUpdateUserApprovals))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetIncomingApproval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetIncomingApproval)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetIncomingApproval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/SetIncomingApproval",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetIncomingApproval(ctx, req.(*MsgSetIncomingApproval))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeleteIncomingApproval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteIncomingApproval)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeleteIncomingApproval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/DeleteIncomingApproval",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeleteIncomingApproval(ctx, req.(*MsgDeleteIncomingApproval))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetOutgoingApproval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetOutgoingApproval)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetOutgoingApproval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/SetOutgoingApproval",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetOutgoingApproval(ctx, req.(*MsgSetOutgoingApproval))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeleteOutgoingApproval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteOutgoingApproval)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeleteOutgoingApproval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/DeleteOutgoingApproval",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeleteOutgoingApproval(ctx, req.(*MsgDeleteOutgoingApproval))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PurgeApprovals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPurgeApprovals)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PurgeApprovals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/PurgeApprovals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PurgeApprovals(ctx, req.(*MsgPurgeApprovals))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeleteCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeleteCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/DeleteCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeleteCollection(ctx, req.(*MsgDeleteCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/UpdateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateCollection(ctx, req.(*MsgUpdateCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/CreateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateCollection(ctx, req.(*MsgCreateCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateDynamicStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateDynamicStore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateDynamicStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/CreateDynamicStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateDynamicStore(ctx, req.(*MsgCreateDynamicStore))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDynamicStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDynamicStore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDynamicStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/UpdateDynamicStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDynamicStore(ctx, req.(*MsgUpdateDynamicStore))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeleteDynamicStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteDynamicStore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeleteDynamicStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/DeleteDynamicStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeleteDynamicStore(ctx, req.(*MsgDeleteDynamicStore))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetDynamicStoreValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetDynamicStoreValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetDynamicStoreValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/SetDynamicStoreValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetDynamicStoreValue(ctx, req.(*MsgSetDynamicStoreValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_IncrementStoreValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgIncrementStoreValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).IncrementStoreValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/IncrementStoreValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).IncrementStoreValue(ctx, req.(*MsgIncrementStoreValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DecrementStoreValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDecrementStoreValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DecrementStoreValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/DecrementStoreValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DecrementStoreValue(ctx, req.(*MsgDecrementStoreValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetValidBadgeIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetValidBadgeIds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetValidBadgeIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/SetValidBadgeIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetValidBadgeIds(ctx, req.(*MsgSetValidBadgeIds))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetManager_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetManager)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetManager(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/SetManager",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetManager(ctx, req.(*MsgSetManager))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetCollectionMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetCollectionMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetCollectionMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/SetCollectionMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetCollectionMetadata(ctx, req.(*MsgSetCollectionMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetBadgeMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetBadgeMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetBadgeMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/SetBadgeMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetBadgeMetadata(ctx, req.(*MsgSetBadgeMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetCustomData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetCustomData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetCustomData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/SetCustomData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetCustomData(ctx, req.(*MsgSetCustomData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetStandards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetStandards)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetStandards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/SetStandards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetStandards(ctx, req.(*MsgSetStandards))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetCollectionApprovals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetCollectionApprovals)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetCollectionApprovals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/SetCollectionApprovals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetCollectionApprovals(ctx, req.(*MsgSetCollectionApprovals))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetIsArchived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetIsArchived)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetIsArchived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v17.Msg/SetIsArchived",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetIsArchived(ctx, req.(*MsgSetIsArchived))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "badges.v17.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "UniversalUpdateCollection",
			Handler:    _Msg_UniversalUpdateCollection_Handler,
		},
		{
			MethodName: "CreateAddressLists",
			Handler:    _Msg_CreateAddressLists_Handler,
		},
		{
			MethodName: "TransferBadges",
			Handler:    _Msg_TransferBadges_Handler,
		},
		{
			MethodName: "UpdateUserApprovals",
			Handler:    _Msg_UpdateUserApprovals_Handler,
		},
		{
			MethodName: "SetIncomingApproval",
			Handler:    _Msg_SetIncomingApproval_Handler,
		},
		{
			MethodName: "DeleteIncomingApproval",
			Handler:    _Msg_DeleteIncomingApproval_Handler,
		},
		{
			MethodName: "SetOutgoingApproval",
			Handler:    _Msg_SetOutgoingApproval_Handler,
		},
		{
			MethodName: "DeleteOutgoingApproval",
			Handler:    _Msg_DeleteOutgoingApproval_Handler,
		},
		{
			MethodName: "PurgeApprovals",
			Handler:    _Msg_PurgeApprovals_Handler,
		},
		{
			MethodName: "DeleteCollection",
			Handler:    _Msg_DeleteCollection_Handler,
		},
		{
			MethodName: "UpdateCollection",
			Handler:    _Msg_UpdateCollection_Handler,
		},
		{
			MethodName: "CreateCollection",
			Handler:    _Msg_CreateCollection_Handler,
		},
		{
			MethodName: "CreateDynamicStore",
			Handler:    _Msg_CreateDynamicStore_Handler,
		},
		{
			MethodName: "UpdateDynamicStore",
			Handler:    _Msg_UpdateDynamicStore_Handler,
		},
		{
			MethodName: "DeleteDynamicStore",
			Handler:    _Msg_DeleteDynamicStore_Handler,
		},
		{
			MethodName: "SetDynamicStoreValue",
			Handler:    _Msg_SetDynamicStoreValue_Handler,
		},
		{
			MethodName: "IncrementStoreValue",
			Handler:    _Msg_IncrementStoreValue_Handler,
		},
		{
			MethodName: "DecrementStoreValue",
			Handler:    _Msg_DecrementStoreValue_Handler,
		},
		{
			MethodName: "SetValidBadgeIds",
			Handler:    _Msg_SetValidBadgeIds_Handler,
		},
		{
			MethodName: "SetManager",
			Handler:    _Msg_SetManager_Handler,
		},
		{
			MethodName: "SetCollectionMetadata",
			Handler:    _Msg_SetCollectionMetadata_Handler,
		},
		{
			MethodName: "SetBadgeMetadata",
			Handler:    _Msg_SetBadgeMetadata_Handler,
		},
		{
			MethodName: "SetCustomData",
			Handler:    _Msg_SetCustomData_Handler,
		},
		{
			MethodName: "SetStandards",
			Handler:    _Msg_SetStandards_Handler,
		},
		{
			MethodName: "SetCollectionApprovals",
			Handler:    _Msg_SetCollectionApprovals_Handler,
		},
		{
			MethodName: "SetIsArchived",
			Handler:    _Msg_SetIsArchived_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "badges/v17/tx.proto",
}

func (m *BadgeCustomMsgType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadgeCustomMsgType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadgeCustomMsgType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetIsArchivedMsg != nil {
		{
			size, err := m.SetIsArchivedMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.SetCollectionApprovalsMsg != nil {
		{
			size, err := m.SetCollectionApprovalsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.SetStandardsMsg != nil {
		{
			size, err := m.SetStandardsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.SetCustomDataMsg != nil {
		{
			size, err := m.SetCustomDataMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.SetBadgeMetadataMsg != nil {
		{
			size, err := m.SetBadgeMetadataMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.SetCollectionMetadataMsg != nil {
		{
			size, err := m.SetCollectionMetadataMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.SetManagerMsg != nil {
		{
			size, err := m.SetManagerMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.SetValidBadgeIdsMsg != nil {
		{
			size, err := m.SetValidBadgeIdsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.PurgeApprovalsMsg != nil {
		{
			size, err := m.PurgeApprovalsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.DeleteOutgoingApprovalMsg != nil {
		{
			size, err := m.DeleteOutgoingApprovalMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.SetOutgoingApprovalMsg != nil {
		{
			size, err := m.SetOutgoingApprovalMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.DeleteIncomingApprovalMsg != nil {
		{
			size, err := m.DeleteIncomingApprovalMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.SetIncomingApprovalMsg != nil {
		{
			size, err := m.SetIncomingApprovalMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.DecrementStoreValueMsg != nil {
		{
			size, err := m.DecrementStoreValueMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.IncrementStoreValueMsg != nil {
		{
			size, err := m.IncrementStoreValueMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.SetDynamicStoreValueMsg != nil {
		{
			size, err := m.SetDynamicStoreValueMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.DeleteDynamicStoreMsg != nil {
		{
			size, err := m.DeleteDynamicStoreMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.UpdateDynamicStoreMsg != nil {
		{
			size, err := m.UpdateDynamicStoreMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CreateDynamicStoreMsg != nil {
		{
			size, err := m.CreateDynamicStoreMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CreateCollectionMsg != nil {
		{
			size, err := m.CreateCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.UpdateCollectionMsg != nil {
		{
			size, err := m.UpdateCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UpdateUserApprovalsMsg != nil {
		{
			size, err := m.UpdateUserApprovalsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TransferBadgesMsg != nil {
		{
			size, err := m.TransferBadgesMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DeleteCollectionMsg != nil {
		{
			size, err := m.DeleteCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.UniversalUpdateCollectionMsg != nil {
		{
			size, err := m.UniversalUpdateCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CreateAddressListsMsg != nil {
		{
			size, err := m.CreateAddressListsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CosmosCoinWrapperPathAddObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosCoinWrapperPathAddObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosCoinWrapperPathAddObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowCosmosWrapping {
		i--
		if m.AllowCosmosWrapping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.AllowOverrideWithAnyValidToken {
		i--
		if m.AllowOverrideWithAnyValidToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.DenomUnits) > 0 {
		for iNdEx := len(m.DenomUnits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DenomUnits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUniversalUpdateCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUniversalUpdateCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUniversalUpdateCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Invariants != nil {
		{
			size, err := m.Invariants.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for iNdEx := len(m.CosmosCoinWrapperPathsToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CosmosCoinWrapperPathsToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for iNdEx := len(m.MintEscrowCoinsToTransfer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MintEscrowCoinsToTransfer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.UpdateIsArchivedTimeline {
		i--
		if m.UpdateIsArchivedTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.UpdateStandardsTimeline {
		i--
		if m.UpdateStandardsTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.UpdateCollectionApprovals {
		i--
		if m.UpdateCollectionApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.UpdateCustomDataTimeline {
		i--
		if m.UpdateCustomDataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for iNdEx := len(m.BadgeMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.UpdateBadgeMetadataTimeline {
		i--
		if m.UpdateBadgeMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		i--
		if m.UpdateCollectionMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.UpdateManagerTimeline {
		i--
		if m.UpdateManagerTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.UpdateCollectionPermissions {
		i--
		if m.UpdateCollectionPermissions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.ValidBadgeIds) > 0 {
		for iNdEx := len(m.ValidBadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidBadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.UpdateValidBadgeIds {
		i--
		if m.UpdateValidBadgeIds {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DefaultBalances != nil {
		{
			size, err := m.DefaultBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUniversalUpdateCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUniversalUpdateCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUniversalUpdateCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Invariants != nil {
		{
			size, err := m.Invariants.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for iNdEx := len(m.CosmosCoinWrapperPathsToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CosmosCoinWrapperPathsToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for iNdEx := len(m.MintEscrowCoinsToTransfer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MintEscrowCoinsToTransfer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.UpdateIsArchivedTimeline {
		i--
		if m.UpdateIsArchivedTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.UpdateStandardsTimeline {
		i--
		if m.UpdateStandardsTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.UpdateCollectionApprovals {
		i--
		if m.UpdateCollectionApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.UpdateCustomDataTimeline {
		i--
		if m.UpdateCustomDataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for iNdEx := len(m.BadgeMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.UpdateBadgeMetadataTimeline {
		i--
		if m.UpdateBadgeMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		i--
		if m.UpdateCollectionMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.UpdateManagerTimeline {
		i--
		if m.UpdateManagerTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UpdateCollectionPermissions {
		i--
		if m.UpdateCollectionPermissions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ValidBadgeIds) > 0 {
		for iNdEx := len(m.ValidBadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidBadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.UpdateValidBadgeIds {
		i--
		if m.UpdateValidBadgeIds {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Invariants != nil {
		{
			size, err := m.Invariants.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for iNdEx := len(m.CosmosCoinWrapperPathsToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CosmosCoinWrapperPathsToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for iNdEx := len(m.MintEscrowCoinsToTransfer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MintEscrowCoinsToTransfer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for iNdEx := len(m.BadgeMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ValidBadgeIds) > 0 {
		for iNdEx := len(m.ValidBadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidBadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DefaultBalances != nil {
		{
			size, err := m.DefaultBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateAddressLists) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAddressLists) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAddressLists) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddressLists) > 0 {
		for iNdEx := len(m.AddressLists) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddressLists[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateAddressListsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAddressListsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAddressListsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgTransferBadges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferBadges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferBadges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Transfers) > 0 {
		for iNdEx := len(m.Transfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransferBadgesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferBadgesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferBadgesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeleteCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeleteCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateUserApprovals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateUserApprovals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateUserApprovals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserPermissions != nil {
		{
			size, err := m.UserPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.UpdateUserPermissions {
		i--
		if m.UpdateUserPermissions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.AutoApproveAllIncomingTransfers {
		i--
		if m.AutoApproveAllIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.UpdateAutoApproveAllIncomingTransfers {
		i--
		if m.UpdateAutoApproveAllIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		i--
		if m.AutoApproveSelfInitiatedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.UpdateAutoApproveSelfInitiatedIncomingTransfers {
		i--
		if m.UpdateAutoApproveSelfInitiatedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		i--
		if m.AutoApproveSelfInitiatedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.UpdateAutoApproveSelfInitiatedOutgoingTransfers {
		i--
		if m.UpdateAutoApproveSelfInitiatedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.IncomingApprovals) > 0 {
		for iNdEx := len(m.IncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IncomingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.UpdateIncomingApprovals {
		i--
		if m.UpdateIncomingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.OutgoingApprovals) > 0 {
		for iNdEx := len(m.OutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutgoingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.UpdateOutgoingApprovals {
		i--
		if m.UpdateOutgoingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateUserApprovalsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateUserApprovalsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateUserApprovalsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetIncomingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetIncomingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetIncomingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Approval != nil {
		{
			size, err := m.Approval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetIncomingApprovalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetIncomingApprovalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetIncomingApprovalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeleteIncomingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteIncomingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteIncomingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeleteIncomingApprovalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteIncomingApprovalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteIncomingApprovalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetOutgoingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetOutgoingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetOutgoingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Approval != nil {
		{
			size, err := m.Approval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetOutgoingApprovalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetOutgoingApprovalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetOutgoingApprovalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeleteOutgoingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteOutgoingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteOutgoingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeleteOutgoingApprovalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteOutgoingApprovalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteOutgoingApprovalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPurgeApprovals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPurgeApprovals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPurgeApprovals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalsToPurge) > 0 {
		for iNdEx := len(m.ApprovalsToPurge) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApprovalsToPurge[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.PurgeCounterpartyApprovals {
		i--
		if m.PurgeCounterpartyApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ApproverAddress) > 0 {
		i -= len(m.ApproverAddress)
		copy(dAtA[i:], m.ApproverAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ApproverAddress)))
		i--
		dAtA[i] = 0x22
	}
	if m.PurgeExpired {
		i--
		if m.PurgeExpired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPurgeApprovalsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPurgeApprovalsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPurgeApprovalsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NumPurged.Size()
		i -= size
		if _, err := m.NumPurged.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateDynamicStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDynamicStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDynamicStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.DefaultValue.Size()
		i -= size
		if _, err := m.DefaultValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDynamicStoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDynamicStoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDynamicStoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDynamicStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDynamicStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDynamicStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.DefaultValue.Size()
		i -= size
		if _, err := m.DefaultValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDynamicStoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDynamicStoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDynamicStoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeleteDynamicStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteDynamicStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteDynamicStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeleteDynamicStoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteDynamicStoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteDynamicStoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetDynamicStoreValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetDynamicStoreValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetDynamicStoreValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Value.Size()
		i -= size
		if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetDynamicStoreValueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetDynamicStoreValueResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetDynamicStoreValueResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgIncrementStoreValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIncrementStoreValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIncrementStoreValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgIncrementStoreValueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIncrementStoreValueResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIncrementStoreValueResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDecrementStoreValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDecrementStoreValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDecrementStoreValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetToZeroOnUnderflow {
		i--
		if m.SetToZeroOnUnderflow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDecrementStoreValueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDecrementStoreValueResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDecrementStoreValueResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetValidBadgeIds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetValidBadgeIds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetValidBadgeIds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateValidBadgeIds) > 0 {
		for iNdEx := len(m.CanUpdateValidBadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateValidBadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ValidBadgeIds) > 0 {
		for iNdEx := len(m.ValidBadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidBadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetValidBadgeIdsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetValidBadgeIdsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetValidBadgeIdsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetManager) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetManager) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetManager) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateManager) > 0 {
		for iNdEx := len(m.CanUpdateManager) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateManager[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetManagerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetManagerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetManagerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetCollectionMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCollectionMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCollectionMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for iNdEx := len(m.CanUpdateCollectionMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetCollectionMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCollectionMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCollectionMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetBadgeMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetBadgeMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetBadgeMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateBadgeMetadata) > 0 {
		for iNdEx := len(m.CanUpdateBadgeMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateBadgeMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for iNdEx := len(m.BadgeMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetBadgeMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetBadgeMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetBadgeMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetCustomData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCustomData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCustomData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateCustomData) > 0 {
		for iNdEx := len(m.CanUpdateCustomData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCustomData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetCustomDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCustomDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCustomDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetStandards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetStandards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetStandards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateStandards) > 0 {
		for iNdEx := len(m.CanUpdateStandards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateStandards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetStandardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetStandardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetStandardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetCollectionApprovals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCollectionApprovals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCollectionApprovals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateCollectionApprovals) > 0 {
		for iNdEx := len(m.CanUpdateCollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetCollectionApprovalsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCollectionApprovalsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCollectionApprovalsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetIsArchived) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetIsArchived) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetIsArchived) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanArchiveCollection) > 0 {
		for iNdEx := len(m.CanArchiveCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanArchiveCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetIsArchivedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetIsArchivedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetIsArchivedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BadgeCustomMsgType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateAddressListsMsg != nil {
		l = m.CreateAddressListsMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UniversalUpdateCollectionMsg != nil {
		l = m.UniversalUpdateCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DeleteCollectionMsg != nil {
		l = m.DeleteCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TransferBadgesMsg != nil {
		l = m.TransferBadgesMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateUserApprovalsMsg != nil {
		l = m.UpdateUserApprovalsMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateCollectionMsg != nil {
		l = m.UpdateCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CreateCollectionMsg != nil {
		l = m.CreateCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CreateDynamicStoreMsg != nil {
		l = m.CreateDynamicStoreMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateDynamicStoreMsg != nil {
		l = m.UpdateDynamicStoreMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DeleteDynamicStoreMsg != nil {
		l = m.DeleteDynamicStoreMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SetDynamicStoreValueMsg != nil {
		l = m.SetDynamicStoreValueMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.IncrementStoreValueMsg != nil {
		l = m.IncrementStoreValueMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DecrementStoreValueMsg != nil {
		l = m.DecrementStoreValueMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SetIncomingApprovalMsg != nil {
		l = m.SetIncomingApprovalMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DeleteIncomingApprovalMsg != nil {
		l = m.DeleteIncomingApprovalMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SetOutgoingApprovalMsg != nil {
		l = m.SetOutgoingApprovalMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.DeleteOutgoingApprovalMsg != nil {
		l = m.DeleteOutgoingApprovalMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.PurgeApprovalsMsg != nil {
		l = m.PurgeApprovalsMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetValidBadgeIdsMsg != nil {
		l = m.SetValidBadgeIdsMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetManagerMsg != nil {
		l = m.SetManagerMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetCollectionMetadataMsg != nil {
		l = m.SetCollectionMetadataMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetBadgeMetadataMsg != nil {
		l = m.SetBadgeMetadataMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetCustomDataMsg != nil {
		l = m.SetCustomDataMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetStandardsMsg != nil {
		l = m.SetStandardsMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetCollectionApprovalsMsg != nil {
		l = m.SetCollectionApprovalsMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetIsArchivedMsg != nil {
		l = m.SetIsArchivedMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CosmosCoinWrapperPathAddObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.DenomUnits) > 0 {
		for _, e := range m.DenomUnits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.AllowOverrideWithAnyValidToken {
		n += 2
	}
	if m.AllowCosmosWrapping {
		n += 2
	}
	return n
}

func (m *MsgUniversalUpdateCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.DefaultBalances != nil {
		l = m.DefaultBalances.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateValidBadgeIds {
		n += 2
	}
	if len(m.ValidBadgeIds) > 0 {
		for _, e := range m.ValidBadgeIds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionPermissions {
		n += 2
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateManagerTimeline {
		n += 2
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		n += 2
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateBadgeMetadataTimeline {
		n += 2
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for _, e := range m.BadgeMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCustomDataTimeline {
		n += 2
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionApprovals {
		n += 3
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateStandardsTimeline {
		n += 3
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateIsArchivedTimeline {
		n += 3
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for _, e := range m.MintEscrowCoinsToTransfer {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for _, e := range m.CosmosCoinWrapperPathsToAdd {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.Invariants != nil {
		l = m.Invariants.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUniversalUpdateCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.UpdateValidBadgeIds {
		n += 2
	}
	if len(m.ValidBadgeIds) > 0 {
		for _, e := range m.ValidBadgeIds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionPermissions {
		n += 2
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateManagerTimeline {
		n += 2
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		n += 2
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateBadgeMetadataTimeline {
		n += 2
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for _, e := range m.BadgeMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCustomDataTimeline {
		n += 2
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionApprovals {
		n += 2
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateStandardsTimeline {
		n += 3
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateIsArchivedTimeline {
		n += 3
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for _, e := range m.MintEscrowCoinsToTransfer {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for _, e := range m.CosmosCoinWrapperPathsToAdd {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.Invariants != nil {
		l = m.Invariants.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DefaultBalances != nil {
		l = m.DefaultBalances.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.ValidBadgeIds) > 0 {
		for _, e := range m.ValidBadgeIds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for _, e := range m.BadgeMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for _, e := range m.MintEscrowCoinsToTransfer {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for _, e := range m.CosmosCoinWrapperPathsToAdd {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Invariants != nil {
		l = m.Invariants.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateAddressLists) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.AddressLists) > 0 {
		for _, e := range m.AddressLists {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateAddressListsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgTransferBadges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.Transfers) > 0 {
		for _, e := range m.Transfers {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgTransferBadgesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeleteCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDeleteCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateUserApprovals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.UpdateOutgoingApprovals {
		n += 2
	}
	if len(m.OutgoingApprovals) > 0 {
		for _, e := range m.OutgoingApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateIncomingApprovals {
		n += 2
	}
	if len(m.IncomingApprovals) > 0 {
		for _, e := range m.IncomingApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateAutoApproveSelfInitiatedOutgoingTransfers {
		n += 2
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		n += 2
	}
	if m.UpdateAutoApproveSelfInitiatedIncomingTransfers {
		n += 2
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		n += 2
	}
	if m.UpdateAutoApproveAllIncomingTransfers {
		n += 2
	}
	if m.AutoApproveAllIncomingTransfers {
		n += 2
	}
	if m.UpdateUserPermissions {
		n += 2
	}
	if m.UserPermissions != nil {
		l = m.UserPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateUserApprovalsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetIncomingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.Approval != nil {
		l = m.Approval.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetIncomingApprovalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeleteIncomingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDeleteIncomingApprovalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetOutgoingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.Approval != nil {
		l = m.Approval.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetOutgoingApprovalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeleteOutgoingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDeleteOutgoingApprovalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPurgeApprovals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.PurgeExpired {
		n += 2
	}
	l = len(m.ApproverAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PurgeCounterpartyApprovals {
		n += 2
	}
	if len(m.ApprovalsToPurge) > 0 {
		for _, e := range m.ApprovalsToPurge {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgPurgeApprovalsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NumPurged.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateDynamicStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.DefaultValue.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateDynamicStoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StoreId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateDynamicStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.StoreId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.DefaultValue.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateDynamicStoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeleteDynamicStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.StoreId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDeleteDynamicStoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetDynamicStoreValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.StoreId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetDynamicStoreValueResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgIncrementStoreValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.StoreId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgIncrementStoreValueResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDecrementStoreValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.StoreId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.SetToZeroOnUnderflow {
		n += 2
	}
	return n
}

func (m *MsgDecrementStoreValueResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetValidBadgeIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.ValidBadgeIds) > 0 {
		for _, e := range m.ValidBadgeIds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateValidBadgeIds) > 0 {
		for _, e := range m.CanUpdateValidBadgeIds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetValidBadgeIdsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetManager) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for _, e := range m.CanUpdateManager {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetManagerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetCollectionMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for _, e := range m.CanUpdateCollectionMetadata {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetCollectionMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetBadgeMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.BadgeMetadataTimeline) > 0 {
		for _, e := range m.BadgeMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateBadgeMetadata) > 0 {
		for _, e := range m.CanUpdateBadgeMetadata {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetBadgeMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetCustomData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for _, e := range m.CanUpdateCustomData {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetCustomDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetStandards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateStandards) > 0 {
		for _, e := range m.CanUpdateStandards {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetStandardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetCollectionApprovals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionApprovals) > 0 {
		for _, e := range m.CanUpdateCollectionApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetCollectionApprovalsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetIsArchived) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanArchiveCollection) > 0 {
		for _, e := range m.CanArchiveCollection {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetIsArchivedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BadgeCustomMsgType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadgeCustomMsgType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadgeCustomMsgType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAddressListsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateAddressListsMsg == nil {
				m.CreateAddressListsMsg = &MsgCreateAddressLists{}
			}
			if err := m.CreateAddressListsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniversalUpdateCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UniversalUpdateCollectionMsg == nil {
				m.UniversalUpdateCollectionMsg = &MsgUniversalUpdateCollection{}
			}
			if err := m.UniversalUpdateCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteCollectionMsg == nil {
				m.DeleteCollectionMsg = &MsgDeleteCollection{}
			}
			if err := m.DeleteCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferBadgesMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferBadgesMsg == nil {
				m.TransferBadgesMsg = &MsgTransferBadges{}
			}
			if err := m.TransferBadgesMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateUserApprovalsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateUserApprovalsMsg == nil {
				m.UpdateUserApprovalsMsg = &MsgUpdateUserApprovals{}
			}
			if err := m.UpdateUserApprovalsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateCollectionMsg == nil {
				m.UpdateCollectionMsg = &MsgUpdateCollection{}
			}
			if err := m.UpdateCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateCollectionMsg == nil {
				m.CreateCollectionMsg = &MsgCreateCollection{}
			}
			if err := m.CreateCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDynamicStoreMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateDynamicStoreMsg == nil {
				m.CreateDynamicStoreMsg = &MsgCreateDynamicStore{}
			}
			if err := m.CreateDynamicStoreMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDynamicStoreMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateDynamicStoreMsg == nil {
				m.UpdateDynamicStoreMsg = &MsgUpdateDynamicStore{}
			}
			if err := m.UpdateDynamicStoreMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteDynamicStoreMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteDynamicStoreMsg == nil {
				m.DeleteDynamicStoreMsg = &MsgDeleteDynamicStore{}
			}
			if err := m.DeleteDynamicStoreMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetDynamicStoreValueMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetDynamicStoreValueMsg == nil {
				m.SetDynamicStoreValueMsg = &MsgSetDynamicStoreValue{}
			}
			if err := m.SetDynamicStoreValueMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrementStoreValueMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncrementStoreValueMsg == nil {
				m.IncrementStoreValueMsg = &MsgIncrementStoreValue{}
			}
			if err := m.IncrementStoreValueMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecrementStoreValueMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DecrementStoreValueMsg == nil {
				m.DecrementStoreValueMsg = &MsgDecrementStoreValue{}
			}
			if err := m.DecrementStoreValueMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetIncomingApprovalMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetIncomingApprovalMsg == nil {
				m.SetIncomingApprovalMsg = &MsgSetIncomingApproval{}
			}
			if err := m.SetIncomingApprovalMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteIncomingApprovalMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteIncomingApprovalMsg == nil {
				m.DeleteIncomingApprovalMsg = &MsgDeleteIncomingApproval{}
			}
			if err := m.DeleteIncomingApprovalMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetOutgoingApprovalMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetOutgoingApprovalMsg == nil {
				m.SetOutgoingApprovalMsg = &MsgSetOutgoingApproval{}
			}
			if err := m.SetOutgoingApprovalMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteOutgoingApprovalMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteOutgoingApprovalMsg == nil {
				m.DeleteOutgoingApprovalMsg = &MsgDeleteOutgoingApproval{}
			}
			if err := m.DeleteOutgoingApprovalMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeApprovalsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PurgeApprovalsMsg == nil {
				m.PurgeApprovalsMsg = &MsgPurgeApprovals{}
			}
			if err := m.PurgeApprovalsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetValidBadgeIdsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetValidBadgeIdsMsg == nil {
				m.SetValidBadgeIdsMsg = &MsgSetValidBadgeIds{}
			}
			if err := m.SetValidBadgeIdsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetManagerMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetManagerMsg == nil {
				m.SetManagerMsg = &MsgSetManager{}
			}
			if err := m.SetManagerMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetCollectionMetadataMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetCollectionMetadataMsg == nil {
				m.SetCollectionMetadataMsg = &MsgSetCollectionMetadata{}
			}
			if err := m.SetCollectionMetadataMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetBadgeMetadataMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetBadgeMetadataMsg == nil {
				m.SetBadgeMetadataMsg = &MsgSetBadgeMetadata{}
			}
			if err := m.SetBadgeMetadataMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetCustomDataMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetCustomDataMsg == nil {
				m.SetCustomDataMsg = &MsgSetCustomData{}
			}
			if err := m.SetCustomDataMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetStandardsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetStandardsMsg == nil {
				m.SetStandardsMsg = &MsgSetStandards{}
			}
			if err := m.SetStandardsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetCollectionApprovalsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetCollectionApprovalsMsg == nil {
				m.SetCollectionApprovalsMsg = &MsgSetCollectionApprovals{}
			}
			if err := m.SetCollectionApprovalsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetIsArchivedMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetIsArchivedMsg == nil {
				m.SetIsArchivedMsg = &MsgSetIsArchived{}
			}
			if err := m.SetIsArchivedMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosCoinWrapperPathAddObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosCoinWrapperPathAddObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosCoinWrapperPathAddObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomUnits = append(m.DenomUnits, &DenomUnit{})
			if err := m.DenomUnits[len(m.DenomUnits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideWithAnyValidToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideWithAnyValidToken = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCosmosWrapping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowCosmosWrapping = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUniversalUpdateCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBalances == nil {
				m.DefaultBalances = &UserBalanceStore{}
			}
			if err := m.DefaultBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateValidBadgeIds", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateValidBadgeIds = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidBadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidBadgeIds = append(m.ValidBadgeIds, &UintRange{})
			if err := m.ValidBadgeIds[len(m.ValidBadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionPermissions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionPermissions = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateManagerTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateManagerTimeline = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionMetadataTimeline = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateBadgeMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateBadgeMetadataTimeline = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeMetadataTimeline = append(m.BadgeMetadataTimeline, &BadgeMetadataTimeline{})
			if err := m.BadgeMetadataTimeline[len(m.BadgeMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCustomDataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCustomDataTimeline = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionApprovals = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateStandardsTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateStandardsTimeline = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIsArchivedTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateIsArchivedTimeline = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintEscrowCoinsToTransfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintEscrowCoinsToTransfer = append(m.MintEscrowCoinsToTransfer, &types.Coin{})
			if err := m.MintEscrowCoinsToTransfer[len(m.MintEscrowCoinsToTransfer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinWrapperPathsToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosCoinWrapperPathsToAdd = append(m.CosmosCoinWrapperPathsToAdd, &CosmosCoinWrapperPathAddObject{})
			if err := m.CosmosCoinWrapperPathsToAdd[len(m.CosmosCoinWrapperPathsToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invariants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invariants == nil {
				m.Invariants = &CollectionInvariants{}
			}
			if err := m.Invariants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUniversalUpdateCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateValidBadgeIds", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateValidBadgeIds = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidBadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidBadgeIds = append(m.ValidBadgeIds, &UintRange{})
			if err := m.ValidBadgeIds[len(m.ValidBadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionPermissions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionPermissions = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateManagerTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateManagerTimeline = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionMetadataTimeline = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateBadgeMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateBadgeMetadataTimeline = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeMetadataTimeline = append(m.BadgeMetadataTimeline, &BadgeMetadataTimeline{})
			if err := m.BadgeMetadataTimeline[len(m.BadgeMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCustomDataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCustomDataTimeline = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionApprovals = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateStandardsTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateStandardsTimeline = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIsArchivedTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateIsArchivedTimeline = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintEscrowCoinsToTransfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintEscrowCoinsToTransfer = append(m.MintEscrowCoinsToTransfer, &types.Coin{})
			if err := m.MintEscrowCoinsToTransfer[len(m.MintEscrowCoinsToTransfer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinWrapperPathsToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosCoinWrapperPathsToAdd = append(m.CosmosCoinWrapperPathsToAdd, &CosmosCoinWrapperPathAddObject{})
			if err := m.CosmosCoinWrapperPathsToAdd[len(m.CosmosCoinWrapperPathsToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invariants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invariants == nil {
				m.Invariants = &CollectionInvariants{}
			}
			if err := m.Invariants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBalances == nil {
				m.DefaultBalances = &UserBalanceStore{}
			}
			if err := m.DefaultBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidBadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidBadgeIds = append(m.ValidBadgeIds, &UintRange{})
			if err := m.ValidBadgeIds[len(m.ValidBadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeMetadataTimeline = append(m.BadgeMetadataTimeline, &BadgeMetadataTimeline{})
			if err := m.BadgeMetadataTimeline[len(m.BadgeMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintEscrowCoinsToTransfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintEscrowCoinsToTransfer = append(m.MintEscrowCoinsToTransfer, &types.Coin{})
			if err := m.MintEscrowCoinsToTransfer[len(m.MintEscrowCoinsToTransfer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinWrapperPathsToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosCoinWrapperPathsToAdd = append(m.CosmosCoinWrapperPathsToAdd, &CosmosCoinWrapperPathAddObject{})
			if err := m.CosmosCoinWrapperPathsToAdd[len(m.CosmosCoinWrapperPathsToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invariants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invariants == nil {
				m.Invariants = &CollectionInvariants{}
			}
			if err := m.Invariants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAddressLists) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAddressLists: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAddressLists: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressLists", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressLists = append(m.AddressLists, &AddressList{})
			if err := m.AddressLists[len(m.AddressLists)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAddressListsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAddressListsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAddressListsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferBadges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferBadges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferBadges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transfers = append(m.Transfers, &Transfer{})
			if err := m.Transfers[len(m.Transfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferBadgesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferBadgesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferBadgesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateUserApprovals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateUserApprovals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateUserApprovals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateOutgoingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateOutgoingApprovals = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutgoingApprovals = append(m.OutgoingApprovals, &UserOutgoingApproval{})
			if err := m.OutgoingApprovals[len(m.OutgoingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIncomingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateIncomingApprovals = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncomingApprovals = append(m.IncomingApprovals, &UserIncomingApproval{})
			if err := m.IncomingApprovals[len(m.IncomingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateAutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateAutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAutoApproveAllIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateAutoApproveAllIncomingTransfers = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveAllIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveAllIncomingTransfers = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateUserPermissions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateUserPermissions = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPermissions == nil {
				m.UserPermissions = &UserPermissions{}
			}
			if err := m.UserPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateUserApprovalsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateUserApprovalsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateUserApprovalsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetIncomingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetIncomingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetIncomingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Approval == nil {
				m.Approval = &UserIncomingApproval{}
			}
			if err := m.Approval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetIncomingApprovalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetIncomingApprovalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetIncomingApprovalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteIncomingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteIncomingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteIncomingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteIncomingApprovalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteIncomingApprovalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteIncomingApprovalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetOutgoingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetOutgoingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetOutgoingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Approval == nil {
				m.Approval = &UserOutgoingApproval{}
			}
			if err := m.Approval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetOutgoingApprovalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetOutgoingApprovalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetOutgoingApprovalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteOutgoingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteOutgoingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteOutgoingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteOutgoingApprovalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteOutgoingApprovalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteOutgoingApprovalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPurgeApprovals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPurgeApprovals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPurgeApprovals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeExpired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PurgeExpired = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproverAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApproverAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeCounterpartyApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PurgeCounterpartyApprovals = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalsToPurge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalsToPurge = append(m.ApprovalsToPurge, &ApprovalIdentifierDetails{})
			if err := m.ApprovalsToPurge[len(m.ApprovalsToPurge)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPurgeApprovalsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPurgeApprovalsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPurgeApprovalsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPurged", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NumPurged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDynamicStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDynamicStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDynamicStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDynamicStoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDynamicStoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDynamicStoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDynamicStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDynamicStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDynamicStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDynamicStoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDynamicStoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDynamicStoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteDynamicStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteDynamicStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteDynamicStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteDynamicStoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteDynamicStoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteDynamicStoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetDynamicStoreValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetDynamicStoreValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetDynamicStoreValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetDynamicStoreValueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetDynamicStoreValueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetDynamicStoreValueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIncrementStoreValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIncrementStoreValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIncrementStoreValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIncrementStoreValueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIncrementStoreValueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIncrementStoreValueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDecrementStoreValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDecrementStoreValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDecrementStoreValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetToZeroOnUnderflow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SetToZeroOnUnderflow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDecrementStoreValueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDecrementStoreValueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDecrementStoreValueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetValidBadgeIds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetValidBadgeIds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetValidBadgeIds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidBadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidBadgeIds = append(m.ValidBadgeIds, &UintRange{})
			if err := m.ValidBadgeIds[len(m.ValidBadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateValidBadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateValidBadgeIds = append(m.CanUpdateValidBadgeIds, &BadgeIdsActionPermission{})
			if err := m.CanUpdateValidBadgeIds[len(m.CanUpdateValidBadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetValidBadgeIdsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetValidBadgeIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetValidBadgeIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetManager) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetManager: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetManager: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateManager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateManager = append(m.CanUpdateManager, &TimedUpdatePermission{})
			if err := m.CanUpdateManager[len(m.CanUpdateManager)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetManagerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetManagerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetManagerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCollectionMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCollectionMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCollectionMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionMetadata = append(m.CanUpdateCollectionMetadata, &TimedUpdatePermission{})
			if err := m.CanUpdateCollectionMetadata[len(m.CanUpdateCollectionMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCollectionMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCollectionMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCollectionMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetBadgeMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetBadgeMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetBadgeMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeMetadataTimeline = append(m.BadgeMetadataTimeline, &BadgeMetadataTimeline{})
			if err := m.BadgeMetadataTimeline[len(m.BadgeMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateBadgeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateBadgeMetadata = append(m.CanUpdateBadgeMetadata, &TimedUpdateWithBadgeIdsPermission{})
			if err := m.CanUpdateBadgeMetadata[len(m.CanUpdateBadgeMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetBadgeMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetBadgeMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetBadgeMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCustomData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCustomData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCustomData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCustomData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCustomData = append(m.CanUpdateCustomData, &TimedUpdatePermission{})
			if err := m.CanUpdateCustomData[len(m.CanUpdateCustomData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCustomDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCustomDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCustomDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetStandards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetStandards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetStandards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateStandards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateStandards = append(m.CanUpdateStandards, &TimedUpdatePermission{})
			if err := m.CanUpdateStandards[len(m.CanUpdateStandards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetStandardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetStandardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetStandardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCollectionApprovals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCollectionApprovals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCollectionApprovals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionApprovals = append(m.CanUpdateCollectionApprovals, &CollectionApprovalPermission{})
			if err := m.CanUpdateCollectionApprovals[len(m.CanUpdateCollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCollectionApprovalsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCollectionApprovalsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCollectionApprovalsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetIsArchived) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetIsArchived: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetIsArchived: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanArchiveCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanArchiveCollection = append(m.CanArchiveCollection, &TimedUpdatePermission{})
			if err := m.CanArchiveCollection[len(m.CanArchiveCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetIsArchivedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetIsArchivedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetIsArchivedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
