// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/collections.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A BadgeCollection is the top-level object for a collection of badges.
// It defines everything about the collection, such as the manager, metadata, etc.
//
// All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).
//
// All collections can have a manager who is responsible for managing the collection and can be granted certain admin
// permissions, such as the ability to mint new badges.
//
// Certain fields are timeline-based, which means they may have different values at different block heights.
// We fetch the value according to the current time.
// For example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.
//
// Collections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.
//
// See documentation for more details.
type BadgeCollection struct {
	// The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The metadata for the collection itself, which can vary over time.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,2,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// The metadata for each badge in the collection, also subject to changes over time.
	BadgeMetadataTimeline []*BadgeMetadataTimeline `protobuf:"bytes,3,rep,name=badgeMetadataTimeline,proto3" json:"badgeMetadataTimeline,omitempty"`
	// The type of balances this collection uses ("Standard", "Off-Chain - Indexed", "Off-Chain - Non-Indexed", or "Non-Public").
	BalancesType string `protobuf:"bytes,4,opt,name=balancesType,proto3" json:"balancesType,omitempty"`
	// Metadata for fetching balances for collections with off-chain balances, subject to changes over time.
	OffChainBalancesMetadataTimeline []*OffChainBalancesMetadataTimeline `protobuf:"bytes,5,rep,name=offChainBalancesMetadataTimeline,proto3" json:"offChainBalancesMetadataTimeline,omitempty"`
	// An arbitrary field that can store any data, subject to changes over time.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,7,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// The address of the manager of this collection, subject to changes over time.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,8,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Permissions that define what the manager of the collection can do or not do.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,9,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Transferability of the collection for collections with standard balances, subject to changes over time.
	// Overrides user approvals for a transfer if specified.
	// Transfer must satisfy both user and collection-level approvals.
	// Only applicable to on-chain balances.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,10,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Standards that define how to interpret the fields of the collection, subject to changes over time.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,11,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// Whether the collection is archived or not, subject to changes over time.
	// When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,12,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// The default store of a balance for a user, upon genesis.
	DefaultBalances *UserBalanceStore `protobuf:"bytes,13,opt,name=defaultBalances,proto3" json:"defaultBalances,omitempty"`
	// The user or entity who created the badge collection.
	CreatedBy string `protobuf:"bytes,14,opt,name=createdBy,proto3" json:"createdBy,omitempty"`
	//The generated address of the badge collection.
	AliasAddress string `protobuf:"bytes,15,opt,name=aliasAddress,proto3" json:"aliasAddress,omitempty"`
}

func (m *BadgeCollection) Reset()         { *m = BadgeCollection{} }
func (m *BadgeCollection) String() string { return proto.CompactTextString(m) }
func (*BadgeCollection) ProtoMessage()    {}
func (*BadgeCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{0}
}
func (m *BadgeCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadgeCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BadgeCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BadgeCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadgeCollection.Merge(m, src)
}
func (m *BadgeCollection) XXX_Size() int {
	return m.Size()
}
func (m *BadgeCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_BadgeCollection.DiscardUnknown(m)
}

var xxx_messageInfo_BadgeCollection proto.InternalMessageInfo

func (m *BadgeCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetBadgeMetadataTimeline() []*BadgeMetadataTimeline {
	if m != nil {
		return m.BadgeMetadataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetBalancesType() string {
	if m != nil {
		return m.BalancesType
	}
	return ""
}

func (m *BadgeCollection) GetOffChainBalancesMetadataTimeline() []*OffChainBalancesMetadataTimeline {
	if m != nil {
		return m.OffChainBalancesMetadataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *BadgeCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *BadgeCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *BadgeCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *BadgeCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *BadgeCollection) GetDefaultBalances() *UserBalanceStore {
	if m != nil {
		return m.DefaultBalances
	}
	return nil
}

func (m *BadgeCollection) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *BadgeCollection) GetAliasAddress() string {
	if m != nil {
		return m.AliasAddress
	}
	return ""
}

func init() {
	proto.RegisterType((*BadgeCollection)(nil), "badges.BadgeCollection")
}

func init() { proto.RegisterFile("badges/collections.proto", fileDescriptor_9eac0b7495c54217) }

var fileDescriptor_9eac0b7495c54217 = []byte{
	// 526 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0xcf, 0x6f, 0xd3, 0x30,
	0x14, 0x6e, 0xd8, 0xd8, 0xa8, 0x57, 0xa8, 0x30, 0xbf, 0xbc, 0x8a, 0x65, 0x55, 0x4f, 0x3d, 0x35,
	0x08, 0x0e, 0x9c, 0x9b, 0x22, 0xa1, 0x21, 0x26, 0x90, 0xbb, 0x5d, 0xb8, 0x39, 0xb1, 0x9b, 0x59,
	0x4a, 0xe3, 0xc8, 0x76, 0x27, 0xfa, 0x5f, 0xf0, 0x67, 0xed, 0xb8, 0x23, 0xe2, 0x30, 0xa1, 0xf6,
	0x1f, 0x41, 0x71, 0xe2, 0xa4, 0x6d, 0xc2, 0x76, 0x4b, 0xbe, 0xf7, 0x7d, 0xdf, 0xfb, 0xde, 0xcb,
	0x53, 0x00, 0x0a, 0x08, 0x8d, 0x98, 0xf2, 0x42, 0x11, 0xc7, 0x2c, 0xd4, 0x5c, 0x24, 0x6a, 0x94,
	0x4a, 0xa1, 0x05, 0x3c, 0xc8, 0x2b, 0xbd, 0xe3, 0x48, 0x88, 0x28, 0x66, 0x9e, 0x41, 0x83, 0xc5,
	0xcc, 0x23, 0xc9, 0x32, 0xa7, 0xf4, 0x5e, 0x17, 0x62, 0x2d, 0x49, 0xa2, 0x66, 0x4c, 0x16, 0xd2,
	0xde, 0xab, 0x02, 0x0f, 0x48, 0x4c, 0x92, 0x90, 0x59, 0xd8, 0xf6, 0x4a, 0x99, 0x9c, 0x73, 0xa5,
	0xaa, 0x5e, 0xa5, 0x60, 0xce, 0x34, 0xa1, 0x44, 0x93, 0x5d, 0x7f, 0x3e, 0x67, 0x31, 0x4f, 0x4a,
	0xa3, 0x97, 0x91, 0x88, 0x84, 0x79, 0xf4, 0xb2, 0xa7, 0x1c, 0x1d, 0xac, 0x0f, 0x41, 0xd7, 0xcf,
	0x04, 0x93, 0x72, 0x16, 0xf8, 0x0e, 0x74, 0xaa, 0xc9, 0xce, 0x28, 0x72, 0xfa, 0xce, 0xb0, 0xed,
	0x77, 0x6e, 0xee, 0x4e, 0x5b, 0x7f, 0xee, 0x4e, 0xf7, 0x2f, 0x79, 0xa2, 0xf1, 0x16, 0x03, 0x06,
	0xa0, 0x57, 0xbd, 0x9f, 0x17, 0x79, 0x2e, 0x8a, 0x00, 0xe8, 0x51, 0x7f, 0x6f, 0x78, 0xf4, 0x7e,
	0x30, 0xca, 0x83, 0x8d, 0x26, 0xff, 0x65, 0xe2, 0x7b, 0x5c, 0xe0, 0x14, 0xe4, 0x03, 0xd7, 0xec,
	0xf7, 0x8c, 0xfd, 0x89, 0xb5, 0xf7, 0x9b, 0x48, 0xb8, 0x59, 0x0b, 0x07, 0xa0, 0x63, 0xf7, 0x7d,
	0xb1, 0x4c, 0x19, 0xda, 0xcf, 0x46, 0xc5, 0x5b, 0x18, 0xd4, 0xa0, 0x2f, 0x66, 0xb3, 0xc9, 0x15,
	0xe1, 0x89, 0x5f, 0xe0, 0xb5, 0x0c, 0x8f, 0x4d, 0x86, 0xa1, 0xcd, 0xf0, 0xed, 0x01, 0x3e, 0x7e,
	0xd0, 0x11, 0x7e, 0x01, 0x30, 0x5c, 0x28, 0x2d, 0xe6, 0x9f, 0x36, 0xfb, 0x1c, 0x9a, 0x3e, 0xbd,
	0x72, 0x95, 0x35, 0x06, 0x6e, 0x50, 0xc1, 0x31, 0xe8, 0xce, 0x49, 0x42, 0x22, 0x26, 0x4b, 0xa3,
	0x27, 0xc6, 0xe8, 0x8d, 0x35, 0x3a, 0xdf, 0x2e, 0xe3, 0x5d, 0x7e, 0xb6, 0xfd, 0xea, 0xdb, 0x7c,
	0xaf, 0x6e, 0x11, 0xb5, 0xfb, 0xce, 0xe6, 0xf6, 0x27, 0x4d, 0x24, 0xdc, 0xac, 0x85, 0x5f, 0xc1,
	0x8b, 0xaa, 0x30, 0x4e, 0x53, 0x29, 0xae, 0x49, 0xac, 0x10, 0xd8, 0x19, 0xb2, 0x46, 0xc1, 0x4d,
	0x32, 0xf8, 0x19, 0x3c, 0x57, 0x9a, 0x24, 0x94, 0x48, 0xaa, 0xca, 0x39, 0x8f, 0x8c, 0xd7, 0xb1,
	0xf5, 0x9a, 0xee, 0x12, 0x70, 0x5d, 0x93, 0xad, 0x9e, 0xab, 0xb1, 0x0c, 0xaf, 0xf8, 0x35, 0xa3,
	0xa5, 0x53, 0x67, 0x3b, 0xd5, 0x59, 0x8d, 0x81, 0x1b, 0x54, 0xd0, 0x07, 0x5d, 0xca, 0x66, 0x64,
	0x11, 0x6b, 0xfb, 0xa5, 0xd1, 0x53, 0xb3, 0x31, 0x64, 0x8d, 0x2e, 0x15, 0x93, 0x45, 0x6d, 0xaa,
	0x85, 0x64, 0x78, 0x57, 0x00, 0xdf, 0x82, 0x76, 0x28, 0x19, 0xd1, 0x8c, 0xfa, 0x4b, 0xf4, 0xcc,
	0x5c, 0x68, 0x05, 0x64, 0x27, 0x4c, 0x62, 0x4e, 0xd4, 0x98, 0x52, 0xc9, 0x94, 0x42, 0xdd, 0xfc,
	0x84, 0x37, 0x31, 0xff, 0xe3, 0xcd, 0xca, 0x75, 0x6e, 0x57, 0xae, 0xf3, 0x77, 0xe5, 0x3a, 0xbf,
	0xd6, 0x6e, 0xeb, 0x76, 0xed, 0xb6, 0x7e, 0xaf, 0xdd, 0xd6, 0x8f, 0x93, 0x80, 0xeb, 0x3c, 0x48,
	0x98, 0x9d, 0xa3, 0xf7, 0xd3, 0xb3, 0xbf, 0x8f, 0x65, 0xca, 0x54, 0x70, 0x60, 0xfe, 0x12, 0x1f,
	0xfe, 0x05, 0x00, 0x00, 0xff, 0xff, 0x79, 0x8c, 0x85, 0xdf, 0xf2, 0x04, 0x00, 0x00,
}

func (m *BadgeCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadgeCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadgeCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AliasAddress) > 0 {
		i -= len(m.AliasAddress)
		copy(dAtA[i:], m.AliasAddress)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.AliasAddress)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.CreatedBy) > 0 {
		i -= len(m.CreatedBy)
		copy(dAtA[i:], m.CreatedBy)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CreatedBy)))
		i--
		dAtA[i] = 0x72
	}
	if m.DefaultBalances != nil {
		{
			size, err := m.DefaultBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for iNdEx := len(m.OffChainBalancesMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OffChainBalancesMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BalancesType) > 0 {
		i -= len(m.BalancesType)
		copy(dAtA[i:], m.BalancesType)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.BalancesType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for iNdEx := len(m.BadgeMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintCollections(dAtA []byte, offset int, v uint64) int {
	offset -= sovCollections(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BadgeCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovCollections(uint64(l))
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for _, e := range m.BadgeMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.BalancesType)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for _, e := range m.OffChainBalancesMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.DefaultBalances != nil {
		l = m.DefaultBalances.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.CreatedBy)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.AliasAddress)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func sovCollections(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCollections(x uint64) (n int) {
	return sovCollections(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BadgeCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadgeCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadgeCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeMetadataTimeline = append(m.BadgeMetadataTimeline, &BadgeMetadataTimeline{})
			if err := m.BadgeMetadataTimeline[len(m.BadgeMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalancesType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalancesType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffChainBalancesMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffChainBalancesMetadataTimeline = append(m.OffChainBalancesMetadataTimeline, &OffChainBalancesMetadataTimeline{})
			if err := m.OffChainBalancesMetadataTimeline[len(m.OffChainBalancesMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBalances == nil {
				m.DefaultBalances = &UserBalanceStore{}
			}
			if err := m.DefaultBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AliasAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCollections(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCollections
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCollections
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCollections
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCollections        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCollections          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCollections = fmt.Errorf("proto: unexpected end of group")
)
