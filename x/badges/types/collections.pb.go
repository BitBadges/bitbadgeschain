// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/collections.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A TokenCollection is the top-level object for a collection of tokens.
// It defines everything about the collection, such as the manager, metadata, etc.
//
// All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).
//
// All collections can have a manager who is responsible for managing the collection and can be granted certain admin
// permissions, such as the ability to mint new tokens.
//
// Collections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.
//
// See documentation for more details.
type TokenCollection struct {
	// The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The metadata for the collection itself.
	CollectionMetadata *CollectionMetadata `protobuf:"bytes,2,opt,name=collectionMetadata,proto3" json:"collectionMetadata,omitempty"`
	// The metadata for each token in the collection.
	TokenMetadata []*TokenMetadata `protobuf:"bytes,3,rep,name=tokenMetadata,proto3" json:"tokenMetadata,omitempty"`
	// An arbitrary field that can store any data.
	CustomData string `protobuf:"bytes,4,opt,name=customData,proto3" json:"customData,omitempty"`
	// The address of the manager of this collection.
	Manager string `protobuf:"bytes,5,opt,name=manager,proto3" json:"manager,omitempty"`
	// Permissions that define what the manager of the collection can do or not do.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,6,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Transferability of the collection for collections with standard balances, subject to changes over time.
	// Overrides user approvals for a transfer if specified.
	// Transfer must satisfy both user and collection-level approvals.
	// Only applicable to on-chain balances.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,7,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Standards that define how to interpret the fields of the collection.
	Standards []string `protobuf:"bytes,8,rep,name=standards,proto3" json:"standards,omitempty"`
	// Whether the collection is archived or not.
	// When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
	IsArchived bool `protobuf:"varint,9,opt,name=isArchived,proto3" json:"isArchived,omitempty"`
	// The default store of a balance / approvals for a user, upon genesis.
	DefaultBalances *UserBalanceStore `protobuf:"bytes,10,opt,name=defaultBalances,proto3" json:"defaultBalances,omitempty"`
	// The user or entity who created the collection.
	CreatedBy string `protobuf:"bytes,11,opt,name=createdBy,proto3" json:"createdBy,omitempty"`
	// The valid token IDs for this collection.
	ValidTokenIds []*UintRange `protobuf:"bytes,12,rep,name=validTokenIds,proto3" json:"validTokenIds,omitempty"`
	//The generated address of the collection. Also used to escrow Mint balances.
	MintEscrowAddress string `protobuf:"bytes,13,opt,name=mintEscrowAddress,proto3" json:"mintEscrowAddress,omitempty"`
	// The IBC wrapper (sdk.coin) paths for the collection.
	CosmosCoinWrapperPaths []*CosmosCoinWrapperPath `protobuf:"bytes,14,rep,name=cosmosCoinWrapperPaths,proto3" json:"cosmosCoinWrapperPaths,omitempty"`
	// Collection-level invariants that cannot be broken.
	// These are set upon genesis and cannot be modified.
	Invariants *CollectionInvariants `protobuf:"bytes,15,opt,name=invariants,proto3" json:"invariants,omitempty"`
}

func (m *TokenCollection) Reset()         { *m = TokenCollection{} }
func (m *TokenCollection) String() string { return proto.CompactTextString(m) }
func (*TokenCollection) ProtoMessage()    {}
func (*TokenCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{0}
}
func (m *TokenCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenCollection.Merge(m, src)
}
func (m *TokenCollection) XXX_Size() int {
	return m.Size()
}
func (m *TokenCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenCollection.DiscardUnknown(m)
}

var xxx_messageInfo_TokenCollection proto.InternalMessageInfo

func (m *TokenCollection) GetCollectionMetadata() *CollectionMetadata {
	if m != nil {
		return m.CollectionMetadata
	}
	return nil
}

func (m *TokenCollection) GetTokenMetadata() []*TokenMetadata {
	if m != nil {
		return m.TokenMetadata
	}
	return nil
}

func (m *TokenCollection) GetCustomData() string {
	if m != nil {
		return m.CustomData
	}
	return ""
}

func (m *TokenCollection) GetManager() string {
	if m != nil {
		return m.Manager
	}
	return ""
}

func (m *TokenCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *TokenCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *TokenCollection) GetStandards() []string {
	if m != nil {
		return m.Standards
	}
	return nil
}

func (m *TokenCollection) GetIsArchived() bool {
	if m != nil {
		return m.IsArchived
	}
	return false
}

func (m *TokenCollection) GetDefaultBalances() *UserBalanceStore {
	if m != nil {
		return m.DefaultBalances
	}
	return nil
}

func (m *TokenCollection) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *TokenCollection) GetValidTokenIds() []*UintRange {
	if m != nil {
		return m.ValidTokenIds
	}
	return nil
}

func (m *TokenCollection) GetMintEscrowAddress() string {
	if m != nil {
		return m.MintEscrowAddress
	}
	return ""
}

func (m *TokenCollection) GetCosmosCoinWrapperPaths() []*CosmosCoinWrapperPath {
	if m != nil {
		return m.CosmosCoinWrapperPaths
	}
	return nil
}

func (m *TokenCollection) GetInvariants() *CollectionInvariants {
	if m != nil {
		return m.Invariants
	}
	return nil
}

type CosmosCoinWrapperPath struct {
	// The BitBadges address associated with this wrapper path. Used for routing and identifying the wrapper.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The denomination (denom) to be used for the wrapped coin or the alias denom.
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	// The token balances that correspond to this wrapper path. Defines how much you have to wrap to get x1 of corresponding base level unit.
	Balances []*Balance `protobuf:"bytes,3,rep,name=balances,proto3" json:"balances,omitempty"`
	// The symbol for the wrapped coin (e.g., "BADGE", "NFT"). Used for display purposes. Note that this may not be the default.
	Symbol string `protobuf:"bytes,4,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// Denomination units for the wrapped coin. Defines how the coin can be displayed with different
	// decimal places and symbols (e.g., base unit, display unit). You can specify which is the default display unit (base level or one of these).
	DenomUnits []*DenomUnit `protobuf:"bytes,5,rep,name=denomUnits,proto3" json:"denomUnits,omitempty"`
	// If true, allows this wrapper path to be used with any valid token ID in the collection via an {id} placeholder.
	AllowOverrideWithAnyValidToken bool `protobuf:"varint,6,opt,name=allowOverrideWithAnyValidToken,proto3" json:"allowOverrideWithAnyValidToken,omitempty"`
	// If true, allows tokens to be wrapped into Cosmos SDK coins. When false, this path is just an alias
	AllowCosmosWrapping bool `protobuf:"varint,7,opt,name=allowCosmosWrapping,proto3" json:"allowCosmosWrapping,omitempty"`
}

func (m *CosmosCoinWrapperPath) Reset()         { *m = CosmosCoinWrapperPath{} }
func (m *CosmosCoinWrapperPath) String() string { return proto.CompactTextString(m) }
func (*CosmosCoinWrapperPath) ProtoMessage()    {}
func (*CosmosCoinWrapperPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{1}
}
func (m *CosmosCoinWrapperPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosCoinWrapperPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosCoinWrapperPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosCoinWrapperPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosCoinWrapperPath.Merge(m, src)
}
func (m *CosmosCoinWrapperPath) XXX_Size() int {
	return m.Size()
}
func (m *CosmosCoinWrapperPath) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosCoinWrapperPath.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosCoinWrapperPath proto.InternalMessageInfo

func (m *CosmosCoinWrapperPath) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *CosmosCoinWrapperPath) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetDenomUnits() []*DenomUnit {
	if m != nil {
		return m.DenomUnits
	}
	return nil
}

func (m *CosmosCoinWrapperPath) GetAllowOverrideWithAnyValidToken() bool {
	if m != nil {
		return m.AllowOverrideWithAnyValidToken
	}
	return false
}

func (m *CosmosCoinWrapperPath) GetAllowCosmosWrapping() bool {
	if m != nil {
		return m.AllowCosmosWrapping
	}
	return false
}

type CosmosCoinBackedPath struct {
	// The address associated with this backed path. Used for routing and escrowing IBC tokens.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The IBC denomination of the backing token. This identifies which IBC token backs the badges
	// (e.g., "ibc/..." or "ubadge"). Conversion is Balances[] = sdk.Coins([{ amount: ibcAmount, denom: ibcDenom }])
	IbcDenom string `protobuf:"bytes,2,opt,name=ibcDenom,proto3" json:"ibcDenom,omitempty"`
	// The token balances that correspond to this backed path. Defines which token IDs and amounts
	// are backed by the IBC tokens. Conversion is Balances[] = sdk.Coins([{ amount: ibcAmount, denom: ibcDenom }])
	Balances []*Balance `protobuf:"bytes,3,rep,name=balances,proto3" json:"balances,omitempty"`
	// The amount of IBC tokens that back the tokens. This defines the exchange rate or backing amount
	// for the tokens in this path. Conversion is Balances[] = sdk.Coins([{ amount: ibcAmount, denom: ibcDenom }])
	IbcAmount Uint `protobuf:"bytes,4,opt,name=ibcAmount,proto3,customtype=Uint" json:"ibcAmount"`
}

func (m *CosmosCoinBackedPath) Reset()         { *m = CosmosCoinBackedPath{} }
func (m *CosmosCoinBackedPath) String() string { return proto.CompactTextString(m) }
func (*CosmosCoinBackedPath) ProtoMessage()    {}
func (*CosmosCoinBackedPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{2}
}
func (m *CosmosCoinBackedPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosCoinBackedPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosCoinBackedPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosCoinBackedPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosCoinBackedPath.Merge(m, src)
}
func (m *CosmosCoinBackedPath) XXX_Size() int {
	return m.Size()
}
func (m *CosmosCoinBackedPath) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosCoinBackedPath.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosCoinBackedPath proto.InternalMessageInfo

func (m *CosmosCoinBackedPath) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CosmosCoinBackedPath) GetIbcDenom() string {
	if m != nil {
		return m.IbcDenom
	}
	return ""
}

func (m *CosmosCoinBackedPath) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

type DenomUnit struct {
	// The number of decimal places for this unit. Defines the precision of the unit.
	Decimals Uint `protobuf:"bytes,1,opt,name=decimals,proto3,customtype=Uint" json:"decimals"`
	// The symbol for this unit (e.g., "BADGE", "nBADGE"). Used for display purposes.
	Symbol string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// If true, this is the default display unit. Only one unit should be marked as the default display unit.
	// This unit will be used by default when displaying the coin amount. If none are marked default, we use the base level.
	IsDefaultDisplay bool `protobuf:"varint,3,opt,name=isDefaultDisplay,proto3" json:"isDefaultDisplay,omitempty"`
}

func (m *DenomUnit) Reset()         { *m = DenomUnit{} }
func (m *DenomUnit) String() string { return proto.CompactTextString(m) }
func (*DenomUnit) ProtoMessage()    {}
func (*DenomUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{3}
}
func (m *DenomUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenomUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenomUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenomUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenomUnit.Merge(m, src)
}
func (m *DenomUnit) XXX_Size() int {
	return m.Size()
}
func (m *DenomUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_DenomUnit.DiscardUnknown(m)
}

var xxx_messageInfo_DenomUnit proto.InternalMessageInfo

func (m *DenomUnit) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *DenomUnit) GetIsDefaultDisplay() bool {
	if m != nil {
		return m.IsDefaultDisplay
	}
	return false
}

// CollectionInvariants defines the invariants that apply to a collection.
type CollectionInvariants struct {
	// If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].
	// This prevents time-based restrictions on token ownership.
	NoCustomOwnershipTimes bool `protobuf:"varint,1,opt,name=noCustomOwnershipTimes,proto3" json:"noCustomOwnershipTimes,omitempty"`
	// Maximum supply per token ID. If set, no balance can exceed this amount.
	// This prevents any single token ID from having more than the specified supply.
	MaxSupplyPerId Uint `protobuf:"bytes,2,opt,name=maxSupplyPerId,proto3,customtype=Uint" json:"maxSupplyPerId"`
	// The IBC backed (sdk.coin) path for the collection. Only one path is allowed.
	CosmosCoinBackedPath *CosmosCoinBackedPath `protobuf:"bytes,3,opt,name=cosmosCoinBackedPath,proto3" json:"cosmosCoinBackedPath,omitempty"`
	// If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.
	// This prevents forceful transfers that bypass user-level approvals.
	// This only applies to transfers where the from address does not equal "Mint".
	NoForcefulPostMintTransfers bool `protobuf:"varint,4,opt,name=noForcefulPostMintTransfers,proto3" json:"noForcefulPostMintTransfers,omitempty"`
	// If true, disallows pool creation with this collection's assets.
	// When true, any attempt to create a pool with badges assets from this collection will fail.
	DisablePoolCreation bool `protobuf:"varint,5,opt,name=disablePoolCreation,proto3" json:"disablePoolCreation,omitempty"`
}

func (m *CollectionInvariants) Reset()         { *m = CollectionInvariants{} }
func (m *CollectionInvariants) String() string { return proto.CompactTextString(m) }
func (*CollectionInvariants) ProtoMessage()    {}
func (*CollectionInvariants) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{4}
}
func (m *CollectionInvariants) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionInvariants) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionInvariants.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionInvariants) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionInvariants.Merge(m, src)
}
func (m *CollectionInvariants) XXX_Size() int {
	return m.Size()
}
func (m *CollectionInvariants) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionInvariants.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionInvariants proto.InternalMessageInfo

func (m *CollectionInvariants) GetNoCustomOwnershipTimes() bool {
	if m != nil {
		return m.NoCustomOwnershipTimes
	}
	return false
}

func (m *CollectionInvariants) GetCosmosCoinBackedPath() *CosmosCoinBackedPath {
	if m != nil {
		return m.CosmosCoinBackedPath
	}
	return nil
}

func (m *CollectionInvariants) GetNoForcefulPostMintTransfers() bool {
	if m != nil {
		return m.NoForcefulPostMintTransfers
	}
	return false
}

func (m *CollectionInvariants) GetDisablePoolCreation() bool {
	if m != nil {
		return m.DisablePoolCreation
	}
	return false
}

func init() {
	proto.RegisterType((*TokenCollection)(nil), "badges.TokenCollection")
	proto.RegisterType((*CosmosCoinWrapperPath)(nil), "badges.CosmosCoinWrapperPath")
	proto.RegisterType((*CosmosCoinBackedPath)(nil), "badges.CosmosCoinBackedPath")
	proto.RegisterType((*DenomUnit)(nil), "badges.DenomUnit")
	proto.RegisterType((*CollectionInvariants)(nil), "badges.CollectionInvariants")
}

func init() { proto.RegisterFile("badges/collections.proto", fileDescriptor_9eac0b7495c54217) }

var fileDescriptor_9eac0b7495c54217 = []byte{
	// 909 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xcd, 0x6e, 0x1b, 0xb7,
	0x13, 0xb7, 0xec, 0x58, 0x96, 0xc6, 0x76, 0xfc, 0x0f, 0x63, 0x1b, 0xfc, 0xab, 0xa9, 0x2c, 0xe8,
	0x24, 0xa4, 0x85, 0x95, 0xba, 0x45, 0x7b, 0x68, 0x0f, 0xd5, 0x47, 0x03, 0xb8, 0x48, 0x10, 0x81,
	0xb6, 0x1b, 0xa0, 0x97, 0x80, 0xbb, 0xa4, 0x25, 0x22, 0xbb, 0xe4, 0x82, 0xa4, 0xe4, 0xe8, 0x2d,
	0xfa, 0x12, 0x7d, 0x88, 0x3e, 0x40, 0x81, 0xa0, 0xa7, 0x1c, 0x8b, 0x1e, 0x82, 0xc2, 0x7e, 0x91,
	0x62, 0xb9, 0x5f, 0xfa, 0xd8, 0x34, 0xe8, 0x8d, 0x9c, 0xf9, 0x0d, 0x39, 0xf3, 0xfb, 0x0d, 0x87,
	0x80, 0x3d, 0xca, 0xc6, 0xdc, 0x74, 0x7d, 0x15, 0x04, 0xdc, 0xb7, 0x42, 0x49, 0x73, 0x1a, 0x69,
	0x65, 0x15, 0xaa, 0x26, 0x9e, 0xc6, 0xff, 0xc7, 0x4a, 0x8d, 0x03, 0xde, 0x75, 0x56, 0x6f, 0x7a,
	0xdd, 0xa5, 0x72, 0x9e, 0x40, 0x1a, 0xc7, 0x69, 0xb0, 0xd5, 0x54, 0x9a, 0x6b, 0xae, 0xd3, 0xd0,
	0xc6, 0x51, 0x6a, 0xf7, 0x68, 0x40, 0xa5, 0xcf, 0x33, 0x73, 0x76, 0x57, 0xc4, 0x75, 0x28, 0x8c,
	0x29, 0xee, 0xca, 0x03, 0x42, 0x6e, 0x29, 0xa3, 0x96, 0xae, 0x9c, 0x4f, 0xa3, 0x48, 0xab, 0x19,
	0x0d, 0x32, 0xf8, 0x49, 0x6a, 0x9f, 0x1a, 0xae, 0x5f, 0xa5, 0x97, 0xbc, 0x32, 0x56, 0x69, 0x9e,
	0x02, 0x0e, 0xc7, 0x6a, 0xac, 0xdc, 0xb2, 0x1b, 0xaf, 0x12, 0x6b, 0xfb, 0xf7, 0x2a, 0x1c, 0x5c,
	0xaa, 0xd7, 0x5c, 0x0e, 0xf2, 0x62, 0xd1, 0x13, 0xd8, 0x2b, 0x4a, 0x3f, 0x67, 0xb8, 0xd2, 0xaa,
	0x74, 0xea, 0xfd, 0xbd, 0xb7, 0xef, 0x4f, 0x36, 0xfe, 0x7a, 0x7f, 0x72, 0xef, 0x4a, 0x48, 0x4b,
	0x96, 0x10, 0xe8, 0x47, 0x40, 0xc5, 0xfe, 0x79, 0x9a, 0x30, 0xde, 0x6c, 0x55, 0x3a, 0xbb, 0x67,
	0x8d, 0xd3, 0x24, 0xb3, 0xd3, 0xc1, 0x1a, 0x82, 0x94, 0x44, 0xa1, 0x6f, 0x61, 0xdf, 0xc6, 0x09,
	0xe5, 0xc7, 0x6c, 0xb5, 0xb6, 0x3a, 0xbb, 0x67, 0x47, 0xd9, 0x31, 0x97, 0x8b, 0x4e, 0xb2, 0x8c,
	0x45, 0x4d, 0x00, 0x7f, 0x6a, 0xac, 0x0a, 0x87, 0x71, 0xe4, 0xbd, 0x38, 0x71, 0xb2, 0x60, 0x41,
	0x18, 0x76, 0x42, 0x2a, 0xe9, 0x98, 0x6b, 0xbc, 0xed, 0x9c, 0xd9, 0x16, 0x5d, 0xc0, 0x51, 0x91,
	0xcc, 0xa8, 0x50, 0x03, 0x57, 0x5d, 0x15, 0x9f, 0xae, 0x57, 0xb1, 0x00, 0x22, 0xe5, 0xb1, 0xe8,
	0x19, 0x3c, 0x2c, 0x1c, 0xbd, 0x4c, 0x31, 0xbc, 0xe3, 0x2a, 0x2a, 0x21, 0x26, 0x83, 0x90, 0xb2,
	0x30, 0xf4, 0x08, 0xea, 0xc6, 0x52, 0xc9, 0xa8, 0x66, 0x06, 0xd7, 0x5a, 0x5b, 0x9d, 0x3a, 0x29,
	0x0c, 0x71, 0xe9, 0xc2, 0xf4, 0xb4, 0x3f, 0x11, 0x33, 0xce, 0x70, 0xbd, 0x55, 0xe9, 0xd4, 0xc8,
	0x82, 0x05, 0xf5, 0xe1, 0x80, 0xf1, 0x6b, 0x3a, 0x0d, 0x6c, 0x3f, 0x6d, 0x41, 0x0c, 0xae, 0x34,
	0x9c, 0xe5, 0x71, 0x65, 0xb8, 0x4e, 0x7d, 0x17, 0x71, 0xe3, 0x90, 0xd5, 0x80, 0x38, 0x03, 0x5f,
	0x73, 0x6a, 0x39, 0xeb, 0xcf, 0xf1, 0xae, 0x23, 0xb0, 0x30, 0xa0, 0x6f, 0x60, 0x7f, 0x46, 0x03,
	0xc1, 0x9c, 0x42, 0xe7, 0xcc, 0xe0, 0x3d, 0x57, 0xe7, 0x83, 0xfc, 0xfc, 0xb8, 0x71, 0xa8, 0x1c,
	0x73, 0xb2, 0x8c, 0x43, 0x9f, 0xc3, 0x83, 0x50, 0x48, 0xfb, 0x83, 0xf1, 0xb5, 0xba, 0xe9, 0x31,
	0xa6, 0xb9, 0x31, 0x78, 0xdf, 0x1d, 0xbf, 0xee, 0x40, 0x57, 0x70, 0xec, 0x2b, 0x13, 0x2a, 0x33,
	0x50, 0x42, 0xbe, 0xd4, 0x34, 0x8a, 0xb8, 0x1e, 0x51, 0x3b, 0x31, 0xf8, 0xbe, 0xbb, 0x6f, 0x41,
	0xaa, 0x12, 0x14, 0xf9, 0x40, 0x30, 0xfa, 0x0e, 0x40, 0xc8, 0x19, 0xd5, 0x82, 0x4a, 0x6b, 0xf0,
	0x81, 0xa3, 0xe6, 0xd1, 0xba, 0x44, 0xe7, 0x39, 0x86, 0x2c, 0xe0, 0xdb, 0xbf, 0x6d, 0xc2, 0x51,
	0xe9, 0x7d, 0x71, 0xcb, 0xd1, 0xb4, 0xa4, 0x4a, 0xd2, 0x72, 0xe9, 0x16, 0x1d, 0xc2, 0x36, 0xe3,
	0x52, 0x85, 0xee, 0xa1, 0xd4, 0x49, 0xb2, 0x41, 0x9f, 0x41, 0x2d, 0x9b, 0x11, 0x69, 0xeb, 0x1f,
	0x64, 0x59, 0xa4, 0x3a, 0x90, 0x1c, 0x80, 0x8e, 0xa1, 0x6a, 0xe6, 0xa1, 0xa7, 0x82, 0xb4, 0xd7,
	0xd3, 0x1d, 0xfa, 0x02, 0xc0, 0x9d, 0x76, 0x25, 0x85, 0x35, 0x78, 0x7b, 0x59, 0x87, 0x61, 0xe6,
	0x21, 0x0b, 0x20, 0xf4, 0x14, 0x9a, 0x34, 0x08, 0xd4, 0xcd, 0x8b, 0x19, 0xd7, 0x5a, 0x30, 0xfe,
	0x52, 0xd8, 0x49, 0x4f, 0xce, 0x7f, 0xca, 0x95, 0x72, 0x2f, 0xa1, 0x46, 0x3e, 0x82, 0x42, 0x4f,
	0xe0, 0xa1, 0x43, 0x24, 0x6c, 0x38, 0x26, 0x84, 0x1c, 0xe3, 0x1d, 0x17, 0x5c, 0xe6, 0x6a, 0xff,
	0x5a, 0x81, 0xc3, 0x82, 0xbb, 0x3e, 0xf5, 0x5f, 0x73, 0xf6, 0x11, 0xea, 0x1a, 0x50, 0x13, 0x9e,
	0x3f, 0x5c, 0x60, 0x2f, 0xdf, 0xff, 0x37, 0x02, 0x1f, 0x43, 0x5d, 0x78, 0x7e, 0x2f, 0x54, 0x53,
	0x69, 0x13, 0x0e, 0x57, 0x06, 0x5d, 0xe1, 0x6e, 0xcf, 0xa1, 0x9e, 0x53, 0x87, 0x3a, 0x50, 0x63,
	0xdc, 0x17, 0x61, 0xfc, 0x9e, 0xcb, 0x06, 0x64, 0xee, 0x5d, 0xd0, 0x68, 0x73, 0x49, 0xa3, 0xc7,
	0xf0, 0x3f, 0x61, 0x86, 0xc9, 0x0b, 0x1b, 0x0a, 0x13, 0x05, 0x74, 0x8e, 0xb7, 0x1c, 0x4b, 0x6b,
	0xf6, 0xf6, 0x1f, 0x9b, 0x31, 0x45, 0xeb, 0x3d, 0x88, 0xbe, 0x86, 0x63, 0xa9, 0x06, 0x6e, 0xc0,
	0xbd, 0xb8, 0x91, 0x5c, 0x9b, 0x89, 0x88, 0x2e, 0x45, 0xc8, 0x93, 0xa4, 0x6a, 0xe4, 0x03, 0x5e,
	0xf4, 0x15, 0xdc, 0x0f, 0xe9, 0x9b, 0x8b, 0x69, 0x14, 0x05, 0xf3, 0x11, 0xd7, 0xe7, 0x2c, 0x49,
	0x6e, 0xa5, 0x88, 0x15, 0x0c, 0x1a, 0xc1, 0xa1, 0x5f, 0x22, 0x94, 0x4b, 0x7b, 0xe9, 0xb5, 0xac,
	0x63, 0x48, 0x69, 0x24, 0xfa, 0x1e, 0x3e, 0x91, 0xea, 0xa9, 0xd2, 0x3e, 0xbf, 0x9e, 0x06, 0x23,
	0x65, 0xec, 0x73, 0x21, 0xed, 0x65, 0xf6, 0x77, 0x3a, 0x45, 0x6a, 0xe4, 0xdf, 0x20, 0x71, 0xbf,
	0x31, 0x61, 0xa8, 0x17, 0xf0, 0x91, 0x52, 0xc1, 0x20, 0x9e, 0x46, 0x42, 0x49, 0x37, 0xde, 0x6b,
	0xa4, 0xcc, 0xd5, 0x7f, 0xf6, 0xf6, 0xb6, 0x59, 0x79, 0x77, 0xdb, 0xac, 0xfc, 0x7d, 0xdb, 0xac,
	0xfc, 0x72, 0xd7, 0xdc, 0x78, 0x77, 0xd7, 0xdc, 0xf8, 0xf3, 0xae, 0xb9, 0xf1, 0xf3, 0xd9, 0x58,
	0xd8, 0xc9, 0xd4, 0x3b, 0xf5, 0x55, 0xd8, 0xf5, 0x84, 0xcd, 0xbe, 0xec, 0x6c, 0xe5, 0x4f, 0xa8,
	0x90, 0xdd, 0x37, 0xdd, 0xec, 0x8b, 0x9f, 0x47, 0xdc, 0x78, 0x55, 0xf7, 0x91, 0x7e, 0xf9, 0x4f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x4f, 0x77, 0x6b, 0x46, 0x36, 0x08, 0x00, 0x00,
}

func (m *TokenCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Invariants != nil {
		{
			size, err := m.Invariants.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.CosmosCoinWrapperPaths) > 0 {
		for iNdEx := len(m.CosmosCoinWrapperPaths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CosmosCoinWrapperPaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.MintEscrowAddress) > 0 {
		i -= len(m.MintEscrowAddress)
		copy(dAtA[i:], m.MintEscrowAddress)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.MintEscrowAddress)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ValidTokenIds) > 0 {
		for iNdEx := len(m.ValidTokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidTokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.CreatedBy) > 0 {
		i -= len(m.CreatedBy)
		copy(dAtA[i:], m.CreatedBy)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CreatedBy)))
		i--
		dAtA[i] = 0x5a
	}
	if m.DefaultBalances != nil {
		{
			size, err := m.DefaultBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.IsArchived {
		i--
		if m.IsArchived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.Standards) > 0 {
		for iNdEx := len(m.Standards) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Standards[iNdEx])
			copy(dAtA[i:], m.Standards[iNdEx])
			i = encodeVarintCollections(dAtA, i, uint64(len(m.Standards[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Manager) > 0 {
		i -= len(m.Manager)
		copy(dAtA[i:], m.Manager)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Manager)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenMetadata) > 0 {
		for iNdEx := len(m.TokenMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CollectionMetadata != nil {
		{
			size, err := m.CollectionMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CosmosCoinWrapperPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosCoinWrapperPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosCoinWrapperPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowCosmosWrapping {
		i--
		if m.AllowCosmosWrapping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.AllowOverrideWithAnyValidToken {
		i--
		if m.AllowOverrideWithAnyValidToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.DenomUnits) > 0 {
		for iNdEx := len(m.DenomUnits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DenomUnits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CosmosCoinBackedPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosCoinBackedPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosCoinBackedPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.IbcAmount.Size()
		i -= size
		if _, err := m.IbcAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.IbcDenom) > 0 {
		i -= len(m.IbcDenom)
		copy(dAtA[i:], m.IbcDenom)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.IbcDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DenomUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenomUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenomUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsDefaultDisplay {
		i--
		if m.IsDefaultDisplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Decimals.Size()
		i -= size
		if _, err := m.Decimals.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CollectionInvariants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionInvariants) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionInvariants) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisablePoolCreation {
		i--
		if m.DisablePoolCreation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.NoForcefulPostMintTransfers {
		i--
		if m.NoForcefulPostMintTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CosmosCoinBackedPath != nil {
		{
			size, err := m.CosmosCoinBackedPath.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.MaxSupplyPerId.Size()
		i -= size
		if _, err := m.MaxSupplyPerId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.NoCustomOwnershipTimes {
		i--
		if m.NoCustomOwnershipTimes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCollections(dAtA []byte, offset int, v uint64) int {
	offset -= sovCollections(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TokenCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovCollections(uint64(l))
	if m.CollectionMetadata != nil {
		l = m.CollectionMetadata.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.TokenMetadata) > 0 {
		for _, e := range m.TokenMetadata {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.Standards) > 0 {
		for _, s := range m.Standards {
			l = len(s)
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.IsArchived {
		n += 2
	}
	if m.DefaultBalances != nil {
		l = m.DefaultBalances.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.CreatedBy)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.ValidTokenIds) > 0 {
		for _, e := range m.ValidTokenIds {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.MintEscrowAddress)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.CosmosCoinWrapperPaths) > 0 {
		for _, e := range m.CosmosCoinWrapperPaths {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.Invariants != nil {
		l = m.Invariants.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *CosmosCoinWrapperPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.DenomUnits) > 0 {
		for _, e := range m.DenomUnits {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.AllowOverrideWithAnyValidToken {
		n += 2
	}
	if m.AllowCosmosWrapping {
		n += 2
	}
	return n
}

func (m *CosmosCoinBackedPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.IbcDenom)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = m.IbcAmount.Size()
	n += 1 + l + sovCollections(uint64(l))
	return n
}

func (m *DenomUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Decimals.Size()
	n += 1 + l + sovCollections(uint64(l))
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.IsDefaultDisplay {
		n += 2
	}
	return n
}

func (m *CollectionInvariants) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoCustomOwnershipTimes {
		n += 2
	}
	l = m.MaxSupplyPerId.Size()
	n += 1 + l + sovCollections(uint64(l))
	if m.CosmosCoinBackedPath != nil {
		l = m.CosmosCoinBackedPath.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.NoForcefulPostMintTransfers {
		n += 2
	}
	if m.DisablePoolCreation {
		n += 2
	}
	return n
}

func sovCollections(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCollections(x uint64) (n int) {
	return sovCollections(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TokenCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionMetadata == nil {
				m.CollectionMetadata = &CollectionMetadata{}
			}
			if err := m.CollectionMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenMetadata = append(m.TokenMetadata, &TokenMetadata{})
			if err := m.TokenMetadata[len(m.TokenMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Standards = append(m.Standards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsArchived = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBalances == nil {
				m.DefaultBalances = &UserBalanceStore{}
			}
			if err := m.DefaultBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidTokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidTokenIds = append(m.ValidTokenIds, &UintRange{})
			if err := m.ValidTokenIds[len(m.ValidTokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintEscrowAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintEscrowAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinWrapperPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosCoinWrapperPaths = append(m.CosmosCoinWrapperPaths, &CosmosCoinWrapperPath{})
			if err := m.CosmosCoinWrapperPaths[len(m.CosmosCoinWrapperPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invariants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invariants == nil {
				m.Invariants = &CollectionInvariants{}
			}
			if err := m.Invariants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosCoinWrapperPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosCoinWrapperPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosCoinWrapperPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomUnits = append(m.DenomUnits, &DenomUnit{})
			if err := m.DenomUnits[len(m.DenomUnits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideWithAnyValidToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideWithAnyValidToken = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCosmosWrapping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowCosmosWrapping = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosCoinBackedPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosCoinBackedPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosCoinBackedPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IbcDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IbcAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenomUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenomUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenomUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Decimals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDefaultDisplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDefaultDisplay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionInvariants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionInvariants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionInvariants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCustomOwnershipTimes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoCustomOwnershipTimes = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSupplyPerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSupplyPerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinBackedPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CosmosCoinBackedPath == nil {
				m.CosmosCoinBackedPath = &CosmosCoinBackedPath{}
			}
			if err := m.CosmosCoinBackedPath.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoForcefulPostMintTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoForcefulPostMintTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePoolCreation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePoolCreation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCollections(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCollections
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCollections
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCollections
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCollections        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCollections          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCollections = fmt.Errorf("proto: unexpected end of group")
)
