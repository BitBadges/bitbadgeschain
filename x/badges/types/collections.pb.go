// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/collections.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A BadgeCollection is the top level object for a collection of badges.
// It defines everything about the collection, such as the manager, metadata, etc.
//
// All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. first collection has ID 1).
//
// All collections also have a manager who is responsible for managing the collection.
// They can be granted certain permissions, such as the ability to mint new badges.
//
// Certain fields are timeline-based, which means they may have different values at different block heights.
// We fetch the value according to the current time.
// For example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.
//
// Collections may have different balance types: standard vs off-chain vs inherited. See documentation for differences.
type BadgeCollection struct {
	// The collectionId is the unique identifier for this collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The collection metadata is the metadata for the collection itself.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,2,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// The badge metadata is the metadata for each badge in the collection.
	BadgeMetadataTimeline []*BadgeMetadataTimeline `protobuf:"bytes,3,rep,name=badgeMetadataTimeline,proto3" json:"badgeMetadataTimeline,omitempty"`
	// The balancesType is the type of balances this collection uses (standard, off-chain, or inherited).
	BalancesType string `protobuf:"bytes,4,opt,name=balancesType,proto3" json:"balancesType,omitempty"`
	// The off-chain balances metadata defines where to fetch the balances for collections with off-chain balances.
	OffChainBalancesMetadataTimeline []*OffChainBalancesMetadataTimeline `protobuf:"bytes,5,rep,name=offChainBalancesMetadataTimeline,proto3" json:"offChainBalancesMetadataTimeline,omitempty"`
	// The custom data field is an arbitrary field that can be used to store any data.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,7,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// The manager is the address of the manager of this collection.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,8,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// The permissions define what the manager of the collection can do or not do.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,9,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// The approved transfers defines the transferability of the collection for collections with standard balances.
	// This defines it on a collection-level. All transfers must be explicitly allowed on the collection-level, or else, they will fail.
	//
	// Collection approved transfers can optionally specify to override the user approvals for a transfer (e.g. forcefully revoke a badge).
	// If user approvals are not overriden, then a transfer must also satisfy the From user's approved outgoing transfers and the To user's approved incoming transfers.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,10,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Standards allow us to define a standard for the collection. This lets others know how to interpret the fields of the collection.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,11,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// The isArchivedTimeline defines whether the collection is archived or not.
	// When a collection is archived, it is read-only and no transactions can be processed.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,12,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// The defaultUserOutgoingApprovals defines the default user approved outgoing transfers for an uninitialized user balance.
	// The user can change this value at any time.
	DefaultUserOutgoingApprovals []*UserOutgoingApproval `protobuf:"bytes,14,rep,name=defaultUserOutgoingApprovals,proto3" json:"defaultUserOutgoingApprovals,omitempty"`
	// The defaultUserIncomingApprovals defines the default user approved incoming transfers for an uninitialized user balance.
	// The user can change this value at any time.
	//
	// Ex: Set this to disallow all incoming transfers by default, making the user have to opt-in to receiving the badge.
	DefaultUserIncomingApprovals                     []*UserIncomingApproval `protobuf:"bytes,15,rep,name=defaultUserIncomingApprovals,proto3" json:"defaultUserIncomingApprovals,omitempty"`
	DefaultUserPermissions                           *UserPermissions        `protobuf:"bytes,16,opt,name=defaultUserPermissions,proto3" json:"defaultUserPermissions,omitempty"`
	DefaultAutoApproveSelfInitiatedOutgoingTransfers bool                    `protobuf:"varint,17,opt,name=defaultAutoApproveSelfInitiatedOutgoingTransfers,proto3" json:"defaultAutoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	DefaultAutoApproveSelfInitiatedIncomingTransfers bool                    `protobuf:"varint,18,opt,name=defaultAutoApproveSelfInitiatedIncomingTransfers,proto3" json:"defaultAutoApproveSelfInitiatedIncomingTransfers,omitempty"`
	CreatedBy                                        string                  `protobuf:"bytes,19,opt,name=createdBy,proto3" json:"createdBy,omitempty"`
}

func (m *BadgeCollection) Reset()         { *m = BadgeCollection{} }
func (m *BadgeCollection) String() string { return proto.CompactTextString(m) }
func (*BadgeCollection) ProtoMessage()    {}
func (*BadgeCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{0}
}
func (m *BadgeCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadgeCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BadgeCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BadgeCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadgeCollection.Merge(m, src)
}
func (m *BadgeCollection) XXX_Size() int {
	return m.Size()
}
func (m *BadgeCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_BadgeCollection.DiscardUnknown(m)
}

var xxx_messageInfo_BadgeCollection proto.InternalMessageInfo

func (m *BadgeCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetBadgeMetadataTimeline() []*BadgeMetadataTimeline {
	if m != nil {
		return m.BadgeMetadataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetBalancesType() string {
	if m != nil {
		return m.BalancesType
	}
	return ""
}

func (m *BadgeCollection) GetOffChainBalancesMetadataTimeline() []*OffChainBalancesMetadataTimeline {
	if m != nil {
		return m.OffChainBalancesMetadataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *BadgeCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *BadgeCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *BadgeCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *BadgeCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *BadgeCollection) GetDefaultUserOutgoingApprovals() []*UserOutgoingApproval {
	if m != nil {
		return m.DefaultUserOutgoingApprovals
	}
	return nil
}

func (m *BadgeCollection) GetDefaultUserIncomingApprovals() []*UserIncomingApproval {
	if m != nil {
		return m.DefaultUserIncomingApprovals
	}
	return nil
}

func (m *BadgeCollection) GetDefaultUserPermissions() *UserPermissions {
	if m != nil {
		return m.DefaultUserPermissions
	}
	return nil
}

func (m *BadgeCollection) GetDefaultAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if m != nil {
		return m.DefaultAutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (m *BadgeCollection) GetDefaultAutoApproveSelfInitiatedIncomingTransfers() bool {
	if m != nil {
		return m.DefaultAutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (m *BadgeCollection) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func init() {
	proto.RegisterType((*BadgeCollection)(nil), "bitbadges.bitbadgeschain.badges.BadgeCollection")
}

func init() { proto.RegisterFile("badges/collections.proto", fileDescriptor_9eac0b7495c54217) }

var fileDescriptor_9eac0b7495c54217 = []byte{
	// 621 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x95, 0x4f, 0x4f, 0xdb, 0x3e,
	0x18, 0xc7, 0x9b, 0x1f, 0xfc, 0x36, 0x30, 0xdd, 0x18, 0x66, 0x43, 0x59, 0x85, 0x4a, 0xc5, 0x89,
	0x53, 0x52, 0x81, 0xb6, 0xcb, 0x4e, 0x4d, 0x77, 0xa9, 0x34, 0xc4, 0x64, 0xe0, 0xc2, 0x69, 0x4e,
	0xe2, 0xa4, 0x9e, 0x12, 0x3b, 0x8a, 0x1d, 0xb4, 0x6a, 0xaf, 0x61, 0xd2, 0x2e, 0x7b, 0x4f, 0x1c,
	0x39, 0x4e, 0x3b, 0xa0, 0x09, 0xde, 0xc8, 0x94, 0xff, 0x6d, 0x13, 0x9a, 0x70, 0x33, 0x7e, 0xf2,
	0xfd, 0x7e, 0x1e, 0x7f, 0x1f, 0x53, 0x03, 0xd5, 0xc4, 0xb6, 0x4b, 0x84, 0x6e, 0x71, 0xcf, 0x23,
	0x96, 0xa4, 0x9c, 0x09, 0x2d, 0x08, 0xb9, 0xe4, 0xf0, 0xc0, 0xa4, 0x32, 0x2d, 0x6a, 0xc5, 0xca,
	0x9a, 0x62, 0xca, 0xb4, 0x74, 0xdd, 0x7b, 0xeb, 0x72, 0xee, 0x7a, 0x44, 0x4f, 0x3e, 0x37, 0x23,
	0x47, 0xc7, 0x6c, 0x96, 0x6a, 0x7b, 0x7b, 0x99, 0xab, 0x0c, 0x31, 0x13, 0x0e, 0x09, 0x33, 0xcf,
	0xde, 0x9b, 0x6c, 0xdf, 0xc4, 0x1e, 0x66, 0x16, 0xc9, 0xb7, 0xf3, 0x26, 0x02, 0x12, 0xfa, 0x54,
	0x88, 0xb2, 0x89, 0x42, 0xe0, 0x13, 0x89, 0x6d, 0x2c, 0xf1, 0xb2, 0x3f, 0xf5, 0x89, 0x47, 0x59,
	0x61, 0xf4, 0xda, 0xe5, 0x2e, 0x4f, 0x96, 0x7a, 0xbc, 0x4a, 0x77, 0x0f, 0x7f, 0xbd, 0x00, 0xdb,
	0x46, 0x2c, 0x18, 0x17, 0x87, 0x84, 0x43, 0xd0, 0x2d, 0x8f, 0x3c, 0xb1, 0x55, 0x65, 0xa0, 0x1c,
	0x6d, 0x1a, 0xdd, 0x9b, 0xbb, 0x83, 0xce, 0x9f, 0xbb, 0x83, 0xf5, 0x4b, 0xca, 0x24, 0x5a, 0xf8,
	0x02, 0x7e, 0x07, 0xbd, 0xf2, 0xef, 0xd3, 0xac, 0x9f, 0x8b, 0xac, 0x01, 0xf5, 0xbf, 0xc1, 0xda,
	0xd1, 0xd6, 0xf1, 0x07, 0xad, 0x21, 0x34, 0x6d, 0xfc, 0xa8, 0x05, 0x5a, 0x61, 0x0f, 0x3d, 0x90,
	0x26, 0x51, 0xe1, 0xae, 0x25, 0xdc, 0xf7, 0x8d, 0x5c, 0xa3, 0x4e, 0x8d, 0xea, 0x4d, 0xe1, 0x21,
	0xe8, 0xe6, 0x13, 0xba, 0x98, 0x05, 0x44, 0x5d, 0x8f, 0xc3, 0x41, 0x0b, 0x7b, 0xf0, 0x87, 0x02,
	0x06, 0xdc, 0x71, 0xc6, 0x31, 0xc4, 0xc8, 0x0a, 0x95, 0xee, 0xfe, 0x4f, 0xba, 0x1b, 0x35, 0x76,
	0x77, 0xd6, 0x60, 0x84, 0x1a, 0x51, 0xd0, 0x02, 0xd0, 0x8a, 0x84, 0xe4, 0xfe, 0xc7, 0xf9, 0x06,
	0x9e, 0x27, 0x0d, 0x9c, 0x34, 0x8f, 0xa5, 0x22, 0x45, 0x35, 0x76, 0xf0, 0x0a, 0x6c, 0xfb, 0x98,
	0x61, 0x97, 0x84, 0x05, 0x61, 0x23, 0x21, 0x0c, 0x1b, 0x09, 0xa7, 0x8b, 0x3a, 0xb4, 0x6c, 0x14,
	0x8f, 0xb8, 0xbc, 0x00, 0x9f, 0xcb, 0xff, 0x04, 0x75, 0x73, 0xa0, 0xb4, 0x1a, 0xf1, 0xb8, 0x4e,
	0x8d, 0xea, 0x4d, 0x21, 0x01, 0xbb, 0x65, 0x61, 0x14, 0x04, 0x21, 0xbf, 0xc6, 0x9e, 0x50, 0x41,
	0xdb, 0xbc, 0x2a, 0x5a, 0x54, 0xe7, 0x07, 0xbf, 0x80, 0x1d, 0x21, 0x31, 0xb3, 0x71, 0x68, 0x8b,
	0x22, 0xb2, 0xad, 0x04, 0x72, 0xdc, 0x08, 0x39, 0x5f, 0x56, 0xa2, 0xaa, 0x59, 0x3c, 0x77, 0x2a,
	0x46, 0xa1, 0x35, 0xa5, 0xd7, 0xc4, 0x2e, 0x10, 0xdd, 0x96, 0xe7, 0x98, 0x54, 0xa4, 0xa8, 0xc6,
	0x0e, 0xce, 0xc0, 0xbe, 0x4d, 0x1c, 0x1c, 0x79, 0xf2, 0x52, 0x90, 0xf0, 0x2c, 0x92, 0x2e, 0xa7,
	0xcc, 0x2d, 0x63, 0x7b, 0x99, 0xe0, 0xde, 0x35, 0xe2, 0xea, 0xd4, 0x68, 0xa5, 0xf5, 0x12, 0x7a,
	0xc2, 0x2c, 0xee, 0x2f, 0xa0, 0xb7, 0x9f, 0x80, 0x5e, 0x56, 0xa3, 0x95, 0xd6, 0x70, 0x0a, 0xf6,
	0xe6, 0xea, 0xf3, 0x57, 0xf2, 0x55, 0x72, 0x25, 0x87, 0xad, 0xa0, 0xf3, 0x97, 0xf1, 0x11, 0x3f,
	0xf8, 0x15, 0x0c, 0xb3, 0xca, 0x28, 0x92, 0x3c, 0xed, 0x80, 0x9c, 0x13, 0xcf, 0x99, 0x30, 0x2a,
	0x29, 0x96, 0xc4, 0xce, 0x83, 0xb9, 0xc8, 0x5f, 0x14, 0x75, 0x67, 0xa0, 0x1c, 0x6d, 0xa0, 0x27,
	0xeb, 0x5a, 0xb0, 0xf2, 0x24, 0x4a, 0x16, 0x6c, 0xc5, 0xaa, 0xe8, 0xe0, 0x3e, 0xd8, 0xb4, 0x42,
	0x12, 0xd7, 0x8c, 0x99, 0xba, 0x9b, 0xfc, 0x8a, 0x96, 0x1b, 0xc6, 0xa7, 0x9b, 0xfb, 0xbe, 0x72,
	0x7b, 0xdf, 0x57, 0xfe, 0xde, 0xf7, 0x95, 0x9f, 0x0f, 0xfd, 0xce, 0xed, 0x43, 0xbf, 0xf3, 0xfb,
	0xa1, 0xdf, 0xb9, 0x3a, 0x76, 0xa9, 0x9c, 0x46, 0xa6, 0x66, 0x71, 0x5f, 0x2f, 0x92, 0xd5, 0x17,
	0x33, 0xd6, 0xbf, 0xe9, 0xf9, 0x2b, 0x38, 0x0b, 0x88, 0x30, 0x9f, 0x25, 0x8f, 0xdd, 0xc9, 0xbf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x12, 0x9e, 0xde, 0x7a, 0xd2, 0x07, 0x00, 0x00,
}

func (m *BadgeCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadgeCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadgeCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CreatedBy) > 0 {
		i -= len(m.CreatedBy)
		copy(dAtA[i:], m.CreatedBy)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CreatedBy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.DefaultAutoApproveSelfInitiatedIncomingTransfers {
		i--
		if m.DefaultAutoApproveSelfInitiatedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.DefaultAutoApproveSelfInitiatedOutgoingTransfers {
		i--
		if m.DefaultAutoApproveSelfInitiatedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.DefaultUserPermissions != nil {
		{
			size, err := m.DefaultUserPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.DefaultUserIncomingApprovals) > 0 {
		for iNdEx := len(m.DefaultUserIncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DefaultUserIncomingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.DefaultUserOutgoingApprovals) > 0 {
		for iNdEx := len(m.DefaultUserOutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DefaultUserOutgoingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for iNdEx := len(m.OffChainBalancesMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OffChainBalancesMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BalancesType) > 0 {
		i -= len(m.BalancesType)
		copy(dAtA[i:], m.BalancesType)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.BalancesType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for iNdEx := len(m.BadgeMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintCollections(dAtA []byte, offset int, v uint64) int {
	offset -= sovCollections(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BadgeCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovCollections(uint64(l))
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for _, e := range m.BadgeMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.BalancesType)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for _, e := range m.OffChainBalancesMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.DefaultUserOutgoingApprovals) > 0 {
		for _, e := range m.DefaultUserOutgoingApprovals {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.DefaultUserIncomingApprovals) > 0 {
		for _, e := range m.DefaultUserIncomingApprovals {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.DefaultUserPermissions != nil {
		l = m.DefaultUserPermissions.Size()
		n += 2 + l + sovCollections(uint64(l))
	}
	if m.DefaultAutoApproveSelfInitiatedOutgoingTransfers {
		n += 3
	}
	if m.DefaultAutoApproveSelfInitiatedIncomingTransfers {
		n += 3
	}
	l = len(m.CreatedBy)
	if l > 0 {
		n += 2 + l + sovCollections(uint64(l))
	}
	return n
}

func sovCollections(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCollections(x uint64) (n int) {
	return sovCollections(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BadgeCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadgeCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadgeCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeMetadataTimeline = append(m.BadgeMetadataTimeline, &BadgeMetadataTimeline{})
			if err := m.BadgeMetadataTimeline[len(m.BadgeMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalancesType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalancesType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffChainBalancesMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffChainBalancesMetadataTimeline = append(m.OffChainBalancesMetadataTimeline, &OffChainBalancesMetadataTimeline{})
			if err := m.OffChainBalancesMetadataTimeline[len(m.OffChainBalancesMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultUserOutgoingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultUserOutgoingApprovals = append(m.DefaultUserOutgoingApprovals, &UserOutgoingApproval{})
			if err := m.DefaultUserOutgoingApprovals[len(m.DefaultUserOutgoingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultUserIncomingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultUserIncomingApprovals = append(m.DefaultUserIncomingApprovals, &UserIncomingApproval{})
			if err := m.DefaultUserIncomingApprovals[len(m.DefaultUserIncomingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultUserPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultUserPermissions == nil {
				m.DefaultUserPermissions = &UserPermissions{}
			}
			if err := m.DefaultUserPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultAutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultAutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCollections(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCollections
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCollections
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCollections
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCollections        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCollections          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCollections = fmt.Errorf("proto: unexpected end of group")
)
