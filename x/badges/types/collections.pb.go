// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/collections.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A BadgeCollection is the top-level object for a collection of tokens.
// It defines everything about the collection, such as the manager, metadata, etc.
//
// All collections are identified by a collectionId assigned by the blockchain, which is a uint64 that increments (i.e. the first collection has ID 1).
//
// All collections can have a manager who is responsible for managing the collection and can be granted certain admin
// permissions, such as the ability to mint new tokens.
//
// Certain fields are timeline-based, which means they may have different values at different block heights.
// We fetch the value according to the current time.
// For example, we may set the manager to be Alice from Time1 to Time2, and then set the manager to be Bob from Time2 to Time3.
//
// Collections may have different balance types: standard vs. off-chain - indexed vs. inherited.vs off-chain - non-indexed vs non-public.
//
// See documentation for more details.
type BadgeCollection struct {
	// The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The metadata for the collection itself, which can vary over time.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,2,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// The metadata for each token in the collection, also subject to changes over time.
	BadgeMetadataTimeline []*BadgeMetadataTimeline `protobuf:"bytes,3,rep,name=badgeMetadataTimeline,proto3" json:"badgeMetadataTimeline,omitempty"`
	// The type of balances this collection uses ("Standard", "Off-Chain - Indexed", "Off-Chain - Non-Indexed", or "Non-Public").
	BalancesType string `protobuf:"bytes,4,opt,name=balancesType,proto3" json:"balancesType,omitempty"`
	// Metadata for fetching balances for collections with off-chain balances, subject to changes over time.
	OffChainBalancesMetadataTimeline []*OffChainBalancesMetadataTimeline `protobuf:"bytes,5,rep,name=offChainBalancesMetadataTimeline,proto3" json:"offChainBalancesMetadataTimeline,omitempty"`
	// An arbitrary field that can store any data, subject to changes over time.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,7,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// The address of the manager of this collection, subject to changes over time.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,8,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Permissions that define what the manager of the collection can do or not do.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,9,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Transferability of the collection for collections with standard balances, subject to changes over time.
	// Overrides user approvals for a transfer if specified.
	// Transfer must satisfy both user and collection-level approvals.
	// Only applicable to on-chain balances.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,10,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Standards that define how to interpret the fields of the collection, subject to changes over time.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,11,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// Whether the collection is archived or not, subject to changes over time.
	// When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,12,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// The default store of a balance for a user, upon genesis.
	DefaultBalances *UserBalanceStore `protobuf:"bytes,13,opt,name=defaultBalances,proto3" json:"defaultBalances,omitempty"`
	// The user or entity who created the collection.
	CreatedBy string `protobuf:"bytes,14,opt,name=createdBy,proto3" json:"createdBy,omitempty"`
	// The valid token IDs for this collection.
	ValidBadgeIds []*UintRange `protobuf:"bytes,15,rep,name=validBadgeIds,proto3" json:"validBadgeIds,omitempty"`
	//The generated address of the collection. Also used to escrow Mint balances.
	MintEscrowAddress string `protobuf:"bytes,16,opt,name=mintEscrowAddress,proto3" json:"mintEscrowAddress,omitempty"`
	// The IBC wrapper (sdk.coin) paths for the collection.
	CosmosCoinWrapperPaths []*CosmosCoinWrapperPath `protobuf:"bytes,17,rep,name=cosmosCoinWrapperPaths,proto3" json:"cosmosCoinWrapperPaths,omitempty"`
	// The IBC unwrap paths for the collection.
	IbcUnwrapPaths []*IBCUnwrapPath `protobuf:"bytes,19,rep,name=ibcUnwrapPaths,proto3" json:"ibcUnwrapPaths,omitempty"`
	// Collection-level invariants that cannot be broken.
	// These are set upon genesis and cannot be modified.
	Invariants *CollectionInvariants `protobuf:"bytes,18,opt,name=invariants,proto3" json:"invariants,omitempty"`
}

func (m *BadgeCollection) Reset()         { *m = BadgeCollection{} }
func (m *BadgeCollection) String() string { return proto.CompactTextString(m) }
func (*BadgeCollection) ProtoMessage()    {}
func (*BadgeCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{0}
}
func (m *BadgeCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadgeCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BadgeCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BadgeCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadgeCollection.Merge(m, src)
}
func (m *BadgeCollection) XXX_Size() int {
	return m.Size()
}
func (m *BadgeCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_BadgeCollection.DiscardUnknown(m)
}

var xxx_messageInfo_BadgeCollection proto.InternalMessageInfo

func (m *BadgeCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetBadgeMetadataTimeline() []*BadgeMetadataTimeline {
	if m != nil {
		return m.BadgeMetadataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetBalancesType() string {
	if m != nil {
		return m.BalancesType
	}
	return ""
}

func (m *BadgeCollection) GetOffChainBalancesMetadataTimeline() []*OffChainBalancesMetadataTimeline {
	if m != nil {
		return m.OffChainBalancesMetadataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *BadgeCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *BadgeCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *BadgeCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *BadgeCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *BadgeCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *BadgeCollection) GetDefaultBalances() *UserBalanceStore {
	if m != nil {
		return m.DefaultBalances
	}
	return nil
}

func (m *BadgeCollection) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *BadgeCollection) GetValidBadgeIds() []*UintRange {
	if m != nil {
		return m.ValidBadgeIds
	}
	return nil
}

func (m *BadgeCollection) GetMintEscrowAddress() string {
	if m != nil {
		return m.MintEscrowAddress
	}
	return ""
}

func (m *BadgeCollection) GetCosmosCoinWrapperPaths() []*CosmosCoinWrapperPath {
	if m != nil {
		return m.CosmosCoinWrapperPaths
	}
	return nil
}

func (m *BadgeCollection) GetIbcUnwrapPaths() []*IBCUnwrapPath {
	if m != nil {
		return m.IbcUnwrapPaths
	}
	return nil
}

func (m *BadgeCollection) GetInvariants() *CollectionInvariants {
	if m != nil {
		return m.Invariants
	}
	return nil
}

type CosmosCoinWrapperPath struct {
	Address                        string              `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Denom                          string              `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Balances                       []*Balance          `protobuf:"bytes,3,rep,name=balances,proto3" json:"balances,omitempty"`
	Symbol                         string              `protobuf:"bytes,4,opt,name=symbol,proto3" json:"symbol,omitempty"`
	DenomUnits                     []*DenomUnit        `protobuf:"bytes,5,rep,name=denomUnits,proto3" json:"denomUnits,omitempty"`
	AllowOverrideWithAnyValidToken bool                `protobuf:"varint,6,opt,name=allowOverrideWithAnyValidToken,proto3" json:"allowOverrideWithAnyValidToken,omitempty"`
	AllowCosmosWrapping            bool                `protobuf:"varint,7,opt,name=allowCosmosWrapping,proto3" json:"allowCosmosWrapping,omitempty"`
	DenomSuffixDetails             *DenomSuffixDetails `protobuf:"bytes,8,opt,name=denomSuffixDetails,proto3" json:"denomSuffixDetails,omitempty"`
}

func (m *CosmosCoinWrapperPath) Reset()         { *m = CosmosCoinWrapperPath{} }
func (m *CosmosCoinWrapperPath) String() string { return proto.CompactTextString(m) }
func (*CosmosCoinWrapperPath) ProtoMessage()    {}
func (*CosmosCoinWrapperPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{1}
}
func (m *CosmosCoinWrapperPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosCoinWrapperPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosCoinWrapperPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosCoinWrapperPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosCoinWrapperPath.Merge(m, src)
}
func (m *CosmosCoinWrapperPath) XXX_Size() int {
	return m.Size()
}
func (m *CosmosCoinWrapperPath) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosCoinWrapperPath.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosCoinWrapperPath proto.InternalMessageInfo

func (m *CosmosCoinWrapperPath) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *CosmosCoinWrapperPath) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CosmosCoinWrapperPath) GetDenomUnits() []*DenomUnit {
	if m != nil {
		return m.DenomUnits
	}
	return nil
}

func (m *CosmosCoinWrapperPath) GetAllowOverrideWithAnyValidToken() bool {
	if m != nil {
		return m.AllowOverrideWithAnyValidToken
	}
	return false
}

func (m *CosmosCoinWrapperPath) GetAllowCosmosWrapping() bool {
	if m != nil {
		return m.AllowCosmosWrapping
	}
	return false
}

func (m *CosmosCoinWrapperPath) GetDenomSuffixDetails() *DenomSuffixDetails {
	if m != nil {
		return m.DenomSuffixDetails
	}
	return nil
}

type IBCUnwrapPath struct {
	ChannelId                      string              `protobuf:"bytes,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	PortId                         string              `protobuf:"bytes,2,opt,name=portId,proto3" json:"portId,omitempty"`
	SourceCollectionId             Uint                `protobuf:"bytes,3,opt,name=sourceCollectionId,proto3,customtype=Uint" json:"sourceCollectionId"`
	Denom                          string              `protobuf:"bytes,4,opt,name=denom,proto3" json:"denom,omitempty"`
	AllowOverrideWithAnyValidToken bool                `protobuf:"varint,5,opt,name=allowOverrideWithAnyValidToken,proto3" json:"allowOverrideWithAnyValidToken,omitempty"`
	Balances                       []*Balance          `protobuf:"bytes,6,rep,name=balances,proto3" json:"balances,omitempty"`
	DenomSuffixDetails             *DenomSuffixDetails `protobuf:"bytes,7,opt,name=denomSuffixDetails,proto3" json:"denomSuffixDetails,omitempty"`
}

func (m *IBCUnwrapPath) Reset()         { *m = IBCUnwrapPath{} }
func (m *IBCUnwrapPath) String() string { return proto.CompactTextString(m) }
func (*IBCUnwrapPath) ProtoMessage()    {}
func (*IBCUnwrapPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{2}
}
func (m *IBCUnwrapPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IBCUnwrapPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IBCUnwrapPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IBCUnwrapPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IBCUnwrapPath.Merge(m, src)
}
func (m *IBCUnwrapPath) XXX_Size() int {
	return m.Size()
}
func (m *IBCUnwrapPath) XXX_DiscardUnknown() {
	xxx_messageInfo_IBCUnwrapPath.DiscardUnknown(m)
}

var xxx_messageInfo_IBCUnwrapPath proto.InternalMessageInfo

func (m *IBCUnwrapPath) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *IBCUnwrapPath) GetPortId() string {
	if m != nil {
		return m.PortId
	}
	return ""
}

func (m *IBCUnwrapPath) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *IBCUnwrapPath) GetAllowOverrideWithAnyValidToken() bool {
	if m != nil {
		return m.AllowOverrideWithAnyValidToken
	}
	return false
}

func (m *IBCUnwrapPath) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *IBCUnwrapPath) GetDenomSuffixDetails() *DenomSuffixDetails {
	if m != nil {
		return m.DenomSuffixDetails
	}
	return nil
}

type DenomSuffixDetails struct {
	WithAddress             bool   `protobuf:"varint,1,opt,name=withAddress,proto3" json:"withAddress,omitempty"`
	DestinationCollectionId string `protobuf:"bytes,2,opt,name=destinationCollectionId,proto3" json:"destinationCollectionId,omitempty"`
	DestinationChainId      string `protobuf:"bytes,3,opt,name=destinationChainId,proto3" json:"destinationChainId,omitempty"`
}

func (m *DenomSuffixDetails) Reset()         { *m = DenomSuffixDetails{} }
func (m *DenomSuffixDetails) String() string { return proto.CompactTextString(m) }
func (*DenomSuffixDetails) ProtoMessage()    {}
func (*DenomSuffixDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{3}
}
func (m *DenomSuffixDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenomSuffixDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenomSuffixDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenomSuffixDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenomSuffixDetails.Merge(m, src)
}
func (m *DenomSuffixDetails) XXX_Size() int {
	return m.Size()
}
func (m *DenomSuffixDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_DenomSuffixDetails.DiscardUnknown(m)
}

var xxx_messageInfo_DenomSuffixDetails proto.InternalMessageInfo

func (m *DenomSuffixDetails) GetWithAddress() bool {
	if m != nil {
		return m.WithAddress
	}
	return false
}

func (m *DenomSuffixDetails) GetDestinationCollectionId() string {
	if m != nil {
		return m.DestinationCollectionId
	}
	return ""
}

func (m *DenomSuffixDetails) GetDestinationChainId() string {
	if m != nil {
		return m.DestinationChainId
	}
	return ""
}

type DenomUnit struct {
	Decimals         Uint   `protobuf:"bytes,1,opt,name=decimals,proto3,customtype=Uint" json:"decimals"`
	Symbol           string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`
	IsDefaultDisplay bool   `protobuf:"varint,3,opt,name=isDefaultDisplay,proto3" json:"isDefaultDisplay,omitempty"`
}

func (m *DenomUnit) Reset()         { *m = DenomUnit{} }
func (m *DenomUnit) String() string { return proto.CompactTextString(m) }
func (*DenomUnit) ProtoMessage()    {}
func (*DenomUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{4}
}
func (m *DenomUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenomUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenomUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenomUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenomUnit.Merge(m, src)
}
func (m *DenomUnit) XXX_Size() int {
	return m.Size()
}
func (m *DenomUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_DenomUnit.DiscardUnknown(m)
}

var xxx_messageInfo_DenomUnit proto.InternalMessageInfo

func (m *DenomUnit) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *DenomUnit) GetIsDefaultDisplay() bool {
	if m != nil {
		return m.IsDefaultDisplay
	}
	return false
}

// CollectionInvariants defines the invariants that apply to a collection.
type CollectionInvariants struct {
	// If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].
	// This prevents time-based restrictions on token ownership.
	NoCustomOwnershipTimes bool `protobuf:"varint,1,opt,name=noCustomOwnershipTimes,proto3" json:"noCustomOwnershipTimes,omitempty"`
	// Maximum supply per token ID. If set, no balance can exceed this amount.
	// This prevents any single token ID from having more than the specified supply.
	MaxSupplyPerId Uint `protobuf:"bytes,2,opt,name=maxSupplyPerId,proto3,customtype=Uint" json:"maxSupplyPerId"`
}

func (m *CollectionInvariants) Reset()         { *m = CollectionInvariants{} }
func (m *CollectionInvariants) String() string { return proto.CompactTextString(m) }
func (*CollectionInvariants) ProtoMessage()    {}
func (*CollectionInvariants) Descriptor() ([]byte, []int) {
	return fileDescriptor_9eac0b7495c54217, []int{5}
}
func (m *CollectionInvariants) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionInvariants) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionInvariants.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionInvariants) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionInvariants.Merge(m, src)
}
func (m *CollectionInvariants) XXX_Size() int {
	return m.Size()
}
func (m *CollectionInvariants) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionInvariants.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionInvariants proto.InternalMessageInfo

func (m *CollectionInvariants) GetNoCustomOwnershipTimes() bool {
	if m != nil {
		return m.NoCustomOwnershipTimes
	}
	return false
}

func init() {
	proto.RegisterType((*BadgeCollection)(nil), "badges.BadgeCollection")
	proto.RegisterType((*CosmosCoinWrapperPath)(nil), "badges.CosmosCoinWrapperPath")
	proto.RegisterType((*IBCUnwrapPath)(nil), "badges.IBCUnwrapPath")
	proto.RegisterType((*DenomSuffixDetails)(nil), "badges.DenomSuffixDetails")
	proto.RegisterType((*DenomUnit)(nil), "badges.DenomUnit")
	proto.RegisterType((*CollectionInvariants)(nil), "badges.CollectionInvariants")
}

func init() { proto.RegisterFile("badges/collections.proto", fileDescriptor_9eac0b7495c54217) }

var fileDescriptor_9eac0b7495c54217 = []byte{
	// 1012 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4b, 0x6f, 0x1b, 0x37,
	0x10, 0xb6, 0xfc, 0x94, 0xc7, 0xaf, 0x98, 0x7e, 0x64, 0x23, 0xa4, 0x8a, 0xa0, 0x93, 0xd1, 0x16,
	0x56, 0x9a, 0x16, 0x6d, 0x0f, 0xe9, 0xc1, 0x92, 0xdb, 0x42, 0x45, 0x02, 0x1b, 0x94, 0xd5, 0x00,
	0xbd, 0x51, 0xbb, 0x94, 0x44, 0x74, 0x97, 0x5c, 0x90, 0x94, 0x64, 0xdd, 0xdb, 0x7b, 0x7f, 0x42,
	0x7f, 0x4e, 0x8e, 0x39, 0x16, 0x39, 0x04, 0x85, 0xfd, 0x2f, 0x7a, 0x2a, 0x96, 0xfb, 0xd6, 0xae,
	0xab, 0x22, 0xb7, 0xe5, 0xcc, 0x37, 0x1f, 0x87, 0xdf, 0x0c, 0x87, 0x0b, 0xd6, 0x80, 0x38, 0x23,
	0xaa, 0x5a, 0xb6, 0x70, 0x5d, 0x6a, 0x6b, 0x26, 0xb8, 0x3a, 0xf7, 0xa5, 0xd0, 0x02, 0x6d, 0x86,
	0x9e, 0xda, 0x93, 0x91, 0x10, 0x23, 0x97, 0xb6, 0x8c, 0x75, 0x30, 0x19, 0xb6, 0x08, 0x9f, 0x87,
	0x90, 0xda, 0x69, 0x14, 0xac, 0x25, 0xe1, 0x6a, 0x48, 0x65, 0x14, 0x5a, 0x3b, 0x89, 0xec, 0x03,
	0xe2, 0x12, 0x6e, 0xd3, 0xd8, 0x1c, 0xef, 0xe5, 0x53, 0xe9, 0x31, 0xa5, 0xd2, 0xbd, 0x92, 0x00,
	0x8f, 0x6a, 0xe2, 0x10, 0x4d, 0x16, 0xf9, 0x99, 0x47, 0x5d, 0xc6, 0x13, 0xa2, 0xe3, 0x91, 0x18,
	0x09, 0xf3, 0xd9, 0x0a, 0xbe, 0x42, 0x6b, 0xf3, 0x9f, 0x6d, 0x38, 0x68, 0x07, 0x01, 0x9d, 0xe4,
	0x2c, 0xe8, 0x39, 0xec, 0xa6, 0x27, 0xeb, 0x3a, 0x56, 0xa5, 0x51, 0x39, 0xdb, 0x6e, 0xef, 0xbe,
	0xfd, 0xf0, 0x6c, 0xe5, 0xfd, 0x87, 0x67, 0xeb, 0x7d, 0xc6, 0x35, 0xce, 0x21, 0xd0, 0x00, 0x6a,
	0xe9, 0xfa, 0x75, 0x94, 0xcf, 0x4d, 0x94, 0x80, 0xb5, 0xda, 0x58, 0x3b, 0xdb, 0x79, 0xd1, 0x3c,
	0x0f, 0x13, 0x3b, 0xef, 0x3c, 0x88, 0xc4, 0xff, 0xc1, 0x82, 0x7a, 0x10, 0x1e, 0xb8, 0x40, 0xbf,
	0x66, 0xe8, 0x3f, 0x89, 0xe9, 0xdb, 0x65, 0x20, 0x5c, 0x1e, 0x8b, 0x9a, 0xb0, 0x1b, 0xeb, 0x7d,
	0x33, 0xf7, 0xa9, 0xb5, 0x1e, 0x1c, 0x15, 0xe7, 0x6c, 0x48, 0x43, 0x43, 0x0c, 0x87, 0x9d, 0x31,
	0x61, 0xbc, 0x1d, 0xd9, 0x0b, 0x39, 0x6c, 0x98, 0x1c, 0xce, 0xe2, 0x1c, 0xae, 0x96, 0xe0, 0xf1,
	0x52, 0x46, 0xf4, 0x13, 0x20, 0x7b, 0xa2, 0xb4, 0xf0, 0x2e, 0xb3, 0xfb, 0x6c, 0x99, 0x7d, 0x6a,
	0x89, 0x94, 0x05, 0x04, 0x2e, 0x89, 0x42, 0x17, 0x70, 0xe0, 0x11, 0x4e, 0x46, 0x54, 0x26, 0x44,
	0x55, 0x43, 0xf4, 0x38, 0x26, 0x7a, 0x9d, 0x77, 0xe3, 0x45, 0x7c, 0xa0, 0x7e, 0x5a, 0x9b, 0xeb,
	0xb4, 0x17, 0xad, 0xed, 0x46, 0x25, 0xab, 0x7e, 0xa7, 0x0c, 0x84, 0xcb, 0x63, 0xd1, 0x2b, 0x38,
	0x4a, 0x1d, 0x17, 0xbe, 0x2f, 0xc5, 0x94, 0xb8, 0xca, 0x82, 0x85, 0x43, 0x16, 0x20, 0xb8, 0x2c,
	0x0c, 0xfd, 0x08, 0x87, 0x4a, 0x13, 0xee, 0x10, 0xe9, 0xa8, 0xe4, 0x9c, 0x3b, 0x86, 0xeb, 0x49,
	0xcc, 0xd5, 0x5b, 0x04, 0xe0, 0x62, 0x4c, 0x20, 0x3d, 0x53, 0x17, 0xd2, 0x1e, 0xb3, 0x29, 0x75,
	0x12, 0xa6, 0xdd, 0x7c, 0x56, 0xdd, 0x02, 0x02, 0x97, 0x44, 0xa1, 0x36, 0x1c, 0x38, 0x74, 0x48,
	0x26, 0xae, 0x8e, 0x2b, 0x6d, 0xed, 0x19, 0xc5, 0xac, 0x98, 0xa8, 0xaf, 0xa8, 0x8c, 0x7c, 0x3d,
	0x2d, 0x24, 0xc5, 0x8b, 0x01, 0xe8, 0x29, 0x6c, 0xdb, 0x92, 0x12, 0x4d, 0x9d, 0xf6, 0xdc, 0xda,
	0x37, 0x1d, 0x9a, 0x1a, 0xd0, 0x37, 0xb0, 0x37, 0x25, 0x2e, 0x73, 0x4c, 0xdf, 0x77, 0x1d, 0x65,
	0x1d, 0x98, 0x44, 0x0f, 0x13, 0xfe, 0xe0, 0xba, 0x12, 0x3e, 0xa2, 0x38, 0x8f, 0x43, 0x9f, 0xc3,
	0xa1, 0xc7, 0xb8, 0xfe, 0x5e, 0xd9, 0x52, 0xcc, 0x2e, 0x1c, 0x47, 0x52, 0xa5, 0xac, 0x47, 0x86,
	0xbe, 0xe8, 0x40, 0x7d, 0x38, 0xb5, 0x85, 0xf2, 0x84, 0xea, 0x08, 0xc6, 0xdf, 0x48, 0xe2, 0xfb,
	0x54, 0x5e, 0x13, 0x3d, 0x56, 0xd6, 0x61, 0xfe, 0xfe, 0x75, 0xca, 0x50, 0xf8, 0x81, 0x60, 0xf4,
	0x1d, 0xec, 0xb3, 0x81, 0xdd, 0xe7, 0x33, 0x49, 0xfc, 0x90, 0xee, 0xc8, 0xd0, 0x9d, 0x24, 0x3a,
	0xb7, 0x3b, 0xa9, 0x17, 0x2f, 0x80, 0xd1, 0x4b, 0x00, 0xc6, 0xa7, 0x44, 0x32, 0xc2, 0xb5, 0xb2,
	0x90, 0x51, 0xf6, 0x69, 0xb1, 0x71, 0xba, 0x09, 0x06, 0x67, 0xf0, 0xcd, 0xdf, 0xd7, 0xe0, 0xa4,
	0x34, 0x5d, 0x64, 0xc1, 0x16, 0x89, 0x14, 0x31, 0xd3, 0x0f, 0xc7, 0x4b, 0x74, 0x0c, 0x1b, 0x0e,
	0xe5, 0xc2, 0xb3, 0x56, 0x8d, 0x3d, 0x5c, 0xa0, 0xcf, 0xa0, 0x1a, 0xcf, 0x8c, 0x68, 0x1e, 0x1d,
	0xa4, 0xf3, 0xc8, 0xd8, 0x71, 0x02, 0x40, 0xa7, 0xb0, 0xa9, 0xe6, 0xde, 0x40, 0xb8, 0xd1, 0xb8,
	0x89, 0x56, 0xe8, 0x0b, 0x00, 0xc3, 0xd6, 0xe7, 0x4c, 0xab, 0x68, 0xa4, 0x24, 0x65, 0xbc, 0x8c,
	0x3d, 0x38, 0x03, 0x42, 0x3f, 0x40, 0x9d, 0xb8, 0xae, 0x98, 0x5d, 0x4d, 0xa9, 0x94, 0xcc, 0xa1,
	0x6f, 0x98, 0x1e, 0x5f, 0xf0, 0xf9, 0xcf, 0x41, 0xa1, 0x6f, 0xc4, 0xaf, 0x94, 0x5b, 0x9b, 0x8d,
	0xca, 0x59, 0x15, 0x2f, 0x41, 0xa1, 0xe7, 0x70, 0x64, 0x10, 0xa1, 0x1a, 0x46, 0x09, 0xc6, 0x47,
	0xd6, 0x96, 0x09, 0x2e, 0x73, 0x05, 0x97, 0xc4, 0xe4, 0xd1, 0x9b, 0x0c, 0x87, 0xec, 0xf6, 0x92,
	0x6a, 0xc2, 0x5c, 0x65, 0x55, 0x4d, 0x05, 0x6a, 0xb9, 0xa4, 0x73, 0x08, 0x5c, 0x12, 0xd5, 0x7c,
	0xbf, 0x0a, 0x7b, 0xb9, 0x3a, 0x9b, 0x96, 0x1f, 0x13, 0xce, 0xa9, 0x1b, 0xbf, 0x3f, 0x38, 0x35,
	0x04, 0x02, 0xfa, 0x42, 0xea, 0xae, 0x13, 0x15, 0x21, 0x5a, 0xa1, 0x97, 0x80, 0x94, 0x98, 0x48,
	0x3b, 0xf3, 0x98, 0x75, 0x1d, 0x6b, 0xad, 0xe4, 0xf9, 0x2a, 0xc1, 0xa5, 0x95, 0x5d, 0xcf, 0x56,
	0x76, 0xb9, 0xc2, 0x1b, 0xff, 0x4b, 0xe1, 0x6c, 0x87, 0x6c, 0x2e, 0xeb, 0x90, 0x72, 0x71, 0xb7,
	0x3e, 0x4a, 0xdc, 0x3f, 0x2b, 0x80, 0x8a, 0x50, 0xd4, 0x80, 0x9d, 0x59, 0x90, 0x64, 0xa6, 0xcb,
	0xab, 0x38, 0x6b, 0x42, 0xdf, 0xc2, 0x63, 0x87, 0x2a, 0xcd, 0x38, 0x09, 0x04, 0xca, 0x49, 0x1a,
	0xca, 0xfe, 0x90, 0x1b, 0x9d, 0x07, 0xe9, 0xa7, 0xae, 0xe0, 0x9d, 0x8b, 0xeb, 0x80, 0x4b, 0x3c,
	0xcd, 0x39, 0x6c, 0x27, 0xed, 0x8d, 0xce, 0xa0, 0xea, 0x50, 0x9b, 0x79, 0xc1, 0x4b, 0x50, 0xf6,
	0xe7, 0x91, 0x78, 0x33, 0xf7, 0x68, 0x35, 0x77, 0x8f, 0x3e, 0x85, 0x47, 0x4c, 0x5d, 0x86, 0x43,
	0xf4, 0x92, 0x29, 0xdf, 0x25, 0x73, 0xb3, 0x79, 0x15, 0x17, 0xec, 0xcd, 0xdf, 0x2a, 0x70, 0x5c,
	0x36, 0x27, 0xd0, 0xd7, 0x70, 0xca, 0x45, 0xf8, 0xbe, 0x5e, 0xcd, 0x38, 0x95, 0x6a, 0xcc, 0xfc,
	0x60, 0xaa, 0xc7, 0x52, 0x3d, 0xe0, 0x45, 0x5f, 0xc1, 0xbe, 0x47, 0x6e, 0x7b, 0x13, 0xdf, 0x77,
	0xe7, 0xd7, 0x54, 0xc6, 0x62, 0x2d, 0x1c, 0x62, 0x01, 0xd3, 0x7e, 0xf5, 0xf6, 0xae, 0x5e, 0x79,
	0x77, 0x57, 0xaf, 0xfc, 0x7d, 0x57, 0xaf, 0xfc, 0x71, 0x5f, 0x5f, 0x79, 0x77, 0x5f, 0x5f, 0xf9,
	0xeb, 0xbe, 0xbe, 0xf2, 0xcb, 0x8b, 0x11, 0xd3, 0xe3, 0xc9, 0xe0, 0xdc, 0x16, 0x5e, 0x6b, 0xc0,
	0x74, 0xfc, 0x93, 0x18, 0x7f, 0xd9, 0x81, 0x84, 0xad, 0xdb, 0x56, 0xfc, 0xd3, 0x37, 0xf7, 0xa9,
	0x1a, 0x6c, 0x9a, 0x7f, 0xbb, 0x2f, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x1a, 0x92, 0x29, 0x14,
	0xa8, 0x0a, 0x00, 0x00,
}

func (m *BadgeCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadgeCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadgeCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IbcUnwrapPaths) > 0 {
		for iNdEx := len(m.IbcUnwrapPaths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IbcUnwrapPaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.Invariants != nil {
		{
			size, err := m.Invariants.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.CosmosCoinWrapperPaths) > 0 {
		for iNdEx := len(m.CosmosCoinWrapperPaths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CosmosCoinWrapperPaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.MintEscrowAddress) > 0 {
		i -= len(m.MintEscrowAddress)
		copy(dAtA[i:], m.MintEscrowAddress)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.MintEscrowAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.ValidBadgeIds) > 0 {
		for iNdEx := len(m.ValidBadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidBadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.CreatedBy) > 0 {
		i -= len(m.CreatedBy)
		copy(dAtA[i:], m.CreatedBy)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.CreatedBy)))
		i--
		dAtA[i] = 0x72
	}
	if m.DefaultBalances != nil {
		{
			size, err := m.DefaultBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for iNdEx := len(m.OffChainBalancesMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OffChainBalancesMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BalancesType) > 0 {
		i -= len(m.BalancesType)
		copy(dAtA[i:], m.BalancesType)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.BalancesType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for iNdEx := len(m.BadgeMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CosmosCoinWrapperPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosCoinWrapperPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosCoinWrapperPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DenomSuffixDetails != nil {
		{
			size, err := m.DenomSuffixDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.AllowCosmosWrapping {
		i--
		if m.AllowCosmosWrapping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.AllowOverrideWithAnyValidToken {
		i--
		if m.AllowOverrideWithAnyValidToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.DenomUnits) > 0 {
		for iNdEx := len(m.DenomUnits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DenomUnits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IBCUnwrapPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IBCUnwrapPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IBCUnwrapPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DenomSuffixDetails != nil {
		{
			size, err := m.DenomSuffixDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCollections(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCollections(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.AllowOverrideWithAnyValidToken {
		i--
		if m.AllowOverrideWithAnyValidToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.SourceCollectionId.Size()
		i -= size
		if _, err := m.SourceCollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DenomSuffixDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenomSuffixDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenomSuffixDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DestinationChainId) > 0 {
		i -= len(m.DestinationChainId)
		copy(dAtA[i:], m.DestinationChainId)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.DestinationChainId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DestinationCollectionId) > 0 {
		i -= len(m.DestinationCollectionId)
		copy(dAtA[i:], m.DestinationCollectionId)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.DestinationCollectionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.WithAddress {
		i--
		if m.WithAddress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DenomUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenomUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenomUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsDefaultDisplay {
		i--
		if m.IsDefaultDisplay {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCollections(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Decimals.Size()
		i -= size
		if _, err := m.Decimals.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CollectionInvariants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionInvariants) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionInvariants) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxSupplyPerId.Size()
		i -= size
		if _, err := m.MaxSupplyPerId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCollections(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.NoCustomOwnershipTimes {
		i--
		if m.NoCustomOwnershipTimes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCollections(dAtA []byte, offset int, v uint64) int {
	offset -= sovCollections(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BadgeCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovCollections(uint64(l))
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for _, e := range m.BadgeMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.BalancesType)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for _, e := range m.OffChainBalancesMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.DefaultBalances != nil {
		l = m.DefaultBalances.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.CreatedBy)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.ValidBadgeIds) > 0 {
		for _, e := range m.ValidBadgeIds {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.MintEscrowAddress)
	if l > 0 {
		n += 2 + l + sovCollections(uint64(l))
	}
	if len(m.CosmosCoinWrapperPaths) > 0 {
		for _, e := range m.CosmosCoinWrapperPaths {
			l = e.Size()
			n += 2 + l + sovCollections(uint64(l))
		}
	}
	if m.Invariants != nil {
		l = m.Invariants.Size()
		n += 2 + l + sovCollections(uint64(l))
	}
	if len(m.IbcUnwrapPaths) > 0 {
		for _, e := range m.IbcUnwrapPaths {
			l = e.Size()
			n += 2 + l + sovCollections(uint64(l))
		}
	}
	return n
}

func (m *CosmosCoinWrapperPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if len(m.DenomUnits) > 0 {
		for _, e := range m.DenomUnits {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.AllowOverrideWithAnyValidToken {
		n += 2
	}
	if m.AllowCosmosWrapping {
		n += 2
	}
	if m.DenomSuffixDetails != nil {
		l = m.DenomSuffixDetails.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *IBCUnwrapPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = m.SourceCollectionId.Size()
	n += 1 + l + sovCollections(uint64(l))
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.AllowOverrideWithAnyValidToken {
		n += 2
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovCollections(uint64(l))
		}
	}
	if m.DenomSuffixDetails != nil {
		l = m.DenomSuffixDetails.Size()
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *DenomSuffixDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithAddress {
		n += 2
	}
	l = len(m.DestinationCollectionId)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	l = len(m.DestinationChainId)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	return n
}

func (m *DenomUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Decimals.Size()
	n += 1 + l + sovCollections(uint64(l))
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCollections(uint64(l))
	}
	if m.IsDefaultDisplay {
		n += 2
	}
	return n
}

func (m *CollectionInvariants) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoCustomOwnershipTimes {
		n += 2
	}
	l = m.MaxSupplyPerId.Size()
	n += 1 + l + sovCollections(uint64(l))
	return n
}

func sovCollections(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCollections(x uint64) (n int) {
	return sovCollections(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BadgeCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadgeCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadgeCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeMetadataTimeline = append(m.BadgeMetadataTimeline, &BadgeMetadataTimeline{})
			if err := m.BadgeMetadataTimeline[len(m.BadgeMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalancesType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalancesType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffChainBalancesMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffChainBalancesMetadataTimeline = append(m.OffChainBalancesMetadataTimeline, &OffChainBalancesMetadataTimeline{})
			if err := m.OffChainBalancesMetadataTimeline[len(m.OffChainBalancesMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBalances == nil {
				m.DefaultBalances = &UserBalanceStore{}
			}
			if err := m.DefaultBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidBadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidBadgeIds = append(m.ValidBadgeIds, &UintRange{})
			if err := m.ValidBadgeIds[len(m.ValidBadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintEscrowAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintEscrowAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinWrapperPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosCoinWrapperPaths = append(m.CosmosCoinWrapperPaths, &CosmosCoinWrapperPath{})
			if err := m.CosmosCoinWrapperPaths[len(m.CosmosCoinWrapperPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invariants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invariants == nil {
				m.Invariants = &CollectionInvariants{}
			}
			if err := m.Invariants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcUnwrapPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IbcUnwrapPaths = append(m.IbcUnwrapPaths, &IBCUnwrapPath{})
			if err := m.IbcUnwrapPaths[len(m.IbcUnwrapPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosCoinWrapperPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosCoinWrapperPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosCoinWrapperPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomUnits = append(m.DenomUnits, &DenomUnit{})
			if err := m.DenomUnits[len(m.DenomUnits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideWithAnyValidToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideWithAnyValidToken = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCosmosWrapping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowCosmosWrapping = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomSuffixDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenomSuffixDetails == nil {
				m.DenomSuffixDetails = &DenomSuffixDetails{}
			}
			if err := m.DenomSuffixDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IBCUnwrapPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IBCUnwrapPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IBCUnwrapPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SourceCollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideWithAnyValidToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideWithAnyValidToken = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomSuffixDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenomSuffixDetails == nil {
				m.DenomSuffixDetails = &DenomSuffixDetails{}
			}
			if err := m.DenomSuffixDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenomSuffixDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenomSuffixDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenomSuffixDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithAddress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithAddress = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationCollectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenomUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenomUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenomUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Decimals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDefaultDisplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDefaultDisplay = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionInvariants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionInvariants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionInvariants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCustomOwnershipTimes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoCustomOwnershipTimes = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSupplyPerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollections
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCollections
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSupplyPerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollections(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCollections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCollections(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCollections
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCollections
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCollections
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCollections
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCollections        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCollections          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCollections = fmt.Errorf("proto: unexpected end of group")
)
