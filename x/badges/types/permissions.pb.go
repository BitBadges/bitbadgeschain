// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/permissions.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CollectionPermissions defines the permissions for the collection (i.e., what the manager can and cannot do).
//
// There are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BalancesActionPermission, and CollectionApprovalPermission.
//
// The permission type allows fine-grained access control for each action.
// - ActionPermission: defines when the manager can perform an action.
// - TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.
// - TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.
// - BalancesActionPermission: defines when the manager can perform an action for specific badges and specific badge ownership times.
// - CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs. locked.
//
// Note there are a few different times here which could get confusing:
// - timelineTimes: the times when a timeline-based field is a specific value
// - permitted/forbiddenTimes - the times that a permission can be performed
// - transferTimes - the times that a transfer occurs
// - ownershipTimes - the times when a badge is owned by a user
//
// The permitted/forbiddenTimes are used to determine when a permission can be executed.
// Once a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.
// If a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.
//
// IMPORTANT: We take first-match only for the permissions. This means that if you forbid time T in array index 0 and permit time T in index 1,
// we will only check the first permission (forbid time T) and not the second permission (permit time T).
type CollectionPermissions struct {
	// Permissions related to deleting the collection.
	CanDeleteCollection []*ActionPermission `protobuf:"bytes,1,rep,name=canDeleteCollection,proto3" json:"canDeleteCollection,omitempty"`
	// Permissions related to archiving the collection.
	CanArchiveCollection []*TimedUpdatePermission `protobuf:"bytes,2,rep,name=canArchiveCollection,proto3" json:"canArchiveCollection,omitempty"`
	// Permissions related to updating off-chain balances metadata.
	CanUpdateOffChainBalancesMetadata []*TimedUpdatePermission `protobuf:"bytes,3,rep,name=canUpdateOffChainBalancesMetadata,proto3" json:"canUpdateOffChainBalancesMetadata,omitempty"`
	// Permissions related to updating standards for the collection.
	CanUpdateStandards []*TimedUpdatePermission `protobuf:"bytes,4,rep,name=canUpdateStandards,proto3" json:"canUpdateStandards,omitempty"`
	// Permissions related to updating custom data for the collection.
	CanUpdateCustomData []*TimedUpdatePermission `protobuf:"bytes,5,rep,name=canUpdateCustomData,proto3" json:"canUpdateCustomData,omitempty"`
	// Permissions related to updating the collection's manager.
	CanUpdateManager []*TimedUpdatePermission `protobuf:"bytes,6,rep,name=canUpdateManager,proto3" json:"canUpdateManager,omitempty"`
	// Permissions related to updating the metadata of the collection.
	CanUpdateCollectionMetadata []*TimedUpdatePermission `protobuf:"bytes,7,rep,name=canUpdateCollectionMetadata,proto3" json:"canUpdateCollectionMetadata,omitempty"`
	// Permissions related to creating more badges for the collection.
	CanCreateMoreBadges []*BalancesActionPermission `protobuf:"bytes,8,rep,name=canCreateMoreBadges,proto3" json:"canCreateMoreBadges,omitempty"`
	// Permissions related to updating badge metadata for specific badges.
	CanUpdateBadgeMetadata []*TimedUpdateWithBadgeIdsPermission `protobuf:"bytes,9,rep,name=canUpdateBadgeMetadata,proto3" json:"canUpdateBadgeMetadata,omitempty"`
	// Permissions related to updating collection approvals.
	CanUpdateCollectionApprovals []*CollectionApprovalPermission `protobuf:"bytes,10,rep,name=canUpdateCollectionApprovals,proto3" json:"canUpdateCollectionApprovals,omitempty"`
}

func (m *CollectionPermissions) Reset()         { *m = CollectionPermissions{} }
func (m *CollectionPermissions) String() string { return proto.CompactTextString(m) }
func (*CollectionPermissions) ProtoMessage()    {}
func (*CollectionPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{0}
}
func (m *CollectionPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionPermissions.Merge(m, src)
}
func (m *CollectionPermissions) XXX_Size() int {
	return m.Size()
}
func (m *CollectionPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionPermissions proto.InternalMessageInfo

func (m *CollectionPermissions) GetCanDeleteCollection() []*ActionPermission {
	if m != nil {
		return m.CanDeleteCollection
	}
	return nil
}

func (m *CollectionPermissions) GetCanArchiveCollection() []*TimedUpdatePermission {
	if m != nil {
		return m.CanArchiveCollection
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateOffChainBalancesMetadata() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateOffChainBalancesMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateStandards() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateStandards
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCustomData() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCustomData
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateManager() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateManager
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCollectionMetadata() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCollectionMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanCreateMoreBadges() []*BalancesActionPermission {
	if m != nil {
		return m.CanCreateMoreBadges
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateBadgeMetadata() []*TimedUpdateWithBadgeIdsPermission {
	if m != nil {
		return m.CanUpdateBadgeMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCollectionApprovals() []*CollectionApprovalPermission {
	if m != nil {
		return m.CanUpdateCollectionApprovals
	}
	return nil
}

// UserPermissions defines the permissions for the user about their approvals (i.e., what the user can and cannot do).
//
// See CollectionPermissions for more details on the different types of permissions.
//
// canUpdateOutgoingApprovals and canUpdateOutgoingApprovals follow the same as the canUpdateCollectionApprovals in CollectionPermissions,
// but certain fields are removed because they are not relevant to the user.
type UserPermissions struct {
	// Permissions related to updating the user's approved outgoing transfers.
	CanUpdateOutgoingApprovals []*UserOutgoingApprovalPermission `protobuf:"bytes,1,rep,name=canUpdateOutgoingApprovals,proto3" json:"canUpdateOutgoingApprovals,omitempty"`
	// Permissions related to updating the user's approved incoming transfers.
	CanUpdateIncomingApprovals []*UserIncomingApprovalPermission `protobuf:"bytes,2,rep,name=canUpdateIncomingApprovals,proto3" json:"canUpdateIncomingApprovals,omitempty"`
	// Permissions related to updating auto-approval settings for self-initiated outgoing transfers (whether they are allowed by default).
	CanUpdateAutoApproveSelfInitiatedOutgoingTransfers []*ActionPermission `protobuf:"bytes,3,rep,name=canUpdateAutoApproveSelfInitiatedOutgoingTransfers,proto3" json:"canUpdateAutoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Permissions related to updating auto-approval settings for self-initiated incoming transfers (whether they are allowed by default).
	CanUpdateAutoApproveSelfInitiatedIncomingTransfers []*ActionPermission `protobuf:"bytes,4,rep,name=canUpdateAutoApproveSelfInitiatedIncomingTransfers,proto3" json:"canUpdateAutoApproveSelfInitiatedIncomingTransfers,omitempty"`
}

func (m *UserPermissions) Reset()         { *m = UserPermissions{} }
func (m *UserPermissions) String() string { return proto.CompactTextString(m) }
func (*UserPermissions) ProtoMessage()    {}
func (*UserPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{1}
}
func (m *UserPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPermissions.Merge(m, src)
}
func (m *UserPermissions) XXX_Size() int {
	return m.Size()
}
func (m *UserPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_UserPermissions proto.InternalMessageInfo

func (m *UserPermissions) GetCanUpdateOutgoingApprovals() []*UserOutgoingApprovalPermission {
	if m != nil {
		return m.CanUpdateOutgoingApprovals
	}
	return nil
}

func (m *UserPermissions) GetCanUpdateIncomingApprovals() []*UserIncomingApprovalPermission {
	if m != nil {
		return m.CanUpdateIncomingApprovals
	}
	return nil
}

func (m *UserPermissions) GetCanUpdateAutoApproveSelfInitiatedOutgoingTransfers() []*ActionPermission {
	if m != nil {
		return m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers
	}
	return nil
}

func (m *UserPermissions) GetCanUpdateAutoApproveSelfInitiatedIncomingTransfers() []*ActionPermission {
	if m != nil {
		return m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers
	}
	return nil
}

// CollectionApprovalPermission defines what collection approved transfers can be updated vs. are locked.
//
// Each transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.
// For a transfer to match, we need to match ALL of the fields in the combination.
// These are determined by the fromMappingId, toMappingId, initiatedByMappingId, transferTimes, badgeIds fields.
// AddressMappings are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressMappings).
//
// TimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?
// permitted/forbidden TimelineTimes: when can the manager execute this permission?
//
// Ex: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", 10, 1000).
// We would check to find the FIRST CollectionApprovalPermission that matches this combination.
// If we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).
//
// Ex: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set
// the combination ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", "All Transfer Times", 1) to always be forbidden at all timelineTimes.
type CollectionApprovalPermission struct {
	// Identifier for the sender mapping.
	FromMappingId string `protobuf:"bytes,1,opt,name=fromMappingId,proto3" json:"fromMappingId,omitempty"`
	// Identifier for the recipient mapping.
	ToMappingId string `protobuf:"bytes,2,opt,name=toMappingId,proto3" json:"toMappingId,omitempty"`
	// Identifier for the initiator mapping (who is approved?).
	InitiatedByMappingId string `protobuf:"bytes,3,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	// Specifies the times when the transfer can occur.
	TransferTimes []*UintRange `protobuf:"bytes,4,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// Specifies the badge IDs involved in the transfer.
	BadgeIds []*UintRange `protobuf:"bytes,5,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// Specifies the ownership times for the badges in the transfer.
	OwnershipTimes []*UintRange `protobuf:"bytes,6,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// Identifier for the amountTrackerId. You can use "All" or "!trackerId" for shorthand.
	// If you use "All", this approval will match to all amountTrackerIds.
	// If you use "!trackerId", this approval will match to all amountTrackerIds except for trackerId.
	// If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
	AmountTrackerId string `protobuf:"bytes,7,opt,name=amountTrackerId,proto3" json:"amountTrackerId,omitempty"`
	// Identifier for the challengeTrackerId. You can use "All" or "!trackerId" for shorthand.
	// If you use "All", this approval will match to all challengeTrackerIds.
	// If you use "!trackerId", this approval will match to all challengeTrackerIds except for trackerId.
	// If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
	ChallengeTrackerId string `protobuf:"bytes,8,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	// Specifies the times when this permission is permitted. Can not overlap with forbiddenTimes.
	PermittedTimes []*UintRange `protobuf:"bytes,9,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permittedTimes.
	ForbiddenTimes []*UintRange `protobuf:"bytes,10,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *CollectionApprovalPermission) Reset()         { *m = CollectionApprovalPermission{} }
func (m *CollectionApprovalPermission) String() string { return proto.CompactTextString(m) }
func (*CollectionApprovalPermission) ProtoMessage()    {}
func (*CollectionApprovalPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{2}
}
func (m *CollectionApprovalPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApprovalPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApprovalPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApprovalPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApprovalPermission.Merge(m, src)
}
func (m *CollectionApprovalPermission) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApprovalPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApprovalPermission.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApprovalPermission proto.InternalMessageInfo

func (m *CollectionApprovalPermission) GetFromMappingId() string {
	if m != nil {
		return m.FromMappingId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetToMappingId() string {
	if m != nil {
		return m.ToMappingId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *CollectionApprovalPermission) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *CollectionApprovalPermission) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *CollectionApprovalPermission) GetAmountTrackerId() string {
	if m != nil {
		return m.AmountTrackerId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *CollectionApprovalPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

// UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.
type UserOutgoingApprovalPermission struct {
	// Identifier for the recipient mapping.
	ToMappingId string `protobuf:"bytes,1,opt,name=toMappingId,proto3" json:"toMappingId,omitempty"`
	// Identifier for the initiator mapping (who is approved?).
	InitiatedByMappingId string `protobuf:"bytes,2,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	// Specifies the times when the transfer can occur.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// Specifies the badge IDs involved in the transfer.
	BadgeIds []*UintRange `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// Specifies the ownership times for the badges in the transfer.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// Identifier for the amountTrackerId. You can use "All" or "!trackerId" for shorthand.
	// If you use "All", this approval will match to all amountTrackerIds.
	// If you use "!trackerId", this approval will match to all amountTrackerIds except for trackerId.
	// If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
	AmountTrackerId string `protobuf:"bytes,6,opt,name=amountTrackerId,proto3" json:"amountTrackerId,omitempty"`
	// Identifier for the challengeTrackerId. You can use "All" or "!trackerId" for shorthand.
	// If you use "All", this approval will match to all challengeTrackerIds.
	// If you use "!trackerId", this approval will match to all challengeTrackerIds except for trackerId.
	// If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
	ChallengeTrackerId string `protobuf:"bytes,7,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	// Specifies the times when this permission is permitted. Can not overlap with forbiddenTimes.
	PermittedTimes []*UintRange `protobuf:"bytes,8,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permittedTimes.
	ForbiddenTimes []*UintRange `protobuf:"bytes,9,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *UserOutgoingApprovalPermission) Reset()         { *m = UserOutgoingApprovalPermission{} }
func (m *UserOutgoingApprovalPermission) String() string { return proto.CompactTextString(m) }
func (*UserOutgoingApprovalPermission) ProtoMessage()    {}
func (*UserOutgoingApprovalPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{3}
}
func (m *UserOutgoingApprovalPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserOutgoingApprovalPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserOutgoingApprovalPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserOutgoingApprovalPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserOutgoingApprovalPermission.Merge(m, src)
}
func (m *UserOutgoingApprovalPermission) XXX_Size() int {
	return m.Size()
}
func (m *UserOutgoingApprovalPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_UserOutgoingApprovalPermission.DiscardUnknown(m)
}

var xxx_messageInfo_UserOutgoingApprovalPermission proto.InternalMessageInfo

func (m *UserOutgoingApprovalPermission) GetToMappingId() string {
	if m != nil {
		return m.ToMappingId
	}
	return ""
}

func (m *UserOutgoingApprovalPermission) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *UserOutgoingApprovalPermission) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetAmountTrackerId() string {
	if m != nil {
		return m.AmountTrackerId
	}
	return ""
}

func (m *UserOutgoingApprovalPermission) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *UserOutgoingApprovalPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

// UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.
//
// See CollectionApprovalPermission for more details. This is equivalent without the toMappingId field because that is always the user.
type UserIncomingApprovalPermission struct {
	// Identifier for the sender mapping.
	FromMappingId string `protobuf:"bytes,1,opt,name=fromMappingId,proto3" json:"fromMappingId,omitempty"`
	// Identifier for the initiator mapping (who is approved?).
	InitiatedByMappingId string `protobuf:"bytes,2,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	// Specifies the times when the transfer can occur.
	TransferTimes []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	// Specifies the badge IDs involved in the transfer.
	BadgeIds []*UintRange `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// Specifies the ownership times for the badges in the transfer.
	OwnershipTimes []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// Identifier for the amountTrackerId. You can use "All" or "!trackerId" for shorthand.
	// If you use "All", this approval will match to all amountTrackerIds.
	// If you use "!trackerId", this approval will match to all amountTrackerIds except for trackerId.
	// If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
	AmountTrackerId string `protobuf:"bytes,6,opt,name=amountTrackerId,proto3" json:"amountTrackerId,omitempty"`
	// Identifier for the challengeTrackerId. You can use "All" or "!trackerId" for shorthand.
	// If you use "All", this approval will match to all challengeTrackerIds.
	// If you use "!trackerId", this approval will match to all challengeTrackerIds except for trackerId.
	// If you use "trackerId", this approval will match to only the specified trackerId and fail on all others.
	ChallengeTrackerId string `protobuf:"bytes,7,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	// Specifies the times when this permission is permitted. Can not overlap with forbiddenTimes.
	PermittedTimes []*UintRange `protobuf:"bytes,8,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permittedTimes.
	ForbiddenTimes []*UintRange `protobuf:"bytes,9,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *UserIncomingApprovalPermission) Reset()         { *m = UserIncomingApprovalPermission{} }
func (m *UserIncomingApprovalPermission) String() string { return proto.CompactTextString(m) }
func (*UserIncomingApprovalPermission) ProtoMessage()    {}
func (*UserIncomingApprovalPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{4}
}
func (m *UserIncomingApprovalPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserIncomingApprovalPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserIncomingApprovalPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserIncomingApprovalPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserIncomingApprovalPermission.Merge(m, src)
}
func (m *UserIncomingApprovalPermission) XXX_Size() int {
	return m.Size()
}
func (m *UserIncomingApprovalPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_UserIncomingApprovalPermission.DiscardUnknown(m)
}

var xxx_messageInfo_UserIncomingApprovalPermission proto.InternalMessageInfo

func (m *UserIncomingApprovalPermission) GetFromMappingId() string {
	if m != nil {
		return m.FromMappingId
	}
	return ""
}

func (m *UserIncomingApprovalPermission) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *UserIncomingApprovalPermission) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetAmountTrackerId() string {
	if m != nil {
		return m.AmountTrackerId
	}
	return ""
}

func (m *UserIncomingApprovalPermission) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *UserIncomingApprovalPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

// BalancesActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.
// Currently, this is only used for creating new badges.
//
// Ex: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021,
// you could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
type BalancesActionPermission struct {
	// Specifies the badge IDs involved in the transfer.
	BadgeIds []*UintRange `protobuf:"bytes,1,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// Specifies the ownership times for the badges in the transfer.
	OwnershipTimes []*UintRange `protobuf:"bytes,2,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	// Specifies the times when this permission is permitted. Can not overlap with forbiddenTimes.
	PermittedTimes []*UintRange `protobuf:"bytes,3,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permittedTimes.
	ForbiddenTimes []*UintRange `protobuf:"bytes,4,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *BalancesActionPermission) Reset()         { *m = BalancesActionPermission{} }
func (m *BalancesActionPermission) String() string { return proto.CompactTextString(m) }
func (*BalancesActionPermission) ProtoMessage()    {}
func (*BalancesActionPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{5}
}
func (m *BalancesActionPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BalancesActionPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BalancesActionPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BalancesActionPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BalancesActionPermission.Merge(m, src)
}
func (m *BalancesActionPermission) XXX_Size() int {
	return m.Size()
}
func (m *BalancesActionPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_BalancesActionPermission.DiscardUnknown(m)
}

var xxx_messageInfo_BalancesActionPermission proto.InternalMessageInfo

func (m *BalancesActionPermission) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *BalancesActionPermission) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *BalancesActionPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *BalancesActionPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

// ActionPermission defines the permissions for performing an action.
//
// This is simple and straightforward as the only thing we need to check is the permitted/forbidden times.
type ActionPermission struct {
	// Specifies the times when this permission is permitted. Can not overlap with forbiddenTimes.
	PermittedTimes []*UintRange `protobuf:"bytes,1,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permittedTimes.
	ForbiddenTimes []*UintRange `protobuf:"bytes,2,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *ActionPermission) Reset()         { *m = ActionPermission{} }
func (m *ActionPermission) String() string { return proto.CompactTextString(m) }
func (*ActionPermission) ProtoMessage()    {}
func (*ActionPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{6}
}
func (m *ActionPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionPermission.Merge(m, src)
}
func (m *ActionPermission) XXX_Size() int {
	return m.Size()
}
func (m *ActionPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionPermission.DiscardUnknown(m)
}

var xxx_messageInfo_ActionPermission proto.InternalMessageInfo

func (m *ActionPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *ActionPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

// TimedUpdatePermission defines the permissions for updating a timeline-based field.
//
// Ex: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,
// you could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
type TimedUpdatePermission struct {
	// Specifies the times when this permission is permitted. Can not overlap with forbiddenTimes.
	PermittedTimes []*UintRange `protobuf:"bytes,1,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permittedTimes.
	ForbiddenTimes []*UintRange `protobuf:"bytes,2,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
	// Specifies the times when the timeline-based field is a specific value.
	TimelineTimes []*UintRange `protobuf:"bytes,3,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
}

func (m *TimedUpdatePermission) Reset()         { *m = TimedUpdatePermission{} }
func (m *TimedUpdatePermission) String() string { return proto.CompactTextString(m) }
func (*TimedUpdatePermission) ProtoMessage()    {}
func (*TimedUpdatePermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{7}
}
func (m *TimedUpdatePermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdatePermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdatePermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdatePermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdatePermission.Merge(m, src)
}
func (m *TimedUpdatePermission) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdatePermission) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdatePermission.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdatePermission proto.InternalMessageInfo

func (m *TimedUpdatePermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *TimedUpdatePermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

func (m *TimedUpdatePermission) GetTimelineTimes() []*UintRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

// TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.
//
// Ex: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,
// you could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
type TimedUpdateWithBadgeIdsPermission struct {
	// Specifies the badge IDs involved in the transfer.
	BadgeIds []*UintRange `protobuf:"bytes,1,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	// Specifies the times when this permission is permitted. Can not overlap with forbiddenTimes.
	PermittedTimes []*UintRange `protobuf:"bytes,2,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	// Specifies the times when this permission is forbidden. Can not overlap with permittedTimes.
	ForbiddenTimes []*UintRange `protobuf:"bytes,3,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
	// Specifies the times when the timeline-based field is a specific value.
	TimelineTimes []*UintRange `protobuf:"bytes,4,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
}

func (m *TimedUpdateWithBadgeIdsPermission) Reset()         { *m = TimedUpdateWithBadgeIdsPermission{} }
func (m *TimedUpdateWithBadgeIdsPermission) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateWithBadgeIdsPermission) ProtoMessage()    {}
func (*TimedUpdateWithBadgeIdsPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{8}
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.Merge(m, src)
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateWithBadgeIdsPermission proto.InternalMessageInfo

func (m *TimedUpdateWithBadgeIdsPermission) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetTimelineTimes() []*UintRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

func init() {
	proto.RegisterType((*CollectionPermissions)(nil), "badges.CollectionPermissions")
	proto.RegisterType((*UserPermissions)(nil), "badges.UserPermissions")
	proto.RegisterType((*CollectionApprovalPermission)(nil), "badges.CollectionApprovalPermission")
	proto.RegisterType((*UserOutgoingApprovalPermission)(nil), "badges.UserOutgoingApprovalPermission")
	proto.RegisterType((*UserIncomingApprovalPermission)(nil), "badges.UserIncomingApprovalPermission")
	proto.RegisterType((*BalancesActionPermission)(nil), "badges.BalancesActionPermission")
	proto.RegisterType((*ActionPermission)(nil), "badges.ActionPermission")
	proto.RegisterType((*TimedUpdatePermission)(nil), "badges.TimedUpdatePermission")
	proto.RegisterType((*TimedUpdateWithBadgeIdsPermission)(nil), "badges.TimedUpdateWithBadgeIdsPermission")
}

func init() { proto.RegisterFile("badges/permissions.proto", fileDescriptor_1298419e4a97cfe6) }

var fileDescriptor_1298419e4a97cfe6 = []byte{
	// 882 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xbf, 0x8f, 0xe3, 0x44,
	0x14, 0x5e, 0xdb, 0xb9, 0xfc, 0x98, 0xd3, 0x71, 0xc7, 0xb0, 0x8b, 0x4c, 0xb8, 0x8b, 0x72, 0xd1,
	0x09, 0x2d, 0x05, 0x89, 0x14, 0x0a, 0x44, 0x99, 0xe4, 0x9a, 0x20, 0xa2, 0x83, 0xdc, 0x9e, 0x90,
	0x68, 0x4e, 0x63, 0x7b, 0xec, 0x8c, 0xce, 0x9e, 0xb1, 0xc6, 0x93, 0x83, 0x2d, 0xe9, 0xae, 0x41,
	0xda, 0xbf, 0x0a, 0x51, 0x6e, 0x49, 0x89, 0x76, 0x2b, 0x0a, 0x6a, 0x24, 0x2a, 0xe4, 0xf1, 0xcf,
	0xd8, 0x4e, 0xd6, 0xeb, 0x2d, 0x10, 0x12, 0x5d, 0xf4, 0xe6, 0x7b, 0xdf, 0xf7, 0xbd, 0xf7, 0xe6,
	0x39, 0x36, 0xd0, 0x0d, 0x64, 0x39, 0x38, 0x98, 0xf8, 0x98, 0x7b, 0x24, 0x08, 0x08, 0xa3, 0xc1,
	0xd8, 0xe7, 0x4c, 0x30, 0xd8, 0x8e, 0x4e, 0xfa, 0x1f, 0x39, 0x8c, 0x39, 0x2e, 0x9e, 0xc8, 0xa8,
	0xb1, 0xb5, 0x27, 0x88, 0x9e, 0x47, 0x90, 0xfe, 0x49, 0x9c, 0x6c, 0x20, 0x17, 0x51, 0x13, 0xc7,
	0x99, 0xfd, 0x27, 0x71, 0x18, 0x59, 0x16, 0xc7, 0x41, 0xf0, 0xda, 0x43, 0xbe, 0x4f, 0xa8, 0x93,
	0x1c, 0x1f, 0x3b, 0xcc, 0x61, 0xf2, 0xe7, 0x24, 0xfc, 0x15, 0x45, 0x47, 0x17, 0x1d, 0x70, 0xb2,
	0x60, 0xae, 0x8b, 0x4d, 0x41, 0x18, 0xfd, 0x26, 0xb3, 0x03, 0xbf, 0x02, 0x1f, 0x98, 0x88, 0x3e,
	0xc7, 0x2e, 0x16, 0x38, 0x43, 0xe8, 0xca, 0x50, 0x3b, 0xbd, 0x3f, 0xd5, 0xc7, 0x91, 0xd8, 0x78,
	0x56, 0xc8, 0x5b, 0x57, 0x25, 0xc1, 0x6f, 0xc1, 0xb1, 0x89, 0xe8, 0x8c, 0x9b, 0x1b, 0xf2, 0x36,
	0x4f, 0xa6, 0x4a, 0xb2, 0x27, 0x09, 0xd9, 0x19, 0xf1, 0xb0, 0xf5, 0xca, 0xb7, 0x90, 0xc0, 0x39,
	0xc6, 0xca, 0x54, 0xf8, 0x06, 0x3c, 0x35, 0x11, 0x8d, 0xc0, 0x2f, 0x6c, 0x7b, 0xb1, 0x41, 0x84,
	0xce, 0xe3, 0x86, 0xac, 0xb0, 0x40, 0x16, 0x12, 0x48, 0xd7, 0xea, 0xf0, 0xdf, 0xcc, 0x03, 0x57,
	0x00, 0xa6, 0xa0, 0x97, 0x02, 0x51, 0x0b, 0x71, 0x2b, 0xd0, 0x5b, 0x75, 0xd8, 0x2b, 0x12, 0xe1,
	0x0b, 0xd9, 0xda, 0x28, 0xba, 0xd8, 0x06, 0x82, 0x79, 0xcf, 0x43, 0xb7, 0xf7, 0xea, 0xf0, 0x55,
	0x65, 0xc2, 0x25, 0x78, 0x94, 0x86, 0x57, 0x88, 0x22, 0x07, 0x73, 0xbd, 0x5d, 0x87, 0xad, 0x94,
	0x06, 0x5f, 0x83, 0x8f, 0x33, 0x85, 0xb4, 0xdd, 0x69, 0x47, 0x3b, 0x75, 0x58, 0x0f, 0x31, 0xc0,
	0xb5, 0x2c, 0x7e, 0xc1, 0x71, 0x28, 0xca, 0x38, 0x9e, 0x4b, 0x26, 0xbd, 0x2b, 0x89, 0x87, 0x09,
	0x71, 0x32, 0x82, 0xca, 0xfb, 0x55, 0x4c, 0x86, 0x08, 0x7c, 0x98, 0x4a, 0xca, 0x50, 0xea, 0xb7,
	0x27, 0x69, 0x3f, 0xad, 0xf0, 0xfb, 0x1d, 0x11, 0x1b, 0x89, 0x5d, 0x5a, 0x41, 0x8e, 0x7f, 0x0f,
	0x11, 0xdc, 0x80, 0xc7, 0x15, 0x55, 0xcd, 0x7c, 0x9f, 0xb3, 0xb7, 0xc8, 0x0d, 0x74, 0x20, 0x85,
	0x9e, 0x25, 0x42, 0x65, 0x48, 0x4e, 0xe3, 0x20, 0xd3, 0xe8, 0x2f, 0x0d, 0x3c, 0x7c, 0x15, 0x60,
	0x9e, 0x5f, 0x46, 0x1b, 0xf4, 0xb3, 0x5b, 0xba, 0x15, 0x0e, 0x23, 0xd4, 0xc9, 0xb4, 0xa3, 0x9d,
	0xfc, 0x24, 0xd1, 0x0e, 0x93, 0x8b, 0xa0, 0x9c, 0xfa, 0x01, 0xa6, 0x1d, 0x9d, 0x25, 0x35, 0x99,
	0xb7, 0xa3, 0xa3, 0x96, 0x75, 0x8a, 0xa0, 0x4a, 0x9d, 0x12, 0x13, 0x7c, 0xa7, 0x80, 0x69, 0x7a,
	0x3c, 0xdb, 0x0a, 0x16, 0x1d, 0xe1, 0x97, 0xd8, 0xb5, 0x97, 0x94, 0x08, 0x82, 0x04, 0xb6, 0x12,
	0x7b, 0x67, 0x1c, 0xd1, 0xc0, 0xc6, 0x3c, 0x88, 0xf7, 0x79, 0xff, 0xc3, 0xa7, 0x01, 0x67, 0x3d,
	0x2b, 0x49, 0x05, 0x99, 0x95, 0xd6, 0x9d, 0xad, 0x94, 0x38, 0x47, 0x3f, 0xb7, 0xc0, 0xe3, 0x43,
	0x17, 0x07, 0x3e, 0x03, 0x0f, 0x6c, 0xce, 0xbc, 0x55, 0xf4, 0x64, 0x5f, 0x5a, 0xba, 0x32, 0x54,
	0x4e, 0x7b, 0xeb, 0xdd, 0x20, 0x1c, 0x82, 0xfb, 0x82, 0x65, 0x18, 0x55, 0x62, 0xf2, 0x21, 0x38,
	0x05, 0xc7, 0x24, 0xb1, 0x31, 0x3f, 0xcf, 0xa0, 0x9a, 0x84, 0x56, 0x9e, 0xc1, 0x2f, 0xc0, 0x03,
	0x11, 0x3b, 0x0d, 0xb7, 0x28, 0xe9, 0xc0, 0xfb, 0xe9, 0x6d, 0x20, 0x54, 0xac, 0x11, 0x75, 0xf0,
	0x7a, 0x17, 0x07, 0x3f, 0x03, 0x5d, 0x23, 0xde, 0xb3, 0xf8, 0x11, 0x57, 0x91, 0x93, 0x42, 0xe0,
	0x97, 0xe0, 0x3d, 0xf6, 0x03, 0xc5, 0x3c, 0xd8, 0x10, 0x3f, 0x12, 0x6a, 0xef, 0x4b, 0x2a, 0x00,
	0xe1, 0x29, 0x78, 0x88, 0x3c, 0xb6, 0xa5, 0xe2, 0x8c, 0x23, 0xf3, 0x0d, 0xe6, 0x4b, 0x4b, 0xef,
	0xc8, 0x8a, 0x8a, 0x61, 0x38, 0x06, 0xd0, 0xdc, 0x20, 0xd7, 0xc5, 0xd4, 0xc1, 0x19, 0xb8, 0x2b,
	0xc1, 0x15, 0x27, 0xa1, 0x29, 0xf9, 0x57, 0x2d, 0x04, 0xb6, 0x22, 0x53, 0xbd, 0xbd, 0xa6, 0x76,
	0x81, 0x61, 0xaa, 0xcd, 0xb8, 0x41, 0x2c, 0x0b, 0xd3, 0x28, 0x15, 0xec, 0x4d, 0xdd, 0x05, 0x8e,
	0xfe, 0xd0, 0xc0, 0xe0, 0xf0, 0x32, 0x17, 0x67, 0xad, 0xd4, 0x9f, 0xb5, 0x7a, 0x9b, 0x59, 0x6b,
	0x0d, 0x66, 0xdd, 0x6a, 0x32, 0xeb, 0x7b, 0x77, 0x98, 0x75, 0xfb, 0x36, 0xb3, 0xee, 0xdc, 0x62,
	0xd6, 0xdd, 0xe6, 0xb3, 0xee, 0xd5, 0x9d, 0xf5, 0x9f, 0xf1, 0xac, 0xf7, 0x3f, 0x50, 0x6b, 0x6e,
	0xff, 0xff, 0xf3, 0xfe, 0x4f, 0xcc, 0xfb, 0x6f, 0x05, 0xe8, 0xfb, 0x5e, 0x72, 0x76, 0xda, 0xaa,
	0x34, 0x69, 0xab, 0x5a, 0xb7, 0xad, 0xe5, 0xe2, 0xb5, 0xe6, 0xc5, 0xb7, 0xea, 0x16, 0xff, 0x4e,
	0x01, 0x8f, 0x4a, 0x45, 0x97, 0xad, 0x28, 0xcd, 0xad, 0xa8, 0x75, 0xad, 0xfc, 0xa2, 0x80, 0x93,
	0xca, 0xb7, 0xd8, 0x7f, 0xc7, 0x8f, 0x5c, 0x45, 0xe2, 0x61, 0x97, 0x50, 0x7c, 0xe3, 0x2a, 0xe6,
	0x71, 0xa3, 0x9f, 0x54, 0xf0, 0xf4, 0xc6, 0xd7, 0xdb, 0x06, 0x37, 0xab, 0xd0, 0x03, 0xb5, 0x79,
	0x0f, 0xb4, 0xc6, 0x3d, 0x68, 0xd5, 0xeb, 0xc1, 0xfc, 0xeb, 0x5f, 0xaf, 0x06, 0xca, 0xe5, 0xd5,
	0x40, 0xf9, 0xfd, 0x6a, 0xa0, 0x5c, 0x5c, 0x0f, 0x8e, 0x2e, 0xaf, 0x07, 0x47, 0xbf, 0x5d, 0x0f,
	0x8e, 0xbe, 0x9f, 0x3a, 0x44, 0x6c, 0xb6, 0xc6, 0xd8, 0x64, 0xde, 0xc4, 0x20, 0x22, 0xf9, 0x82,
	0x4e, 0x7e, 0x99, 0xe1, 0x67, 0xdf, 0xe4, 0xc7, 0x49, 0x1c, 0x17, 0xe7, 0x3e, 0x0e, 0x8c, 0xb6,
	0xfc, 0x44, 0xfe, 0xfc, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd3, 0xf9, 0xf6, 0x98, 0xad, 0x0f,
	0x00, 0x00,
}

func (m *CollectionPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateCollectionApprovals) > 0 {
		for iNdEx := len(m.CanUpdateCollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.CanUpdateBadgeMetadata) > 0 {
		for iNdEx := len(m.CanUpdateBadgeMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateBadgeMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CanCreateMoreBadges) > 0 {
		for iNdEx := len(m.CanCreateMoreBadges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanCreateMoreBadges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for iNdEx := len(m.CanUpdateCollectionMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for iNdEx := len(m.CanUpdateManager) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateManager[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for iNdEx := len(m.CanUpdateCustomData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCustomData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CanUpdateStandards) > 0 {
		for iNdEx := len(m.CanUpdateStandards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateStandards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CanUpdateOffChainBalancesMetadata) > 0 {
		for iNdEx := len(m.CanUpdateOffChainBalancesMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateOffChainBalancesMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CanArchiveCollection) > 0 {
		for iNdEx := len(m.CanArchiveCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanArchiveCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CanDeleteCollection) > 0 {
		for iNdEx := len(m.CanDeleteCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanDeleteCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers) > 0 {
		for iNdEx := len(m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers) > 0 {
		for iNdEx := len(m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CanUpdateIncomingApprovals) > 0 {
		for iNdEx := len(m.CanUpdateIncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateIncomingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CanUpdateOutgoingApprovals) > 0 {
		for iNdEx := len(m.CanUpdateOutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateOutgoingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApprovalPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApprovalPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApprovalPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AmountTrackerId) > 0 {
		i -= len(m.AmountTrackerId)
		copy(dAtA[i:], m.AmountTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.AmountTrackerId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ToMappingId) > 0 {
		i -= len(m.ToMappingId)
		copy(dAtA[i:], m.ToMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ToMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromMappingId) > 0 {
		i -= len(m.FromMappingId)
		copy(dAtA[i:], m.FromMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.FromMappingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserOutgoingApprovalPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserOutgoingApprovalPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserOutgoingApprovalPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AmountTrackerId) > 0 {
		i -= len(m.AmountTrackerId)
		copy(dAtA[i:], m.AmountTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.AmountTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToMappingId) > 0 {
		i -= len(m.ToMappingId)
		copy(dAtA[i:], m.ToMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ToMappingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserIncomingApprovalPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIncomingApprovalPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserIncomingApprovalPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AmountTrackerId) > 0 {
		i -= len(m.AmountTrackerId)
		copy(dAtA[i:], m.AmountTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.AmountTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromMappingId) > 0 {
		i -= len(m.FromMappingId)
		copy(dAtA[i:], m.FromMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.FromMappingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BalancesActionPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BalancesActionPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BalancesActionPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdatePermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdatePermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdatePermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateWithBadgeIdsPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateWithBadgeIdsPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateWithBadgeIdsPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPermissions(dAtA []byte, offset int, v uint64) int {
	offset -= sovPermissions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CollectionPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CanDeleteCollection) > 0 {
		for _, e := range m.CanDeleteCollection {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanArchiveCollection) > 0 {
		for _, e := range m.CanArchiveCollection {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateOffChainBalancesMetadata) > 0 {
		for _, e := range m.CanUpdateOffChainBalancesMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateStandards) > 0 {
		for _, e := range m.CanUpdateStandards {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for _, e := range m.CanUpdateCustomData {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for _, e := range m.CanUpdateManager {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for _, e := range m.CanUpdateCollectionMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanCreateMoreBadges) > 0 {
		for _, e := range m.CanCreateMoreBadges {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateBadgeMetadata) > 0 {
		for _, e := range m.CanUpdateBadgeMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionApprovals) > 0 {
		for _, e := range m.CanUpdateCollectionApprovals {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CanUpdateOutgoingApprovals) > 0 {
		for _, e := range m.CanUpdateOutgoingApprovals {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateIncomingApprovals) > 0 {
		for _, e := range m.CanUpdateIncomingApprovals {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers) > 0 {
		for _, e := range m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers) > 0 {
		for _, e := range m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *CollectionApprovalPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ToMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.AmountTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserOutgoingApprovalPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.AmountTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserIncomingApprovalPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.AmountTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *BalancesActionPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ActionPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *TimedUpdatePermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *TimedUpdateWithBadgeIdsPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func sovPermissions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPermissions(x uint64) (n int) {
	return sovPermissions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CollectionPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDeleteCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanDeleteCollection = append(m.CanDeleteCollection, &ActionPermission{})
			if err := m.CanDeleteCollection[len(m.CanDeleteCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanArchiveCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanArchiveCollection = append(m.CanArchiveCollection, &TimedUpdatePermission{})
			if err := m.CanArchiveCollection[len(m.CanArchiveCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateOffChainBalancesMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateOffChainBalancesMetadata = append(m.CanUpdateOffChainBalancesMetadata, &TimedUpdatePermission{})
			if err := m.CanUpdateOffChainBalancesMetadata[len(m.CanUpdateOffChainBalancesMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateStandards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateStandards = append(m.CanUpdateStandards, &TimedUpdatePermission{})
			if err := m.CanUpdateStandards[len(m.CanUpdateStandards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCustomData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCustomData = append(m.CanUpdateCustomData, &TimedUpdatePermission{})
			if err := m.CanUpdateCustomData[len(m.CanUpdateCustomData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateManager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateManager = append(m.CanUpdateManager, &TimedUpdatePermission{})
			if err := m.CanUpdateManager[len(m.CanUpdateManager)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionMetadata = append(m.CanUpdateCollectionMetadata, &TimedUpdatePermission{})
			if err := m.CanUpdateCollectionMetadata[len(m.CanUpdateCollectionMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanCreateMoreBadges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanCreateMoreBadges = append(m.CanCreateMoreBadges, &BalancesActionPermission{})
			if err := m.CanCreateMoreBadges[len(m.CanCreateMoreBadges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateBadgeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateBadgeMetadata = append(m.CanUpdateBadgeMetadata, &TimedUpdateWithBadgeIdsPermission{})
			if err := m.CanUpdateBadgeMetadata[len(m.CanUpdateBadgeMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionApprovals = append(m.CanUpdateCollectionApprovals, &CollectionApprovalPermission{})
			if err := m.CanUpdateCollectionApprovals[len(m.CanUpdateCollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateOutgoingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateOutgoingApprovals = append(m.CanUpdateOutgoingApprovals, &UserOutgoingApprovalPermission{})
			if err := m.CanUpdateOutgoingApprovals[len(m.CanUpdateOutgoingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateIncomingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateIncomingApprovals = append(m.CanUpdateIncomingApprovals, &UserIncomingApprovalPermission{})
			if err := m.CanUpdateIncomingApprovals[len(m.CanUpdateIncomingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateAutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers = append(m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers, &ActionPermission{})
			if err := m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers[len(m.CanUpdateAutoApproveSelfInitiatedOutgoingTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateAutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers = append(m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers, &ActionPermission{})
			if err := m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers[len(m.CanUpdateAutoApproveSelfInitiatedIncomingTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApprovalPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApprovalPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApprovalPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserOutgoingApprovalPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserOutgoingApprovalPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserOutgoingApprovalPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIncomingApprovalPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIncomingApprovalPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIncomingApprovalPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BalancesActionPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BalancesActionPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BalancesActionPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdatePermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdatePermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdatePermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &UintRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateWithBadgeIdsPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &UintRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPermissions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPermissions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPermissions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPermissions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPermissions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPermissions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPermissions = fmt.Errorf("proto: unexpected end of group")
)
