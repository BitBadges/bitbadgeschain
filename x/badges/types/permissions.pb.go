// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/permissions.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CollectionPermissions defines the permissions for the collection (i.e. what the manager can and cannot do).
//
// There are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BalancesActionPermission, and CollectionApprovedTransferPermission.
//
// The permission type allows fine-grained access control for each action.
// ActionPermission: defines when the manager can perform an action.
// TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.
// TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.
// BalancesActionPermission: defines when the manager can perform an action for specific badges and specific badge ownership times.
// CollectionApprovedTransferPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs locked
//
// Note there are a few different times here which could get confusing:
// - timelineTimes: the times when a timeline-based field is a specific value
// - permitted/forbiddenTimes - the times that a permission can be performed
// - transferTimes - the times that a transfer occurs
// - ownershipTimes - the times when a badge is owned by a user
//
// The permitted/forbiddenTimes are used to determine when a permission can be executed.
// Once a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.
// If a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.
//
// Each permission type has a defaultValues field and a combinations field.
// The defaultValues field defines the default values for the permission which can be manipulated by the combinations field (to avoid unnecessary repetition).
// Ex: We can have default value badgeIds = [1,2] and combinations = [{invertDefault: true, isApproved: false}, {isApproved: true}].
// This would mean that badgeIds [1,2] are allowed but everything else is not allowed.
//
// IMPORTANT: For all permissions, we ONLY take the first combination that matches. Any subsequent combinations are ignored.
// Ex: If we have defaultValues = {badgeIds: [1,2]} and combinations = [{isApproved: true}, {isApproved: false}].
// This would mean that badgeIds [1,2] are allowed and the second combination is ignored.
type CollectionPermissions struct {
	CanDeleteCollection                  []*ActionPermission                     `protobuf:"bytes,1,rep,name=canDeleteCollection,proto3" json:"canDeleteCollection,omitempty"`
	CanArchiveCollection                 []*TimedUpdatePermission                `protobuf:"bytes,2,rep,name=canArchiveCollection,proto3" json:"canArchiveCollection,omitempty"`
	CanUpdateContractAddress             []*TimedUpdatePermission                `protobuf:"bytes,3,rep,name=canUpdateContractAddress,proto3" json:"canUpdateContractAddress,omitempty"`
	CanUpdateOffChainBalancesMetadata    []*TimedUpdatePermission                `protobuf:"bytes,4,rep,name=canUpdateOffChainBalancesMetadata,proto3" json:"canUpdateOffChainBalancesMetadata,omitempty"`
	CanUpdateStandards                   []*TimedUpdatePermission                `protobuf:"bytes,5,rep,name=canUpdateStandards,proto3" json:"canUpdateStandards,omitempty"`
	CanUpdateCustomData                  []*TimedUpdatePermission                `protobuf:"bytes,6,rep,name=canUpdateCustomData,proto3" json:"canUpdateCustomData,omitempty"`
	CanUpdateManager                     []*TimedUpdatePermission                `protobuf:"bytes,7,rep,name=canUpdateManager,proto3" json:"canUpdateManager,omitempty"`
	CanUpdateCollectionMetadata          []*TimedUpdatePermission                `protobuf:"bytes,8,rep,name=canUpdateCollectionMetadata,proto3" json:"canUpdateCollectionMetadata,omitempty"`
	CanCreateMoreBadges                  []*BalancesActionPermission             `protobuf:"bytes,9,rep,name=canCreateMoreBadges,proto3" json:"canCreateMoreBadges,omitempty"`
	CanUpdateBadgeMetadata               []*TimedUpdateWithBadgeIdsPermission    `protobuf:"bytes,10,rep,name=canUpdateBadgeMetadata,proto3" json:"canUpdateBadgeMetadata,omitempty"`
	CanUpdateCollectionApprovedTransfers []*CollectionApprovedTransferPermission `protobuf:"bytes,12,rep,name=canUpdateCollectionApprovedTransfers,proto3" json:"canUpdateCollectionApprovedTransfers,omitempty"`
}

func (m *CollectionPermissions) Reset()         { *m = CollectionPermissions{} }
func (m *CollectionPermissions) String() string { return proto.CompactTextString(m) }
func (*CollectionPermissions) ProtoMessage()    {}
func (*CollectionPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{0}
}
func (m *CollectionPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionPermissions.Merge(m, src)
}
func (m *CollectionPermissions) XXX_Size() int {
	return m.Size()
}
func (m *CollectionPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionPermissions proto.InternalMessageInfo

func (m *CollectionPermissions) GetCanDeleteCollection() []*ActionPermission {
	if m != nil {
		return m.CanDeleteCollection
	}
	return nil
}

func (m *CollectionPermissions) GetCanArchiveCollection() []*TimedUpdatePermission {
	if m != nil {
		return m.CanArchiveCollection
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateContractAddress() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateContractAddress
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateOffChainBalancesMetadata() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateOffChainBalancesMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateStandards() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateStandards
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCustomData() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCustomData
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateManager() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateManager
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCollectionMetadata() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCollectionMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanCreateMoreBadges() []*BalancesActionPermission {
	if m != nil {
		return m.CanCreateMoreBadges
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateBadgeMetadata() []*TimedUpdateWithBadgeIdsPermission {
	if m != nil {
		return m.CanUpdateBadgeMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCollectionApprovedTransfers() []*CollectionApprovedTransferPermission {
	if m != nil {
		return m.CanUpdateCollectionApprovedTransfers
	}
	return nil
}

// UserPermissions defines the permissions for the user (i.e. what the user can and cannot do).
//
// See CollectionPermissions for more details on the different types of permissions.
// The UserApprovedOutgoing and UserApprovedIncoming permissions are the same as the CollectionApprovedTransferPermission,
// but certain fields are removed because they are not relevant to the user.
type UserPermissions struct {
	CanUpdateApprovedOutgoingTransfers []*UserApprovedOutgoingTransferPermission `protobuf:"bytes,1,rep,name=canUpdateApprovedOutgoingTransfers,proto3" json:"canUpdateApprovedOutgoingTransfers,omitempty"`
	CanUpdateApprovedIncomingTransfers []*UserApprovedIncomingTransferPermission `protobuf:"bytes,2,rep,name=canUpdateApprovedIncomingTransfers,proto3" json:"canUpdateApprovedIncomingTransfers,omitempty"`
}

func (m *UserPermissions) Reset()         { *m = UserPermissions{} }
func (m *UserPermissions) String() string { return proto.CompactTextString(m) }
func (*UserPermissions) ProtoMessage()    {}
func (*UserPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{1}
}
func (m *UserPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPermissions.Merge(m, src)
}
func (m *UserPermissions) XXX_Size() int {
	return m.Size()
}
func (m *UserPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_UserPermissions proto.InternalMessageInfo

func (m *UserPermissions) GetCanUpdateApprovedOutgoingTransfers() []*UserApprovedOutgoingTransferPermission {
	if m != nil {
		return m.CanUpdateApprovedOutgoingTransfers
	}
	return nil
}

func (m *UserPermissions) GetCanUpdateApprovedIncomingTransfers() []*UserApprovedIncomingTransferPermission {
	if m != nil {
		return m.CanUpdateApprovedIncomingTransfers
	}
	return nil
}

// ValueOptions defines how we manipulate the default values.
type ValueOptions struct {
	InvertDefault bool `protobuf:"varint,1,opt,name=invertDefault,proto3" json:"invertDefault,omitempty"`
	AllValues     bool `protobuf:"varint,2,opt,name=allValues,proto3" json:"allValues,omitempty"`
	NoValues      bool `protobuf:"varint,3,opt,name=noValues,proto3" json:"noValues,omitempty"`
}

func (m *ValueOptions) Reset()         { *m = ValueOptions{} }
func (m *ValueOptions) String() string { return proto.CompactTextString(m) }
func (*ValueOptions) ProtoMessage()    {}
func (*ValueOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{2}
}
func (m *ValueOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueOptions.Merge(m, src)
}
func (m *ValueOptions) XXX_Size() int {
	return m.Size()
}
func (m *ValueOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ValueOptions proto.InternalMessageInfo

func (m *ValueOptions) GetInvertDefault() bool {
	if m != nil {
		return m.InvertDefault
	}
	return false
}

func (m *ValueOptions) GetAllValues() bool {
	if m != nil {
		return m.AllValues
	}
	return false
}

func (m *ValueOptions) GetNoValues() bool {
	if m != nil {
		return m.NoValues
	}
	return false
}

type CollectionApprovedTransferCombination struct {
	FromMappingOptions        *ValueOptions `protobuf:"bytes,1,opt,name=fromMappingOptions,proto3" json:"fromMappingOptions,omitempty"`
	ToMappingOptions          *ValueOptions `protobuf:"bytes,2,opt,name=toMappingOptions,proto3" json:"toMappingOptions,omitempty"`
	InitiatedByMappingOptions *ValueOptions `protobuf:"bytes,3,opt,name=initiatedByMappingOptions,proto3" json:"initiatedByMappingOptions,omitempty"`
	TransferTimesOptions      *ValueOptions `protobuf:"bytes,4,opt,name=transferTimesOptions,proto3" json:"transferTimesOptions,omitempty"`
	BadgeIdsOptions           *ValueOptions `protobuf:"bytes,5,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	OwnershipTimesOptions     *ValueOptions `protobuf:"bytes,6,opt,name=ownershipTimesOptions,proto3" json:"ownershipTimesOptions,omitempty"`
	ApprovalTrackerIdOptions  *ValueOptions `protobuf:"bytes,10,opt,name=approvalTrackerIdOptions,proto3" json:"approvalTrackerIdOptions,omitempty"`
	ChallengeTrackerIdOptions *ValueOptions `protobuf:"bytes,9,opt,name=challengeTrackerIdOptions,proto3" json:"challengeTrackerIdOptions,omitempty"`
	PermittedTimesOptions     *ValueOptions `protobuf:"bytes,7,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions     *ValueOptions `protobuf:"bytes,8,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *CollectionApprovedTransferCombination) Reset()         { *m = CollectionApprovedTransferCombination{} }
func (m *CollectionApprovedTransferCombination) String() string { return proto.CompactTextString(m) }
func (*CollectionApprovedTransferCombination) ProtoMessage()    {}
func (*CollectionApprovedTransferCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{3}
}
func (m *CollectionApprovedTransferCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApprovedTransferCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApprovedTransferCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApprovedTransferCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApprovedTransferCombination.Merge(m, src)
}
func (m *CollectionApprovedTransferCombination) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApprovedTransferCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApprovedTransferCombination.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApprovedTransferCombination proto.InternalMessageInfo

func (m *CollectionApprovedTransferCombination) GetFromMappingOptions() *ValueOptions {
	if m != nil {
		return m.FromMappingOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetToMappingOptions() *ValueOptions {
	if m != nil {
		return m.ToMappingOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetInitiatedByMappingOptions() *ValueOptions {
	if m != nil {
		return m.InitiatedByMappingOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetTransferTimesOptions() *ValueOptions {
	if m != nil {
		return m.TransferTimesOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetOwnershipTimesOptions() *ValueOptions {
	if m != nil {
		return m.OwnershipTimesOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetApprovalTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ApprovalTrackerIdOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetChallengeTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ChallengeTrackerIdOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type CollectionApprovedTransferDefaultValues struct {
	FromMappingId        string       `protobuf:"bytes,1,opt,name=fromMappingId,proto3" json:"fromMappingId,omitempty"`
	ToMappingId          string       `protobuf:"bytes,2,opt,name=toMappingId,proto3" json:"toMappingId,omitempty"`
	InitiatedByMappingId string       `protobuf:"bytes,3,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	TransferTimes        []*UintRange `protobuf:"bytes,4,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	BadgeIds             []*UintRange `protobuf:"bytes,5,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	OwnershipTimes       []*UintRange `protobuf:"bytes,6,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	ApprovalTrackerId    string       `protobuf:"bytes,10,opt,name=approvalTrackerId,proto3" json:"approvalTrackerId,omitempty"`
	ChallengeTrackerId   string       `protobuf:"bytes,9,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	PermittedTimes       []*UintRange `protobuf:"bytes,7,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes       []*UintRange `protobuf:"bytes,8,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *CollectionApprovedTransferDefaultValues) Reset() {
	*m = CollectionApprovedTransferDefaultValues{}
}
func (m *CollectionApprovedTransferDefaultValues) String() string { return proto.CompactTextString(m) }
func (*CollectionApprovedTransferDefaultValues) ProtoMessage()    {}
func (*CollectionApprovedTransferDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{4}
}
func (m *CollectionApprovedTransferDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApprovedTransferDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApprovedTransferDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApprovedTransferDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApprovedTransferDefaultValues.Merge(m, src)
}
func (m *CollectionApprovedTransferDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApprovedTransferDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApprovedTransferDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApprovedTransferDefaultValues proto.InternalMessageInfo

func (m *CollectionApprovedTransferDefaultValues) GetFromMappingId() string {
	if m != nil {
		return m.FromMappingId
	}
	return ""
}

func (m *CollectionApprovedTransferDefaultValues) GetToMappingId() string {
	if m != nil {
		return m.ToMappingId
	}
	return ""
}

func (m *CollectionApprovedTransferDefaultValues) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *CollectionApprovedTransferDefaultValues) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *CollectionApprovedTransferDefaultValues) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *CollectionApprovedTransferDefaultValues) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *CollectionApprovedTransferDefaultValues) GetApprovalTrackerId() string {
	if m != nil {
		return m.ApprovalTrackerId
	}
	return ""
}

func (m *CollectionApprovedTransferDefaultValues) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *CollectionApprovedTransferDefaultValues) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *CollectionApprovedTransferDefaultValues) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

// CollectionApprovedTransferPermission defines what collection approved transfers can be updated vs are locked.
//
// Each transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.
// For a transfer to match, we need to match ALL of the fields in the combination.
// These are detemined by the fromMappingId, toMappingId, initiatedByMappingId, transferTimes, badgeIds fields.
// AddressMappings are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressMappings).
//
// TimelineTimes: which timeline times of the collection's approvedTransfersTimeline field can be updated or not?
// permitted/forbidden TimelineTimes: when can the manager execute this permission?
//
// Ex: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", 10, 1000).
// We would check to find the FIRST CollectionApprovedTransferPermission that matches this combination.
// If we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).
//
// Ex: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set
// the combination ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", "All Transfer Times", 1) to always be forbidden at all timelineTimes.
type CollectionApprovedTransferPermission struct {
	DefaultValues *CollectionApprovedTransferDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*CollectionApprovedTransferCombination `protobuf:"bytes,7,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *CollectionApprovedTransferPermission) Reset()         { *m = CollectionApprovedTransferPermission{} }
func (m *CollectionApprovedTransferPermission) String() string { return proto.CompactTextString(m) }
func (*CollectionApprovedTransferPermission) ProtoMessage()    {}
func (*CollectionApprovedTransferPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{5}
}
func (m *CollectionApprovedTransferPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApprovedTransferPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApprovedTransferPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApprovedTransferPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApprovedTransferPermission.Merge(m, src)
}
func (m *CollectionApprovedTransferPermission) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApprovedTransferPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApprovedTransferPermission.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApprovedTransferPermission proto.InternalMessageInfo

func (m *CollectionApprovedTransferPermission) GetDefaultValues() *CollectionApprovedTransferDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *CollectionApprovedTransferPermission) GetCombinations() []*CollectionApprovedTransferCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

type UserApprovedOutgoingTransferCombination struct {
	ToMappingOptions          *ValueOptions `protobuf:"bytes,1,opt,name=toMappingOptions,proto3" json:"toMappingOptions,omitempty"`
	InitiatedByMappingOptions *ValueOptions `protobuf:"bytes,2,opt,name=initiatedByMappingOptions,proto3" json:"initiatedByMappingOptions,omitempty"`
	TransferTimesOptions      *ValueOptions `protobuf:"bytes,3,opt,name=transferTimesOptions,proto3" json:"transferTimesOptions,omitempty"`
	BadgeIdsOptions           *ValueOptions `protobuf:"bytes,4,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	OwnershipTimesOptions     *ValueOptions `protobuf:"bytes,5,opt,name=ownershipTimesOptions,proto3" json:"ownershipTimesOptions,omitempty"`
	ApprovalTrackerIdOptions  *ValueOptions `protobuf:"bytes,10,opt,name=approvalTrackerIdOptions,proto3" json:"approvalTrackerIdOptions,omitempty"`
	ChallengeTrackerIdOptions *ValueOptions `protobuf:"bytes,9,opt,name=challengeTrackerIdOptions,proto3" json:"challengeTrackerIdOptions,omitempty"`
	PermittedTimesOptions     *ValueOptions `protobuf:"bytes,6,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions     *ValueOptions `protobuf:"bytes,7,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *UserApprovedOutgoingTransferCombination) Reset() {
	*m = UserApprovedOutgoingTransferCombination{}
}
func (m *UserApprovedOutgoingTransferCombination) String() string { return proto.CompactTextString(m) }
func (*UserApprovedOutgoingTransferCombination) ProtoMessage()    {}
func (*UserApprovedOutgoingTransferCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{6}
}
func (m *UserApprovedOutgoingTransferCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedOutgoingTransferCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedOutgoingTransferCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedOutgoingTransferCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedOutgoingTransferCombination.Merge(m, src)
}
func (m *UserApprovedOutgoingTransferCombination) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedOutgoingTransferCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedOutgoingTransferCombination.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedOutgoingTransferCombination proto.InternalMessageInfo

func (m *UserApprovedOutgoingTransferCombination) GetToMappingOptions() *ValueOptions {
	if m != nil {
		return m.ToMappingOptions
	}
	return nil
}

func (m *UserApprovedOutgoingTransferCombination) GetInitiatedByMappingOptions() *ValueOptions {
	if m != nil {
		return m.InitiatedByMappingOptions
	}
	return nil
}

func (m *UserApprovedOutgoingTransferCombination) GetTransferTimesOptions() *ValueOptions {
	if m != nil {
		return m.TransferTimesOptions
	}
	return nil
}

func (m *UserApprovedOutgoingTransferCombination) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *UserApprovedOutgoingTransferCombination) GetOwnershipTimesOptions() *ValueOptions {
	if m != nil {
		return m.OwnershipTimesOptions
	}
	return nil
}

func (m *UserApprovedOutgoingTransferCombination) GetApprovalTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ApprovalTrackerIdOptions
	}
	return nil
}

func (m *UserApprovedOutgoingTransferCombination) GetChallengeTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ChallengeTrackerIdOptions
	}
	return nil
}

func (m *UserApprovedOutgoingTransferCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *UserApprovedOutgoingTransferCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type UserApprovedOutgoingTransferDefaultValues struct {
	ToMappingId          string       `protobuf:"bytes,1,opt,name=toMappingId,proto3" json:"toMappingId,omitempty"`
	InitiatedByMappingId string       `protobuf:"bytes,2,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	TransferTimes        []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	BadgeIds             []*UintRange `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	OwnershipTimes       []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	ApprovalTrackerId    string       `protobuf:"bytes,10,opt,name=approvalTrackerId,proto3" json:"approvalTrackerId,omitempty"`
	ChallengeTrackerId   string       `protobuf:"bytes,9,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	PermittedTimes       []*UintRange `protobuf:"bytes,6,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes       []*UintRange `protobuf:"bytes,7,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *UserApprovedOutgoingTransferDefaultValues) Reset() {
	*m = UserApprovedOutgoingTransferDefaultValues{}
}
func (m *UserApprovedOutgoingTransferDefaultValues) String() string {
	return proto.CompactTextString(m)
}
func (*UserApprovedOutgoingTransferDefaultValues) ProtoMessage() {}
func (*UserApprovedOutgoingTransferDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{7}
}
func (m *UserApprovedOutgoingTransferDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedOutgoingTransferDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedOutgoingTransferDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedOutgoingTransferDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedOutgoingTransferDefaultValues.Merge(m, src)
}
func (m *UserApprovedOutgoingTransferDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedOutgoingTransferDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedOutgoingTransferDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedOutgoingTransferDefaultValues proto.InternalMessageInfo

func (m *UserApprovedOutgoingTransferDefaultValues) GetToMappingId() string {
	if m != nil {
		return m.ToMappingId
	}
	return ""
}

func (m *UserApprovedOutgoingTransferDefaultValues) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *UserApprovedOutgoingTransferDefaultValues) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserApprovedOutgoingTransferDefaultValues) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserApprovedOutgoingTransferDefaultValues) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserApprovedOutgoingTransferDefaultValues) GetApprovalTrackerId() string {
	if m != nil {
		return m.ApprovalTrackerId
	}
	return ""
}

func (m *UserApprovedOutgoingTransferDefaultValues) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *UserApprovedOutgoingTransferDefaultValues) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *UserApprovedOutgoingTransferDefaultValues) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

// UserApprovedOutgoingTransferPermission defines the permissions for updating the user's approved outgoing transfers.
// See CollectionApprovedTransferPermission for more details. This is equivalent without the fromMappingId field because that is always the user.
type UserApprovedOutgoingTransferPermission struct {
	DefaultValues *UserApprovedOutgoingTransferDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*UserApprovedOutgoingTransferCombination `protobuf:"bytes,2,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *UserApprovedOutgoingTransferPermission) Reset() {
	*m = UserApprovedOutgoingTransferPermission{}
}
func (m *UserApprovedOutgoingTransferPermission) String() string { return proto.CompactTextString(m) }
func (*UserApprovedOutgoingTransferPermission) ProtoMessage()    {}
func (*UserApprovedOutgoingTransferPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{8}
}
func (m *UserApprovedOutgoingTransferPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedOutgoingTransferPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedOutgoingTransferPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedOutgoingTransferPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedOutgoingTransferPermission.Merge(m, src)
}
func (m *UserApprovedOutgoingTransferPermission) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedOutgoingTransferPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedOutgoingTransferPermission.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedOutgoingTransferPermission proto.InternalMessageInfo

func (m *UserApprovedOutgoingTransferPermission) GetDefaultValues() *UserApprovedOutgoingTransferDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *UserApprovedOutgoingTransferPermission) GetCombinations() []*UserApprovedOutgoingTransferCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

type UserApprovedIncomingTransferCombination struct {
	FromMappingOptions        *ValueOptions `protobuf:"bytes,1,opt,name=fromMappingOptions,proto3" json:"fromMappingOptions,omitempty"`
	InitiatedByMappingOptions *ValueOptions `protobuf:"bytes,2,opt,name=initiatedByMappingOptions,proto3" json:"initiatedByMappingOptions,omitempty"`
	TransferTimesOptions      *ValueOptions `protobuf:"bytes,3,opt,name=transferTimesOptions,proto3" json:"transferTimesOptions,omitempty"`
	BadgeIdsOptions           *ValueOptions `protobuf:"bytes,4,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	OwnershipTimesOptions     *ValueOptions `protobuf:"bytes,5,opt,name=ownershipTimesOptions,proto3" json:"ownershipTimesOptions,omitempty"`
	ApprovalTrackerIdOptions  *ValueOptions `protobuf:"bytes,10,opt,name=approvalTrackerIdOptions,proto3" json:"approvalTrackerIdOptions,omitempty"`
	ChallengeTrackerIdOptions *ValueOptions `protobuf:"bytes,9,opt,name=challengeTrackerIdOptions,proto3" json:"challengeTrackerIdOptions,omitempty"`
	PermittedTimesOptions     *ValueOptions `protobuf:"bytes,6,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions     *ValueOptions `protobuf:"bytes,7,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *UserApprovedIncomingTransferCombination) Reset() {
	*m = UserApprovedIncomingTransferCombination{}
}
func (m *UserApprovedIncomingTransferCombination) String() string { return proto.CompactTextString(m) }
func (*UserApprovedIncomingTransferCombination) ProtoMessage()    {}
func (*UserApprovedIncomingTransferCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{9}
}
func (m *UserApprovedIncomingTransferCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedIncomingTransferCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedIncomingTransferCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedIncomingTransferCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedIncomingTransferCombination.Merge(m, src)
}
func (m *UserApprovedIncomingTransferCombination) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedIncomingTransferCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedIncomingTransferCombination.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedIncomingTransferCombination proto.InternalMessageInfo

func (m *UserApprovedIncomingTransferCombination) GetFromMappingOptions() *ValueOptions {
	if m != nil {
		return m.FromMappingOptions
	}
	return nil
}

func (m *UserApprovedIncomingTransferCombination) GetInitiatedByMappingOptions() *ValueOptions {
	if m != nil {
		return m.InitiatedByMappingOptions
	}
	return nil
}

func (m *UserApprovedIncomingTransferCombination) GetTransferTimesOptions() *ValueOptions {
	if m != nil {
		return m.TransferTimesOptions
	}
	return nil
}

func (m *UserApprovedIncomingTransferCombination) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *UserApprovedIncomingTransferCombination) GetOwnershipTimesOptions() *ValueOptions {
	if m != nil {
		return m.OwnershipTimesOptions
	}
	return nil
}

func (m *UserApprovedIncomingTransferCombination) GetApprovalTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ApprovalTrackerIdOptions
	}
	return nil
}

func (m *UserApprovedIncomingTransferCombination) GetChallengeTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ChallengeTrackerIdOptions
	}
	return nil
}

func (m *UserApprovedIncomingTransferCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *UserApprovedIncomingTransferCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type UserApprovedIncomingTransferDefaultValues struct {
	FromMappingId        string       `protobuf:"bytes,1,opt,name=fromMappingId,proto3" json:"fromMappingId,omitempty"`
	InitiatedByMappingId string       `protobuf:"bytes,2,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	TransferTimes        []*UintRange `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	BadgeIds             []*UintRange `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	OwnershipTimes       []*UintRange `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	ApprovalTrackerId    string       `protobuf:"bytes,10,opt,name=approvalTrackerId,proto3" json:"approvalTrackerId,omitempty"`
	ChallengeTrackerId   string       `protobuf:"bytes,9,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	PermittedTimes       []*UintRange `protobuf:"bytes,6,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes       []*UintRange `protobuf:"bytes,7,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *UserApprovedIncomingTransferDefaultValues) Reset() {
	*m = UserApprovedIncomingTransferDefaultValues{}
}
func (m *UserApprovedIncomingTransferDefaultValues) String() string {
	return proto.CompactTextString(m)
}
func (*UserApprovedIncomingTransferDefaultValues) ProtoMessage() {}
func (*UserApprovedIncomingTransferDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{10}
}
func (m *UserApprovedIncomingTransferDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedIncomingTransferDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedIncomingTransferDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedIncomingTransferDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedIncomingTransferDefaultValues.Merge(m, src)
}
func (m *UserApprovedIncomingTransferDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedIncomingTransferDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedIncomingTransferDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedIncomingTransferDefaultValues proto.InternalMessageInfo

func (m *UserApprovedIncomingTransferDefaultValues) GetFromMappingId() string {
	if m != nil {
		return m.FromMappingId
	}
	return ""
}

func (m *UserApprovedIncomingTransferDefaultValues) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *UserApprovedIncomingTransferDefaultValues) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserApprovedIncomingTransferDefaultValues) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserApprovedIncomingTransferDefaultValues) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserApprovedIncomingTransferDefaultValues) GetApprovalTrackerId() string {
	if m != nil {
		return m.ApprovalTrackerId
	}
	return ""
}

func (m *UserApprovedIncomingTransferDefaultValues) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *UserApprovedIncomingTransferDefaultValues) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *UserApprovedIncomingTransferDefaultValues) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

// UserApprovedIncomingTransferPermission defines the permissions for updating the user's approved incoming transfers.
// See CollectionApprovedTransferPermission for more details. This is equivalent without the toMappingId field because that is always the user.
type UserApprovedIncomingTransferPermission struct {
	DefaultValues *UserApprovedIncomingTransferDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*UserApprovedIncomingTransferCombination `protobuf:"bytes,2,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *UserApprovedIncomingTransferPermission) Reset() {
	*m = UserApprovedIncomingTransferPermission{}
}
func (m *UserApprovedIncomingTransferPermission) String() string { return proto.CompactTextString(m) }
func (*UserApprovedIncomingTransferPermission) ProtoMessage()    {}
func (*UserApprovedIncomingTransferPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{11}
}
func (m *UserApprovedIncomingTransferPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedIncomingTransferPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedIncomingTransferPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedIncomingTransferPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedIncomingTransferPermission.Merge(m, src)
}
func (m *UserApprovedIncomingTransferPermission) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedIncomingTransferPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedIncomingTransferPermission.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedIncomingTransferPermission proto.InternalMessageInfo

func (m *UserApprovedIncomingTransferPermission) GetDefaultValues() *UserApprovedIncomingTransferDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *UserApprovedIncomingTransferPermission) GetCombinations() []*UserApprovedIncomingTransferCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

type BalancesActionCombination struct {
	BadgeIdsOptions       *ValueOptions `protobuf:"bytes,1,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	OwnershipTimesOptions *ValueOptions `protobuf:"bytes,2,opt,name=ownershipTimesOptions,proto3" json:"ownershipTimesOptions,omitempty"`
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,3,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,4,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *BalancesActionCombination) Reset()         { *m = BalancesActionCombination{} }
func (m *BalancesActionCombination) String() string { return proto.CompactTextString(m) }
func (*BalancesActionCombination) ProtoMessage()    {}
func (*BalancesActionCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{12}
}
func (m *BalancesActionCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BalancesActionCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BalancesActionCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BalancesActionCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BalancesActionCombination.Merge(m, src)
}
func (m *BalancesActionCombination) XXX_Size() int {
	return m.Size()
}
func (m *BalancesActionCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_BalancesActionCombination.DiscardUnknown(m)
}

var xxx_messageInfo_BalancesActionCombination proto.InternalMessageInfo

func (m *BalancesActionCombination) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *BalancesActionCombination) GetOwnershipTimesOptions() *ValueOptions {
	if m != nil {
		return m.OwnershipTimesOptions
	}
	return nil
}

func (m *BalancesActionCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *BalancesActionCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type BalancesActionDefaultValues struct {
	BadgeIds       []*UintRange `protobuf:"bytes,1,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	OwnershipTimes []*UintRange `protobuf:"bytes,2,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	PermittedTimes []*UintRange `protobuf:"bytes,3,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes []*UintRange `protobuf:"bytes,4,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *BalancesActionDefaultValues) Reset()         { *m = BalancesActionDefaultValues{} }
func (m *BalancesActionDefaultValues) String() string { return proto.CompactTextString(m) }
func (*BalancesActionDefaultValues) ProtoMessage()    {}
func (*BalancesActionDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{13}
}
func (m *BalancesActionDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BalancesActionDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BalancesActionDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BalancesActionDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BalancesActionDefaultValues.Merge(m, src)
}
func (m *BalancesActionDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *BalancesActionDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_BalancesActionDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_BalancesActionDefaultValues proto.InternalMessageInfo

func (m *BalancesActionDefaultValues) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *BalancesActionDefaultValues) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *BalancesActionDefaultValues) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *BalancesActionDefaultValues) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

// BalancesActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.
// Currently, this is only used for creating new badges.
//
// Ex: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021,
// you could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
type BalancesActionPermission struct {
	DefaultValues *BalancesActionDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*BalancesActionCombination `protobuf:"bytes,2,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *BalancesActionPermission) Reset()         { *m = BalancesActionPermission{} }
func (m *BalancesActionPermission) String() string { return proto.CompactTextString(m) }
func (*BalancesActionPermission) ProtoMessage()    {}
func (*BalancesActionPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{14}
}
func (m *BalancesActionPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BalancesActionPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BalancesActionPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BalancesActionPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BalancesActionPermission.Merge(m, src)
}
func (m *BalancesActionPermission) XXX_Size() int {
	return m.Size()
}
func (m *BalancesActionPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_BalancesActionPermission.DiscardUnknown(m)
}

var xxx_messageInfo_BalancesActionPermission proto.InternalMessageInfo

func (m *BalancesActionPermission) GetDefaultValues() *BalancesActionDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *BalancesActionPermission) GetCombinations() []*BalancesActionCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

type ActionDefaultValues struct {
	PermittedTimes []*UintRange `protobuf:"bytes,1,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes []*UintRange `protobuf:"bytes,2,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *ActionDefaultValues) Reset()         { *m = ActionDefaultValues{} }
func (m *ActionDefaultValues) String() string { return proto.CompactTextString(m) }
func (*ActionDefaultValues) ProtoMessage()    {}
func (*ActionDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{15}
}
func (m *ActionDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDefaultValues.Merge(m, src)
}
func (m *ActionDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *ActionDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDefaultValues proto.InternalMessageInfo

func (m *ActionDefaultValues) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *ActionDefaultValues) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

type ActionCombination struct {
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,1,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,2,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *ActionCombination) Reset()         { *m = ActionCombination{} }
func (m *ActionCombination) String() string { return proto.CompactTextString(m) }
func (*ActionCombination) ProtoMessage()    {}
func (*ActionCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{16}
}
func (m *ActionCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionCombination.Merge(m, src)
}
func (m *ActionCombination) XXX_Size() int {
	return m.Size()
}
func (m *ActionCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionCombination.DiscardUnknown(m)
}

var xxx_messageInfo_ActionCombination proto.InternalMessageInfo

func (m *ActionCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *ActionCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

// ActionPermission defines the permissions for performing an action.
//
// This is simple and straightforward as the only thing we need to check is the permitted/forbidden times.
type ActionPermission struct {
	DefaultValues *ActionDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*ActionCombination `protobuf:"bytes,2,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *ActionPermission) Reset()         { *m = ActionPermission{} }
func (m *ActionPermission) String() string { return proto.CompactTextString(m) }
func (*ActionPermission) ProtoMessage()    {}
func (*ActionPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{17}
}
func (m *ActionPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionPermission.Merge(m, src)
}
func (m *ActionPermission) XXX_Size() int {
	return m.Size()
}
func (m *ActionPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionPermission.DiscardUnknown(m)
}

var xxx_messageInfo_ActionPermission proto.InternalMessageInfo

func (m *ActionPermission) GetDefaultValues() *ActionDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *ActionPermission) GetCombinations() []*ActionCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

type TimedUpdateCombination struct {
	TimelineTimesOptions  *ValueOptions `protobuf:"bytes,1,opt,name=timelineTimesOptions,proto3" json:"timelineTimesOptions,omitempty"`
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,2,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,3,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *TimedUpdateCombination) Reset()         { *m = TimedUpdateCombination{} }
func (m *TimedUpdateCombination) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateCombination) ProtoMessage()    {}
func (*TimedUpdateCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{18}
}
func (m *TimedUpdateCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateCombination.Merge(m, src)
}
func (m *TimedUpdateCombination) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateCombination.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateCombination proto.InternalMessageInfo

func (m *TimedUpdateCombination) GetTimelineTimesOptions() *ValueOptions {
	if m != nil {
		return m.TimelineTimesOptions
	}
	return nil
}

func (m *TimedUpdateCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *TimedUpdateCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type TimedUpdateDefaultValues struct {
	TimelineTimes  []*UintRange `protobuf:"bytes,1,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
	PermittedTimes []*UintRange `protobuf:"bytes,2,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes []*UintRange `protobuf:"bytes,3,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *TimedUpdateDefaultValues) Reset()         { *m = TimedUpdateDefaultValues{} }
func (m *TimedUpdateDefaultValues) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateDefaultValues) ProtoMessage()    {}
func (*TimedUpdateDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{19}
}
func (m *TimedUpdateDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateDefaultValues.Merge(m, src)
}
func (m *TimedUpdateDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateDefaultValues proto.InternalMessageInfo

func (m *TimedUpdateDefaultValues) GetTimelineTimes() []*UintRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

func (m *TimedUpdateDefaultValues) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *TimedUpdateDefaultValues) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

// TimedUpdatePermission defines the permissions for updating a timeline-based field.
//
// Ex: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,
// you could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
type TimedUpdatePermission struct {
	DefaultValues *TimedUpdateDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*TimedUpdateCombination `protobuf:"bytes,2,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *TimedUpdatePermission) Reset()         { *m = TimedUpdatePermission{} }
func (m *TimedUpdatePermission) String() string { return proto.CompactTextString(m) }
func (*TimedUpdatePermission) ProtoMessage()    {}
func (*TimedUpdatePermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{20}
}
func (m *TimedUpdatePermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdatePermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdatePermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdatePermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdatePermission.Merge(m, src)
}
func (m *TimedUpdatePermission) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdatePermission) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdatePermission.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdatePermission proto.InternalMessageInfo

func (m *TimedUpdatePermission) GetDefaultValues() *TimedUpdateDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *TimedUpdatePermission) GetCombinations() []*TimedUpdateCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

type TimedUpdateWithBadgeIdsCombination struct {
	TimelineTimesOptions  *ValueOptions `protobuf:"bytes,1,opt,name=timelineTimesOptions,proto3" json:"timelineTimesOptions,omitempty"`
	BadgeIdsOptions       *ValueOptions `protobuf:"bytes,2,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,3,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,4,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *TimedUpdateWithBadgeIdsCombination) Reset()         { *m = TimedUpdateWithBadgeIdsCombination{} }
func (m *TimedUpdateWithBadgeIdsCombination) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateWithBadgeIdsCombination) ProtoMessage()    {}
func (*TimedUpdateWithBadgeIdsCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{21}
}
func (m *TimedUpdateWithBadgeIdsCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateWithBadgeIdsCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateWithBadgeIdsCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateWithBadgeIdsCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateWithBadgeIdsCombination.Merge(m, src)
}
func (m *TimedUpdateWithBadgeIdsCombination) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateWithBadgeIdsCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateWithBadgeIdsCombination.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateWithBadgeIdsCombination proto.InternalMessageInfo

func (m *TimedUpdateWithBadgeIdsCombination) GetTimelineTimesOptions() *ValueOptions {
	if m != nil {
		return m.TimelineTimesOptions
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsCombination) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type TimedUpdateWithBadgeIdsDefaultValues struct {
	BadgeIds       []*UintRange `protobuf:"bytes,1,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	TimelineTimes  []*UintRange `protobuf:"bytes,2,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
	PermittedTimes []*UintRange `protobuf:"bytes,3,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes []*UintRange `protobuf:"bytes,4,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) Reset()         { *m = TimedUpdateWithBadgeIdsDefaultValues{} }
func (m *TimedUpdateWithBadgeIdsDefaultValues) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateWithBadgeIdsDefaultValues) ProtoMessage()    {}
func (*TimedUpdateWithBadgeIdsDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{22}
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateWithBadgeIdsDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateWithBadgeIdsDefaultValues.Merge(m, src)
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateWithBadgeIdsDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateWithBadgeIdsDefaultValues proto.InternalMessageInfo

func (m *TimedUpdateWithBadgeIdsDefaultValues) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) GetTimelineTimes() []*UintRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

// TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.
//
// Ex: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,
// you could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
type TimedUpdateWithBadgeIdsPermission struct {
	DefaultValues *TimedUpdateWithBadgeIdsDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*TimedUpdateWithBadgeIdsCombination `protobuf:"bytes,2,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *TimedUpdateWithBadgeIdsPermission) Reset()         { *m = TimedUpdateWithBadgeIdsPermission{} }
func (m *TimedUpdateWithBadgeIdsPermission) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateWithBadgeIdsPermission) ProtoMessage()    {}
func (*TimedUpdateWithBadgeIdsPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{23}
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.Merge(m, src)
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateWithBadgeIdsPermission proto.InternalMessageInfo

func (m *TimedUpdateWithBadgeIdsPermission) GetDefaultValues() *TimedUpdateWithBadgeIdsDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetCombinations() []*TimedUpdateWithBadgeIdsCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

func init() {
	proto.RegisterType((*CollectionPermissions)(nil), "bitbadges.bitbadgeschain.badges.CollectionPermissions")
	proto.RegisterType((*UserPermissions)(nil), "bitbadges.bitbadgeschain.badges.UserPermissions")
	proto.RegisterType((*ValueOptions)(nil), "bitbadges.bitbadgeschain.badges.ValueOptions")
	proto.RegisterType((*CollectionApprovedTransferCombination)(nil), "bitbadges.bitbadgeschain.badges.CollectionApprovedTransferCombination")
	proto.RegisterType((*CollectionApprovedTransferDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.CollectionApprovedTransferDefaultValues")
	proto.RegisterType((*CollectionApprovedTransferPermission)(nil), "bitbadges.bitbadgeschain.badges.CollectionApprovedTransferPermission")
	proto.RegisterType((*UserApprovedOutgoingTransferCombination)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedOutgoingTransferCombination")
	proto.RegisterType((*UserApprovedOutgoingTransferDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedOutgoingTransferDefaultValues")
	proto.RegisterType((*UserApprovedOutgoingTransferPermission)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedOutgoingTransferPermission")
	proto.RegisterType((*UserApprovedIncomingTransferCombination)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedIncomingTransferCombination")
	proto.RegisterType((*UserApprovedIncomingTransferDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedIncomingTransferDefaultValues")
	proto.RegisterType((*UserApprovedIncomingTransferPermission)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedIncomingTransferPermission")
	proto.RegisterType((*BalancesActionCombination)(nil), "bitbadges.bitbadgeschain.badges.BalancesActionCombination")
	proto.RegisterType((*BalancesActionDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.BalancesActionDefaultValues")
	proto.RegisterType((*BalancesActionPermission)(nil), "bitbadges.bitbadgeschain.badges.BalancesActionPermission")
	proto.RegisterType((*ActionDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.ActionDefaultValues")
	proto.RegisterType((*ActionCombination)(nil), "bitbadges.bitbadgeschain.badges.ActionCombination")
	proto.RegisterType((*ActionPermission)(nil), "bitbadges.bitbadgeschain.badges.ActionPermission")
	proto.RegisterType((*TimedUpdateCombination)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdateCombination")
	proto.RegisterType((*TimedUpdateDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdateDefaultValues")
	proto.RegisterType((*TimedUpdatePermission)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdatePermission")
	proto.RegisterType((*TimedUpdateWithBadgeIdsCombination)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdateWithBadgeIdsCombination")
	proto.RegisterType((*TimedUpdateWithBadgeIdsDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdateWithBadgeIdsDefaultValues")
	proto.RegisterType((*TimedUpdateWithBadgeIdsPermission)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdateWithBadgeIdsPermission")
}

func init() { proto.RegisterFile("badges/permissions.proto", fileDescriptor_1298419e4a97cfe6) }

var fileDescriptor_1298419e4a97cfe6 = []byte{
	// 1474 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcd, 0x8f, 0xdb, 0x44,
	0x14, 0xaf, 0xed, 0xec, 0x47, 0x5e, 0xbb, 0xb4, 0x9d, 0xee, 0x56, 0xee, 0x16, 0x96, 0x36, 0x5a,
	0x68, 0x41, 0x90, 0x88, 0x05, 0x81, 0x8a, 0xb8, 0xec, 0x6e, 0x5b, 0xba, 0x88, 0xaa, 0x95, 0xe9,
	0x87, 0x28, 0x82, 0x6a, 0x62, 0x4f, 0x1c, 0x77, 0x9d, 0x71, 0x64, 0x4f, 0x4a, 0xcb, 0x11, 0x71,
	0xe0, 0x08, 0x12, 0x12, 0xf4, 0xcc, 0x8d, 0x33, 0x07, 0x2e, 0x1c, 0x8b, 0x38, 0xf6, 0x82, 0xc4,
	0x05, 0x04, 0xdd, 0x0b, 0xff, 0x00, 0x87, 0xde, 0x90, 0x27, 0x8e, 0xd7, 0x1f, 0xe3, 0x7c, 0xd8,
	0x49, 0x04, 0x28, 0xb7, 0xec, 0x8c, 0xfd, 0xfb, 0x3d, 0xcf, 0xbc, 0xdf, 0xfb, 0x3d, 0xaf, 0x07,
	0xd4, 0x3a, 0x36, 0x4c, 0xe2, 0xd5, 0xda, 0xc4, 0x6d, 0x59, 0x9e, 0x67, 0x39, 0xd4, 0xab, 0xb6,
	0x5d, 0x87, 0x39, 0xe8, 0xd9, 0xba, 0xc5, 0xba, 0x93, 0xd5, 0xf0, 0x97, 0xde, 0xc4, 0x16, 0xad,
	0x76, 0x7f, 0xaf, 0x9e, 0x30, 0x1d, 0xc7, 0xb4, 0x49, 0x8d, 0x5f, 0x5e, 0xef, 0x34, 0x6a, 0x98,
	0xde, 0xef, 0xde, 0xbb, 0xba, 0x12, 0xa0, 0xd6, 0xb1, 0x8d, 0xa9, 0x4e, 0x02, 0xc8, 0xd5, 0x67,
	0x82, 0x61, 0x6c, 0x18, 0x2e, 0xf1, 0xbc, 0xdb, 0x2d, 0xdc, 0x6e, 0x5b, 0xd4, 0xec, 0x4d, 0x2f,
	0x9b, 0x8e, 0xe9, 0xf0, 0x9f, 0x35, 0xff, 0x57, 0x77, 0xb4, 0xf2, 0x0d, 0xc0, 0xca, 0xb6, 0x63,
	0xdb, 0x44, 0x67, 0x96, 0x43, 0xaf, 0xee, 0xc7, 0x89, 0x74, 0x38, 0xa6, 0x63, 0x7a, 0x9e, 0xd8,
	0x84, 0x91, 0xfd, 0x2b, 0x54, 0xe9, 0x94, 0x72, 0xf6, 0xe0, 0xc6, 0x2b, 0xd5, 0x01, 0xf1, 0x57,
	0x37, 0x13, 0x80, 0x9a, 0x08, 0x0d, 0xdd, 0x81, 0x65, 0x1d, 0xd3, 0x4d, 0x57, 0x6f, 0x5a, 0x77,
	0xa3, 0x2c, 0x32, 0x67, 0x79, 0x7d, 0x20, 0xcb, 0x35, 0xab, 0x45, 0x8c, 0xeb, 0x6d, 0x03, 0x33,
	0x12, 0xa1, 0x12, 0x62, 0x22, 0x17, 0x54, 0x1d, 0xd3, 0xee, 0xc5, 0xdb, 0x0e, 0x65, 0x2e, 0xd6,
	0xd9, 0x66, 0x77, 0xad, 0x54, 0xa5, 0x10, 0x5f, 0x26, 0x2e, 0xfa, 0x4c, 0x82, 0xd3, 0xe1, 0xe4,
	0x95, 0x46, 0x63, 0xdb, 0x07, 0xdb, 0x0a, 0xf6, 0xed, 0x32, 0x61, 0xd8, 0xc0, 0x0c, 0xab, 0xa5,
	0x42, 0xec, 0x83, 0x09, 0x50, 0x03, 0x50, 0x78, 0xd1, 0x7b, 0x0c, 0x53, 0x03, 0xbb, 0x86, 0xa7,
	0xce, 0x15, 0xa2, 0x15, 0x20, 0xa2, 0x26, 0xcf, 0x99, 0x60, 0x29, 0x3a, 0x1e, 0x73, 0x5a, 0xe7,
	0xfd, 0xe7, 0x9b, 0x2f, 0x44, 0x24, 0x82, 0x44, 0x75, 0x38, 0x12, 0x0e, 0x5f, 0xc6, 0x14, 0x9b,
	0xc4, 0x55, 0x17, 0x0a, 0xd1, 0xa4, 0xf0, 0xd0, 0x3d, 0x38, 0x19, 0xd9, 0xd8, 0x5e, 0x1e, 0x85,
	0xbb, 0xb6, 0x58, 0x88, 0xae, 0x1f, 0x34, 0xda, 0xe5, 0xeb, 0xb8, 0xed, 0x12, 0x3f, 0x1a, 0xc7,
	0x25, 0x5b, 0x1c, 0x49, 0x2d, 0x73, 0xc6, 0x73, 0x03, 0x19, 0x7b, 0xfb, 0x2f, 0xd4, 0x60, 0x12,
	0x15, 0x7d, 0x02, 0xc7, 0xc3, 0x58, 0xf8, 0x50, 0xf8, 0x84, 0xc0, 0xf9, 0xb6, 0x46, 0x79, 0xc2,
	0x9b, 0x16, 0x6b, 0x72, 0x90, 0x1d, 0xc3, 0x8b, 0x10, 0x67, 0x30, 0xa0, 0x07, 0x12, 0xac, 0x0b,
	0x16, 0x62, 0xb3, 0xdd, 0x76, 0x9d, 0xbb, 0xc4, 0xb8, 0xe6, 0x62, 0xea, 0x35, 0x88, 0xeb, 0xa9,
	0x87, 0x78, 0x28, 0x17, 0x06, 0x86, 0x92, 0x8d, 0x11, 0x89, 0x66, 0x28, 0xca, 0xca, 0x43, 0x19,
	0x0e, 0x5f, 0xf7, 0xa2, 0x37, 0x7a, 0xe8, 0x6b, 0x09, 0x2a, 0xe1, 0xcd, 0xbd, 0x5b, 0xae, 0x74,
	0x98, 0xe9, 0x58, 0xd4, 0xdc, 0x8f, 0xb6, 0x5b, 0x24, 0xdf, 0x1e, 0x18, 0xad, 0x0f, 0x9f, 0x85,
	0x12, 0x89, 0x77, 0x08, 0x4a, 0x71, 0x64, 0x3b, 0x54, 0x77, 0x5a, 0xb1, 0xc8, 0xe4, 0x1c, 0x91,
	0x25, 0x51, 0xfa, 0x46, 0x96, 0xa2, 0xac, 0x50, 0x38, 0x74, 0x03, 0xdb, 0x1d, 0x72, 0xa5, 0xcd,
	0xf8, 0x1a, 0xae, 0xc3, 0x92, 0x45, 0xef, 0x12, 0x97, 0x9d, 0x27, 0x0d, 0xdc, 0xb1, 0x99, 0x2a,
	0x9d, 0x92, 0xce, 0x2e, 0x6a, 0xf1, 0x41, 0xf4, 0x34, 0x94, 0xb1, 0x6d, 0xf3, 0x1b, 0xfd, 0xa8,
	0xfd, 0x2b, 0xf6, 0x07, 0xd0, 0x2a, 0x2c, 0x52, 0x27, 0x98, 0x54, 0xf8, 0x64, 0xf8, 0x77, 0xe5,
	0xcb, 0x45, 0x78, 0x2e, 0x7b, 0x5f, 0xb7, 0x9d, 0x56, 0xdd, 0xa2, 0x98, 0x3b, 0xc2, 0x87, 0x80,
	0x1a, 0xae, 0xd3, 0xba, 0xdc, 0x35, 0xca, 0x20, 0x3e, 0x1e, 0xce, 0xc1, 0x8d, 0x97, 0x07, 0x2e,
	0x51, 0xf4, 0xa1, 0x34, 0x01, 0x10, 0x7a, 0x1f, 0x8e, 0x30, 0x27, 0x01, 0x2e, 0xe7, 0x01, 0x4f,
	0xc1, 0xa0, 0x5d, 0x38, 0x61, 0x51, 0x8b, 0x59, 0x98, 0x11, 0x63, 0xeb, 0x7e, 0x82, 0x43, 0xc9,
	0xc3, 0x91, 0x8d, 0x87, 0x30, 0x2c, 0xb3, 0x60, 0xf5, 0x7c, 0xa5, 0x7b, 0x3d, 0x9e, 0x52, 0x1e,
	0x1e, 0x21, 0x14, 0xba, 0x09, 0x87, 0xeb, 0x41, 0xd5, 0xe8, 0xa1, 0xcf, 0xe5, 0x41, 0x4f, 0xa2,
	0x20, 0x1d, 0x56, 0x9c, 0x8f, 0x29, 0x71, 0xbd, 0xa6, 0xd5, 0x8e, 0x05, 0x3f, 0x9f, 0x07, 0x5e,
	0x8c, 0x85, 0x2c, 0x50, 0x31, 0x4f, 0x33, 0x6c, 0x5f, 0x73, 0xb1, 0xbe, 0x4b, 0xdc, 0x1d, 0xa3,
	0xc7, 0x03, 0x79, 0x78, 0x32, 0xe1, 0xfc, 0x8d, 0xd7, 0x9b, 0xd8, 0xb6, 0x09, 0x35, 0x49, 0x8a,
	0xab, 0x9c, 0x6b, 0xe3, 0x33, 0xf1, 0xfc, 0xc5, 0xe3, 0x9d, 0x2b, 0x63, 0xc4, 0x88, 0x2d, 0xde,
	0x42, 0xae, 0xc5, 0x13, 0x62, 0xf9, 0x24, 0x0d, 0xc7, 0xad, 0x5b, 0x86, 0x41, 0x68, 0x8c, 0x64,
	0x31, 0x17, 0x89, 0x10, 0xab, 0xf2, 0x60, 0x0e, 0xce, 0x64, 0xd7, 0x84, 0xa0, 0xe6, 0x04, 0xb5,
	0x65, 0x1d, 0x96, 0x22, 0x62, 0xde, 0x31, 0x78, 0x41, 0x28, 0x6b, 0xf1, 0x41, 0x74, 0x0a, 0x0e,
	0x86, 0xaa, 0xdc, 0x31, 0xb8, 0xae, 0xcb, 0x5a, 0x74, 0x08, 0x6d, 0xc0, 0x72, 0x5a, 0x53, 0x3b,
	0x06, 0x97, 0x67, 0x59, 0x13, 0xce, 0xa1, 0xab, 0xb0, 0x14, 0xd3, 0x47, 0xd0, 0x1a, 0xbe, 0x38,
	0xb8, 0x5e, 0x5b, 0x94, 0x69, 0x98, 0x9a, 0x44, 0x8b, 0x03, 0xa0, 0x8b, 0xb0, 0xd8, 0xd3, 0x44,
	0xd0, 0xf0, 0x8d, 0x02, 0x16, 0xde, 0x8b, 0x34, 0x78, 0x2a, 0x9e, 0xfc, 0x41, 0x57, 0x37, 0x0a,
	0x5a, 0x02, 0x01, 0xbd, 0x04, 0x47, 0x53, 0x89, 0xce, 0x05, 0x53, 0xd6, 0xd2, 0x13, 0xa8, 0x0a,
	0x28, 0x9d, 0xaa, 0x3c, 0xe7, 0xcb, 0x9a, 0x60, 0xc6, 0x8f, 0x38, 0x9e, 0x71, 0x41, 0x83, 0x38,
	0x52, 0xc4, 0x71, 0x04, 0x1f, 0x33, 0x9e, 0x60, 0x41, 0x17, 0x38, 0x12, 0x66, 0x1c, 0xa1, 0xf2,
	0xa9, 0x0c, 0xeb, 0xc3, 0xb4, 0x2d, 0x88, 0xc2, 0x92, 0x11, 0xcd, 0xd4, 0xc0, 0xa9, 0x2e, 0x15,
	0x68, 0x8a, 0x62, 0x99, 0xaf, 0xc5, 0xe1, 0xd1, 0x1d, 0x38, 0xa4, 0xef, 0xbb, 0x65, 0x6f, 0xf9,
	0x2e, 0x16, 0xa0, 0x8b, 0x98, 0xaf, 0x16, 0xc3, 0xae, 0x7c, 0xbf, 0x00, 0x67, 0xfa, 0x75, 0x43,
	0x51, 0xdb, 0x16, 0xf9, 0xaa, 0x34, 0x05, 0x5f, 0x95, 0xa7, 0xe4, 0xab, 0xca, 0x44, 0x7d, 0xb5,
	0x34, 0x59, 0x5f, 0x9d, 0x9b, 0xf9, 0x6a, 0x7e, 0x5f, 0x9d, 0x9f, 0x86, 0xaf, 0x2e, 0x8c, 0xd1,
	0x57, 0xff, 0x2e, 0xc1, 0x0b, 0xfd, 0x64, 0x1b, 0x77, 0xd6, 0x84, 0x67, 0x4a, 0xc3, 0x7b, 0xa6,
	0x3c, 0x8a, 0x67, 0x2a, 0xe3, 0xf4, 0xcc, 0xd2, 0x58, 0x3d, 0x73, 0xee, 0x3f, 0xe7, 0x99, 0xf3,
	0x13, 0xf0, 0xcc, 0x85, 0xc2, 0x9e, 0xf9, 0xb9, 0x0c, 0xcf, 0x0f, 0xf7, 0xf2, 0x8c, 0xda, 0x62,
	0xd7, 0x7c, 0xa7, 0xd0, 0xcb, 0x79, 0x5f, 0xdf, 0xb4, 0x13, 0xbe, 0xd9, 0x7d, 0xe7, 0xbe, 0x54,
	0x88, 0x30, 0xdb, 0x39, 0x7f, 0x48, 0x38, 0x67, 0xf2, 0x05, 0x7c, 0x8a, 0x2f, 0xbc, 0x33, 0xf7,
	0x9c, 0xb9, 0xe7, 0xcc, 0x3d, 0x87, 0x77, 0xcf, 0x27, 0x09, 0xf7, 0x4c, 0x4a, 0x37, 0xcf, 0x7b,
	0xe9, 0xcc, 0x41, 0x67, 0x0e, 0x9a, 0xc7, 0x41, 0xb3, 0xff, 0xc9, 0x3b, 0x1e, 0x07, 0xed, 0x9b,
	0xdb, 0x93, 0x70, 0xd0, 0x3e, 0x3e, 0x98, 0x70, 0xd0, 0x6f, 0x15, 0x38, 0x11, 0xff, 0x64, 0x12,
	0xf5, 0x4c, 0x81, 0x09, 0x48, 0x93, 0x35, 0x01, 0x79, 0x8c, 0x26, 0x90, 0x59, 0x2c, 0x95, 0x69,
	0x14, 0xcb, 0xd2, 0x18, 0x8b, 0xe5, 0x9f, 0x32, 0x9c, 0x8c, 0xef, 0x52, 0xbc, 0x3c, 0x46, 0x4b,
	0x8e, 0x34, 0xd6, 0x92, 0x23, 0x17, 0x2e, 0x39, 0xe9, 0xa2, 0xa0, 0x4c, 0xa0, 0x28, 0x94, 0x0a,
	0x17, 0x85, 0xdf, 0x25, 0x50, 0xb3, 0x3e, 0x1e, 0xa2, 0xba, 0xb8, 0x0c, 0xbc, 0x35, 0xe2, 0xe7,
	0xc8, 0xbe, 0xc2, 0xff, 0x48, 0x28, 0xfc, 0x37, 0x47, 0xa4, 0xc8, 0x96, 0xfa, 0x8f, 0x12, 0x1c,
	0x13, 0x25, 0x4f, 0x7a, 0x83, 0xa4, 0x09, 0x6c, 0x90, 0x5c, 0x78, 0x83, 0x7e, 0x93, 0xe0, 0x68,
	0xba, 0x44, 0x65, 0x8a, 0x5c, 0x9a, 0x86, 0xc8, 0xe5, 0x31, 0x8a, 0xfc, 0x27, 0x09, 0x8e, 0xa4,
	0x12, 0xef, 0x96, 0x38, 0xf1, 0x5e, 0x1b, 0xf2, 0x0c, 0x4a, 0xdf, 0x84, 0xbb, 0x21, 0x4c, 0xb8,
	0x8d, 0x21, 0xa1, 0xb3, 0x13, 0xed, 0xa1, 0x0c, 0xc7, 0x23, 0x9f, 0xc5, 0xa3, 0xbb, 0xe5, 0xbf,
	0xb8, 0x58, 0x2d, 0x62, 0x5b, 0x94, 0x14, 0xdf, 0x2c, 0x21, 0x54, 0x76, 0x42, 0xc8, 0xd3, 0x48,
	0x08, 0x65, 0x8c, 0x09, 0xf1, 0x95, 0x0c, 0x6a, 0x64, 0x1d, 0xe3, 0xaa, 0xf5, 0xfb, 0xd6, 0xe8,
	0xe3, 0xe7, 0x10, 0x6d, 0x1c, 0x40, 0x50, 0x07, 0xe4, 0x09, 0xd4, 0x01, 0xa5, 0x70, 0x1d, 0xf8,
	0x45, 0x82, 0x15, 0xe1, 0xb9, 0x12, 0x74, 0x5b, 0x2c, 0x96, 0x73, 0xa3, 0x1c, 0xe2, 0xe8, 0xab,
	0x98, 0x0f, 0x84, 0x8a, 0x79, 0x63, 0x14, 0xfc, 0x6c, 0xd9, 0x7c, 0xa7, 0x40, 0x25, 0xe3, 0x34,
	0xc9, 0x94, 0x25, 0x24, 0x68, 0xfb, 0xe4, 0x71, 0xb5, 0x7d, 0xff, 0x93, 0x8e, 0xec, 0x2f, 0x19,
	0xd6, 0x33, 0x36, 0x6b, 0x32, 0xad, 0x59, 0x4a, 0xef, 0xf2, 0xf8, 0xf5, 0xfe, 0xef, 0x6c, 0xcc,
	0x9e, 0x48, 0x70, 0x7a, 0xe0, 0x29, 0x2b, 0xb4, 0x2b, 0xd6, 0xfe, 0x85, 0xbc, 0x07, 0xb8, 0xfa,
	0xd6, 0x01, 0x53, 0x58, 0x07, 0xb6, 0xf3, 0x72, 0x65, 0xd6, 0x84, 0xad, 0x77, 0x7f, 0x7e, 0xbc,
	0x26, 0x3d, 0x7a, 0xbc, 0x26, 0xfd, 0xf1, 0x78, 0x4d, 0xfa, 0x62, 0x6f, 0xed, 0xc0, 0xa3, 0xbd,
	0xb5, 0x03, 0xbf, 0xee, 0xad, 0x1d, 0xb8, 0xb5, 0x61, 0x5a, 0xac, 0xd9, 0xa9, 0x57, 0x75, 0xa7,
	0x55, 0x0b, 0xc9, 0x6a, 0x71, 0xda, 0xda, 0xbd, 0x5a, 0x30, 0xce, 0xee, 0xb7, 0x89, 0x57, 0x9f,
	0xe7, 0xe7, 0x5e, 0x5f, 0xfd, 0x27, 0x00, 0x00, 0xff, 0xff, 0xbf, 0xe5, 0x43, 0xdd, 0x9b, 0x2b,
	0x00, 0x00,
}

func (m *CollectionPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateCollectionApprovedTransfers) > 0 {
		for iNdEx := len(m.CanUpdateCollectionApprovedTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionApprovedTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.CanUpdateBadgeMetadata) > 0 {
		for iNdEx := len(m.CanUpdateBadgeMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateBadgeMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.CanCreateMoreBadges) > 0 {
		for iNdEx := len(m.CanCreateMoreBadges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanCreateMoreBadges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for iNdEx := len(m.CanUpdateCollectionMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for iNdEx := len(m.CanUpdateManager) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateManager[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for iNdEx := len(m.CanUpdateCustomData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCustomData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CanUpdateStandards) > 0 {
		for iNdEx := len(m.CanUpdateStandards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateStandards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CanUpdateOffChainBalancesMetadata) > 0 {
		for iNdEx := len(m.CanUpdateOffChainBalancesMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateOffChainBalancesMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CanUpdateContractAddress) > 0 {
		for iNdEx := len(m.CanUpdateContractAddress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateContractAddress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CanArchiveCollection) > 0 {
		for iNdEx := len(m.CanArchiveCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanArchiveCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CanDeleteCollection) > 0 {
		for iNdEx := len(m.CanDeleteCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanDeleteCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateApprovedIncomingTransfers) > 0 {
		for iNdEx := len(m.CanUpdateApprovedIncomingTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateApprovedIncomingTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CanUpdateApprovedOutgoingTransfers) > 0 {
		for iNdEx := len(m.CanUpdateApprovedOutgoingTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateApprovedOutgoingTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ValueOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoValues {
		i--
		if m.NoValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AllValues {
		i--
		if m.AllValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.InvertDefault {
		i--
		if m.InvertDefault {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApprovedTransferCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApprovedTransferCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApprovedTransferCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApprovalTrackerIdOptions != nil {
		{
			size, err := m.ApprovalTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ChallengeTrackerIdOptions != nil {
		{
			size, err := m.ChallengeTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.OwnershipTimesOptions != nil {
		{
			size, err := m.OwnershipTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TransferTimesOptions != nil {
		{
			size, err := m.TransferTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.InitiatedByMappingOptions != nil {
		{
			size, err := m.InitiatedByMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ToMappingOptions != nil {
		{
			size, err := m.ToMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FromMappingOptions != nil {
		{
			size, err := m.FromMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApprovedTransferDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApprovedTransferDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApprovedTransferDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalTrackerId) > 0 {
		i -= len(m.ApprovalTrackerId)
		copy(dAtA[i:], m.ApprovalTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ApprovalTrackerId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ToMappingId) > 0 {
		i -= len(m.ToMappingId)
		copy(dAtA[i:], m.ToMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ToMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromMappingId) > 0 {
		i -= len(m.FromMappingId)
		copy(dAtA[i:], m.FromMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.FromMappingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApprovedTransferPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApprovedTransferPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApprovedTransferPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedOutgoingTransferCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedOutgoingTransferCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedOutgoingTransferCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApprovalTrackerIdOptions != nil {
		{
			size, err := m.ApprovalTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ChallengeTrackerIdOptions != nil {
		{
			size, err := m.ChallengeTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.OwnershipTimesOptions != nil {
		{
			size, err := m.OwnershipTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TransferTimesOptions != nil {
		{
			size, err := m.TransferTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.InitiatedByMappingOptions != nil {
		{
			size, err := m.InitiatedByMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ToMappingOptions != nil {
		{
			size, err := m.ToMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedOutgoingTransferDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedOutgoingTransferDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedOutgoingTransferDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalTrackerId) > 0 {
		i -= len(m.ApprovalTrackerId)
		copy(dAtA[i:], m.ApprovalTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ApprovalTrackerId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToMappingId) > 0 {
		i -= len(m.ToMappingId)
		copy(dAtA[i:], m.ToMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ToMappingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedOutgoingTransferPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedOutgoingTransferPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedOutgoingTransferPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedIncomingTransferCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedIncomingTransferCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedIncomingTransferCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApprovalTrackerIdOptions != nil {
		{
			size, err := m.ApprovalTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ChallengeTrackerIdOptions != nil {
		{
			size, err := m.ChallengeTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.OwnershipTimesOptions != nil {
		{
			size, err := m.OwnershipTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TransferTimesOptions != nil {
		{
			size, err := m.TransferTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.InitiatedByMappingOptions != nil {
		{
			size, err := m.InitiatedByMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FromMappingOptions != nil {
		{
			size, err := m.FromMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedIncomingTransferDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedIncomingTransferDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedIncomingTransferDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalTrackerId) > 0 {
		i -= len(m.ApprovalTrackerId)
		copy(dAtA[i:], m.ApprovalTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ApprovalTrackerId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromMappingId) > 0 {
		i -= len(m.FromMappingId)
		copy(dAtA[i:], m.FromMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.FromMappingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedIncomingTransferPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedIncomingTransferPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedIncomingTransferPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BalancesActionCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BalancesActionCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BalancesActionCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.OwnershipTimesOptions != nil {
		{
			size, err := m.OwnershipTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BalancesActionDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BalancesActionDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BalancesActionDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BalancesActionPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BalancesActionPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BalancesActionPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TimelineTimesOptions != nil {
		{
			size, err := m.TimelineTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdatePermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdatePermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdatePermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateWithBadgeIdsCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateWithBadgeIdsCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateWithBadgeIdsCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TimelineTimesOptions != nil {
		{
			size, err := m.TimelineTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateWithBadgeIdsPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateWithBadgeIdsPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateWithBadgeIdsPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPermissions(dAtA []byte, offset int, v uint64) int {
	offset -= sovPermissions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CollectionPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CanDeleteCollection) > 0 {
		for _, e := range m.CanDeleteCollection {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanArchiveCollection) > 0 {
		for _, e := range m.CanArchiveCollection {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateContractAddress) > 0 {
		for _, e := range m.CanUpdateContractAddress {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateOffChainBalancesMetadata) > 0 {
		for _, e := range m.CanUpdateOffChainBalancesMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateStandards) > 0 {
		for _, e := range m.CanUpdateStandards {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for _, e := range m.CanUpdateCustomData {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for _, e := range m.CanUpdateManager {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for _, e := range m.CanUpdateCollectionMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanCreateMoreBadges) > 0 {
		for _, e := range m.CanCreateMoreBadges {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateBadgeMetadata) > 0 {
		for _, e := range m.CanUpdateBadgeMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionApprovedTransfers) > 0 {
		for _, e := range m.CanUpdateCollectionApprovedTransfers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CanUpdateApprovedOutgoingTransfers) > 0 {
		for _, e := range m.CanUpdateApprovedOutgoingTransfers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateApprovedIncomingTransfers) > 0 {
		for _, e := range m.CanUpdateApprovedIncomingTransfers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ValueOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvertDefault {
		n += 2
	}
	if m.AllValues {
		n += 2
	}
	if m.NoValues {
		n += 2
	}
	return n
}

func (m *CollectionApprovedTransferCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FromMappingOptions != nil {
		l = m.FromMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ToMappingOptions != nil {
		l = m.ToMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.InitiatedByMappingOptions != nil {
		l = m.InitiatedByMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.TransferTimesOptions != nil {
		l = m.TransferTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.OwnershipTimesOptions != nil {
		l = m.OwnershipTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ChallengeTrackerIdOptions != nil {
		l = m.ChallengeTrackerIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ApprovalTrackerIdOptions != nil {
		l = m.ApprovalTrackerIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *CollectionApprovedTransferDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ToMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ApprovalTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *CollectionApprovedTransferPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserApprovedOutgoingTransferCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToMappingOptions != nil {
		l = m.ToMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.InitiatedByMappingOptions != nil {
		l = m.InitiatedByMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.TransferTimesOptions != nil {
		l = m.TransferTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.OwnershipTimesOptions != nil {
		l = m.OwnershipTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ChallengeTrackerIdOptions != nil {
		l = m.ChallengeTrackerIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ApprovalTrackerIdOptions != nil {
		l = m.ApprovalTrackerIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *UserApprovedOutgoingTransferDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ApprovalTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *UserApprovedOutgoingTransferPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserApprovedIncomingTransferCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FromMappingOptions != nil {
		l = m.FromMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.InitiatedByMappingOptions != nil {
		l = m.InitiatedByMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.TransferTimesOptions != nil {
		l = m.TransferTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.OwnershipTimesOptions != nil {
		l = m.OwnershipTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ChallengeTrackerIdOptions != nil {
		l = m.ChallengeTrackerIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ApprovalTrackerIdOptions != nil {
		l = m.ApprovalTrackerIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *UserApprovedIncomingTransferDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ApprovalTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *UserApprovedIncomingTransferPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *BalancesActionCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.OwnershipTimesOptions != nil {
		l = m.OwnershipTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *BalancesActionDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *BalancesActionPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ActionDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ActionCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *ActionPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *TimedUpdateCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimelineTimesOptions != nil {
		l = m.TimelineTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *TimedUpdateDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *TimedUpdatePermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *TimedUpdateWithBadgeIdsCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimelineTimesOptions != nil {
		l = m.TimelineTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *TimedUpdateWithBadgeIdsPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func sovPermissions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPermissions(x uint64) (n int) {
	return sovPermissions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CollectionPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDeleteCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanDeleteCollection = append(m.CanDeleteCollection, &ActionPermission{})
			if err := m.CanDeleteCollection[len(m.CanDeleteCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanArchiveCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanArchiveCollection = append(m.CanArchiveCollection, &TimedUpdatePermission{})
			if err := m.CanArchiveCollection[len(m.CanArchiveCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateContractAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateContractAddress = append(m.CanUpdateContractAddress, &TimedUpdatePermission{})
			if err := m.CanUpdateContractAddress[len(m.CanUpdateContractAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateOffChainBalancesMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateOffChainBalancesMetadata = append(m.CanUpdateOffChainBalancesMetadata, &TimedUpdatePermission{})
			if err := m.CanUpdateOffChainBalancesMetadata[len(m.CanUpdateOffChainBalancesMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateStandards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateStandards = append(m.CanUpdateStandards, &TimedUpdatePermission{})
			if err := m.CanUpdateStandards[len(m.CanUpdateStandards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCustomData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCustomData = append(m.CanUpdateCustomData, &TimedUpdatePermission{})
			if err := m.CanUpdateCustomData[len(m.CanUpdateCustomData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateManager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateManager = append(m.CanUpdateManager, &TimedUpdatePermission{})
			if err := m.CanUpdateManager[len(m.CanUpdateManager)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionMetadata = append(m.CanUpdateCollectionMetadata, &TimedUpdatePermission{})
			if err := m.CanUpdateCollectionMetadata[len(m.CanUpdateCollectionMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanCreateMoreBadges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanCreateMoreBadges = append(m.CanCreateMoreBadges, &BalancesActionPermission{})
			if err := m.CanCreateMoreBadges[len(m.CanCreateMoreBadges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateBadgeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateBadgeMetadata = append(m.CanUpdateBadgeMetadata, &TimedUpdateWithBadgeIdsPermission{})
			if err := m.CanUpdateBadgeMetadata[len(m.CanUpdateBadgeMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionApprovedTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionApprovedTransfers = append(m.CanUpdateCollectionApprovedTransfers, &CollectionApprovedTransferPermission{})
			if err := m.CanUpdateCollectionApprovedTransfers[len(m.CanUpdateCollectionApprovedTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateApprovedOutgoingTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateApprovedOutgoingTransfers = append(m.CanUpdateApprovedOutgoingTransfers, &UserApprovedOutgoingTransferPermission{})
			if err := m.CanUpdateApprovedOutgoingTransfers[len(m.CanUpdateApprovedOutgoingTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateApprovedIncomingTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateApprovedIncomingTransfers = append(m.CanUpdateApprovedIncomingTransfers, &UserApprovedIncomingTransferPermission{})
			if err := m.CanUpdateApprovedIncomingTransfers[len(m.CanUpdateApprovedIncomingTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertDefault = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllValues = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoValues = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApprovedTransferCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApprovedTransferCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApprovedTransferCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FromMappingOptions == nil {
				m.FromMappingOptions = &ValueOptions{}
			}
			if err := m.FromMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToMappingOptions == nil {
				m.ToMappingOptions = &ValueOptions{}
			}
			if err := m.ToMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedByMappingOptions == nil {
				m.InitiatedByMappingOptions = &ValueOptions{}
			}
			if err := m.InitiatedByMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTimesOptions == nil {
				m.TransferTimesOptions = &ValueOptions{}
			}
			if err := m.TransferTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnershipTimesOptions == nil {
				m.OwnershipTimesOptions = &ValueOptions{}
			}
			if err := m.OwnershipTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChallengeTrackerIdOptions == nil {
				m.ChallengeTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ChallengeTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalTrackerIdOptions == nil {
				m.ApprovalTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ApprovalTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApprovedTransferDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApprovedTransferDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApprovedTransferDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApprovedTransferPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApprovedTransferPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApprovedTransferPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &CollectionApprovedTransferDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &CollectionApprovedTransferCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedOutgoingTransferCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedOutgoingTransferCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedOutgoingTransferCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToMappingOptions == nil {
				m.ToMappingOptions = &ValueOptions{}
			}
			if err := m.ToMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedByMappingOptions == nil {
				m.InitiatedByMappingOptions = &ValueOptions{}
			}
			if err := m.InitiatedByMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTimesOptions == nil {
				m.TransferTimesOptions = &ValueOptions{}
			}
			if err := m.TransferTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnershipTimesOptions == nil {
				m.OwnershipTimesOptions = &ValueOptions{}
			}
			if err := m.OwnershipTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChallengeTrackerIdOptions == nil {
				m.ChallengeTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ChallengeTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalTrackerIdOptions == nil {
				m.ApprovalTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ApprovalTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedOutgoingTransferDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedOutgoingTransferDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedOutgoingTransferDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedOutgoingTransferPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedOutgoingTransferPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedOutgoingTransferPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &UserApprovedOutgoingTransferDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &UserApprovedOutgoingTransferCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedIncomingTransferCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedIncomingTransferCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedIncomingTransferCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FromMappingOptions == nil {
				m.FromMappingOptions = &ValueOptions{}
			}
			if err := m.FromMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedByMappingOptions == nil {
				m.InitiatedByMappingOptions = &ValueOptions{}
			}
			if err := m.InitiatedByMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTimesOptions == nil {
				m.TransferTimesOptions = &ValueOptions{}
			}
			if err := m.TransferTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnershipTimesOptions == nil {
				m.OwnershipTimesOptions = &ValueOptions{}
			}
			if err := m.OwnershipTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChallengeTrackerIdOptions == nil {
				m.ChallengeTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ChallengeTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalTrackerIdOptions == nil {
				m.ApprovalTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ApprovalTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedIncomingTransferDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedIncomingTransferDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedIncomingTransferDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedIncomingTransferPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedIncomingTransferPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedIncomingTransferPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &UserApprovedIncomingTransferDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &UserApprovedIncomingTransferCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BalancesActionCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BalancesActionCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BalancesActionCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnershipTimesOptions == nil {
				m.OwnershipTimesOptions = &ValueOptions{}
			}
			if err := m.OwnershipTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BalancesActionDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BalancesActionDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BalancesActionDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BalancesActionPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BalancesActionPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BalancesActionPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &BalancesActionDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &BalancesActionCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &ActionDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &ActionCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimelineTimesOptions == nil {
				m.TimelineTimesOptions = &ValueOptions{}
			}
			if err := m.TimelineTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &UintRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdatePermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdatePermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdatePermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &TimedUpdateDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &TimedUpdateCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateWithBadgeIdsCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimelineTimesOptions == nil {
				m.TimelineTimesOptions = &ValueOptions{}
			}
			if err := m.TimelineTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &UintRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateWithBadgeIdsPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &TimedUpdateWithBadgeIdsDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &TimedUpdateWithBadgeIdsCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPermissions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPermissions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPermissions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPermissions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPermissions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPermissions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPermissions = fmt.Errorf("proto: unexpected end of group")
)
