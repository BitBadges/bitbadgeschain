// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/permissions.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CollectionPermissions struct {
	CanDeleteCollection               []*ActionPermission                     `protobuf:"bytes,1,rep,name=canDeleteCollection,proto3" json:"canDeleteCollection,omitempty"`
	CanArchive                        []*TimedUpdatePermission                `protobuf:"bytes,2,rep,name=canArchive,proto3" json:"canArchive,omitempty"`
	CanUpdateContractAddress          []*TimedUpdatePermission                `protobuf:"bytes,3,rep,name=canUpdateContractAddress,proto3" json:"canUpdateContractAddress,omitempty"`
	CanUpdateOffChainBalancesMetadata []*TimedUpdatePermission                `protobuf:"bytes,4,rep,name=canUpdateOffChainBalancesMetadata,proto3" json:"canUpdateOffChainBalancesMetadata,omitempty"`
	CanUpdateCustomData               []*TimedUpdatePermission                `protobuf:"bytes,5,rep,name=canUpdateCustomData,proto3" json:"canUpdateCustomData,omitempty"`
	CanUpdateManager                  []*TimedUpdatePermission                `protobuf:"bytes,6,rep,name=canUpdateManager,proto3" json:"canUpdateManager,omitempty"`
	CanUpdateCollectionMetadata       []*TimedUpdatePermission                `protobuf:"bytes,7,rep,name=canUpdateCollectionMetadata,proto3" json:"canUpdateCollectionMetadata,omitempty"`
	CanCreateMoreBadges               []*ActionWithBadgeIdsPermission         `protobuf:"bytes,8,rep,name=canCreateMoreBadges,proto3" json:"canCreateMoreBadges,omitempty"`
	CanUpdateBadgeMetadata            []*TimedUpdateWithBadgeIdsPermission    `protobuf:"bytes,9,rep,name=canUpdateBadgeMetadata,proto3" json:"canUpdateBadgeMetadata,omitempty"`
	CanUpdateInheritedBalances        []*TimedUpdateWithBadgeIdsPermission    `protobuf:"bytes,10,rep,name=canUpdateInheritedBalances,proto3" json:"canUpdateInheritedBalances,omitempty"`
	CanUpdateApprovedTransfers        []*CollectionApprovedTransferPermission `protobuf:"bytes,11,rep,name=canUpdateApprovedTransfers,proto3" json:"canUpdateApprovedTransfers,omitempty"`
}

func (m *CollectionPermissions) Reset()         { *m = CollectionPermissions{} }
func (m *CollectionPermissions) String() string { return proto.CompactTextString(m) }
func (*CollectionPermissions) ProtoMessage()    {}
func (*CollectionPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{0}
}
func (m *CollectionPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionPermissions.Merge(m, src)
}
func (m *CollectionPermissions) XXX_Size() int {
	return m.Size()
}
func (m *CollectionPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionPermissions proto.InternalMessageInfo

func (m *CollectionPermissions) GetCanDeleteCollection() []*ActionPermission {
	if m != nil {
		return m.CanDeleteCollection
	}
	return nil
}

func (m *CollectionPermissions) GetCanArchive() []*TimedUpdatePermission {
	if m != nil {
		return m.CanArchive
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateContractAddress() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateContractAddress
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateOffChainBalancesMetadata() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateOffChainBalancesMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCustomData() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCustomData
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateManager() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateManager
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCollectionMetadata() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCollectionMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanCreateMoreBadges() []*ActionWithBadgeIdsPermission {
	if m != nil {
		return m.CanCreateMoreBadges
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateBadgeMetadata() []*TimedUpdateWithBadgeIdsPermission {
	if m != nil {
		return m.CanUpdateBadgeMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateInheritedBalances() []*TimedUpdateWithBadgeIdsPermission {
	if m != nil {
		return m.CanUpdateInheritedBalances
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateApprovedTransfers() []*CollectionApprovedTransferPermission {
	if m != nil {
		return m.CanUpdateApprovedTransfers
	}
	return nil
}

type UserPermissions struct {
	CanUpdateApprovedTransfers []*UserApprovedTransferPermission `protobuf:"bytes,1,rep,name=canUpdateApprovedTransfers,proto3" json:"canUpdateApprovedTransfers,omitempty"`
}

func (m *UserPermissions) Reset()         { *m = UserPermissions{} }
func (m *UserPermissions) String() string { return proto.CompactTextString(m) }
func (*UserPermissions) ProtoMessage()    {}
func (*UserPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{1}
}
func (m *UserPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPermissions.Merge(m, src)
}
func (m *UserPermissions) XXX_Size() int {
	return m.Size()
}
func (m *UserPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_UserPermissions proto.InternalMessageInfo

func (m *UserPermissions) GetCanUpdateApprovedTransfers() []*UserApprovedTransferPermission {
	if m != nil {
		return m.CanUpdateApprovedTransfers
	}
	return nil
}

type ValueOptions struct {
	InvertDefault bool `protobuf:"varint,1,opt,name=invertDefault,proto3" json:"invertDefault,omitempty"`
	AllValues     bool `protobuf:"varint,2,opt,name=allValues,proto3" json:"allValues,omitempty"`
	NoValues      bool `protobuf:"varint,3,opt,name=noValues,proto3" json:"noValues,omitempty"`
}

func (m *ValueOptions) Reset()         { *m = ValueOptions{} }
func (m *ValueOptions) String() string { return proto.CompactTextString(m) }
func (*ValueOptions) ProtoMessage()    {}
func (*ValueOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{2}
}
func (m *ValueOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueOptions.Merge(m, src)
}
func (m *ValueOptions) XXX_Size() int {
	return m.Size()
}
func (m *ValueOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ValueOptions proto.InternalMessageInfo

func (m *ValueOptions) GetInvertDefault() bool {
	if m != nil {
		return m.InvertDefault
	}
	return false
}

func (m *ValueOptions) GetAllValues() bool {
	if m != nil {
		return m.AllValues
	}
	return false
}

func (m *ValueOptions) GetNoValues() bool {
	if m != nil {
		return m.NoValues
	}
	return false
}

type CollectionApprovedTransferCombination struct {
	TimelineTimesOptions        *ValueOptions `protobuf:"bytes,1,opt,name=timelineTimesOptions,proto3" json:"timelineTimesOptions,omitempty"`
	FromMappingIdOptions        *ValueOptions `protobuf:"bytes,2,opt,name=fromMappingIdOptions,proto3" json:"fromMappingIdOptions,omitempty"`
	ToMappingIdOptions          *ValueOptions `protobuf:"bytes,3,opt,name=toMappingIdOptions,proto3" json:"toMappingIdOptions,omitempty"`
	InitiatedByMappingIdOptions *ValueOptions `protobuf:"bytes,4,opt,name=initiatedByMappingIdOptions,proto3" json:"initiatedByMappingIdOptions,omitempty"`
	TransferTimesOptions        *ValueOptions `protobuf:"bytes,5,opt,name=transferTimesOptions,proto3" json:"transferTimesOptions,omitempty"`
	BadgeIdsOptions             *ValueOptions `protobuf:"bytes,6,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	PermittedTimesOptions       *ValueOptions `protobuf:"bytes,7,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions       *ValueOptions `protobuf:"bytes,8,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *CollectionApprovedTransferCombination) Reset()         { *m = CollectionApprovedTransferCombination{} }
func (m *CollectionApprovedTransferCombination) String() string { return proto.CompactTextString(m) }
func (*CollectionApprovedTransferCombination) ProtoMessage()    {}
func (*CollectionApprovedTransferCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{3}
}
func (m *CollectionApprovedTransferCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApprovedTransferCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApprovedTransferCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApprovedTransferCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApprovedTransferCombination.Merge(m, src)
}
func (m *CollectionApprovedTransferCombination) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApprovedTransferCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApprovedTransferCombination.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApprovedTransferCombination proto.InternalMessageInfo

func (m *CollectionApprovedTransferCombination) GetTimelineTimesOptions() *ValueOptions {
	if m != nil {
		return m.TimelineTimesOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetFromMappingIdOptions() *ValueOptions {
	if m != nil {
		return m.FromMappingIdOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetToMappingIdOptions() *ValueOptions {
	if m != nil {
		return m.ToMappingIdOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetInitiatedByMappingIdOptions() *ValueOptions {
	if m != nil {
		return m.InitiatedByMappingIdOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetTransferTimesOptions() *ValueOptions {
	if m != nil {
		return m.TransferTimesOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *CollectionApprovedTransferCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type CollectionApprovedTransferDefaultValues struct {
	TimelineTimes        []*IdRange `protobuf:"bytes,1,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
	FromMappingId        string     `protobuf:"bytes,2,opt,name=fromMappingId,proto3" json:"fromMappingId,omitempty"`
	ToMappingId          string     `protobuf:"bytes,3,opt,name=toMappingId,proto3" json:"toMappingId,omitempty"`
	InitiatedByMappingId string     `protobuf:"bytes,4,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	TransferTimes        []*IdRange `protobuf:"bytes,5,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	BadgeIds             []*IdRange `protobuf:"bytes,6,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	PermittedTimes       []*IdRange `protobuf:"bytes,7,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes       []*IdRange `protobuf:"bytes,8,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *CollectionApprovedTransferDefaultValues) Reset() {
	*m = CollectionApprovedTransferDefaultValues{}
}
func (m *CollectionApprovedTransferDefaultValues) String() string { return proto.CompactTextString(m) }
func (*CollectionApprovedTransferDefaultValues) ProtoMessage()    {}
func (*CollectionApprovedTransferDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{4}
}
func (m *CollectionApprovedTransferDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApprovedTransferDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApprovedTransferDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApprovedTransferDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApprovedTransferDefaultValues.Merge(m, src)
}
func (m *CollectionApprovedTransferDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApprovedTransferDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApprovedTransferDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApprovedTransferDefaultValues proto.InternalMessageInfo

func (m *CollectionApprovedTransferDefaultValues) GetTimelineTimes() []*IdRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

func (m *CollectionApprovedTransferDefaultValues) GetFromMappingId() string {
	if m != nil {
		return m.FromMappingId
	}
	return ""
}

func (m *CollectionApprovedTransferDefaultValues) GetToMappingId() string {
	if m != nil {
		return m.ToMappingId
	}
	return ""
}

func (m *CollectionApprovedTransferDefaultValues) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *CollectionApprovedTransferDefaultValues) GetTransferTimes() []*IdRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *CollectionApprovedTransferDefaultValues) GetBadgeIds() []*IdRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *CollectionApprovedTransferDefaultValues) GetPermittedTimes() []*IdRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *CollectionApprovedTransferDefaultValues) GetForbiddenTimes() []*IdRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

type CollectionApprovedTransferPermission struct {
	DefaultValues *CollectionApprovedTransferDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*CollectionApprovedTransferCombination `protobuf:"bytes,7,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *CollectionApprovedTransferPermission) Reset()         { *m = CollectionApprovedTransferPermission{} }
func (m *CollectionApprovedTransferPermission) String() string { return proto.CompactTextString(m) }
func (*CollectionApprovedTransferPermission) ProtoMessage()    {}
func (*CollectionApprovedTransferPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{5}
}
func (m *CollectionApprovedTransferPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApprovedTransferPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApprovedTransferPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApprovedTransferPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApprovedTransferPermission.Merge(m, src)
}
func (m *CollectionApprovedTransferPermission) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApprovedTransferPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApprovedTransferPermission.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApprovedTransferPermission proto.InternalMessageInfo

func (m *CollectionApprovedTransferPermission) GetDefaultValues() *CollectionApprovedTransferDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *CollectionApprovedTransferPermission) GetCombinations() []*CollectionApprovedTransferCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

type UserApprovedTransferCombination struct {
	TimelineTimesOptions        *ValueOptions `protobuf:"bytes,1,opt,name=timelineTimesOptions,proto3" json:"timelineTimesOptions,omitempty"`
	ToMappingIdOptions          *ValueOptions `protobuf:"bytes,2,opt,name=toMappingIdOptions,proto3" json:"toMappingIdOptions,omitempty"`
	InitiatedByMappingIdOptions *ValueOptions `protobuf:"bytes,3,opt,name=initiatedByMappingIdOptions,proto3" json:"initiatedByMappingIdOptions,omitempty"`
	TransferTimesOptions        *ValueOptions `protobuf:"bytes,4,opt,name=transferTimesOptions,proto3" json:"transferTimesOptions,omitempty"`
	BadgeIdsOptions             *ValueOptions `protobuf:"bytes,5,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	PermittedTimesOptions       *ValueOptions `protobuf:"bytes,6,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions       *ValueOptions `protobuf:"bytes,7,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *UserApprovedTransferCombination) Reset()         { *m = UserApprovedTransferCombination{} }
func (m *UserApprovedTransferCombination) String() string { return proto.CompactTextString(m) }
func (*UserApprovedTransferCombination) ProtoMessage()    {}
func (*UserApprovedTransferCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{6}
}
func (m *UserApprovedTransferCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedTransferCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedTransferCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedTransferCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedTransferCombination.Merge(m, src)
}
func (m *UserApprovedTransferCombination) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedTransferCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedTransferCombination.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedTransferCombination proto.InternalMessageInfo

func (m *UserApprovedTransferCombination) GetTimelineTimesOptions() *ValueOptions {
	if m != nil {
		return m.TimelineTimesOptions
	}
	return nil
}

func (m *UserApprovedTransferCombination) GetToMappingIdOptions() *ValueOptions {
	if m != nil {
		return m.ToMappingIdOptions
	}
	return nil
}

func (m *UserApprovedTransferCombination) GetInitiatedByMappingIdOptions() *ValueOptions {
	if m != nil {
		return m.InitiatedByMappingIdOptions
	}
	return nil
}

func (m *UserApprovedTransferCombination) GetTransferTimesOptions() *ValueOptions {
	if m != nil {
		return m.TransferTimesOptions
	}
	return nil
}

func (m *UserApprovedTransferCombination) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *UserApprovedTransferCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *UserApprovedTransferCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type UserApprovedTransferDefaultValues struct {
	TimelineTimes        []*IdRange `protobuf:"bytes,1,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
	ToMappingId          string     `protobuf:"bytes,2,opt,name=toMappingId,proto3" json:"toMappingId,omitempty"`
	InitiatedByMappingId string     `protobuf:"bytes,3,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	TransferTimes        []*IdRange `protobuf:"bytes,4,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	BadgeIds             []*IdRange `protobuf:"bytes,5,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	PermittedTimes       []*IdRange `protobuf:"bytes,7,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes       []*IdRange `protobuf:"bytes,8,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *UserApprovedTransferDefaultValues) Reset()         { *m = UserApprovedTransferDefaultValues{} }
func (m *UserApprovedTransferDefaultValues) String() string { return proto.CompactTextString(m) }
func (*UserApprovedTransferDefaultValues) ProtoMessage()    {}
func (*UserApprovedTransferDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{7}
}
func (m *UserApprovedTransferDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedTransferDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedTransferDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedTransferDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedTransferDefaultValues.Merge(m, src)
}
func (m *UserApprovedTransferDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedTransferDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedTransferDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedTransferDefaultValues proto.InternalMessageInfo

func (m *UserApprovedTransferDefaultValues) GetTimelineTimes() []*IdRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

func (m *UserApprovedTransferDefaultValues) GetToMappingId() string {
	if m != nil {
		return m.ToMappingId
	}
	return ""
}

func (m *UserApprovedTransferDefaultValues) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *UserApprovedTransferDefaultValues) GetTransferTimes() []*IdRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserApprovedTransferDefaultValues) GetBadgeIds() []*IdRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserApprovedTransferDefaultValues) GetPermittedTimes() []*IdRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *UserApprovedTransferDefaultValues) GetForbiddenTimes() []*IdRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

type UserApprovedTransferPermission struct {
	DefaultValues *UserApprovedTransferDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*UserApprovedTransferCombination `protobuf:"bytes,2,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *UserApprovedTransferPermission) Reset()         { *m = UserApprovedTransferPermission{} }
func (m *UserApprovedTransferPermission) String() string { return proto.CompactTextString(m) }
func (*UserApprovedTransferPermission) ProtoMessage()    {}
func (*UserApprovedTransferPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{8}
}
func (m *UserApprovedTransferPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserApprovedTransferPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserApprovedTransferPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserApprovedTransferPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApprovedTransferPermission.Merge(m, src)
}
func (m *UserApprovedTransferPermission) XXX_Size() int {
	return m.Size()
}
func (m *UserApprovedTransferPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApprovedTransferPermission.DiscardUnknown(m)
}

var xxx_messageInfo_UserApprovedTransferPermission proto.InternalMessageInfo

func (m *UserApprovedTransferPermission) GetDefaultValues() *UserApprovedTransferDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *UserApprovedTransferPermission) GetCombinations() []*UserApprovedTransferCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

type ActionWithBadgeIdsCombination struct {
	BadgeIdsOptions       *ValueOptions `protobuf:"bytes,1,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,2,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,3,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *ActionWithBadgeIdsCombination) Reset()         { *m = ActionWithBadgeIdsCombination{} }
func (m *ActionWithBadgeIdsCombination) String() string { return proto.CompactTextString(m) }
func (*ActionWithBadgeIdsCombination) ProtoMessage()    {}
func (*ActionWithBadgeIdsCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{9}
}
func (m *ActionWithBadgeIdsCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionWithBadgeIdsCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionWithBadgeIdsCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionWithBadgeIdsCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionWithBadgeIdsCombination.Merge(m, src)
}
func (m *ActionWithBadgeIdsCombination) XXX_Size() int {
	return m.Size()
}
func (m *ActionWithBadgeIdsCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionWithBadgeIdsCombination.DiscardUnknown(m)
}

var xxx_messageInfo_ActionWithBadgeIdsCombination proto.InternalMessageInfo

func (m *ActionWithBadgeIdsCombination) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *ActionWithBadgeIdsCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *ActionWithBadgeIdsCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type ActionWithBadgeIdsDefaultValues struct {
	BadgeIds       []*IdRange `protobuf:"bytes,1,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	PermittedTimes []*IdRange `protobuf:"bytes,2,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes []*IdRange `protobuf:"bytes,3,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *ActionWithBadgeIdsDefaultValues) Reset()         { *m = ActionWithBadgeIdsDefaultValues{} }
func (m *ActionWithBadgeIdsDefaultValues) String() string { return proto.CompactTextString(m) }
func (*ActionWithBadgeIdsDefaultValues) ProtoMessage()    {}
func (*ActionWithBadgeIdsDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{10}
}
func (m *ActionWithBadgeIdsDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionWithBadgeIdsDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionWithBadgeIdsDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionWithBadgeIdsDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionWithBadgeIdsDefaultValues.Merge(m, src)
}
func (m *ActionWithBadgeIdsDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *ActionWithBadgeIdsDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionWithBadgeIdsDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_ActionWithBadgeIdsDefaultValues proto.InternalMessageInfo

func (m *ActionWithBadgeIdsDefaultValues) GetBadgeIds() []*IdRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *ActionWithBadgeIdsDefaultValues) GetPermittedTimes() []*IdRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *ActionWithBadgeIdsDefaultValues) GetForbiddenTimes() []*IdRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

type ActionWithBadgeIdsPermission struct {
	DefaultValues *ActionWithBadgeIdsDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*ActionWithBadgeIdsCombination `protobuf:"bytes,2,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *ActionWithBadgeIdsPermission) Reset()         { *m = ActionWithBadgeIdsPermission{} }
func (m *ActionWithBadgeIdsPermission) String() string { return proto.CompactTextString(m) }
func (*ActionWithBadgeIdsPermission) ProtoMessage()    {}
func (*ActionWithBadgeIdsPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{11}
}
func (m *ActionWithBadgeIdsPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionWithBadgeIdsPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionWithBadgeIdsPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionWithBadgeIdsPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionWithBadgeIdsPermission.Merge(m, src)
}
func (m *ActionWithBadgeIdsPermission) XXX_Size() int {
	return m.Size()
}
func (m *ActionWithBadgeIdsPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionWithBadgeIdsPermission.DiscardUnknown(m)
}

var xxx_messageInfo_ActionWithBadgeIdsPermission proto.InternalMessageInfo

func (m *ActionWithBadgeIdsPermission) GetDefaultValues() *ActionWithBadgeIdsDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *ActionWithBadgeIdsPermission) GetCombinations() []*ActionWithBadgeIdsCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

type ActionDefaultValues struct {
	PermittedTimes []*IdRange `protobuf:"bytes,1,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes []*IdRange `protobuf:"bytes,2,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *ActionDefaultValues) Reset()         { *m = ActionDefaultValues{} }
func (m *ActionDefaultValues) String() string { return proto.CompactTextString(m) }
func (*ActionDefaultValues) ProtoMessage()    {}
func (*ActionDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{12}
}
func (m *ActionDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDefaultValues.Merge(m, src)
}
func (m *ActionDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *ActionDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDefaultValues proto.InternalMessageInfo

func (m *ActionDefaultValues) GetPermittedTimes() []*IdRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *ActionDefaultValues) GetForbiddenTimes() []*IdRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

type ActionCombination struct {
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,1,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,2,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *ActionCombination) Reset()         { *m = ActionCombination{} }
func (m *ActionCombination) String() string { return proto.CompactTextString(m) }
func (*ActionCombination) ProtoMessage()    {}
func (*ActionCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{13}
}
func (m *ActionCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionCombination.Merge(m, src)
}
func (m *ActionCombination) XXX_Size() int {
	return m.Size()
}
func (m *ActionCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionCombination.DiscardUnknown(m)
}

var xxx_messageInfo_ActionCombination proto.InternalMessageInfo

func (m *ActionCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *ActionCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type ActionPermission struct {
	DefaultValues *ActionDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*ActionCombination `protobuf:"bytes,2,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *ActionPermission) Reset()         { *m = ActionPermission{} }
func (m *ActionPermission) String() string { return proto.CompactTextString(m) }
func (*ActionPermission) ProtoMessage()    {}
func (*ActionPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{14}
}
func (m *ActionPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionPermission.Merge(m, src)
}
func (m *ActionPermission) XXX_Size() int {
	return m.Size()
}
func (m *ActionPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionPermission.DiscardUnknown(m)
}

var xxx_messageInfo_ActionPermission proto.InternalMessageInfo

func (m *ActionPermission) GetDefaultValues() *ActionDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *ActionPermission) GetCombinations() []*ActionCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

type TimedUpdateCombination struct {
	TimelineTimesOptions  *ValueOptions `protobuf:"bytes,1,opt,name=timelineTimesOptions,proto3" json:"timelineTimesOptions,omitempty"`
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,2,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,3,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *TimedUpdateCombination) Reset()         { *m = TimedUpdateCombination{} }
func (m *TimedUpdateCombination) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateCombination) ProtoMessage()    {}
func (*TimedUpdateCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{15}
}
func (m *TimedUpdateCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateCombination.Merge(m, src)
}
func (m *TimedUpdateCombination) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateCombination.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateCombination proto.InternalMessageInfo

func (m *TimedUpdateCombination) GetTimelineTimesOptions() *ValueOptions {
	if m != nil {
		return m.TimelineTimesOptions
	}
	return nil
}

func (m *TimedUpdateCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *TimedUpdateCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type TimedUpdateDefaultValues struct {
	TimelineTimes  []*IdRange `protobuf:"bytes,1,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
	PermittedTimes []*IdRange `protobuf:"bytes,2,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes []*IdRange `protobuf:"bytes,3,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *TimedUpdateDefaultValues) Reset()         { *m = TimedUpdateDefaultValues{} }
func (m *TimedUpdateDefaultValues) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateDefaultValues) ProtoMessage()    {}
func (*TimedUpdateDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{16}
}
func (m *TimedUpdateDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateDefaultValues.Merge(m, src)
}
func (m *TimedUpdateDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateDefaultValues proto.InternalMessageInfo

func (m *TimedUpdateDefaultValues) GetTimelineTimes() []*IdRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

func (m *TimedUpdateDefaultValues) GetPermittedTimes() []*IdRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *TimedUpdateDefaultValues) GetForbiddenTimes() []*IdRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

type TimedUpdatePermission struct {
	DefaultValues *TimedUpdateDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*TimedUpdateCombination `protobuf:"bytes,2,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *TimedUpdatePermission) Reset()         { *m = TimedUpdatePermission{} }
func (m *TimedUpdatePermission) String() string { return proto.CompactTextString(m) }
func (*TimedUpdatePermission) ProtoMessage()    {}
func (*TimedUpdatePermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{17}
}
func (m *TimedUpdatePermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdatePermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdatePermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdatePermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdatePermission.Merge(m, src)
}
func (m *TimedUpdatePermission) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdatePermission) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdatePermission.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdatePermission proto.InternalMessageInfo

func (m *TimedUpdatePermission) GetDefaultValues() *TimedUpdateDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *TimedUpdatePermission) GetCombinations() []*TimedUpdateCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

type TimedUpdateWithBadgeIdsCombination struct {
	TimelineTimesOptions  *ValueOptions `protobuf:"bytes,1,opt,name=timelineTimesOptions,proto3" json:"timelineTimesOptions,omitempty"`
	BadgeIdsOptions       *ValueOptions `protobuf:"bytes,2,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,3,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,4,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *TimedUpdateWithBadgeIdsCombination) Reset()         { *m = TimedUpdateWithBadgeIdsCombination{} }
func (m *TimedUpdateWithBadgeIdsCombination) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateWithBadgeIdsCombination) ProtoMessage()    {}
func (*TimedUpdateWithBadgeIdsCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{18}
}
func (m *TimedUpdateWithBadgeIdsCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateWithBadgeIdsCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateWithBadgeIdsCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateWithBadgeIdsCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateWithBadgeIdsCombination.Merge(m, src)
}
func (m *TimedUpdateWithBadgeIdsCombination) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateWithBadgeIdsCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateWithBadgeIdsCombination.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateWithBadgeIdsCombination proto.InternalMessageInfo

func (m *TimedUpdateWithBadgeIdsCombination) GetTimelineTimesOptions() *ValueOptions {
	if m != nil {
		return m.TimelineTimesOptions
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsCombination) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsCombination) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsCombination) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

type TimedUpdateWithBadgeIdsDefaultValues struct {
	BadgeIds       []*IdRange `protobuf:"bytes,1,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	TimelineTimes  []*IdRange `protobuf:"bytes,2,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
	PermittedTimes []*IdRange `protobuf:"bytes,3,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes []*IdRange `protobuf:"bytes,4,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) Reset()         { *m = TimedUpdateWithBadgeIdsDefaultValues{} }
func (m *TimedUpdateWithBadgeIdsDefaultValues) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateWithBadgeIdsDefaultValues) ProtoMessage()    {}
func (*TimedUpdateWithBadgeIdsDefaultValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{19}
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateWithBadgeIdsDefaultValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateWithBadgeIdsDefaultValues.Merge(m, src)
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateWithBadgeIdsDefaultValues.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateWithBadgeIdsDefaultValues proto.InternalMessageInfo

func (m *TimedUpdateWithBadgeIdsDefaultValues) GetBadgeIds() []*IdRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) GetTimelineTimes() []*IdRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) GetPermittedTimes() []*IdRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) GetForbiddenTimes() []*IdRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

type TimedUpdateWithBadgeIdsPermission struct {
	DefaultValues *TimedUpdateWithBadgeIdsDefaultValues `protobuf:"bytes,1,opt,name=defaultValues,proto3" json:"defaultValues,omitempty"`
	Combinations  []*TimedUpdateWithBadgeIdsCombination `protobuf:"bytes,2,rep,name=combinations,proto3" json:"combinations,omitempty"`
}

func (m *TimedUpdateWithBadgeIdsPermission) Reset()         { *m = TimedUpdateWithBadgeIdsPermission{} }
func (m *TimedUpdateWithBadgeIdsPermission) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateWithBadgeIdsPermission) ProtoMessage()    {}
func (*TimedUpdateWithBadgeIdsPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{20}
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.Merge(m, src)
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateWithBadgeIdsPermission proto.InternalMessageInfo

func (m *TimedUpdateWithBadgeIdsPermission) GetDefaultValues() *TimedUpdateWithBadgeIdsDefaultValues {
	if m != nil {
		return m.DefaultValues
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetCombinations() []*TimedUpdateWithBadgeIdsCombination {
	if m != nil {
		return m.Combinations
	}
	return nil
}

func init() {
	proto.RegisterType((*CollectionPermissions)(nil), "bitbadges.bitbadgeschain.badges.CollectionPermissions")
	proto.RegisterType((*UserPermissions)(nil), "bitbadges.bitbadgeschain.badges.UserPermissions")
	proto.RegisterType((*ValueOptions)(nil), "bitbadges.bitbadgeschain.badges.ValueOptions")
	proto.RegisterType((*CollectionApprovedTransferCombination)(nil), "bitbadges.bitbadgeschain.badges.CollectionApprovedTransferCombination")
	proto.RegisterType((*CollectionApprovedTransferDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.CollectionApprovedTransferDefaultValues")
	proto.RegisterType((*CollectionApprovedTransferPermission)(nil), "bitbadges.bitbadgeschain.badges.CollectionApprovedTransferPermission")
	proto.RegisterType((*UserApprovedTransferCombination)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedTransferCombination")
	proto.RegisterType((*UserApprovedTransferDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedTransferDefaultValues")
	proto.RegisterType((*UserApprovedTransferPermission)(nil), "bitbadges.bitbadgeschain.badges.UserApprovedTransferPermission")
	proto.RegisterType((*ActionWithBadgeIdsCombination)(nil), "bitbadges.bitbadgeschain.badges.ActionWithBadgeIdsCombination")
	proto.RegisterType((*ActionWithBadgeIdsDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.ActionWithBadgeIdsDefaultValues")
	proto.RegisterType((*ActionWithBadgeIdsPermission)(nil), "bitbadges.bitbadgeschain.badges.ActionWithBadgeIdsPermission")
	proto.RegisterType((*ActionDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.ActionDefaultValues")
	proto.RegisterType((*ActionCombination)(nil), "bitbadges.bitbadgeschain.badges.ActionCombination")
	proto.RegisterType((*ActionPermission)(nil), "bitbadges.bitbadgeschain.badges.ActionPermission")
	proto.RegisterType((*TimedUpdateCombination)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdateCombination")
	proto.RegisterType((*TimedUpdateDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdateDefaultValues")
	proto.RegisterType((*TimedUpdatePermission)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdatePermission")
	proto.RegisterType((*TimedUpdateWithBadgeIdsCombination)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdateWithBadgeIdsCombination")
	proto.RegisterType((*TimedUpdateWithBadgeIdsDefaultValues)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdateWithBadgeIdsDefaultValues")
	proto.RegisterType((*TimedUpdateWithBadgeIdsPermission)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdateWithBadgeIdsPermission")
}

func init() { proto.RegisterFile("badges/permissions.proto", fileDescriptor_1298419e4a97cfe6) }

var fileDescriptor_1298419e4a97cfe6 = []byte{
	// 1254 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x59, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0x5e, 0xdb, 0xe9, 0xaf, 0xd7, 0x2d, 0xbb, 0xcc, 0xb6, 0x95, 0xe9, 0x2e, 0x69, 0x1b, 0x15,
	0xd1, 0x0b, 0x89, 0x28, 0x08, 0xc4, 0x01, 0xd8, 0x36, 0x5d, 0x44, 0x25, 0xca, 0xae, 0xa2, 0xdd,
	0xae, 0xb4, 0x08, 0xa1, 0xb1, 0x3d, 0x49, 0x0c, 0xc9, 0x4c, 0x64, 0x4f, 0xab, 0x2d, 0x17, 0xa4,
	0x05, 0x4e, 0x48, 0x08, 0xf8, 0x33, 0xb8, 0x70, 0xe6, 0x0a, 0x02, 0x71, 0xdc, 0x0b, 0x12, 0x42,
	0x42, 0x5a, 0xb5, 0x37, 0x4e, 0x5c, 0xb9, 0x21, 0x4f, 0x1c, 0xd7, 0x4e, 0xc6, 0x4e, 0x62, 0x3b,
	0x91, 0xd8, 0x9b, 0x33, 0xf6, 0x7c, 0xdf, 0xf3, 0xbc, 0xf7, 0x7d, 0x6f, 0x32, 0x06, 0xdd, 0xc0,
	0x56, 0x83, 0xb8, 0x95, 0x0e, 0x71, 0xda, 0xb6, 0xeb, 0xda, 0x8c, 0xba, 0xe5, 0x8e, 0xc3, 0x38,
	0x43, 0xeb, 0x86, 0xcd, 0xbb, 0x37, 0xcb, 0xc1, 0x95, 0xd9, 0xc4, 0x36, 0x2d, 0x77, 0xaf, 0xd7,
	0x9e, 0x6b, 0x30, 0xd6, 0x68, 0x91, 0x8a, 0x78, 0xdc, 0x38, 0xae, 0x57, 0x30, 0x3d, 0xed, 0xce,
	0x5d, 0x5b, 0xf1, 0x51, 0x0d, 0xdc, 0xc2, 0xd4, 0x24, 0x3e, 0xe4, 0xda, 0xaa, 0x3f, 0x8c, 0x2d,
	0xcb, 0x21, 0xae, 0x1b, 0x8c, 0x2f, 0x37, 0x58, 0x83, 0x89, 0xcb, 0x8a, 0x77, 0xd5, 0x1d, 0x2d,
	0x7d, 0x0b, 0xb0, 0x52, 0x65, 0xad, 0x16, 0x31, 0xb9, 0xcd, 0xe8, 0x9d, 0x8b, 0x00, 0x91, 0x09,
	0xd7, 0x4c, 0x4c, 0xf7, 0x49, 0x8b, 0x70, 0x72, 0xf1, 0x84, 0xae, 0x6c, 0x68, 0xdb, 0x8b, 0x3b,
	0x2f, 0x97, 0x87, 0x04, 0x5e, 0xde, 0xed, 0x03, 0xac, 0xc9, 0xd0, 0xd0, 0x11, 0x80, 0x89, 0xe9,
	0xae, 0x63, 0x36, 0xed, 0x13, 0xa2, 0xab, 0x02, 0xfb, 0xb5, 0xa1, 0xd8, 0x77, 0xed, 0x36, 0xb1,
	0xee, 0x75, 0x2c, 0xcc, 0x49, 0x88, 0x20, 0x84, 0x84, 0x1c, 0xd0, 0x4d, 0x4c, 0xbb, 0x8f, 0x54,
	0x19, 0xe5, 0x0e, 0x36, 0xf9, 0x6e, 0x77, 0x41, 0x74, 0x2d, 0x13, 0x4b, 0x2c, 0x2e, 0xfa, 0x42,
	0x81, 0xcd, 0xe0, 0xe6, 0xed, 0x7a, 0xbd, 0xea, 0x81, 0xed, 0xf9, 0xc9, 0x39, 0x24, 0x1c, 0x5b,
	0x98, 0x63, 0xbd, 0x90, 0x89, 0x7d, 0x38, 0x01, 0x6a, 0x8a, 0xbc, 0xf9, 0x21, 0x1e, 0xbb, 0x9c,
	0xb5, 0xf7, 0x3d, 0xde, 0x99, 0x4c, 0xbc, 0x32, 0x48, 0x64, 0xc0, 0xd5, 0x60, 0xf8, 0x10, 0x53,
	0xdc, 0x20, 0x8e, 0x3e, 0x9b, 0x89, 0x66, 0x00, 0x0f, 0x3d, 0x84, 0xeb, 0xa1, 0x05, 0xef, 0xd5,
	0x4d, 0xb0, 0x9a, 0x73, 0x99, 0xe8, 0x92, 0xa0, 0x11, 0x13, 0xeb, 0x58, 0x75, 0x88, 0x17, 0x0d,
	0x73, 0xc8, 0x9e, 0x40, 0xd2, 0xe7, 0x05, 0xe3, 0x9b, 0x23, 0xd6, 0xff, 0x7d, 0x9b, 0x37, 0xc5,
	0xc4, 0x03, 0xcb, 0xed, 0x5b, 0xce, 0x7e, 0x64, 0xf4, 0x29, 0xac, 0x06, 0xf1, 0x88, 0xa1, 0xe0,
	0x2d, 0x17, 0x04, 0xe7, 0xde, 0x38, 0x6f, 0x19, 0x43, 0x1c, 0xc3, 0x80, 0x1e, 0x29, 0xb0, 0x16,
	0xdc, 0x3a, 0xa0, 0x4d, 0xe2, 0xd8, 0x9c, 0x58, 0xbd, 0xda, 0xd2, 0x21, 0xb7, 0x00, 0x12, 0x58,
	0xd0, 0x97, 0xe1, 0x20, 0x76, 0x3b, 0x1d, 0x87, 0x9d, 0x10, 0xeb, 0xae, 0x83, 0xa9, 0x5b, 0x27,
	0x8e, 0xab, 0x2f, 0x8a, 0x20, 0x6e, 0x0d, 0x0d, 0xe2, 0x22, 0x97, 0xfd, 0x18, 0xd2, 0x38, 0x06,
	0x88, 0x4a, 0xdf, 0x29, 0x70, 0xe5, 0x9e, 0x1b, 0x7e, 0xdc, 0x45, 0x9f, 0x25, 0x86, 0xd6, 0x35,
	0xc5, 0xb7, 0x87, 0x86, 0xe6, 0xa1, 0xa6, 0x0c, 0x8a, 0xc2, 0xe5, 0x23, 0xdc, 0x3a, 0x26, 0xb7,
	0x3b, 0x5c, 0x04, 0xb4, 0x05, 0x4b, 0x36, 0x3d, 0x21, 0x0e, 0xdf, 0x27, 0x75, 0x7c, 0xdc, 0xe2,
	0xba, 0xb2, 0xa1, 0x6c, 0xcf, 0xd7, 0xa2, 0x83, 0xe8, 0x06, 0x2c, 0xe0, 0x56, 0x4b, 0x4c, 0x74,
	0x75, 0x55, 0x3c, 0x71, 0x31, 0x80, 0xd6, 0x60, 0x9e, 0x32, 0xff, 0xa6, 0x26, 0x6e, 0x06, 0xbf,
	0x4b, 0x3f, 0xcf, 0xc2, 0x0b, 0xf1, 0x2b, 0x59, 0x65, 0x6d, 0xc3, 0xa6, 0x58, 0x78, 0x38, 0x86,
	0x65, 0x6e, 0xb7, 0x49, 0xcb, 0xa6, 0xc4, 0xcb, 0xbf, 0xeb, 0x47, 0x28, 0x02, 0x5a, 0xdc, 0x79,
	0x69, 0xe8, 0xa2, 0x84, 0x5f, 0xab, 0x26, 0x85, 0xf2, 0x28, 0xea, 0x0e, 0x6b, 0x1f, 0xe2, 0x4e,
	0xc7, 0xa6, 0x8d, 0x03, 0xab, 0x47, 0xa1, 0xa6, 0xa2, 0x90, 0x41, 0xa1, 0x0f, 0x01, 0x71, 0x36,
	0x40, 0xa0, 0xa5, 0x21, 0x90, 0x00, 0x21, 0x06, 0xd7, 0x6d, 0x6a, 0x73, 0x1b, 0x7b, 0x05, 0x7f,
	0x3a, 0xc0, 0x53, 0x48, 0xc3, 0x93, 0x84, 0x28, 0xb2, 0xe2, 0x27, 0x2b, 0x92, 0x95, 0x99, 0x74,
	0x59, 0x91, 0x40, 0xa1, 0xfb, 0x70, 0xc5, 0xf0, 0x15, 0xde, 0x43, 0x9f, 0x4d, 0x83, 0xde, 0x8f,
	0x82, 0x4c, 0x58, 0x11, 0x5b, 0x25, 0xce, 0x89, 0x15, 0x09, 0x7e, 0x2e, 0x0d, 0xbc, 0x1c, 0xcb,
	0x23, 0xa9, 0x33, 0xc7, 0xb0, 0x2d, 0x8b, 0xd0, 0x08, 0xc9, 0x7c, 0x2a, 0x12, 0x29, 0x56, 0xe9,
	0x87, 0x02, 0xbc, 0x18, 0xaf, 0x22, 0x5f, 0xa5, 0xbe, 0x1a, 0xdf, 0x87, 0xa5, 0x48, 0xf1, 0xfb,
	0xae, 0xb2, 0x3d, 0x34, 0x90, 0x03, 0xab, 0x86, 0x69, 0x83, 0xd4, 0xa2, 0xd3, 0x3d, 0x87, 0x88,
	0x54, 0xba, 0x50, 0xcb, 0x42, 0x2d, 0x3a, 0x88, 0x36, 0x60, 0x31, 0x54, 0xae, 0xa2, 0xe0, 0x17,
	0x6a, 0xe1, 0x21, 0xb4, 0x03, 0xcb, 0xb2, 0x42, 0x13, 0x35, 0xbb, 0x50, 0x93, 0xde, 0x13, 0xef,
	0x12, 0x2e, 0x19, 0x7f, 0xfb, 0x31, 0xce, 0xbb, 0x84, 0xa7, 0xa3, 0x7d, 0x98, 0xef, 0x15, 0x89,
	0xbf, 0xc5, 0x18, 0x1d, 0x2a, 0x98, 0x89, 0xee, 0xc0, 0x33, 0xd1, 0x5a, 0xf0, 0xf7, 0x0f, 0xa3,
	0x63, 0xf5, 0xcd, 0xf7, 0x10, 0xa3, 0x89, 0xf7, 0xf7, 0x07, 0x63, 0x20, 0x46, 0xe7, 0x97, 0x1e,
	0xa9, 0xb0, 0x35, 0x4a, 0x07, 0x43, 0x14, 0x96, 0xac, 0x70, 0xfd, 0xf8, 0x7e, 0xfb, 0x6e, 0x86,
	0xfe, 0x18, 0xa9, 0xc7, 0x5a, 0x14, 0x1e, 0x7d, 0x0c, 0x97, 0xcd, 0x0b, 0xd7, 0xef, 0x2d, 0xdd,
	0x3b, 0x19, 0xe8, 0x42, 0x4d, 0xa4, 0x16, 0xc1, 0x2e, 0xfd, 0x39, 0x03, 0xeb, 0xb2, 0x5e, 0x39,
	0xe5, 0xb6, 0x23, 0xef, 0x09, 0xea, 0x94, 0x7a, 0x82, 0x36, 0xb5, 0x9e, 0x50, 0x98, 0x68, 0x4f,
	0x98, 0x99, 0x6c, 0x4f, 0x98, 0x9d, 0x46, 0x4f, 0x98, 0xcb, 0xb1, 0x27, 0x7c, 0x5e, 0x80, 0x4d,
	0x59, 0x71, 0x4f, 0xb6, 0x1b, 0xf4, 0xf9, 0xbc, 0x3a, 0xba, 0xcf, 0x6b, 0xe3, 0xf8, 0x7c, 0x21,
	0x3f, 0x9f, 0x9f, 0x79, 0xaa, 0x7d, 0xfe, 0x1f, 0x05, 0x8a, 0xc9, 0x7f, 0x07, 0x50, 0x53, 0xee,
	0xf0, 0x7b, 0xa9, 0xfe, 0x66, 0x24, 0x7a, 0xbb, 0xd5, 0xe7, 0xed, 0xdd, 0x83, 0x98, 0x9b, 0xa9,
	0x88, 0xe2, 0x5d, 0xfd, 0x27, 0x15, 0x9e, 0x1f, 0xfc, 0x5b, 0x1c, 0xf6, 0x74, 0x89, 0x7b, 0x28,
	0x93, 0x75, 0x0f, 0x75, 0x1a, 0xee, 0xa1, 0xe5, 0xe8, 0x1e, 0x5f, 0xa9, 0xb0, 0x3e, 0xb8, 0x88,
	0x51, 0xef, 0x08, 0xab, 0x48, 0xc9, 0x51, 0x45, 0x6a, 0xee, 0x2a, 0xd2, 0x32, 0xaa, 0xe8, 0x6f,
	0x05, 0x6e, 0x24, 0x9d, 0xb4, 0xa0, 0xba, 0x5c, 0x43, 0x37, 0x53, 0x9c, 0xdf, 0x24, 0x2a, 0xc8,
	0x90, 0x2a, 0xe8, 0xad, 0x14, 0x34, 0xf1, 0xfa, 0xf9, 0x51, 0x81, 0x6b, 0xdd, 0xe7, 0xa3, 0xe9,
	0x1e, 0x4c, 0x94, 0x92, 0x7b, 0xa2, 0xd4, 0x8c, 0x89, 0xfa, 0x4b, 0x81, 0x67, 0xbb, 0xb1, 0x87,
	0xf5, 0x1e, 0x2b, 0x4b, 0x65, 0x1a, 0xb2, 0x54, 0x73, 0x94, 0xe5, 0xaf, 0x0a, 0x5c, 0xed, 0x3f,
	0xf2, 0x46, 0x0f, 0xe4, 0xc5, 0xf7, 0xea, 0x88, 0x55, 0x91, 0x58, 0x70, 0x47, 0xd2, 0x82, 0xdb,
	0x19, 0x11, 0x3a, 0xbe, 0xc8, 0x7e, 0x51, 0x61, 0x35, 0x74, 0x8c, 0x37, 0xe5, 0x1d, 0xf7, 0xd3,
	0xe3, 0xd3, 0x5f, 0xab, 0xa0, 0x87, 0xd6, 0x71, 0xb2, 0x9b, 0xbb, 0xff, 0x83, 0x55, 0xff, 0xae,
	0xc0, 0x8a, 0xf4, 0x18, 0x1e, 0x7d, 0x24, 0x97, 0xc9, 0x1b, 0xe3, 0x1c, 0x37, 0x27, 0x6a, 0xe5,
	0x03, 0xa9, 0x56, 0x5e, 0x1f, 0x07, 0x3f, 0x5e, 0x30, 0xdf, 0x6b, 0x50, 0x8a, 0x39, 0xf7, 0x9e,
	0xb2, 0x78, 0x24, 0xbb, 0x27, 0x75, 0xb2, 0xbb, 0x27, 0x6d, 0x1a, 0xaa, 0x2c, 0xe4, 0xa8, 0xca,
	0x27, 0x2a, 0x6c, 0xc5, 0x24, 0x6b, 0x12, 0x5b, 0xa8, 0x01, 0x9d, 0xab, 0x79, 0xeb, 0x5c, 0xcb,
	0x5d, 0xe7, 0x85, 0x8c, 0x3a, 0xff, 0x57, 0x81, 0xcd, 0xa1, 0xdf, 0x81, 0xd0, 0x27, 0x72, 0xcd,
	0xdf, 0x4a, 0xfb, 0x89, 0x29, 0x51, 0xff, 0x0d, 0xa9, 0xfe, 0xab, 0x69, 0xb9, 0x62, 0xbd, 0x60,
	0xef, 0xbd, 0xdf, 0xce, 0x8a, 0xca, 0xe3, 0xb3, 0xa2, 0xf2, 0xe4, 0xac, 0xa8, 0x7c, 0x73, 0x5e,
	0xbc, 0xf4, 0xf8, 0xbc, 0x78, 0xe9, 0x8f, 0xf3, 0xe2, 0xa5, 0x07, 0x3b, 0x0d, 0x9b, 0x37, 0x8f,
	0x8d, 0xb2, 0xc9, 0xda, 0x95, 0x80, 0xac, 0x12, 0xa5, 0xad, 0x3c, 0xac, 0xf8, 0xe3, 0xfc, 0xb4,
	0x43, 0x5c, 0x63, 0x56, 0x7c, 0xa2, 0x7f, 0xe5, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x63, 0xe8,
	0xa8, 0x60, 0x3f, 0x20, 0x00, 0x00,
}

func (m *CollectionPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateApprovedTransfers) > 0 {
		for iNdEx := len(m.CanUpdateApprovedTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateApprovedTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.CanUpdateInheritedBalances) > 0 {
		for iNdEx := len(m.CanUpdateInheritedBalances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateInheritedBalances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.CanUpdateBadgeMetadata) > 0 {
		for iNdEx := len(m.CanUpdateBadgeMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateBadgeMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CanCreateMoreBadges) > 0 {
		for iNdEx := len(m.CanCreateMoreBadges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanCreateMoreBadges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for iNdEx := len(m.CanUpdateCollectionMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for iNdEx := len(m.CanUpdateManager) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateManager[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for iNdEx := len(m.CanUpdateCustomData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCustomData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CanUpdateOffChainBalancesMetadata) > 0 {
		for iNdEx := len(m.CanUpdateOffChainBalancesMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateOffChainBalancesMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CanUpdateContractAddress) > 0 {
		for iNdEx := len(m.CanUpdateContractAddress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateContractAddress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CanArchive) > 0 {
		for iNdEx := len(m.CanArchive) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanArchive[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CanDeleteCollection) > 0 {
		for iNdEx := len(m.CanDeleteCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanDeleteCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateApprovedTransfers) > 0 {
		for iNdEx := len(m.CanUpdateApprovedTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateApprovedTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ValueOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoValues {
		i--
		if m.NoValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AllValues {
		i--
		if m.AllValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.InvertDefault {
		i--
		if m.InvertDefault {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApprovedTransferCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApprovedTransferCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApprovedTransferCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TransferTimesOptions != nil {
		{
			size, err := m.TransferTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.InitiatedByMappingIdOptions != nil {
		{
			size, err := m.InitiatedByMappingIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ToMappingIdOptions != nil {
		{
			size, err := m.ToMappingIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.FromMappingIdOptions != nil {
		{
			size, err := m.FromMappingIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TimelineTimesOptions != nil {
		{
			size, err := m.TimelineTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApprovedTransferDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApprovedTransferDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApprovedTransferDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ToMappingId) > 0 {
		i -= len(m.ToMappingId)
		copy(dAtA[i:], m.ToMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ToMappingId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FromMappingId) > 0 {
		i -= len(m.FromMappingId)
		copy(dAtA[i:], m.FromMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.FromMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApprovedTransferPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApprovedTransferPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApprovedTransferPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedTransferCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedTransferCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedTransferCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TransferTimesOptions != nil {
		{
			size, err := m.TransferTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.InitiatedByMappingIdOptions != nil {
		{
			size, err := m.InitiatedByMappingIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ToMappingIdOptions != nil {
		{
			size, err := m.ToMappingIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TimelineTimesOptions != nil {
		{
			size, err := m.TimelineTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedTransferDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedTransferDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedTransferDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ToMappingId) > 0 {
		i -= len(m.ToMappingId)
		copy(dAtA[i:], m.ToMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ToMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserApprovedTransferPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserApprovedTransferPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserApprovedTransferPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionWithBadgeIdsCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionWithBadgeIdsCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionWithBadgeIdsCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionWithBadgeIdsDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionWithBadgeIdsDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionWithBadgeIdsDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionWithBadgeIdsPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionWithBadgeIdsPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionWithBadgeIdsPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TimelineTimesOptions != nil {
		{
			size, err := m.TimelineTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdatePermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdatePermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdatePermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateWithBadgeIdsCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateWithBadgeIdsCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateWithBadgeIdsCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TimelineTimesOptions != nil {
		{
			size, err := m.TimelineTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateWithBadgeIdsPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateWithBadgeIdsPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateWithBadgeIdsPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Combinations) > 0 {
		for iNdEx := len(m.Combinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Combinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DefaultValues != nil {
		{
			size, err := m.DefaultValues.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPermissions(dAtA []byte, offset int, v uint64) int {
	offset -= sovPermissions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CollectionPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CanDeleteCollection) > 0 {
		for _, e := range m.CanDeleteCollection {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanArchive) > 0 {
		for _, e := range m.CanArchive {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateContractAddress) > 0 {
		for _, e := range m.CanUpdateContractAddress {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateOffChainBalancesMetadata) > 0 {
		for _, e := range m.CanUpdateOffChainBalancesMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for _, e := range m.CanUpdateCustomData {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for _, e := range m.CanUpdateManager {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for _, e := range m.CanUpdateCollectionMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanCreateMoreBadges) > 0 {
		for _, e := range m.CanCreateMoreBadges {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateBadgeMetadata) > 0 {
		for _, e := range m.CanUpdateBadgeMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateInheritedBalances) > 0 {
		for _, e := range m.CanUpdateInheritedBalances {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateApprovedTransfers) > 0 {
		for _, e := range m.CanUpdateApprovedTransfers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CanUpdateApprovedTransfers) > 0 {
		for _, e := range m.CanUpdateApprovedTransfers {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ValueOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvertDefault {
		n += 2
	}
	if m.AllValues {
		n += 2
	}
	if m.NoValues {
		n += 2
	}
	return n
}

func (m *CollectionApprovedTransferCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimelineTimesOptions != nil {
		l = m.TimelineTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.FromMappingIdOptions != nil {
		l = m.FromMappingIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ToMappingIdOptions != nil {
		l = m.ToMappingIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.InitiatedByMappingIdOptions != nil {
		l = m.InitiatedByMappingIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.TransferTimesOptions != nil {
		l = m.TransferTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *CollectionApprovedTransferDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.FromMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ToMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *CollectionApprovedTransferPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserApprovedTransferCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimelineTimesOptions != nil {
		l = m.TimelineTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ToMappingIdOptions != nil {
		l = m.ToMappingIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.InitiatedByMappingIdOptions != nil {
		l = m.InitiatedByMappingIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.TransferTimesOptions != nil {
		l = m.TransferTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *UserApprovedTransferDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.ToMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserApprovedTransferPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ActionWithBadgeIdsCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *ActionWithBadgeIdsDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ActionWithBadgeIdsPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ActionDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ActionCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *ActionPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *TimedUpdateCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimelineTimesOptions != nil {
		l = m.TimelineTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *TimedUpdateDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *TimedUpdatePermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *TimedUpdateWithBadgeIdsCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimelineTimesOptions != nil {
		l = m.TimelineTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *TimedUpdateWithBadgeIdsDefaultValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *TimedUpdateWithBadgeIdsPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultValues != nil {
		l = m.DefaultValues.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.Combinations) > 0 {
		for _, e := range m.Combinations {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func sovPermissions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPermissions(x uint64) (n int) {
	return sovPermissions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CollectionPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDeleteCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanDeleteCollection = append(m.CanDeleteCollection, &ActionPermission{})
			if err := m.CanDeleteCollection[len(m.CanDeleteCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanArchive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanArchive = append(m.CanArchive, &TimedUpdatePermission{})
			if err := m.CanArchive[len(m.CanArchive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateContractAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateContractAddress = append(m.CanUpdateContractAddress, &TimedUpdatePermission{})
			if err := m.CanUpdateContractAddress[len(m.CanUpdateContractAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateOffChainBalancesMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateOffChainBalancesMetadata = append(m.CanUpdateOffChainBalancesMetadata, &TimedUpdatePermission{})
			if err := m.CanUpdateOffChainBalancesMetadata[len(m.CanUpdateOffChainBalancesMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCustomData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCustomData = append(m.CanUpdateCustomData, &TimedUpdatePermission{})
			if err := m.CanUpdateCustomData[len(m.CanUpdateCustomData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateManager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateManager = append(m.CanUpdateManager, &TimedUpdatePermission{})
			if err := m.CanUpdateManager[len(m.CanUpdateManager)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionMetadata = append(m.CanUpdateCollectionMetadata, &TimedUpdatePermission{})
			if err := m.CanUpdateCollectionMetadata[len(m.CanUpdateCollectionMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanCreateMoreBadges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanCreateMoreBadges = append(m.CanCreateMoreBadges, &ActionWithBadgeIdsPermission{})
			if err := m.CanCreateMoreBadges[len(m.CanCreateMoreBadges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateBadgeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateBadgeMetadata = append(m.CanUpdateBadgeMetadata, &TimedUpdateWithBadgeIdsPermission{})
			if err := m.CanUpdateBadgeMetadata[len(m.CanUpdateBadgeMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateInheritedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateInheritedBalances = append(m.CanUpdateInheritedBalances, &TimedUpdateWithBadgeIdsPermission{})
			if err := m.CanUpdateInheritedBalances[len(m.CanUpdateInheritedBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateApprovedTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateApprovedTransfers = append(m.CanUpdateApprovedTransfers, &CollectionApprovedTransferPermission{})
			if err := m.CanUpdateApprovedTransfers[len(m.CanUpdateApprovedTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateApprovedTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateApprovedTransfers = append(m.CanUpdateApprovedTransfers, &UserApprovedTransferPermission{})
			if err := m.CanUpdateApprovedTransfers[len(m.CanUpdateApprovedTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertDefault = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllValues = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoValues = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApprovedTransferCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApprovedTransferCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApprovedTransferCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimelineTimesOptions == nil {
				m.TimelineTimesOptions = &ValueOptions{}
			}
			if err := m.TimelineTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FromMappingIdOptions == nil {
				m.FromMappingIdOptions = &ValueOptions{}
			}
			if err := m.FromMappingIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToMappingIdOptions == nil {
				m.ToMappingIdOptions = &ValueOptions{}
			}
			if err := m.ToMappingIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedByMappingIdOptions == nil {
				m.InitiatedByMappingIdOptions = &ValueOptions{}
			}
			if err := m.InitiatedByMappingIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTimesOptions == nil {
				m.TransferTimesOptions = &ValueOptions{}
			}
			if err := m.TransferTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApprovedTransferDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApprovedTransferDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApprovedTransferDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &IdRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &IdRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &IdRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &IdRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &IdRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApprovedTransferPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApprovedTransferPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApprovedTransferPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &CollectionApprovedTransferDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &CollectionApprovedTransferCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedTransferCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedTransferCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedTransferCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimelineTimesOptions == nil {
				m.TimelineTimesOptions = &ValueOptions{}
			}
			if err := m.TimelineTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToMappingIdOptions == nil {
				m.ToMappingIdOptions = &ValueOptions{}
			}
			if err := m.ToMappingIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedByMappingIdOptions == nil {
				m.InitiatedByMappingIdOptions = &ValueOptions{}
			}
			if err := m.InitiatedByMappingIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTimesOptions == nil {
				m.TransferTimesOptions = &ValueOptions{}
			}
			if err := m.TransferTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedTransferDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedTransferDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedTransferDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &IdRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &IdRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &IdRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &IdRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &IdRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserApprovedTransferPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserApprovedTransferPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserApprovedTransferPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &UserApprovedTransferDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &UserApprovedTransferCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionWithBadgeIdsCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionWithBadgeIdsCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionWithBadgeIdsCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionWithBadgeIdsDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionWithBadgeIdsDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionWithBadgeIdsDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &IdRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &IdRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &IdRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionWithBadgeIdsPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionWithBadgeIdsPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionWithBadgeIdsPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &ActionWithBadgeIdsDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &ActionWithBadgeIdsCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &IdRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &IdRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &ActionDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &ActionCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimelineTimesOptions == nil {
				m.TimelineTimesOptions = &ValueOptions{}
			}
			if err := m.TimelineTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &IdRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &IdRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &IdRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdatePermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdatePermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdatePermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &TimedUpdateDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &TimedUpdateCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateWithBadgeIdsCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimelineTimesOptions == nil {
				m.TimelineTimesOptions = &ValueOptions{}
			}
			if err := m.TimelineTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateWithBadgeIdsDefaultValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsDefaultValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsDefaultValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &IdRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &IdRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &IdRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &IdRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateWithBadgeIdsPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValues == nil {
				m.DefaultValues = &TimedUpdateWithBadgeIdsDefaultValues{}
			}
			if err := m.DefaultValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combinations = append(m.Combinations, &TimedUpdateWithBadgeIdsCombination{})
			if err := m.Combinations[len(m.Combinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPermissions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPermissions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPermissions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPermissions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPermissions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPermissions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPermissions = fmt.Errorf("proto: unexpected end of group")
)
