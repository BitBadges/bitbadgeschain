// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/permissions.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CollectionPermissions defines the permissions for the collection (i.e. what the manager can and cannot do).
//
// There are five types of permissions for a collection: ActionPermission, TimedUpdatePermission, TimedUpdateWithBadgeIdsPermission, BalancesActionPermission, and CollectionApprovalPermission.
//
// The permission type allows fine-grained access control for each action.
// ActionPermission: defines when the manager can perform an action.
// TimedUpdatePermission: defines when the manager can update a timeline-based field and what times of the timeline can be updated.
// TimedUpdateWithBadgeIdsPermission: defines when the manager can update a timeline-based field for specific badges and what times of the timeline can be updated.
// BalancesActionPermission: defines when the manager can perform an action for specific badges and specific badge ownership times.
// CollectionApprovalPermission: defines when the manager can update the transferability of the collection and what transfers can be updated vs locked
//
// Note there are a few different times here which could get confusing:
// - timelineTimes: the times when a timeline-based field is a specific value
// - permitted/forbiddenTimes - the times that a permission can be performed
// - transferTimes - the times that a transfer occurs
// - ownershipTimes - the times when a badge is owned by a user
//
// The permitted/forbiddenTimes are used to determine when a permission can be executed.
// Once a time is set to be permitted or forbidden, it is PERMANENT and cannot be changed.
// If a time is not set to be permitted or forbidden, it is considered NEUTRAL and can be updated but is ALLOWED by default.
//
// Each permission type has a defaultValues field and a combinations field.
// The defaultValues field defines the default values for the permission which can be manipulated by the combinations field (to avoid unnecessary repetition).
// Ex: We can have default value badgeIds = [1,2] and combinations = [{invertDefault: true, isApproved: false}, {isApproved: true}].
// This would mean that badgeIds [1,2] are allowed but everything else is not allowed.
//
// IMPORTANT: For all permissions, we ONLY take the first combination that matches. Any subsequent combinations are ignored.
// Ex: If we have defaultValues = {badgeIds: [1,2]} and combinations = [{isApproved: true}, {isApproved: false}].
// This would mean that badgeIds [1,2] are allowed and the second combination is ignored.
type CollectionPermissions struct {
	CanDeleteCollection               []*ActionPermission                  `protobuf:"bytes,1,rep,name=canDeleteCollection,proto3" json:"canDeleteCollection,omitempty"`
	CanArchiveCollection              []*TimedUpdatePermission             `protobuf:"bytes,2,rep,name=canArchiveCollection,proto3" json:"canArchiveCollection,omitempty"`
	CanUpdateContractAddress          []*TimedUpdatePermission             `protobuf:"bytes,3,rep,name=canUpdateContractAddress,proto3" json:"canUpdateContractAddress,omitempty"`
	CanUpdateOffChainBalancesMetadata []*TimedUpdatePermission             `protobuf:"bytes,4,rep,name=canUpdateOffChainBalancesMetadata,proto3" json:"canUpdateOffChainBalancesMetadata,omitempty"`
	CanUpdateStandards                []*TimedUpdatePermission             `protobuf:"bytes,5,rep,name=canUpdateStandards,proto3" json:"canUpdateStandards,omitempty"`
	CanUpdateCustomData               []*TimedUpdatePermission             `protobuf:"bytes,6,rep,name=canUpdateCustomData,proto3" json:"canUpdateCustomData,omitempty"`
	CanUpdateManager                  []*TimedUpdatePermission             `protobuf:"bytes,7,rep,name=canUpdateManager,proto3" json:"canUpdateManager,omitempty"`
	CanUpdateCollectionMetadata       []*TimedUpdatePermission             `protobuf:"bytes,8,rep,name=canUpdateCollectionMetadata,proto3" json:"canUpdateCollectionMetadata,omitempty"`
	CanCreateMoreBadges               []*BalancesActionPermission          `protobuf:"bytes,9,rep,name=canCreateMoreBadges,proto3" json:"canCreateMoreBadges,omitempty"`
	CanUpdateBadgeMetadata            []*TimedUpdateWithBadgeIdsPermission `protobuf:"bytes,10,rep,name=canUpdateBadgeMetadata,proto3" json:"canUpdateBadgeMetadata,omitempty"`
	CanUpdateCollectionApprovals      []*CollectionApprovalPermission      `protobuf:"bytes,12,rep,name=canUpdateCollectionApprovals,proto3" json:"canUpdateCollectionApprovals,omitempty"`
}

func (m *CollectionPermissions) Reset()         { *m = CollectionPermissions{} }
func (m *CollectionPermissions) String() string { return proto.CompactTextString(m) }
func (*CollectionPermissions) ProtoMessage()    {}
func (*CollectionPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{0}
}
func (m *CollectionPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionPermissions.Merge(m, src)
}
func (m *CollectionPermissions) XXX_Size() int {
	return m.Size()
}
func (m *CollectionPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionPermissions proto.InternalMessageInfo

func (m *CollectionPermissions) GetCanDeleteCollection() []*ActionPermission {
	if m != nil {
		return m.CanDeleteCollection
	}
	return nil
}

func (m *CollectionPermissions) GetCanArchiveCollection() []*TimedUpdatePermission {
	if m != nil {
		return m.CanArchiveCollection
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateContractAddress() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateContractAddress
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateOffChainBalancesMetadata() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateOffChainBalancesMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateStandards() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateStandards
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCustomData() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCustomData
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateManager() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateManager
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCollectionMetadata() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCollectionMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanCreateMoreBadges() []*BalancesActionPermission {
	if m != nil {
		return m.CanCreateMoreBadges
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateBadgeMetadata() []*TimedUpdateWithBadgeIdsPermission {
	if m != nil {
		return m.CanUpdateBadgeMetadata
	}
	return nil
}

func (m *CollectionPermissions) GetCanUpdateCollectionApprovals() []*CollectionApprovalPermission {
	if m != nil {
		return m.CanUpdateCollectionApprovals
	}
	return nil
}

// UserPermissions defines the permissions for the user (i.e. what the user can and cannot do).
//
// See CollectionPermissions for more details on the different types of permissions.
// The UserApprovedOutgoing and UserApprovedIncoming permissions are the same as the CollectionApprovalPermission,
// but certain fields are removed because they are not relevant to the user.
type UserPermissions struct {
	CanUpdateOutgoingApprovals []*UserOutgoingApprovalPermission `protobuf:"bytes,1,rep,name=canUpdateOutgoingApprovals,proto3" json:"canUpdateOutgoingApprovals,omitempty"`
	CanUpdateIncomingApprovals []*UserIncomingApprovalPermission `protobuf:"bytes,2,rep,name=canUpdateIncomingApprovals,proto3" json:"canUpdateIncomingApprovals,omitempty"`
}

func (m *UserPermissions) Reset()         { *m = UserPermissions{} }
func (m *UserPermissions) String() string { return proto.CompactTextString(m) }
func (*UserPermissions) ProtoMessage()    {}
func (*UserPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{1}
}
func (m *UserPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPermissions.Merge(m, src)
}
func (m *UserPermissions) XXX_Size() int {
	return m.Size()
}
func (m *UserPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_UserPermissions proto.InternalMessageInfo

func (m *UserPermissions) GetCanUpdateOutgoingApprovals() []*UserOutgoingApprovalPermission {
	if m != nil {
		return m.CanUpdateOutgoingApprovals
	}
	return nil
}

func (m *UserPermissions) GetCanUpdateIncomingApprovals() []*UserIncomingApprovalPermission {
	if m != nil {
		return m.CanUpdateIncomingApprovals
	}
	return nil
}

// ValueOptions defines how we manipulate the default values.
type ValueOptions struct {
	InvertDefault bool `protobuf:"varint,1,opt,name=invertDefault,proto3" json:"invertDefault,omitempty"`
	AllValues     bool `protobuf:"varint,2,opt,name=allValues,proto3" json:"allValues,omitempty"`
	NoValues      bool `protobuf:"varint,3,opt,name=noValues,proto3" json:"noValues,omitempty"`
}

func (m *ValueOptions) Reset()         { *m = ValueOptions{} }
func (m *ValueOptions) String() string { return proto.CompactTextString(m) }
func (*ValueOptions) ProtoMessage()    {}
func (*ValueOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{2}
}
func (m *ValueOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueOptions.Merge(m, src)
}
func (m *ValueOptions) XXX_Size() int {
	return m.Size()
}
func (m *ValueOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ValueOptions proto.InternalMessageInfo

func (m *ValueOptions) GetInvertDefault() bool {
	if m != nil {
		return m.InvertDefault
	}
	return false
}

func (m *ValueOptions) GetAllValues() bool {
	if m != nil {
		return m.AllValues
	}
	return false
}

func (m *ValueOptions) GetNoValues() bool {
	if m != nil {
		return m.NoValues
	}
	return false
}

// CollectionApprovalPermission defines what collection approved transfers can be updated vs are locked.
//
// Each transfer is broken down to a (from, to, initiatedBy, transferTime, badgeId) tuple.
// For a transfer to match, we need to match ALL of the fields in the combination.
// These are detemined by the fromMappingId, toMappingId, initiatedByMappingId, transferTimes, badgeIds fields.
// AddressMappings are used for (from, to, initiatedBy) which are a permanent list of addresses identified by an ID (see AddressMappings).
//
// TimelineTimes: which timeline times of the collection's approvalsTimeline field can be updated or not?
// permitted/forbidden TimelineTimes: when can the manager execute this permission?
//
// Ex: Let's say we are updating the transferability for timelineTime 1 and the transfer tuple ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", 10, 1000).
// We would check to find the FIRST CollectionApprovalPermission that matches this combination.
// If we find a match, we would check the permitted/forbidden times to see if we can execute this permission (default is ALLOWED).
//
// Ex: So if you wanted to freeze the transferability to enforce that badge ID 1 will always be transferable, you could set
// the combination ("AllWithoutMint", "AllWithoutMint", "AllWithoutMint", "All Transfer Times", 1) to always be forbidden at all timelineTimes.
type CollectionApprovalPermission struct {
	FromMappingId             string        `protobuf:"bytes,1,opt,name=fromMappingId,proto3" json:"fromMappingId,omitempty"`
	ToMappingId               string        `protobuf:"bytes,2,opt,name=toMappingId,proto3" json:"toMappingId,omitempty"`
	InitiatedByMappingId      string        `protobuf:"bytes,3,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	TransferTimes             []*UintRange  `protobuf:"bytes,4,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	BadgeIds                  []*UintRange  `protobuf:"bytes,5,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	OwnershipTimes            []*UintRange  `protobuf:"bytes,6,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	ApprovalTrackerId         string        `protobuf:"bytes,7,opt,name=approvalTrackerId,proto3" json:"approvalTrackerId,omitempty"`
	ChallengeTrackerId        string        `protobuf:"bytes,8,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	PermittedTimes            []*UintRange  `protobuf:"bytes,9,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes            []*UintRange  `protobuf:"bytes,10,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
	FromMappingOptions        *ValueOptions `protobuf:"bytes,11,opt,name=fromMappingOptions,proto3" json:"fromMappingOptions,omitempty"`
	ToMappingOptions          *ValueOptions `protobuf:"bytes,12,opt,name=toMappingOptions,proto3" json:"toMappingOptions,omitempty"`
	InitiatedByMappingOptions *ValueOptions `protobuf:"bytes,13,opt,name=initiatedByMappingOptions,proto3" json:"initiatedByMappingOptions,omitempty"`
	TransferTimesOptions      *ValueOptions `protobuf:"bytes,14,opt,name=transferTimesOptions,proto3" json:"transferTimesOptions,omitempty"`
	BadgeIdsOptions           *ValueOptions `protobuf:"bytes,15,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	OwnershipTimesOptions     *ValueOptions `protobuf:"bytes,16,opt,name=ownershipTimesOptions,proto3" json:"ownershipTimesOptions,omitempty"`
	ApprovalTrackerIdOptions  *ValueOptions `protobuf:"bytes,17,opt,name=approvalTrackerIdOptions,proto3" json:"approvalTrackerIdOptions,omitempty"`
	ChallengeTrackerIdOptions *ValueOptions `protobuf:"bytes,18,opt,name=challengeTrackerIdOptions,proto3" json:"challengeTrackerIdOptions,omitempty"`
	PermittedTimesOptions     *ValueOptions `protobuf:"bytes,19,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions     *ValueOptions `protobuf:"bytes,20,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *CollectionApprovalPermission) Reset()         { *m = CollectionApprovalPermission{} }
func (m *CollectionApprovalPermission) String() string { return proto.CompactTextString(m) }
func (*CollectionApprovalPermission) ProtoMessage()    {}
func (*CollectionApprovalPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{3}
}
func (m *CollectionApprovalPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectionApprovalPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectionApprovalPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectionApprovalPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectionApprovalPermission.Merge(m, src)
}
func (m *CollectionApprovalPermission) XXX_Size() int {
	return m.Size()
}
func (m *CollectionApprovalPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectionApprovalPermission.DiscardUnknown(m)
}

var xxx_messageInfo_CollectionApprovalPermission proto.InternalMessageInfo

func (m *CollectionApprovalPermission) GetFromMappingId() string {
	if m != nil {
		return m.FromMappingId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetToMappingId() string {
	if m != nil {
		return m.ToMappingId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *CollectionApprovalPermission) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *CollectionApprovalPermission) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *CollectionApprovalPermission) GetApprovalTrackerId() string {
	if m != nil {
		return m.ApprovalTrackerId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *CollectionApprovalPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *CollectionApprovalPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

func (m *CollectionApprovalPermission) GetFromMappingOptions() *ValueOptions {
	if m != nil {
		return m.FromMappingOptions
	}
	return nil
}

func (m *CollectionApprovalPermission) GetToMappingOptions() *ValueOptions {
	if m != nil {
		return m.ToMappingOptions
	}
	return nil
}

func (m *CollectionApprovalPermission) GetInitiatedByMappingOptions() *ValueOptions {
	if m != nil {
		return m.InitiatedByMappingOptions
	}
	return nil
}

func (m *CollectionApprovalPermission) GetTransferTimesOptions() *ValueOptions {
	if m != nil {
		return m.TransferTimesOptions
	}
	return nil
}

func (m *CollectionApprovalPermission) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *CollectionApprovalPermission) GetOwnershipTimesOptions() *ValueOptions {
	if m != nil {
		return m.OwnershipTimesOptions
	}
	return nil
}

func (m *CollectionApprovalPermission) GetApprovalTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ApprovalTrackerIdOptions
	}
	return nil
}

func (m *CollectionApprovalPermission) GetChallengeTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ChallengeTrackerIdOptions
	}
	return nil
}

func (m *CollectionApprovalPermission) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *CollectionApprovalPermission) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

// UserOutgoingApprovalPermission defines the permissions for updating the user's approved outgoing transfers.
// See CollectionApprovalPermission for more details. This is equivalent without the fromMappingId field because that is always the user.
type UserOutgoingApprovalPermission struct {
	ToMappingId               string        `protobuf:"bytes,1,opt,name=toMappingId,proto3" json:"toMappingId,omitempty"`
	InitiatedByMappingId      string        `protobuf:"bytes,2,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	TransferTimes             []*UintRange  `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	BadgeIds                  []*UintRange  `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	OwnershipTimes            []*UintRange  `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	ApprovalTrackerId         string        `protobuf:"bytes,6,opt,name=approvalTrackerId,proto3" json:"approvalTrackerId,omitempty"`
	ChallengeTrackerId        string        `protobuf:"bytes,7,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	PermittedTimes            []*UintRange  `protobuf:"bytes,8,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes            []*UintRange  `protobuf:"bytes,9,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
	ToMappingOptions          *ValueOptions `protobuf:"bytes,10,opt,name=toMappingOptions,proto3" json:"toMappingOptions,omitempty"`
	InitiatedByMappingOptions *ValueOptions `protobuf:"bytes,11,opt,name=initiatedByMappingOptions,proto3" json:"initiatedByMappingOptions,omitempty"`
	TransferTimesOptions      *ValueOptions `protobuf:"bytes,12,opt,name=transferTimesOptions,proto3" json:"transferTimesOptions,omitempty"`
	BadgeIdsOptions           *ValueOptions `protobuf:"bytes,13,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	OwnershipTimesOptions     *ValueOptions `protobuf:"bytes,14,opt,name=ownershipTimesOptions,proto3" json:"ownershipTimesOptions,omitempty"`
	ApprovalTrackerIdOptions  *ValueOptions `protobuf:"bytes,15,opt,name=approvalTrackerIdOptions,proto3" json:"approvalTrackerIdOptions,omitempty"`
	ChallengeTrackerIdOptions *ValueOptions `protobuf:"bytes,16,opt,name=challengeTrackerIdOptions,proto3" json:"challengeTrackerIdOptions,omitempty"`
	PermittedTimesOptions     *ValueOptions `protobuf:"bytes,17,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions     *ValueOptions `protobuf:"bytes,18,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *UserOutgoingApprovalPermission) Reset()         { *m = UserOutgoingApprovalPermission{} }
func (m *UserOutgoingApprovalPermission) String() string { return proto.CompactTextString(m) }
func (*UserOutgoingApprovalPermission) ProtoMessage()    {}
func (*UserOutgoingApprovalPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{4}
}
func (m *UserOutgoingApprovalPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserOutgoingApprovalPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserOutgoingApprovalPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserOutgoingApprovalPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserOutgoingApprovalPermission.Merge(m, src)
}
func (m *UserOutgoingApprovalPermission) XXX_Size() int {
	return m.Size()
}
func (m *UserOutgoingApprovalPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_UserOutgoingApprovalPermission.DiscardUnknown(m)
}

var xxx_messageInfo_UserOutgoingApprovalPermission proto.InternalMessageInfo

func (m *UserOutgoingApprovalPermission) GetToMappingId() string {
	if m != nil {
		return m.ToMappingId
	}
	return ""
}

func (m *UserOutgoingApprovalPermission) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *UserOutgoingApprovalPermission) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetApprovalTrackerId() string {
	if m != nil {
		return m.ApprovalTrackerId
	}
	return ""
}

func (m *UserOutgoingApprovalPermission) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *UserOutgoingApprovalPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetToMappingOptions() *ValueOptions {
	if m != nil {
		return m.ToMappingOptions
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetInitiatedByMappingOptions() *ValueOptions {
	if m != nil {
		return m.InitiatedByMappingOptions
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetTransferTimesOptions() *ValueOptions {
	if m != nil {
		return m.TransferTimesOptions
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetOwnershipTimesOptions() *ValueOptions {
	if m != nil {
		return m.OwnershipTimesOptions
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetApprovalTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ApprovalTrackerIdOptions
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetChallengeTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ChallengeTrackerIdOptions
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *UserOutgoingApprovalPermission) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

// UserIncomingApprovalPermission defines the permissions for updating the user's approved incoming transfers.
// See CollectionApprovalPermission for more details. This is equivalent without the toMappingId field because that is always the user.
type UserIncomingApprovalPermission struct {
	FromMappingId             string        `protobuf:"bytes,1,opt,name=fromMappingId,proto3" json:"fromMappingId,omitempty"`
	InitiatedByMappingId      string        `protobuf:"bytes,2,opt,name=initiatedByMappingId,proto3" json:"initiatedByMappingId,omitempty"`
	TransferTimes             []*UintRange  `protobuf:"bytes,3,rep,name=transferTimes,proto3" json:"transferTimes,omitempty"`
	BadgeIds                  []*UintRange  `protobuf:"bytes,4,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	OwnershipTimes            []*UintRange  `protobuf:"bytes,5,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	ApprovalTrackerId         string        `protobuf:"bytes,6,opt,name=approvalTrackerId,proto3" json:"approvalTrackerId,omitempty"`
	ChallengeTrackerId        string        `protobuf:"bytes,7,opt,name=challengeTrackerId,proto3" json:"challengeTrackerId,omitempty"`
	PermittedTimes            []*UintRange  `protobuf:"bytes,8,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes            []*UintRange  `protobuf:"bytes,9,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
	FromMappingOptions        *ValueOptions `protobuf:"bytes,10,opt,name=fromMappingOptions,proto3" json:"fromMappingOptions,omitempty"`
	InitiatedByMappingOptions *ValueOptions `protobuf:"bytes,11,opt,name=initiatedByMappingOptions,proto3" json:"initiatedByMappingOptions,omitempty"`
	TransferTimesOptions      *ValueOptions `protobuf:"bytes,12,opt,name=transferTimesOptions,proto3" json:"transferTimesOptions,omitempty"`
	BadgeIdsOptions           *ValueOptions `protobuf:"bytes,13,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	OwnershipTimesOptions     *ValueOptions `protobuf:"bytes,14,opt,name=ownershipTimesOptions,proto3" json:"ownershipTimesOptions,omitempty"`
	ApprovalTrackerIdOptions  *ValueOptions `protobuf:"bytes,15,opt,name=approvalTrackerIdOptions,proto3" json:"approvalTrackerIdOptions,omitempty"`
	ChallengeTrackerIdOptions *ValueOptions `protobuf:"bytes,16,opt,name=challengeTrackerIdOptions,proto3" json:"challengeTrackerIdOptions,omitempty"`
	PermittedTimesOptions     *ValueOptions `protobuf:"bytes,17,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions     *ValueOptions `protobuf:"bytes,18,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *UserIncomingApprovalPermission) Reset()         { *m = UserIncomingApprovalPermission{} }
func (m *UserIncomingApprovalPermission) String() string { return proto.CompactTextString(m) }
func (*UserIncomingApprovalPermission) ProtoMessage()    {}
func (*UserIncomingApprovalPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{5}
}
func (m *UserIncomingApprovalPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserIncomingApprovalPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserIncomingApprovalPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserIncomingApprovalPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserIncomingApprovalPermission.Merge(m, src)
}
func (m *UserIncomingApprovalPermission) XXX_Size() int {
	return m.Size()
}
func (m *UserIncomingApprovalPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_UserIncomingApprovalPermission.DiscardUnknown(m)
}

var xxx_messageInfo_UserIncomingApprovalPermission proto.InternalMessageInfo

func (m *UserIncomingApprovalPermission) GetFromMappingId() string {
	if m != nil {
		return m.FromMappingId
	}
	return ""
}

func (m *UserIncomingApprovalPermission) GetInitiatedByMappingId() string {
	if m != nil {
		return m.InitiatedByMappingId
	}
	return ""
}

func (m *UserIncomingApprovalPermission) GetTransferTimes() []*UintRange {
	if m != nil {
		return m.TransferTimes
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetApprovalTrackerId() string {
	if m != nil {
		return m.ApprovalTrackerId
	}
	return ""
}

func (m *UserIncomingApprovalPermission) GetChallengeTrackerId() string {
	if m != nil {
		return m.ChallengeTrackerId
	}
	return ""
}

func (m *UserIncomingApprovalPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetFromMappingOptions() *ValueOptions {
	if m != nil {
		return m.FromMappingOptions
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetInitiatedByMappingOptions() *ValueOptions {
	if m != nil {
		return m.InitiatedByMappingOptions
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetTransferTimesOptions() *ValueOptions {
	if m != nil {
		return m.TransferTimesOptions
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetOwnershipTimesOptions() *ValueOptions {
	if m != nil {
		return m.OwnershipTimesOptions
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetApprovalTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ApprovalTrackerIdOptions
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetChallengeTrackerIdOptions() *ValueOptions {
	if m != nil {
		return m.ChallengeTrackerIdOptions
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *UserIncomingApprovalPermission) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

// BalancesActionPermission defines the permissions for updating a timeline-based field for specific badges and specific badge ownership times.
// Currently, this is only used for creating new badges.
//
// Ex: If you want to lock the ability to create new badges for badgeIds [1,2] at ownershipTimes 1/1/2020 - 1/1/2021,
// you could set the combination (badgeIds: [1,2], ownershipTimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
type BalancesActionPermission struct {
	BadgeIds              []*UintRange  `protobuf:"bytes,1,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	OwnershipTimes        []*UintRange  `protobuf:"bytes,2,rep,name=ownershipTimes,proto3" json:"ownershipTimes,omitempty"`
	PermittedTimes        []*UintRange  `protobuf:"bytes,3,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes        []*UintRange  `protobuf:"bytes,4,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
	BadgeIdsOptions       *ValueOptions `protobuf:"bytes,5,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	OwnershipTimesOptions *ValueOptions `protobuf:"bytes,6,opt,name=ownershipTimesOptions,proto3" json:"ownershipTimesOptions,omitempty"`
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,7,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,8,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *BalancesActionPermission) Reset()         { *m = BalancesActionPermission{} }
func (m *BalancesActionPermission) String() string { return proto.CompactTextString(m) }
func (*BalancesActionPermission) ProtoMessage()    {}
func (*BalancesActionPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{6}
}
func (m *BalancesActionPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BalancesActionPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BalancesActionPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BalancesActionPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BalancesActionPermission.Merge(m, src)
}
func (m *BalancesActionPermission) XXX_Size() int {
	return m.Size()
}
func (m *BalancesActionPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_BalancesActionPermission.DiscardUnknown(m)
}

var xxx_messageInfo_BalancesActionPermission proto.InternalMessageInfo

func (m *BalancesActionPermission) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *BalancesActionPermission) GetOwnershipTimes() []*UintRange {
	if m != nil {
		return m.OwnershipTimes
	}
	return nil
}

func (m *BalancesActionPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *BalancesActionPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

func (m *BalancesActionPermission) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *BalancesActionPermission) GetOwnershipTimesOptions() *ValueOptions {
	if m != nil {
		return m.OwnershipTimesOptions
	}
	return nil
}

func (m *BalancesActionPermission) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *BalancesActionPermission) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

// ActionPermission defines the permissions for performing an action.
//
// This is simple and straightforward as the only thing we need to check is the permitted/forbidden times.
type ActionPermission struct {
	PermittedTimes        []*UintRange  `protobuf:"bytes,1,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes        []*UintRange  `protobuf:"bytes,2,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,3,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,4,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *ActionPermission) Reset()         { *m = ActionPermission{} }
func (m *ActionPermission) String() string { return proto.CompactTextString(m) }
func (*ActionPermission) ProtoMessage()    {}
func (*ActionPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{7}
}
func (m *ActionPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionPermission.Merge(m, src)
}
func (m *ActionPermission) XXX_Size() int {
	return m.Size()
}
func (m *ActionPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionPermission.DiscardUnknown(m)
}

var xxx_messageInfo_ActionPermission proto.InternalMessageInfo

func (m *ActionPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *ActionPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

func (m *ActionPermission) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *ActionPermission) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

// TimedUpdatePermission defines the permissions for updating a timeline-based field.
//
// Ex: If you want to lock the ability to update the collection's metadata for timelineTimes 1/1/2020 - 1/1/2021,
// you could set the combination (TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
type TimedUpdatePermission struct {
	TimelineTimes        []*UintRange  `protobuf:"bytes,1,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
	PermittedTimes        []*UintRange  `protobuf:"bytes,2,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes        []*UintRange  `protobuf:"bytes,3,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
	TimelineTimesOptions *ValueOptions `protobuf:"bytes,4,opt,name=timelineTimesOptions,proto3" json:"timelineTimesOptions,omitempty"`
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,5,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,6,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *TimedUpdatePermission) Reset()         { *m = TimedUpdatePermission{} }
func (m *TimedUpdatePermission) String() string { return proto.CompactTextString(m) }
func (*TimedUpdatePermission) ProtoMessage()    {}
func (*TimedUpdatePermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{8}
}
func (m *TimedUpdatePermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdatePermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdatePermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdatePermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdatePermission.Merge(m, src)
}
func (m *TimedUpdatePermission) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdatePermission) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdatePermission.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdatePermission proto.InternalMessageInfo

func (m *TimedUpdatePermission) GetTimelineTimes() []*UintRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

func (m *TimedUpdatePermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *TimedUpdatePermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

func (m *TimedUpdatePermission) GetTimelineTimesOptions() *ValueOptions {
	if m != nil {
		return m.TimelineTimesOptions
	}
	return nil
}

func (m *TimedUpdatePermission) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *TimedUpdatePermission) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

// TimedUpdateWithBadgeIdsPermission defines the permissions for updating a timeline-based field for specific badges.
//
// Ex: If you want to lock the ability to update the metadata for badgeIds [1,2] for timelineTimes 1/1/2020 - 1/1/2021,
// you could set the combination (badgeIds: [1,2], TimelineTimes: [1/1/2020 - 1/1/2021]) to always be forbidden.
type TimedUpdateWithBadgeIdsPermission struct {
	BadgeIds              []*UintRange  `protobuf:"bytes,1,rep,name=badgeIds,proto3" json:"badgeIds,omitempty"`
	TimelineTimes        []*UintRange  `protobuf:"bytes,2,rep,name=timelineTimes,proto3" json:"timelineTimes,omitempty"`
	PermittedTimes        []*UintRange  `protobuf:"bytes,3,rep,name=permittedTimes,proto3" json:"permittedTimes,omitempty"`
	ForbiddenTimes        []*UintRange  `protobuf:"bytes,4,rep,name=forbiddenTimes,proto3" json:"forbiddenTimes,omitempty"`
	TimelineTimesOptions *ValueOptions `protobuf:"bytes,5,opt,name=timelineTimesOptions,proto3" json:"timelineTimesOptions,omitempty"`
	BadgeIdsOptions       *ValueOptions `protobuf:"bytes,6,opt,name=badgeIdsOptions,proto3" json:"badgeIdsOptions,omitempty"`
	PermittedTimesOptions *ValueOptions `protobuf:"bytes,7,opt,name=permittedTimesOptions,proto3" json:"permittedTimesOptions,omitempty"`
	ForbiddenTimesOptions *ValueOptions `protobuf:"bytes,8,opt,name=forbiddenTimesOptions,proto3" json:"forbiddenTimesOptions,omitempty"`
}

func (m *TimedUpdateWithBadgeIdsPermission) Reset()         { *m = TimedUpdateWithBadgeIdsPermission{} }
func (m *TimedUpdateWithBadgeIdsPermission) String() string { return proto.CompactTextString(m) }
func (*TimedUpdateWithBadgeIdsPermission) ProtoMessage()    {}
func (*TimedUpdateWithBadgeIdsPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_1298419e4a97cfe6, []int{9}
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.Merge(m, src)
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_Size() int {
	return m.Size()
}
func (m *TimedUpdateWithBadgeIdsPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_TimedUpdateWithBadgeIdsPermission.DiscardUnknown(m)
}

var xxx_messageInfo_TimedUpdateWithBadgeIdsPermission proto.InternalMessageInfo

func (m *TimedUpdateWithBadgeIdsPermission) GetBadgeIds() []*UintRange {
	if m != nil {
		return m.BadgeIds
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetTimelineTimes() []*UintRange {
	if m != nil {
		return m.TimelineTimes
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetPermittedTimes() []*UintRange {
	if m != nil {
		return m.PermittedTimes
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetForbiddenTimes() []*UintRange {
	if m != nil {
		return m.ForbiddenTimes
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetTimelineTimesOptions() *ValueOptions {
	if m != nil {
		return m.TimelineTimesOptions
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetBadgeIdsOptions() *ValueOptions {
	if m != nil {
		return m.BadgeIdsOptions
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetPermittedTimesOptions() *ValueOptions {
	if m != nil {
		return m.PermittedTimesOptions
	}
	return nil
}

func (m *TimedUpdateWithBadgeIdsPermission) GetForbiddenTimesOptions() *ValueOptions {
	if m != nil {
		return m.ForbiddenTimesOptions
	}
	return nil
}

func init() {
	proto.RegisterType((*CollectionPermissions)(nil), "bitbadges.bitbadgeschain.badges.CollectionPermissions")
	proto.RegisterType((*UserPermissions)(nil), "bitbadges.bitbadgeschain.badges.UserPermissions")
	proto.RegisterType((*ValueOptions)(nil), "bitbadges.bitbadgeschain.badges.ValueOptions")
	proto.RegisterType((*CollectionApprovalPermission)(nil), "bitbadges.bitbadgeschain.badges.CollectionApprovalPermission")
	proto.RegisterType((*UserOutgoingApprovalPermission)(nil), "bitbadges.bitbadgeschain.badges.UserOutgoingApprovalPermission")
	proto.RegisterType((*UserIncomingApprovalPermission)(nil), "bitbadges.bitbadgeschain.badges.UserIncomingApprovalPermission")
	proto.RegisterType((*BalancesActionPermission)(nil), "bitbadges.bitbadgeschain.badges.BalancesActionPermission")
	proto.RegisterType((*ActionPermission)(nil), "bitbadges.bitbadgeschain.badges.ActionPermission")
	proto.RegisterType((*TimedUpdatePermission)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdatePermission")
	proto.RegisterType((*TimedUpdateWithBadgeIdsPermission)(nil), "bitbadges.bitbadgeschain.badges.TimedUpdateWithBadgeIdsPermission")
}

func init() { proto.RegisterFile("badges/permissions.proto", fileDescriptor_1298419e4a97cfe6) }

var fileDescriptor_1298419e4a97cfe6 = []byte{
	// 1200 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcd, 0x6b, 0x2b, 0x55,
	0x14, 0xef, 0x24, 0x4d, 0x9a, 0x9e, 0xf4, 0xf3, 0xbe, 0x56, 0xe6, 0xd5, 0x1a, 0xfb, 0x8a, 0x8b,
	0x22, 0x9a, 0x60, 0x05, 0xc1, 0x85, 0x48, 0x3f, 0x10, 0x0a, 0x96, 0xf7, 0x88, 0xef, 0xf9, 0x50,
	0x10, 0xb9, 0x99, 0xb9, 0x99, 0x8c, 0x9d, 0xdc, 0x1b, 0xee, 0xdc, 0xd4, 0x57, 0x37, 0x2a, 0xbc,
	0x3f, 0x40, 0xf0, 0x3f, 0x72, 0xe5, 0xf2, 0x2d, 0x5d, 0x4a, 0x0b, 0x6e, 0x5d, 0x09, 0x6e, 0x04,
	0x99, 0x3b, 0x1f, 0xc9, 0x64, 0xee, 0x34, 0x4d, 0x66, 0x12, 0x44, 0xba, 0x9b, 0xde, 0x8f, 0xdf,
	0xef, 0xe4, 0x9c, 0xdf, 0xf9, 0x9d, 0x4e, 0x53, 0xd0, 0x5b, 0xd8, 0xb4, 0x88, 0xdb, 0xe8, 0x11,
	0xde, 0xb5, 0x5d, 0xd7, 0x66, 0xd4, 0xad, 0xf7, 0x38, 0x13, 0x0c, 0xbd, 0xd9, 0xb2, 0x85, 0xbf,
	0x59, 0x8f, 0x9e, 0x8c, 0x0e, 0xb6, 0x69, 0xdd, 0x7f, 0xde, 0x79, 0x68, 0x31, 0x66, 0x39, 0xa4,
	0x21, 0x8f, 0xb7, 0xfa, 0xed, 0x06, 0xa6, 0x57, 0xfe, 0xdd, 0x9d, 0xed, 0x00, 0xb5, 0x85, 0x1d,
	0x4c, 0x0d, 0x12, 0x40, 0xee, 0xbc, 0x11, 0x2c, 0x63, 0xd3, 0xe4, 0xc4, 0x75, 0xbf, 0xee, 0xe2,
	0x5e, 0xcf, 0xa6, 0x56, 0xb8, 0xbd, 0x65, 0x31, 0x8b, 0xc9, 0xc7, 0x86, 0xf7, 0xe4, 0xaf, 0xee,
	0xff, 0x00, 0xb0, 0x7d, 0xc2, 0x1c, 0x87, 0x18, 0xc2, 0x66, 0xf4, 0xc9, 0x20, 0x4e, 0x64, 0xc0,
	0x03, 0x03, 0xd3, 0x53, 0xe2, 0x10, 0x41, 0x06, 0x27, 0x74, 0x6d, 0xaf, 0x78, 0x50, 0x3d, 0x7c,
	0xaf, 0x3e, 0x26, 0xfe, 0xfa, 0xd1, 0x08, 0x60, 0x53, 0x85, 0x86, 0xbe, 0x81, 0x2d, 0x03, 0xd3,
	0x23, 0x6e, 0x74, 0xec, 0xcb, 0x61, 0x96, 0x82, 0x64, 0xf9, 0x60, 0x2c, 0xcb, 0x53, 0xbb, 0x4b,
	0xcc, 0x67, 0x3d, 0x13, 0x0b, 0x32, 0x44, 0xa5, 0xc4, 0x44, 0x1c, 0x74, 0x03, 0x53, 0xff, 0xf0,
	0x09, 0xa3, 0x82, 0x63, 0x43, 0x1c, 0xf9, 0xb9, 0xd2, 0x8b, 0x99, 0xf8, 0x52, 0x71, 0xd1, 0x4b,
	0x0d, 0x1e, 0x45, 0x9b, 0x8f, 0xdb, 0xed, 0x13, 0x0f, 0xec, 0x38, 0xa8, 0xdb, 0x39, 0x11, 0xd8,
	0xc4, 0x02, 0xeb, 0x8b, 0x99, 0xd8, 0xc7, 0x13, 0xa0, 0x36, 0xa0, 0xe8, 0xd0, 0x67, 0x02, 0x53,
	0x13, 0x73, 0xd3, 0xd5, 0x4b, 0x99, 0x68, 0x15, 0x88, 0xa8, 0x23, 0x35, 0x13, 0xa4, 0xa2, 0xef,
	0x0a, 0xd6, 0x3d, 0xf5, 0x3e, 0x5f, 0x39, 0x13, 0x91, 0x0a, 0x12, 0xb5, 0x60, 0x23, 0x5a, 0x3e,
	0xc7, 0x14, 0x5b, 0x84, 0xeb, 0x4b, 0x99, 0x68, 0x12, 0x78, 0xe8, 0x05, 0xbc, 0x3e, 0x54, 0xd8,
	0x50, 0x47, 0x51, 0xd5, 0x2a, 0x99, 0xe8, 0x6e, 0x83, 0x46, 0x17, 0x32, 0x8f, 0x27, 0x9c, 0x78,
	0xd1, 0x30, 0x4e, 0x8e, 0x25, 0x92, 0xbe, 0x2c, 0x19, 0x3f, 0x1c, 0xcb, 0x18, 0xd6, 0x5f, 0xd9,
	0x83, 0xa3, 0xa8, 0xe8, 0x3b, 0x78, 0x2d, 0x8a, 0x45, 0x2e, 0x45, 0x9f, 0x10, 0x24, 0xdf, 0xf1,
	0x24, 0x9f, 0xf0, 0xb9, 0x2d, 0x3a, 0x12, 0xe4, 0xcc, 0x74, 0x87, 0x88, 0x53, 0x18, 0xd0, 0x8f,
	0x1a, 0xec, 0x2a, 0x12, 0x71, 0xd4, 0xeb, 0x71, 0x76, 0x89, 0x1d, 0x57, 0x5f, 0x91, 0x21, 0x7c,
	0x34, 0x36, 0x84, 0xe4, 0xdd, 0x21, 0xf6, 0x5b, 0x29, 0xf6, 0x7f, 0x2e, 0xc0, 0xfa, 0x33, 0x97,
	0xf0, 0x61, 0xf3, 0xfb, 0x1e, 0x76, 0x06, 0x5d, 0xd5, 0x17, 0x16, 0xb3, 0xa9, 0x35, 0x08, 0xca,
	0xf7, 0xc0, 0x8f, 0xc7, 0x06, 0xe5, 0xa1, 0x8e, 0xde, 0x1e, 0x0a, 0xeb, 0x16, 0x8a, 0x58, 0x00,
	0x67, 0xd4, 0x60, 0xdd, 0x58, 0x00, 0x85, 0x09, 0x02, 0x18, 0xbd, 0xad, 0x0c, 0x20, 0x41, 0xb1,
	0x4f, 0x61, 0xe5, 0x73, 0xec, 0xf4, 0xc9, 0xe3, 0x9e, 0x90, 0x19, 0x79, 0x0b, 0x56, 0x6d, 0x7a,
	0x49, 0xb8, 0x38, 0x25, 0x6d, 0xdc, 0x77, 0x84, 0xae, 0xed, 0x69, 0x07, 0x95, 0x66, 0x7c, 0x11,
	0xed, 0xc2, 0x32, 0x76, 0x1c, 0x79, 0xd1, 0x8b, 0xd2, 0x3b, 0x31, 0x58, 0x40, 0x3b, 0x50, 0xa1,
	0x2c, 0xd8, 0x2c, 0xca, 0xcd, 0xe8, 0xe7, 0xfd, 0xbf, 0x57, 0x60, 0xf7, 0xb6, 0x22, 0x7a, 0x01,
	0xb4, 0x39, 0xeb, 0x9e, 0xfb, 0x53, 0xed, 0xcc, 0x94, 0x01, 0x2c, 0x37, 0xe3, 0x8b, 0x68, 0x0f,
	0xaa, 0x82, 0x0d, 0xce, 0x14, 0xe4, 0x99, 0xe1, 0x25, 0x74, 0x08, 0x5b, 0x36, 0xb5, 0x85, 0x8d,
	0x05, 0x31, 0x8f, 0xaf, 0x06, 0x47, 0x8b, 0xf2, 0xa8, 0x72, 0x0f, 0x3d, 0x81, 0x55, 0xc1, 0x31,
	0x75, 0xdb, 0x84, 0x7b, 0x5a, 0x77, 0x03, 0xc7, 0x7e, 0x7b, 0x7c, 0x01, 0x6c, 0x2a, 0x9a, 0x98,
	0x5a, 0xa4, 0x19, 0x07, 0x40, 0x9f, 0x40, 0xa5, 0x15, 0xb4, 0x49, 0xe0, 0xc3, 0x93, 0x80, 0x45,
	0x77, 0x51, 0x13, 0xd6, 0xd8, 0xb7, 0x94, 0x70, 0xb7, 0x63, 0xf7, 0xfc, 0xd0, 0xca, 0x13, 0xa3,
	0x8d, 0x20, 0xa0, 0x77, 0x60, 0x13, 0x07, 0xf9, 0x7f, 0xca, 0xb1, 0x71, 0x41, 0xf8, 0x99, 0xa9,
	0x2f, 0xc9, 0xf4, 0x24, 0x37, 0x50, 0x1d, 0x90, 0xd1, 0xc1, 0x8e, 0x43, 0xa8, 0x45, 0x06, 0xc7,
	0x2b, 0xf2, 0xb8, 0x62, 0xc7, 0x8b, 0x58, 0xfe, 0x3a, 0x24, 0x04, 0x31, 0xfd, 0x88, 0x97, 0x27,
	0x8f, 0x38, 0x8e, 0xe0, 0x61, 0xb6, 0x19, 0x6f, 0xd9, 0xa6, 0x49, 0xa8, 0x8f, 0x09, 0x93, 0x63,
	0xc6, 0x11, 0xd0, 0x57, 0x80, 0x86, 0xa4, 0x15, 0xb4, 0x81, 0x5e, 0xdd, 0xd3, 0x0e, 0xaa, 0x87,
	0xef, 0x8e, 0xc5, 0x1d, 0xee, 0x9d, 0xa6, 0x02, 0x08, 0x7d, 0x01, 0x1b, 0x91, 0x2a, 0x43, 0xf0,
	0x95, 0x69, 0xc0, 0x13, 0x30, 0xe8, 0x02, 0x1e, 0x26, 0x55, 0x1c, 0x72, 0xac, 0x4e, 0xc3, 0x91,
	0x8e, 0x87, 0x30, 0x6c, 0xc5, 0x94, 0x1d, 0xf2, 0xac, 0x4d, 0xc3, 0xa3, 0x84, 0x42, 0xcf, 0x61,
	0x3d, 0xd4, 0x7b, 0x88, 0xbe, 0x3e, 0x0d, 0xfa, 0x28, 0x0a, 0x32, 0x60, 0x3b, 0x2e, 0xfd, 0x10,
	0x7e, 0x63, 0x1a, 0x78, 0x35, 0x16, 0xb2, 0x41, 0x4f, 0x34, 0x4d, 0xc8, 0xb3, 0x39, 0x0d, 0x4f,
	0x2a, 0x9c, 0x57, 0xf8, 0x64, 0xc3, 0x85, 0x5c, 0x68, 0xaa, 0xc2, 0xa7, 0xe2, 0x79, 0xc9, 0x8b,
	0x77, 0x61, 0x48, 0xf4, 0x60, 0xaa, 0xe4, 0x29, 0xb1, 0x3c, 0x92, 0x78, 0x5b, 0x86, 0x24, 0x5b,
	0x53, 0x91, 0x28, 0xb1, 0xf6, 0xff, 0xaa, 0x42, 0xed, 0xf6, 0x51, 0x3d, 0x3a, 0x56, 0xb4, 0xbb,
	0x8f, 0x95, 0xc2, 0x24, 0x63, 0xa5, 0x98, 0xe7, 0x58, 0x59, 0xcc, 0x75, 0xac, 0x94, 0x66, 0x33,
	0x56, 0xca, 0x93, 0x8d, 0x95, 0xa5, 0x09, 0xc6, 0x4a, 0x65, 0x06, 0x63, 0x65, 0x39, 0xf3, 0x58,
	0x51, 0xf9, 0x3e, 0xcc, 0xc1, 0xf7, 0xab, 0x73, 0xf2, 0xfd, 0x95, 0x99, 0xfa, 0xfe, 0xea, 0x6c,
	0x7d, 0x7f, 0x6d, 0x4e, 0xbe, 0xbf, 0x3e, 0x47, 0xdf, 0xdf, 0x98, 0x97, 0xef, 0x6f, 0xce, 0xc3,
	0xf7, 0x51, 0x8e, 0xbe, 0xff, 0x4f, 0xe0, 0xfb, 0xe9, 0x6f, 0x48, 0x77, 0x7c, 0xe9, 0xb8, 0xf7,
	0xfe, 0x7b, 0xef, 0x9f, 0xfe, 0x95, 0x02, 0xf2, 0x7a, 0xa5, 0xb8, 0xf7, 0xff, 0x7b, 0xff, 0xbf,
	0xf7, 0xff, 0xbb, 0xfb, 0xff, 0x1f, 0x25, 0xd0, 0xd3, 0xfe, 0x54, 0x1a, 0x73, 0x53, 0x2d, 0x57,
	0x37, 0x2d, 0x64, 0x76, 0xd3, 0xa4, 0xdf, 0x15, 0x67, 0xe0, 0x77, 0x8b, 0x99, 0xfd, 0x4e, 0xd1,
	0xc0, 0xa5, 0xd9, 0x36, 0x70, 0x39, 0xc7, 0x06, 0x4e, 0x15, 0xfa, 0xd2, 0x3c, 0x84, 0x5e, 0xc9,
	0x51, 0xe8, 0x2f, 0x8b, 0xb0, 0x91, 0x10, 0x78, 0x52, 0x44, 0xda, 0x0c, 0x44, 0x54, 0xc8, 0x2c,
	0xa2, 0xd4, 0x32, 0x14, 0xe7, 0x51, 0x86, 0xc5, 0x1c, 0xcb, 0xf0, 0xcb, 0x22, 0x6c, 0x2b, 0xbf,
	0x0c, 0xf2, 0xf2, 0xe6, 0x1a, 0x1d, 0x62, 0xf6, 0x9d, 0x0c, 0xb5, 0x88, 0x23, 0x28, 0xea, 0x5b,
	0x98, 0x41, 0x7d, 0x8b, 0x79, 0xd4, 0x37, 0x1e, 0x79, 0xb6, 0xd4, 0x2b, 0xb1, 0xd2, 0x45, 0x54,
	0x9a, 0x87, 0x88, 0xca, 0x39, 0x8a, 0xe8, 0xcf, 0x12, 0x3c, 0x1a, 0xfb, 0x7d, 0x5b, 0x9e, 0xd3,
	0x6b, 0x44, 0x98, 0x85, 0x19, 0x08, 0xf3, 0xbf, 0x39, 0xbd, 0x52, 0x85, 0x59, 0xca, 0x51, 0x98,
	0x8a, 0x11, 0x59, 0xce, 0x6b, 0x44, 0xfe, 0x3f, 0xa6, 0xd7, 0xf1, 0xa7, 0xbf, 0x5e, 0xd7, 0xb4,
	0x57, 0xd7, 0x35, 0xed, 0xf7, 0xeb, 0x9a, 0xf6, 0xd3, 0x4d, 0x6d, 0xe1, 0xd5, 0x4d, 0x6d, 0xe1,
	0xb7, 0x9b, 0xda, 0xc2, 0x97, 0x87, 0x96, 0x2d, 0x3a, 0xfd, 0x56, 0xdd, 0x60, 0xdd, 0x46, 0x84,
	0xdf, 0x88, 0x33, 0x35, 0x5e, 0x34, 0x82, 0x75, 0x71, 0xd5, 0x23, 0x6e, 0xab, 0x2c, 0xff, 0xef,
	0xe5, 0xfd, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x06, 0x3f, 0x1f, 0x9a, 0x9b, 0x23, 0x00, 0x00,
}

func (m *CollectionPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateCollectionApprovals) > 0 {
		for iNdEx := len(m.CanUpdateCollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.CanUpdateBadgeMetadata) > 0 {
		for iNdEx := len(m.CanUpdateBadgeMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateBadgeMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.CanCreateMoreBadges) > 0 {
		for iNdEx := len(m.CanCreateMoreBadges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanCreateMoreBadges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for iNdEx := len(m.CanUpdateCollectionMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for iNdEx := len(m.CanUpdateManager) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateManager[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for iNdEx := len(m.CanUpdateCustomData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCustomData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.CanUpdateStandards) > 0 {
		for iNdEx := len(m.CanUpdateStandards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateStandards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CanUpdateOffChainBalancesMetadata) > 0 {
		for iNdEx := len(m.CanUpdateOffChainBalancesMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateOffChainBalancesMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CanUpdateContractAddress) > 0 {
		for iNdEx := len(m.CanUpdateContractAddress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateContractAddress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CanArchiveCollection) > 0 {
		for iNdEx := len(m.CanArchiveCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanArchiveCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CanDeleteCollection) > 0 {
		for iNdEx := len(m.CanDeleteCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanDeleteCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateIncomingApprovals) > 0 {
		for iNdEx := len(m.CanUpdateIncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateIncomingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CanUpdateOutgoingApprovals) > 0 {
		for iNdEx := len(m.CanUpdateOutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateOutgoingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ValueOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoValues {
		i--
		if m.NoValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AllValues {
		i--
		if m.AllValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.InvertDefault {
		i--
		if m.InvertDefault {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CollectionApprovalPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectionApprovalPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectionApprovalPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.ChallengeTrackerIdOptions != nil {
		{
			size, err := m.ChallengeTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.ApprovalTrackerIdOptions != nil {
		{
			size, err := m.ApprovalTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.OwnershipTimesOptions != nil {
		{
			size, err := m.OwnershipTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.TransferTimesOptions != nil {
		{
			size, err := m.TransferTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.InitiatedByMappingOptions != nil {
		{
			size, err := m.InitiatedByMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.ToMappingOptions != nil {
		{
			size, err := m.ToMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.FromMappingOptions != nil {
		{
			size, err := m.FromMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ApprovalTrackerId) > 0 {
		i -= len(m.ApprovalTrackerId)
		copy(dAtA[i:], m.ApprovalTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ApprovalTrackerId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ToMappingId) > 0 {
		i -= len(m.ToMappingId)
		copy(dAtA[i:], m.ToMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ToMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromMappingId) > 0 {
		i -= len(m.FromMappingId)
		copy(dAtA[i:], m.FromMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.FromMappingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserOutgoingApprovalPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserOutgoingApprovalPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserOutgoingApprovalPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ChallengeTrackerIdOptions != nil {
		{
			size, err := m.ChallengeTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ApprovalTrackerIdOptions != nil {
		{
			size, err := m.ApprovalTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.OwnershipTimesOptions != nil {
		{
			size, err := m.OwnershipTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.TransferTimesOptions != nil {
		{
			size, err := m.TransferTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.InitiatedByMappingOptions != nil {
		{
			size, err := m.InitiatedByMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ToMappingOptions != nil {
		{
			size, err := m.ToMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ApprovalTrackerId) > 0 {
		i -= len(m.ApprovalTrackerId)
		copy(dAtA[i:], m.ApprovalTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ApprovalTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ToMappingId) > 0 {
		i -= len(m.ToMappingId)
		copy(dAtA[i:], m.ToMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ToMappingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserIncomingApprovalPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIncomingApprovalPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserIncomingApprovalPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ChallengeTrackerIdOptions != nil {
		{
			size, err := m.ChallengeTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ApprovalTrackerIdOptions != nil {
		{
			size, err := m.ApprovalTrackerIdOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.OwnershipTimesOptions != nil {
		{
			size, err := m.OwnershipTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.TransferTimesOptions != nil {
		{
			size, err := m.TransferTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.InitiatedByMappingOptions != nil {
		{
			size, err := m.InitiatedByMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.FromMappingOptions != nil {
		{
			size, err := m.FromMappingOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ChallengeTrackerId) > 0 {
		i -= len(m.ChallengeTrackerId)
		copy(dAtA[i:], m.ChallengeTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ChallengeTrackerId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ApprovalTrackerId) > 0 {
		i -= len(m.ApprovalTrackerId)
		copy(dAtA[i:], m.ApprovalTrackerId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.ApprovalTrackerId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TransferTimes) > 0 {
		for iNdEx := len(m.TransferTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TransferTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.InitiatedByMappingId) > 0 {
		i -= len(m.InitiatedByMappingId)
		copy(dAtA[i:], m.InitiatedByMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.InitiatedByMappingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromMappingId) > 0 {
		i -= len(m.FromMappingId)
		copy(dAtA[i:], m.FromMappingId)
		i = encodeVarintPermissions(dAtA, i, uint64(len(m.FromMappingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BalancesActionPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BalancesActionPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BalancesActionPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.OwnershipTimesOptions != nil {
		{
			size, err := m.OwnershipTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for iNdEx := len(m.OwnershipTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnershipTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActionPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdatePermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdatePermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdatePermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TimelineTimesOptions != nil {
		{
			size, err := m.TimelineTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TimedUpdateWithBadgeIdsPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedUpdateWithBadgeIdsPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimedUpdateWithBadgeIdsPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForbiddenTimesOptions != nil {
		{
			size, err := m.ForbiddenTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.PermittedTimesOptions != nil {
		{
			size, err := m.PermittedTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BadgeIdsOptions != nil {
		{
			size, err := m.BadgeIdsOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TimelineTimesOptions != nil {
		{
			size, err := m.TimelineTimesOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissions(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ForbiddenTimes) > 0 {
		for iNdEx := len(m.ForbiddenTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForbiddenTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PermittedTimes) > 0 {
		for iNdEx := len(m.PermittedTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PermittedTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TimelineTimes) > 0 {
		for iNdEx := len(m.TimelineTimes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TimelineTimes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BadgeIds) > 0 {
		for iNdEx := len(m.BadgeIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPermissions(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPermissions(dAtA []byte, offset int, v uint64) int {
	offset -= sovPermissions(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CollectionPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CanDeleteCollection) > 0 {
		for _, e := range m.CanDeleteCollection {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanArchiveCollection) > 0 {
		for _, e := range m.CanArchiveCollection {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateContractAddress) > 0 {
		for _, e := range m.CanUpdateContractAddress {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateOffChainBalancesMetadata) > 0 {
		for _, e := range m.CanUpdateOffChainBalancesMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateStandards) > 0 {
		for _, e := range m.CanUpdateStandards {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for _, e := range m.CanUpdateCustomData {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for _, e := range m.CanUpdateManager {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for _, e := range m.CanUpdateCollectionMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanCreateMoreBadges) > 0 {
		for _, e := range m.CanCreateMoreBadges {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateBadgeMetadata) > 0 {
		for _, e := range m.CanUpdateBadgeMetadata {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionApprovals) > 0 {
		for _, e := range m.CanUpdateCollectionApprovals {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *UserPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CanUpdateOutgoingApprovals) > 0 {
		for _, e := range m.CanUpdateOutgoingApprovals {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.CanUpdateIncomingApprovals) > 0 {
		for _, e := range m.CanUpdateIncomingApprovals {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	return n
}

func (m *ValueOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvertDefault {
		n += 2
	}
	if m.AllValues {
		n += 2
	}
	if m.NoValues {
		n += 2
	}
	return n
}

func (m *CollectionApprovalPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ToMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.ApprovalTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if m.FromMappingOptions != nil {
		l = m.FromMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ToMappingOptions != nil {
		l = m.ToMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.InitiatedByMappingOptions != nil {
		l = m.InitiatedByMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.TransferTimesOptions != nil {
		l = m.TransferTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.OwnershipTimesOptions != nil {
		l = m.OwnershipTimesOptions.Size()
		n += 2 + l + sovPermissions(uint64(l))
	}
	if m.ApprovalTrackerIdOptions != nil {
		l = m.ApprovalTrackerIdOptions.Size()
		n += 2 + l + sovPermissions(uint64(l))
	}
	if m.ChallengeTrackerIdOptions != nil {
		l = m.ChallengeTrackerIdOptions.Size()
		n += 2 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 2 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 2 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *UserOutgoingApprovalPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ToMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.ApprovalTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if m.ToMappingOptions != nil {
		l = m.ToMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.InitiatedByMappingOptions != nil {
		l = m.InitiatedByMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.TransferTimesOptions != nil {
		l = m.TransferTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.OwnershipTimesOptions != nil {
		l = m.OwnershipTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ApprovalTrackerIdOptions != nil {
		l = m.ApprovalTrackerIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ChallengeTrackerIdOptions != nil {
		l = m.ChallengeTrackerIdOptions.Size()
		n += 2 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 2 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 2 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *UserIncomingApprovalPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.InitiatedByMappingId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.TransferTimes) > 0 {
		for _, e := range m.TransferTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	l = len(m.ApprovalTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	l = len(m.ChallengeTrackerId)
	if l > 0 {
		n += 1 + l + sovPermissions(uint64(l))
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if m.FromMappingOptions != nil {
		l = m.FromMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.InitiatedByMappingOptions != nil {
		l = m.InitiatedByMappingOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.TransferTimesOptions != nil {
		l = m.TransferTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.OwnershipTimesOptions != nil {
		l = m.OwnershipTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ApprovalTrackerIdOptions != nil {
		l = m.ApprovalTrackerIdOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ChallengeTrackerIdOptions != nil {
		l = m.ChallengeTrackerIdOptions.Size()
		n += 2 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 2 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 2 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *BalancesActionPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.OwnershipTimes) > 0 {
		for _, e := range m.OwnershipTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.OwnershipTimesOptions != nil {
		l = m.OwnershipTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *ActionPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *TimedUpdatePermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if m.TimelineTimesOptions != nil {
		l = m.TimelineTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func (m *TimedUpdateWithBadgeIdsPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BadgeIds) > 0 {
		for _, e := range m.BadgeIds {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.TimelineTimes) > 0 {
		for _, e := range m.TimelineTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.PermittedTimes) > 0 {
		for _, e := range m.PermittedTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if len(m.ForbiddenTimes) > 0 {
		for _, e := range m.ForbiddenTimes {
			l = e.Size()
			n += 1 + l + sovPermissions(uint64(l))
		}
	}
	if m.TimelineTimesOptions != nil {
		l = m.TimelineTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.BadgeIdsOptions != nil {
		l = m.BadgeIdsOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.PermittedTimesOptions != nil {
		l = m.PermittedTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	if m.ForbiddenTimesOptions != nil {
		l = m.ForbiddenTimesOptions.Size()
		n += 1 + l + sovPermissions(uint64(l))
	}
	return n
}

func sovPermissions(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPermissions(x uint64) (n int) {
	return sovPermissions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CollectionPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDeleteCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanDeleteCollection = append(m.CanDeleteCollection, &ActionPermission{})
			if err := m.CanDeleteCollection[len(m.CanDeleteCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanArchiveCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanArchiveCollection = append(m.CanArchiveCollection, &TimedUpdatePermission{})
			if err := m.CanArchiveCollection[len(m.CanArchiveCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateContractAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateContractAddress = append(m.CanUpdateContractAddress, &TimedUpdatePermission{})
			if err := m.CanUpdateContractAddress[len(m.CanUpdateContractAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateOffChainBalancesMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateOffChainBalancesMetadata = append(m.CanUpdateOffChainBalancesMetadata, &TimedUpdatePermission{})
			if err := m.CanUpdateOffChainBalancesMetadata[len(m.CanUpdateOffChainBalancesMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateStandards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateStandards = append(m.CanUpdateStandards, &TimedUpdatePermission{})
			if err := m.CanUpdateStandards[len(m.CanUpdateStandards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCustomData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCustomData = append(m.CanUpdateCustomData, &TimedUpdatePermission{})
			if err := m.CanUpdateCustomData[len(m.CanUpdateCustomData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateManager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateManager = append(m.CanUpdateManager, &TimedUpdatePermission{})
			if err := m.CanUpdateManager[len(m.CanUpdateManager)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionMetadata = append(m.CanUpdateCollectionMetadata, &TimedUpdatePermission{})
			if err := m.CanUpdateCollectionMetadata[len(m.CanUpdateCollectionMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanCreateMoreBadges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanCreateMoreBadges = append(m.CanCreateMoreBadges, &BalancesActionPermission{})
			if err := m.CanCreateMoreBadges[len(m.CanCreateMoreBadges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateBadgeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateBadgeMetadata = append(m.CanUpdateBadgeMetadata, &TimedUpdateWithBadgeIdsPermission{})
			if err := m.CanUpdateBadgeMetadata[len(m.CanUpdateBadgeMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionApprovals = append(m.CanUpdateCollectionApprovals, &CollectionApprovalPermission{})
			if err := m.CanUpdateCollectionApprovals[len(m.CanUpdateCollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateOutgoingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateOutgoingApprovals = append(m.CanUpdateOutgoingApprovals, &UserOutgoingApprovalPermission{})
			if err := m.CanUpdateOutgoingApprovals[len(m.CanUpdateOutgoingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateIncomingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateIncomingApprovals = append(m.CanUpdateIncomingApprovals, &UserIncomingApprovalPermission{})
			if err := m.CanUpdateIncomingApprovals[len(m.CanUpdateIncomingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertDefault = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllValues = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoValues = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectionApprovalPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectionApprovalPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectionApprovalPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FromMappingOptions == nil {
				m.FromMappingOptions = &ValueOptions{}
			}
			if err := m.FromMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToMappingOptions == nil {
				m.ToMappingOptions = &ValueOptions{}
			}
			if err := m.ToMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedByMappingOptions == nil {
				m.InitiatedByMappingOptions = &ValueOptions{}
			}
			if err := m.InitiatedByMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTimesOptions == nil {
				m.TransferTimesOptions = &ValueOptions{}
			}
			if err := m.TransferTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnershipTimesOptions == nil {
				m.OwnershipTimesOptions = &ValueOptions{}
			}
			if err := m.OwnershipTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalTrackerIdOptions == nil {
				m.ApprovalTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ApprovalTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChallengeTrackerIdOptions == nil {
				m.ChallengeTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ChallengeTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserOutgoingApprovalPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserOutgoingApprovalPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserOutgoingApprovalPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToMappingOptions == nil {
				m.ToMappingOptions = &ValueOptions{}
			}
			if err := m.ToMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedByMappingOptions == nil {
				m.InitiatedByMappingOptions = &ValueOptions{}
			}
			if err := m.InitiatedByMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTimesOptions == nil {
				m.TransferTimesOptions = &ValueOptions{}
			}
			if err := m.TransferTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnershipTimesOptions == nil {
				m.OwnershipTimesOptions = &ValueOptions{}
			}
			if err := m.OwnershipTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalTrackerIdOptions == nil {
				m.ApprovalTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ApprovalTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChallengeTrackerIdOptions == nil {
				m.ChallengeTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ChallengeTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIncomingApprovalPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIncomingApprovalPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIncomingApprovalPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatedByMappingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferTimes = append(m.TransferTimes, &UintRange{})
			if err := m.TransferTimes[len(m.TransferTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeTrackerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FromMappingOptions == nil {
				m.FromMappingOptions = &ValueOptions{}
			}
			if err := m.FromMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedByMappingOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatedByMappingOptions == nil {
				m.InitiatedByMappingOptions = &ValueOptions{}
			}
			if err := m.InitiatedByMappingOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTimesOptions == nil {
				m.TransferTimesOptions = &ValueOptions{}
			}
			if err := m.TransferTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnershipTimesOptions == nil {
				m.OwnershipTimesOptions = &ValueOptions{}
			}
			if err := m.OwnershipTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalTrackerIdOptions == nil {
				m.ApprovalTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ApprovalTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTrackerIdOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChallengeTrackerIdOptions == nil {
				m.ChallengeTrackerIdOptions = &ValueOptions{}
			}
			if err := m.ChallengeTrackerIdOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BalancesActionPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BalancesActionPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BalancesActionPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnershipTimes = append(m.OwnershipTimes, &UintRange{})
			if err := m.OwnershipTimes[len(m.OwnershipTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnershipTimesOptions == nil {
				m.OwnershipTimesOptions = &ValueOptions{}
			}
			if err := m.OwnershipTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdatePermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdatePermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdatePermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &UintRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimelineTimesOptions == nil {
				m.TimelineTimesOptions = &ValueOptions{}
			}
			if err := m.TimelineTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedUpdateWithBadgeIdsPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedUpdateWithBadgeIdsPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIds = append(m.BadgeIds, &UintRange{})
			if err := m.BadgeIds[len(m.BadgeIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimelineTimes = append(m.TimelineTimes, &UintRange{})
			if err := m.TimelineTimes[len(m.TimelineTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermittedTimes = append(m.PermittedTimes, &UintRange{})
			if err := m.PermittedTimes[len(m.PermittedTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenTimes = append(m.ForbiddenTimes, &UintRange{})
			if err := m.ForbiddenTimes[len(m.ForbiddenTimes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimelineTimesOptions == nil {
				m.TimelineTimesOptions = &ValueOptions{}
			}
			if err := m.TimelineTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BadgeIdsOptions == nil {
				m.BadgeIdsOptions = &ValueOptions{}
			}
			if err := m.BadgeIdsOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermittedTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermittedTimesOptions == nil {
				m.PermittedTimesOptions = &ValueOptions{}
			}
			if err := m.PermittedTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenTimesOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissions
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissions
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForbiddenTimesOptions == nil {
				m.ForbiddenTimesOptions = &ValueOptions{}
			}
			if err := m.ForbiddenTimesOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissions(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPermissions(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPermissions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPermissions
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPermissions
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPermissions
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPermissions        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPermissions          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPermissions = fmt.Errorf("proto: unexpected end of group")
)
