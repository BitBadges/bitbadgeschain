// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/v20/tx.proto

package v20

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Used for WASM bindings and JSON parsing
type BadgeCustomMsgType struct {
	CreateAddressListsMsg        *MsgCreateAddressLists        `protobuf:"bytes,1,opt,name=createAddressListsMsg,proto3" json:"createAddressListsMsg,omitempty"`
	UniversalUpdateCollectionMsg *MsgUniversalUpdateCollection `protobuf:"bytes,2,opt,name=universalUpdateCollectionMsg,proto3" json:"universalUpdateCollectionMsg,omitempty"`
	DeleteCollectionMsg          *MsgDeleteCollection          `protobuf:"bytes,3,opt,name=deleteCollectionMsg,proto3" json:"deleteCollectionMsg,omitempty"`
	TransferTokensMsg            *MsgTransferTokens            `protobuf:"bytes,4,opt,name=transferTokensMsg,proto3" json:"transferTokensMsg,omitempty"`
	UpdateUserApprovalsMsg       *MsgUpdateUserApprovals       `protobuf:"bytes,5,opt,name=updateUserApprovalsMsg,proto3" json:"updateUserApprovalsMsg,omitempty"`
	UpdateCollectionMsg          *MsgUpdateCollection          `protobuf:"bytes,6,opt,name=updateCollectionMsg,proto3" json:"updateCollectionMsg,omitempty"`
	CreateCollectionMsg          *MsgCreateCollection          `protobuf:"bytes,7,opt,name=createCollectionMsg,proto3" json:"createCollectionMsg,omitempty"`
	CreateDynamicStoreMsg        *MsgCreateDynamicStore        `protobuf:"bytes,8,opt,name=createDynamicStoreMsg,proto3" json:"createDynamicStoreMsg,omitempty"`
	UpdateDynamicStoreMsg        *MsgUpdateDynamicStore        `protobuf:"bytes,9,opt,name=updateDynamicStoreMsg,proto3" json:"updateDynamicStoreMsg,omitempty"`
	DeleteDynamicStoreMsg        *MsgDeleteDynamicStore        `protobuf:"bytes,10,opt,name=deleteDynamicStoreMsg,proto3" json:"deleteDynamicStoreMsg,omitempty"`
	SetDynamicStoreValueMsg      *MsgSetDynamicStoreValue      `protobuf:"bytes,11,opt,name=setDynamicStoreValueMsg,proto3" json:"setDynamicStoreValueMsg,omitempty"`
	SetIncomingApprovalMsg       *MsgSetIncomingApproval       `protobuf:"bytes,14,opt,name=setIncomingApprovalMsg,proto3" json:"setIncomingApprovalMsg,omitempty"`
	DeleteIncomingApprovalMsg    *MsgDeleteIncomingApproval    `protobuf:"bytes,15,opt,name=deleteIncomingApprovalMsg,proto3" json:"deleteIncomingApprovalMsg,omitempty"`
	SetOutgoingApprovalMsg       *MsgSetOutgoingApproval       `protobuf:"bytes,16,opt,name=setOutgoingApprovalMsg,proto3" json:"setOutgoingApprovalMsg,omitempty"`
	DeleteOutgoingApprovalMsg    *MsgDeleteOutgoingApproval    `protobuf:"bytes,17,opt,name=deleteOutgoingApprovalMsg,proto3" json:"deleteOutgoingApprovalMsg,omitempty"`
	PurgeApprovalsMsg            *MsgPurgeApprovals            `protobuf:"bytes,18,opt,name=purgeApprovalsMsg,proto3" json:"purgeApprovalsMsg,omitempty"`
	// Helper message types for UniversalUpdateCollection subsets
	SetValidTokenIdsMsg           *MsgSetValidTokenIds           `protobuf:"bytes,19,opt,name=setValidTokenIdsMsg,proto3" json:"setValidTokenIdsMsg,omitempty"`
	SetManagerMsg                 *MsgSetManager                 `protobuf:"bytes,20,opt,name=setManagerMsg,proto3" json:"setManagerMsg,omitempty"`
	SetCollectionMetadataMsg      *MsgSetCollectionMetadata      `protobuf:"bytes,21,opt,name=setCollectionMetadataMsg,proto3" json:"setCollectionMetadataMsg,omitempty"`
	SetTokenMetadataMsg           *MsgSetTokenMetadata           `protobuf:"bytes,22,opt,name=setTokenMetadataMsg,proto3" json:"setTokenMetadataMsg,omitempty"`
	SetCustomDataMsg              *MsgSetCustomData              `protobuf:"bytes,23,opt,name=setCustomDataMsg,proto3" json:"setCustomDataMsg,omitempty"`
	SetStandardsMsg               *MsgSetStandards               `protobuf:"bytes,24,opt,name=setStandardsMsg,proto3" json:"setStandardsMsg,omitempty"`
	SetCollectionApprovalsMsg     *MsgSetCollectionApprovals     `protobuf:"bytes,25,opt,name=setCollectionApprovalsMsg,proto3" json:"setCollectionApprovalsMsg,omitempty"`
	SetIsArchivedMsg              *MsgSetIsArchived              `protobuf:"bytes,26,opt,name=setIsArchivedMsg,proto3" json:"setIsArchivedMsg,omitempty"`
	SetReservedProtocolAddressMsg *MsgSetReservedProtocolAddress `protobuf:"bytes,27,opt,name=setReservedProtocolAddressMsg,proto3" json:"setReservedProtocolAddressMsg,omitempty"`
}

func (m *BadgeCustomMsgType) Reset()         { *m = BadgeCustomMsgType{} }
func (m *BadgeCustomMsgType) String() string { return proto.CompactTextString(m) }
func (*BadgeCustomMsgType) ProtoMessage()    {}
func (*BadgeCustomMsgType) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{0}
}
func (m *BadgeCustomMsgType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadgeCustomMsgType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BadgeCustomMsgType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BadgeCustomMsgType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadgeCustomMsgType.Merge(m, src)
}
func (m *BadgeCustomMsgType) XXX_Size() int {
	return m.Size()
}
func (m *BadgeCustomMsgType) XXX_DiscardUnknown() {
	xxx_messageInfo_BadgeCustomMsgType.DiscardUnknown(m)
}

var xxx_messageInfo_BadgeCustomMsgType proto.InternalMessageInfo

func (m *BadgeCustomMsgType) GetCreateAddressListsMsg() *MsgCreateAddressLists {
	if m != nil {
		return m.CreateAddressListsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetUniversalUpdateCollectionMsg() *MsgUniversalUpdateCollection {
	if m != nil {
		return m.UniversalUpdateCollectionMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetDeleteCollectionMsg() *MsgDeleteCollection {
	if m != nil {
		return m.DeleteCollectionMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetTransferTokensMsg() *MsgTransferTokens {
	if m != nil {
		return m.TransferTokensMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetUpdateUserApprovalsMsg() *MsgUpdateUserApprovals {
	if m != nil {
		return m.UpdateUserApprovalsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetUpdateCollectionMsg() *MsgUpdateCollection {
	if m != nil {
		return m.UpdateCollectionMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetCreateCollectionMsg() *MsgCreateCollection {
	if m != nil {
		return m.CreateCollectionMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetCreateDynamicStoreMsg() *MsgCreateDynamicStore {
	if m != nil {
		return m.CreateDynamicStoreMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetUpdateDynamicStoreMsg() *MsgUpdateDynamicStore {
	if m != nil {
		return m.UpdateDynamicStoreMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetDeleteDynamicStoreMsg() *MsgDeleteDynamicStore {
	if m != nil {
		return m.DeleteDynamicStoreMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetDynamicStoreValueMsg() *MsgSetDynamicStoreValue {
	if m != nil {
		return m.SetDynamicStoreValueMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetIncomingApprovalMsg() *MsgSetIncomingApproval {
	if m != nil {
		return m.SetIncomingApprovalMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetDeleteIncomingApprovalMsg() *MsgDeleteIncomingApproval {
	if m != nil {
		return m.DeleteIncomingApprovalMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetOutgoingApprovalMsg() *MsgSetOutgoingApproval {
	if m != nil {
		return m.SetOutgoingApprovalMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetDeleteOutgoingApprovalMsg() *MsgDeleteOutgoingApproval {
	if m != nil {
		return m.DeleteOutgoingApprovalMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetPurgeApprovalsMsg() *MsgPurgeApprovals {
	if m != nil {
		return m.PurgeApprovalsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetValidTokenIdsMsg() *MsgSetValidTokenIds {
	if m != nil {
		return m.SetValidTokenIdsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetManagerMsg() *MsgSetManager {
	if m != nil {
		return m.SetManagerMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetCollectionMetadataMsg() *MsgSetCollectionMetadata {
	if m != nil {
		return m.SetCollectionMetadataMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetTokenMetadataMsg() *MsgSetTokenMetadata {
	if m != nil {
		return m.SetTokenMetadataMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetCustomDataMsg() *MsgSetCustomData {
	if m != nil {
		return m.SetCustomDataMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetStandardsMsg() *MsgSetStandards {
	if m != nil {
		return m.SetStandardsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetCollectionApprovalsMsg() *MsgSetCollectionApprovals {
	if m != nil {
		return m.SetCollectionApprovalsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetIsArchivedMsg() *MsgSetIsArchived {
	if m != nil {
		return m.SetIsArchivedMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetSetReservedProtocolAddressMsg() *MsgSetReservedProtocolAddress {
	if m != nil {
		return m.SetReservedProtocolAddressMsg
	}
	return nil
}

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the module parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{1}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{2}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

type CosmosCoinWrapperPathAddObject struct {
	Denom                          string       `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Balances                       []*Balance   `protobuf:"bytes,2,rep,name=balances,proto3" json:"balances,omitempty"`
	Symbol                         string       `protobuf:"bytes,3,opt,name=symbol,proto3" json:"symbol,omitempty"`
	DenomUnits                     []*DenomUnit `protobuf:"bytes,4,rep,name=denomUnits,proto3" json:"denomUnits,omitempty"`
	AllowOverrideWithAnyValidToken bool         `protobuf:"varint,5,opt,name=allowOverrideWithAnyValidToken,proto3" json:"allowOverrideWithAnyValidToken,omitempty"`
	AllowCosmosWrapping            bool         `protobuf:"varint,6,opt,name=allowCosmosWrapping,proto3" json:"allowCosmosWrapping,omitempty"`
}

func (m *CosmosCoinWrapperPathAddObject) Reset()         { *m = CosmosCoinWrapperPathAddObject{} }
func (m *CosmosCoinWrapperPathAddObject) String() string { return proto.CompactTextString(m) }
func (*CosmosCoinWrapperPathAddObject) ProtoMessage()    {}
func (*CosmosCoinWrapperPathAddObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{3}
}
func (m *CosmosCoinWrapperPathAddObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosCoinWrapperPathAddObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosCoinWrapperPathAddObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosCoinWrapperPathAddObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosCoinWrapperPathAddObject.Merge(m, src)
}
func (m *CosmosCoinWrapperPathAddObject) XXX_Size() int {
	return m.Size()
}
func (m *CosmosCoinWrapperPathAddObject) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosCoinWrapperPathAddObject.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosCoinWrapperPathAddObject proto.InternalMessageInfo

func (m *CosmosCoinWrapperPathAddObject) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *CosmosCoinWrapperPathAddObject) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *CosmosCoinWrapperPathAddObject) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CosmosCoinWrapperPathAddObject) GetDenomUnits() []*DenomUnit {
	if m != nil {
		return m.DenomUnits
	}
	return nil
}

func (m *CosmosCoinWrapperPathAddObject) GetAllowOverrideWithAnyValidToken() bool {
	if m != nil {
		return m.AllowOverrideWithAnyValidToken
	}
	return false
}

func (m *CosmosCoinWrapperPathAddObject) GetAllowCosmosWrapping() bool {
	if m != nil {
		return m.AllowCosmosWrapping
	}
	return false
}

type CosmosCoinBackedPathAddObject struct {
	IbcDenom  string     `protobuf:"bytes,1,opt,name=ibcDenom,proto3" json:"ibcDenom,omitempty"`
	Balances  []*Balance `protobuf:"bytes,2,rep,name=balances,proto3" json:"balances,omitempty"`
	IbcAmount Uint       `protobuf:"bytes,3,opt,name=ibcAmount,proto3,customtype=Uint" json:"ibcAmount"`
}

func (m *CosmosCoinBackedPathAddObject) Reset()         { *m = CosmosCoinBackedPathAddObject{} }
func (m *CosmosCoinBackedPathAddObject) String() string { return proto.CompactTextString(m) }
func (*CosmosCoinBackedPathAddObject) ProtoMessage()    {}
func (*CosmosCoinBackedPathAddObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{4}
}
func (m *CosmosCoinBackedPathAddObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CosmosCoinBackedPathAddObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CosmosCoinBackedPathAddObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CosmosCoinBackedPathAddObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CosmosCoinBackedPathAddObject.Merge(m, src)
}
func (m *CosmosCoinBackedPathAddObject) XXX_Size() int {
	return m.Size()
}
func (m *CosmosCoinBackedPathAddObject) XXX_DiscardUnknown() {
	xxx_messageInfo_CosmosCoinBackedPathAddObject.DiscardUnknown(m)
}

var xxx_messageInfo_CosmosCoinBackedPathAddObject proto.InternalMessageInfo

func (m *CosmosCoinBackedPathAddObject) GetIbcDenom() string {
	if m != nil {
		return m.IbcDenom
	}
	return ""
}

func (m *CosmosCoinBackedPathAddObject) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

// InvariantsAddObject is used for adding invariants without specifying addresses.
// Addresses are generated by the keeper and stored in the collection.
type InvariantsAddObject struct {
	// If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].
	// This prevents time-based restrictions on token ownership.
	NoCustomOwnershipTimes bool `protobuf:"varint,1,opt,name=noCustomOwnershipTimes,proto3" json:"noCustomOwnershipTimes,omitempty"`
	// Maximum supply per token ID. If set, no balance can exceed this amount.
	// This prevents any single token ID from having more than the specified supply.
	MaxSupplyPerId Uint `protobuf:"bytes,2,opt,name=maxSupplyPerId,proto3,customtype=Uint" json:"maxSupplyPerId"`
	// The IBC backed (sdk.coin) path for the collection. Only one path is allowed.
	// Address will be generated by the keeper.
	CosmosCoinBackedPath *CosmosCoinBackedPathAddObject `protobuf:"bytes,3,opt,name=cosmosCoinBackedPath,proto3" json:"cosmosCoinBackedPath,omitempty"`
	// If true, disallows any collection approvals that have overridesFromOutgoingApprovals or overridesToIncomingApprovals set to true.
	// This prevents forceful transfers that bypass user-level approvals.
	// This only applies to transfers where the from address does not equal "Mint".
	NoForcefulPostMintTransfers bool `protobuf:"varint,4,opt,name=noForcefulPostMintTransfers,proto3" json:"noForcefulPostMintTransfers,omitempty"`
	// If true, disallows pool creation with this collection's assets.
	// When true, any attempt to create a pool with badges assets from this collection will fail.
	DisablePoolCreation bool `protobuf:"varint,5,opt,name=disablePoolCreation,proto3" json:"disablePoolCreation,omitempty"`
}

func (m *InvariantsAddObject) Reset()         { *m = InvariantsAddObject{} }
func (m *InvariantsAddObject) String() string { return proto.CompactTextString(m) }
func (*InvariantsAddObject) ProtoMessage()    {}
func (*InvariantsAddObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{5}
}
func (m *InvariantsAddObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvariantsAddObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvariantsAddObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InvariantsAddObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvariantsAddObject.Merge(m, src)
}
func (m *InvariantsAddObject) XXX_Size() int {
	return m.Size()
}
func (m *InvariantsAddObject) XXX_DiscardUnknown() {
	xxx_messageInfo_InvariantsAddObject.DiscardUnknown(m)
}

var xxx_messageInfo_InvariantsAddObject proto.InternalMessageInfo

func (m *InvariantsAddObject) GetNoCustomOwnershipTimes() bool {
	if m != nil {
		return m.NoCustomOwnershipTimes
	}
	return false
}

func (m *InvariantsAddObject) GetCosmosCoinBackedPath() *CosmosCoinBackedPathAddObject {
	if m != nil {
		return m.CosmosCoinBackedPath
	}
	return nil
}

func (m *InvariantsAddObject) GetNoForcefulPostMintTransfers() bool {
	if m != nil {
		return m.NoForcefulPostMintTransfers
	}
	return false
}

func (m *InvariantsAddObject) GetDisablePoolCreation() bool {
	if m != nil {
		return m.DisablePoolCreation
	}
	return false
}

// MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the tokens module.
// It is a universal interface that can be used for both creating and updating collections.
// We have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.
type MsgUniversalUpdateCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection (0 for new collection).
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	//The default balances for the user
	DefaultBalances *UserBalanceStore `protobuf:"bytes,3,opt,name=defaultBalances,proto3" json:"defaultBalances,omitempty"`
	// Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateValidTokenIds bool `protobuf:"varint,4,opt,name=updateValidTokenIds,proto3" json:"updateValidTokenIds,omitempty"`
	// New token IDs to add to this collection
	ValidTokenIds []*UintRange `protobuf:"bytes,5,rep,name=validTokenIds,proto3" json:"validTokenIds,omitempty"`
	// Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionPermissions bool `protobuf:"varint,6,opt,name=updateCollectionPermissions,proto3" json:"updateCollectionPermissions,omitempty"`
	// New collection permissions to set.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,7,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateManagerTimeline bool `protobuf:"varint,8,opt,name=updateManagerTimeline,proto3" json:"updateManagerTimeline,omitempty"`
	// New manager timeline to set.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,9,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionMetadataTimeline bool `protobuf:"varint,10,opt,name=updateCollectionMetadataTimeline,proto3" json:"updateCollectionMetadataTimeline,omitempty"`
	// New collection metadata timeline to set.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,11,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateTokenMetadataTimeline bool `protobuf:"varint,12,opt,name=updateTokenMetadataTimeline,proto3" json:"updateTokenMetadataTimeline,omitempty"`
	// New token metadata timeline to set.
	TokenMetadataTimeline []*TokenMetadataTimeline `protobuf:"bytes,13,rep,name=tokenMetadataTimeline,proto3" json:"tokenMetadataTimeline,omitempty"`
	// Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCustomDataTimeline bool `protobuf:"varint,14,opt,name=updateCustomDataTimeline,proto3" json:"updateCustomDataTimeline,omitempty"`
	// New custom data timeline to set.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,15,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionApprovals bool `protobuf:"varint,16,opt,name=updateCollectionApprovals,proto3" json:"updateCollectionApprovals,omitempty"`
	// New collection approvals to set.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,17,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateStandardsTimeline bool `protobuf:"varint,18,opt,name=updateStandardsTimeline,proto3" json:"updateStandardsTimeline,omitempty"`
	// New standards timeline to set.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,19,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateIsArchivedTimeline bool `protobuf:"varint,20,opt,name=updateIsArchivedTimeline,proto3" json:"updateIsArchivedTimeline,omitempty"`
	// New isArchived timeline to set.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,21,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// Coins to be transferred to the mint escrow address.
	MintEscrowCoinsToTransfer []*types.Coin `protobuf:"bytes,22,rep,name=mintEscrowCoinsToTransfer,proto3" json:"mintEscrowCoinsToTransfer,omitempty"`
	// IBC wrapper paths to add.
	CosmosCoinWrapperPathsToAdd []*CosmosCoinWrapperPathAddObject `protobuf:"bytes,23,rep,name=cosmosCoinWrapperPathsToAdd,proto3" json:"cosmosCoinWrapperPathsToAdd,omitempty"`
	// Collection-level invariants that cannot be broken.
	// These are set upon genesis and cannot be modified.
	// Addresses are generated by the keeper and stored in the collection.
	Invariants *InvariantsAddObject `protobuf:"bytes,24,opt,name=invariants,proto3" json:"invariants,omitempty"`
}

func (m *MsgUniversalUpdateCollection) Reset()         { *m = MsgUniversalUpdateCollection{} }
func (m *MsgUniversalUpdateCollection) String() string { return proto.CompactTextString(m) }
func (*MsgUniversalUpdateCollection) ProtoMessage()    {}
func (*MsgUniversalUpdateCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{6}
}
func (m *MsgUniversalUpdateCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUniversalUpdateCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUniversalUpdateCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUniversalUpdateCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUniversalUpdateCollection.Merge(m, src)
}
func (m *MsgUniversalUpdateCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgUniversalUpdateCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUniversalUpdateCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUniversalUpdateCollection proto.InternalMessageInfo

func (m *MsgUniversalUpdateCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUniversalUpdateCollection) GetDefaultBalances() *UserBalanceStore {
	if m != nil {
		return m.DefaultBalances
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateValidTokenIds() bool {
	if m != nil {
		return m.UpdateValidTokenIds
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetValidTokenIds() []*UintRange {
	if m != nil {
		return m.ValidTokenIds
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCollectionPermissions() bool {
	if m != nil {
		return m.UpdateCollectionPermissions
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateManagerTimeline() bool {
	if m != nil {
		return m.UpdateManagerTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCollectionMetadataTimeline() bool {
	if m != nil {
		return m.UpdateCollectionMetadataTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateTokenMetadataTimeline() bool {
	if m != nil {
		return m.UpdateTokenMetadataTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetTokenMetadataTimeline() []*TokenMetadataTimeline {
	if m != nil {
		return m.TokenMetadataTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCustomDataTimeline() bool {
	if m != nil {
		return m.UpdateCustomDataTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCollectionApprovals() bool {
	if m != nil {
		return m.UpdateCollectionApprovals
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateStandardsTimeline() bool {
	if m != nil {
		return m.UpdateStandardsTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateIsArchivedTimeline() bool {
	if m != nil {
		return m.UpdateIsArchivedTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetMintEscrowCoinsToTransfer() []*types.Coin {
	if m != nil {
		return m.MintEscrowCoinsToTransfer
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetCosmosCoinWrapperPathsToAdd() []*CosmosCoinWrapperPathAddObject {
	if m != nil {
		return m.CosmosCoinWrapperPathsToAdd
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetInvariants() *InvariantsAddObject {
	if m != nil {
		return m.Invariants
	}
	return nil
}

// MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.
type MsgUniversalUpdateCollectionResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgUniversalUpdateCollectionResponse) Reset()         { *m = MsgUniversalUpdateCollectionResponse{} }
func (m *MsgUniversalUpdateCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUniversalUpdateCollectionResponse) ProtoMessage()    {}
func (*MsgUniversalUpdateCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{7}
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUniversalUpdateCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUniversalUpdateCollectionResponse.Merge(m, src)
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUniversalUpdateCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUniversalUpdateCollectionResponse proto.InternalMessageInfo

// MsgUpdateCollection is used to update a collection.
type MsgUpdateCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection (0 for new collection).
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// Indicates if the valid token IDs should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateValidTokenIds bool `protobuf:"varint,3,opt,name=updateValidTokenIds,proto3" json:"updateValidTokenIds,omitempty"`
	// New token IDs to add to this collection
	ValidTokenIds []*UintRange `protobuf:"bytes,4,rep,name=validTokenIds,proto3" json:"validTokenIds,omitempty"`
	// Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionPermissions bool `protobuf:"varint,5,opt,name=updateCollectionPermissions,proto3" json:"updateCollectionPermissions,omitempty"`
	// New collection permissions to set.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,6,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateManagerTimeline bool `protobuf:"varint,7,opt,name=updateManagerTimeline,proto3" json:"updateManagerTimeline,omitempty"`
	// New manager timeline to set.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,8,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionMetadataTimeline bool `protobuf:"varint,9,opt,name=updateCollectionMetadataTimeline,proto3" json:"updateCollectionMetadataTimeline,omitempty"`
	// New collection metadata timeline to set.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,10,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// Indicates if the token metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateTokenMetadataTimeline bool `protobuf:"varint,11,opt,name=updateTokenMetadataTimeline,proto3" json:"updateTokenMetadataTimeline,omitempty"`
	// New token metadata timeline to set.
	TokenMetadataTimeline []*TokenMetadataTimeline `protobuf:"bytes,12,rep,name=tokenMetadataTimeline,proto3" json:"tokenMetadataTimeline,omitempty"`
	// Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCustomDataTimeline bool `protobuf:"varint,13,opt,name=updateCustomDataTimeline,proto3" json:"updateCustomDataTimeline,omitempty"`
	// New custom data timeline to set.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,14,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionApprovals bool `protobuf:"varint,15,opt,name=updateCollectionApprovals,proto3" json:"updateCollectionApprovals,omitempty"`
	// New collection approvals to set.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,16,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateStandardsTimeline bool `protobuf:"varint,17,opt,name=updateStandardsTimeline,proto3" json:"updateStandardsTimeline,omitempty"`
	// New standards timeline to set.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,18,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateIsArchivedTimeline bool `protobuf:"varint,19,opt,name=updateIsArchivedTimeline,proto3" json:"updateIsArchivedTimeline,omitempty"`
	// New isArchived timeline to set.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,20,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// Coins to be transferred to the mint escrow address.
	MintEscrowCoinsToTransfer []*types.Coin `protobuf:"bytes,21,rep,name=mintEscrowCoinsToTransfer,proto3" json:"mintEscrowCoinsToTransfer,omitempty"`
	// IBC wrapper paths to add.
	CosmosCoinWrapperPathsToAdd []*CosmosCoinWrapperPathAddObject `protobuf:"bytes,22,rep,name=cosmosCoinWrapperPathsToAdd,proto3" json:"cosmosCoinWrapperPathsToAdd,omitempty"`
	// Collection-level invariants that cannot be broken.
	// These are set upon genesis and cannot be modified.
	// Addresses are generated by the keeper and stored in the collection.
	Invariants *InvariantsAddObject `protobuf:"bytes,23,opt,name=invariants,proto3" json:"invariants,omitempty"`
}

func (m *MsgUpdateCollection) Reset()         { *m = MsgUpdateCollection{} }
func (m *MsgUpdateCollection) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCollection) ProtoMessage()    {}
func (*MsgUpdateCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{8}
}
func (m *MsgUpdateCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCollection.Merge(m, src)
}
func (m *MsgUpdateCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCollection proto.InternalMessageInfo

func (m *MsgUpdateCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUpdateCollection) GetUpdateValidTokenIds() bool {
	if m != nil {
		return m.UpdateValidTokenIds
	}
	return false
}

func (m *MsgUpdateCollection) GetValidTokenIds() []*UintRange {
	if m != nil {
		return m.ValidTokenIds
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCollectionPermissions() bool {
	if m != nil {
		return m.UpdateCollectionPermissions
	}
	return false
}

func (m *MsgUpdateCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateManagerTimeline() bool {
	if m != nil {
		return m.UpdateManagerTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCollectionMetadataTimeline() bool {
	if m != nil {
		return m.UpdateCollectionMetadataTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateTokenMetadataTimeline() bool {
	if m != nil {
		return m.UpdateTokenMetadataTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetTokenMetadataTimeline() []*TokenMetadataTimeline {
	if m != nil {
		return m.TokenMetadataTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCustomDataTimeline() bool {
	if m != nil {
		return m.UpdateCustomDataTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCollectionApprovals() bool {
	if m != nil {
		return m.UpdateCollectionApprovals
	}
	return false
}

func (m *MsgUpdateCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateStandardsTimeline() bool {
	if m != nil {
		return m.UpdateStandardsTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateIsArchivedTimeline() bool {
	if m != nil {
		return m.UpdateIsArchivedTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetMintEscrowCoinsToTransfer() []*types.Coin {
	if m != nil {
		return m.MintEscrowCoinsToTransfer
	}
	return nil
}

func (m *MsgUpdateCollection) GetCosmosCoinWrapperPathsToAdd() []*CosmosCoinWrapperPathAddObject {
	if m != nil {
		return m.CosmosCoinWrapperPathsToAdd
	}
	return nil
}

func (m *MsgUpdateCollection) GetInvariants() *InvariantsAddObject {
	if m != nil {
		return m.Invariants
	}
	return nil
}

// MsgUpdateCollectionResponse is the response to MsgUpdateCollection.
type MsgUpdateCollectionResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgUpdateCollectionResponse) Reset()         { *m = MsgUpdateCollectionResponse{} }
func (m *MsgUpdateCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCollectionResponse) ProtoMessage()    {}
func (*MsgUpdateCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{9}
}
func (m *MsgUpdateCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCollectionResponse.Merge(m, src)
}
func (m *MsgUpdateCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCollectionResponse proto.InternalMessageInfo

// MsgCreateCollection is used to create a new collection.
type MsgCreateCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	//The default balances for the user
	DefaultBalances *UserBalanceStore `protobuf:"bytes,2,opt,name=defaultBalances,proto3" json:"defaultBalances,omitempty"`
	// New token IDs to add to this collection
	ValidTokenIds []*UintRange `protobuf:"bytes,3,rep,name=validTokenIds,proto3" json:"validTokenIds,omitempty"`
	// Collection permissions.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,4,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Manager timeline entries.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,5,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Collection metadata timeline entries.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,6,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// Token metadata timeline entries.
	TokenMetadataTimeline []*TokenMetadataTimeline `protobuf:"bytes,7,rep,name=tokenMetadataTimeline,proto3" json:"tokenMetadataTimeline,omitempty"`
	// Custom data timeline entries.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,8,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// Collection approvals.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,9,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Standards timeline entries.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,10,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// isArchived timeline entries.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,11,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// Coins to be transferred to the mint escrow address.
	MintEscrowCoinsToTransfer []*types.Coin `protobuf:"bytes,12,rep,name=mintEscrowCoinsToTransfer,proto3" json:"mintEscrowCoinsToTransfer,omitempty"`
	// IBC wrapper paths to add.
	CosmosCoinWrapperPathsToAdd []*CosmosCoinWrapperPathAddObject `protobuf:"bytes,13,rep,name=cosmosCoinWrapperPathsToAdd,proto3" json:"cosmosCoinWrapperPathsToAdd,omitempty"`
	// Collection-level invariants that cannot be broken.
	// Addresses are generated by the keeper and stored in the collection.
	Invariants *InvariantsAddObject `protobuf:"bytes,14,opt,name=invariants,proto3" json:"invariants,omitempty"`
}

func (m *MsgCreateCollection) Reset()         { *m = MsgCreateCollection{} }
func (m *MsgCreateCollection) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCollection) ProtoMessage()    {}
func (*MsgCreateCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{10}
}
func (m *MsgCreateCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCollection.Merge(m, src)
}
func (m *MsgCreateCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCollection proto.InternalMessageInfo

func (m *MsgCreateCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateCollection) GetDefaultBalances() *UserBalanceStore {
	if m != nil {
		return m.DefaultBalances
	}
	return nil
}

func (m *MsgCreateCollection) GetValidTokenIds() []*UintRange {
	if m != nil {
		return m.ValidTokenIds
	}
	return nil
}

func (m *MsgCreateCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *MsgCreateCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetTokenMetadataTimeline() []*TokenMetadataTimeline {
	if m != nil {
		return m.TokenMetadataTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *MsgCreateCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetMintEscrowCoinsToTransfer() []*types.Coin {
	if m != nil {
		return m.MintEscrowCoinsToTransfer
	}
	return nil
}

func (m *MsgCreateCollection) GetCosmosCoinWrapperPathsToAdd() []*CosmosCoinWrapperPathAddObject {
	if m != nil {
		return m.CosmosCoinWrapperPathsToAdd
	}
	return nil
}

func (m *MsgCreateCollection) GetInvariants() *InvariantsAddObject {
	if m != nil {
		return m.Invariants
	}
	return nil
}

// MsgCreateCollectionResponse is the response to MsgCreateCollection.
type MsgCreateCollectionResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgCreateCollectionResponse) Reset()         { *m = MsgCreateCollectionResponse{} }
func (m *MsgCreateCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCollectionResponse) ProtoMessage()    {}
func (*MsgCreateCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{11}
}
func (m *MsgCreateCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCollectionResponse.Merge(m, src)
}
func (m *MsgCreateCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCollectionResponse proto.InternalMessageInfo

// MsgCreateAddressLists is used to create address lists.
type MsgCreateAddressLists struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// Address lists to create.
	AddressLists []*AddressList `protobuf:"bytes,2,rep,name=addressLists,proto3" json:"addressLists,omitempty"`
}

func (m *MsgCreateAddressLists) Reset()         { *m = MsgCreateAddressLists{} }
func (m *MsgCreateAddressLists) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAddressLists) ProtoMessage()    {}
func (*MsgCreateAddressLists) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{12}
}
func (m *MsgCreateAddressLists) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAddressLists) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAddressLists.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAddressLists) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAddressLists.Merge(m, src)
}
func (m *MsgCreateAddressLists) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAddressLists) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAddressLists.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAddressLists proto.InternalMessageInfo

func (m *MsgCreateAddressLists) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateAddressLists) GetAddressLists() []*AddressList {
	if m != nil {
		return m.AddressLists
	}
	return nil
}

// MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.
type MsgCreateAddressListsResponse struct {
}

func (m *MsgCreateAddressListsResponse) Reset()         { *m = MsgCreateAddressListsResponse{} }
func (m *MsgCreateAddressListsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAddressListsResponse) ProtoMessage()    {}
func (*MsgCreateAddressListsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{13}
}
func (m *MsgCreateAddressListsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAddressListsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAddressListsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAddressListsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAddressListsResponse.Merge(m, src)
}
func (m *MsgCreateAddressListsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAddressListsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAddressListsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAddressListsResponse proto.InternalMessageInfo

// MsgTransferTokens is used to transfer tokens.
type MsgTransferTokens struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// Transfers to execute.
	Transfers []*Transfer `protobuf:"bytes,3,rep,name=transfers,proto3" json:"transfers,omitempty"`
}

func (m *MsgTransferTokens) Reset()         { *m = MsgTransferTokens{} }
func (m *MsgTransferTokens) String() string { return proto.CompactTextString(m) }
func (*MsgTransferTokens) ProtoMessage()    {}
func (*MsgTransferTokens) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{14}
}
func (m *MsgTransferTokens) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferTokens) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferTokens.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferTokens) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferTokens.Merge(m, src)
}
func (m *MsgTransferTokens) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferTokens) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferTokens.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferTokens proto.InternalMessageInfo

func (m *MsgTransferTokens) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgTransferTokens) GetTransfers() []*Transfer {
	if m != nil {
		return m.Transfers
	}
	return nil
}

// MsgTransferTokensResponse is the response to MsgTransferTokens.
type MsgTransferTokensResponse struct {
}

func (m *MsgTransferTokensResponse) Reset()         { *m = MsgTransferTokensResponse{} }
func (m *MsgTransferTokensResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTransferTokensResponse) ProtoMessage()    {}
func (*MsgTransferTokensResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{15}
}
func (m *MsgTransferTokensResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferTokensResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferTokensResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferTokensResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferTokensResponse.Merge(m, src)
}
func (m *MsgTransferTokensResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferTokensResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferTokensResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferTokensResponse proto.InternalMessageInfo

// MsgDeleteCollection is used to delete a collection.
type MsgDeleteCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgDeleteCollection) Reset()         { *m = MsgDeleteCollection{} }
func (m *MsgDeleteCollection) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteCollection) ProtoMessage()    {}
func (*MsgDeleteCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{16}
}
func (m *MsgDeleteCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteCollection.Merge(m, src)
}
func (m *MsgDeleteCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteCollection proto.InternalMessageInfo

func (m *MsgDeleteCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

// MsgDeleteCollectionResponse is the response to MsgDeleteCollection.
type MsgDeleteCollectionResponse struct {
}

func (m *MsgDeleteCollectionResponse) Reset()         { *m = MsgDeleteCollectionResponse{} }
func (m *MsgDeleteCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteCollectionResponse) ProtoMessage()    {}
func (*MsgDeleteCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{17}
}
func (m *MsgDeleteCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteCollectionResponse.Merge(m, src)
}
func (m *MsgDeleteCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteCollectionResponse proto.InternalMessageInfo

// MsgUpdateUserApprovals is used to update user approvals.
type MsgUpdateUserApprovals struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateOutgoingApprovals bool `protobuf:"varint,3,opt,name=updateOutgoingApprovals,proto3" json:"updateOutgoingApprovals,omitempty"`
	// New outgoing approvals to set.
	OutgoingApprovals []*UserOutgoingApproval `protobuf:"bytes,4,rep,name=outgoingApprovals,proto3" json:"outgoingApprovals,omitempty"`
	// Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateIncomingApprovals bool `protobuf:"varint,5,opt,name=updateIncomingApprovals,proto3" json:"updateIncomingApprovals,omitempty"`
	// New incoming approvals to set.
	IncomingApprovals []*UserIncomingApproval `protobuf:"bytes,6,rep,name=incomingApprovals,proto3" json:"incomingApprovals,omitempty"`
	// Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateAutoApproveSelfInitiatedOutgoingTransfers bool `protobuf:"varint,7,opt,name=updateAutoApproveSelfInitiatedOutgoingTransfers,proto3" json:"updateAutoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Auto-approve setting for self-initiated outgoing transfers.
	AutoApproveSelfInitiatedOutgoingTransfers bool `protobuf:"varint,8,opt,name=autoApproveSelfInitiatedOutgoingTransfers,proto3" json:"autoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateAutoApproveSelfInitiatedIncomingTransfers bool `protobuf:"varint,9,opt,name=updateAutoApproveSelfInitiatedIncomingTransfers,proto3" json:"updateAutoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// Auto-approve setting for self-initiated incoming transfers.
	AutoApproveSelfInitiatedIncomingTransfers bool `protobuf:"varint,10,opt,name=autoApproveSelfInitiatedIncomingTransfers,proto3" json:"autoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// Indicates if auto-approve settings for all incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateAutoApproveAllIncomingTransfers bool `protobuf:"varint,11,opt,name=updateAutoApproveAllIncomingTransfers,proto3" json:"updateAutoApproveAllIncomingTransfers,omitempty"`
	// Auto-approve setting for all incoming transfers.
	AutoApproveAllIncomingTransfers bool `protobuf:"varint,12,opt,name=autoApproveAllIncomingTransfers,proto3" json:"autoApproveAllIncomingTransfers,omitempty"`
	// Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateUserPermissions bool `protobuf:"varint,13,opt,name=updateUserPermissions,proto3" json:"updateUserPermissions,omitempty"`
	// New user permissions to set.
	UserPermissions *UserPermissions `protobuf:"bytes,14,opt,name=userPermissions,proto3" json:"userPermissions,omitempty"`
}

func (m *MsgUpdateUserApprovals) Reset()         { *m = MsgUpdateUserApprovals{} }
func (m *MsgUpdateUserApprovals) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateUserApprovals) ProtoMessage()    {}
func (*MsgUpdateUserApprovals) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{18}
}
func (m *MsgUpdateUserApprovals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateUserApprovals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateUserApprovals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateUserApprovals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateUserApprovals.Merge(m, src)
}
func (m *MsgUpdateUserApprovals) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateUserApprovals) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateUserApprovals.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateUserApprovals proto.InternalMessageInfo

func (m *MsgUpdateUserApprovals) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUpdateUserApprovals) GetUpdateOutgoingApprovals() bool {
	if m != nil {
		return m.UpdateOutgoingApprovals
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetOutgoingApprovals() []*UserOutgoingApproval {
	if m != nil {
		return m.OutgoingApprovals
	}
	return nil
}

func (m *MsgUpdateUserApprovals) GetUpdateIncomingApprovals() bool {
	if m != nil {
		return m.UpdateIncomingApprovals
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetIncomingApprovals() []*UserIncomingApproval {
	if m != nil {
		return m.IncomingApprovals
	}
	return nil
}

func (m *MsgUpdateUserApprovals) GetUpdateAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if m != nil {
		return m.UpdateAutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetUpdateAutoApproveSelfInitiatedIncomingTransfers() bool {
	if m != nil {
		return m.UpdateAutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetAutoApproveSelfInitiatedIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetUpdateAutoApproveAllIncomingTransfers() bool {
	if m != nil {
		return m.UpdateAutoApproveAllIncomingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetAutoApproveAllIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveAllIncomingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetUpdateUserPermissions() bool {
	if m != nil {
		return m.UpdateUserPermissions
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetUserPermissions() *UserPermissions {
	if m != nil {
		return m.UserPermissions
	}
	return nil
}

// MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.
type MsgUpdateUserApprovalsResponse struct {
}

func (m *MsgUpdateUserApprovalsResponse) Reset()         { *m = MsgUpdateUserApprovalsResponse{} }
func (m *MsgUpdateUserApprovalsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateUserApprovalsResponse) ProtoMessage()    {}
func (*MsgUpdateUserApprovalsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{19}
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateUserApprovalsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateUserApprovalsResponse.Merge(m, src)
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateUserApprovalsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateUserApprovalsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateUserApprovalsResponse proto.InternalMessageInfo

// MsgSetIncomingApproval is a helper message to set a single incoming approval.
type MsgSetIncomingApproval struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The incoming approval to set.
	Approval *UserIncomingApproval `protobuf:"bytes,3,opt,name=approval,proto3" json:"approval,omitempty"`
}

func (m *MsgSetIncomingApproval) Reset()         { *m = MsgSetIncomingApproval{} }
func (m *MsgSetIncomingApproval) String() string { return proto.CompactTextString(m) }
func (*MsgSetIncomingApproval) ProtoMessage()    {}
func (*MsgSetIncomingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{20}
}
func (m *MsgSetIncomingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetIncomingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetIncomingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetIncomingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetIncomingApproval.Merge(m, src)
}
func (m *MsgSetIncomingApproval) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetIncomingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetIncomingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetIncomingApproval proto.InternalMessageInfo

func (m *MsgSetIncomingApproval) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetIncomingApproval) GetApproval() *UserIncomingApproval {
	if m != nil {
		return m.Approval
	}
	return nil
}

// MsgSetIncomingApprovalResponse is the response to MsgSetIncomingApproval.
type MsgSetIncomingApprovalResponse struct {
}

func (m *MsgSetIncomingApprovalResponse) Reset()         { *m = MsgSetIncomingApprovalResponse{} }
func (m *MsgSetIncomingApprovalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetIncomingApprovalResponse) ProtoMessage()    {}
func (*MsgSetIncomingApprovalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{21}
}
func (m *MsgSetIncomingApprovalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetIncomingApprovalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetIncomingApprovalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetIncomingApprovalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetIncomingApprovalResponse.Merge(m, src)
}
func (m *MsgSetIncomingApprovalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetIncomingApprovalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetIncomingApprovalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetIncomingApprovalResponse proto.InternalMessageInfo

// MsgDeleteIncomingApproval is a helper message to delete a single incoming approval.
type MsgDeleteIncomingApproval struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The ID of the approval to delete.
	ApprovalId string `protobuf:"bytes,3,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
}

func (m *MsgDeleteIncomingApproval) Reset()         { *m = MsgDeleteIncomingApproval{} }
func (m *MsgDeleteIncomingApproval) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteIncomingApproval) ProtoMessage()    {}
func (*MsgDeleteIncomingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{22}
}
func (m *MsgDeleteIncomingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteIncomingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteIncomingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteIncomingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteIncomingApproval.Merge(m, src)
}
func (m *MsgDeleteIncomingApproval) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteIncomingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteIncomingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteIncomingApproval proto.InternalMessageInfo

func (m *MsgDeleteIncomingApproval) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgDeleteIncomingApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

// MsgDeleteIncomingApprovalResponse is the response to MsgDeleteIncomingApproval.
type MsgDeleteIncomingApprovalResponse struct {
}

func (m *MsgDeleteIncomingApprovalResponse) Reset()         { *m = MsgDeleteIncomingApprovalResponse{} }
func (m *MsgDeleteIncomingApprovalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteIncomingApprovalResponse) ProtoMessage()    {}
func (*MsgDeleteIncomingApprovalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{23}
}
func (m *MsgDeleteIncomingApprovalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteIncomingApprovalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteIncomingApprovalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteIncomingApprovalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteIncomingApprovalResponse.Merge(m, src)
}
func (m *MsgDeleteIncomingApprovalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteIncomingApprovalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteIncomingApprovalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteIncomingApprovalResponse proto.InternalMessageInfo

// MsgSetOutgoingApproval is a helper message to set a single outgoing approval.
type MsgSetOutgoingApproval struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The outgoing approval to set.
	Approval *UserOutgoingApproval `protobuf:"bytes,3,opt,name=approval,proto3" json:"approval,omitempty"`
}

func (m *MsgSetOutgoingApproval) Reset()         { *m = MsgSetOutgoingApproval{} }
func (m *MsgSetOutgoingApproval) String() string { return proto.CompactTextString(m) }
func (*MsgSetOutgoingApproval) ProtoMessage()    {}
func (*MsgSetOutgoingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{24}
}
func (m *MsgSetOutgoingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetOutgoingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetOutgoingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetOutgoingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetOutgoingApproval.Merge(m, src)
}
func (m *MsgSetOutgoingApproval) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetOutgoingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetOutgoingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetOutgoingApproval proto.InternalMessageInfo

func (m *MsgSetOutgoingApproval) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetOutgoingApproval) GetApproval() *UserOutgoingApproval {
	if m != nil {
		return m.Approval
	}
	return nil
}

// MsgSetOutgoingApprovalResponse is the response to MsgSetOutgoingApproval.
type MsgSetOutgoingApprovalResponse struct {
}

func (m *MsgSetOutgoingApprovalResponse) Reset()         { *m = MsgSetOutgoingApprovalResponse{} }
func (m *MsgSetOutgoingApprovalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetOutgoingApprovalResponse) ProtoMessage()    {}
func (*MsgSetOutgoingApprovalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{25}
}
func (m *MsgSetOutgoingApprovalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetOutgoingApprovalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetOutgoingApprovalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetOutgoingApprovalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetOutgoingApprovalResponse.Merge(m, src)
}
func (m *MsgSetOutgoingApprovalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetOutgoingApprovalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetOutgoingApprovalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetOutgoingApprovalResponse proto.InternalMessageInfo

// MsgDeleteOutgoingApproval is a helper message to delete a single outgoing approval.
type MsgDeleteOutgoingApproval struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// The ID of the approval to delete.
	ApprovalId string `protobuf:"bytes,3,opt,name=approvalId,proto3" json:"approvalId,omitempty"`
}

func (m *MsgDeleteOutgoingApproval) Reset()         { *m = MsgDeleteOutgoingApproval{} }
func (m *MsgDeleteOutgoingApproval) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteOutgoingApproval) ProtoMessage()    {}
func (*MsgDeleteOutgoingApproval) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{26}
}
func (m *MsgDeleteOutgoingApproval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteOutgoingApproval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteOutgoingApproval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteOutgoingApproval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteOutgoingApproval.Merge(m, src)
}
func (m *MsgDeleteOutgoingApproval) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteOutgoingApproval) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteOutgoingApproval.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteOutgoingApproval proto.InternalMessageInfo

func (m *MsgDeleteOutgoingApproval) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgDeleteOutgoingApproval) GetApprovalId() string {
	if m != nil {
		return m.ApprovalId
	}
	return ""
}

// MsgDeleteOutgoingApprovalResponse is the response to MsgDeleteOutgoingApproval.
type MsgDeleteOutgoingApprovalResponse struct {
}

func (m *MsgDeleteOutgoingApprovalResponse) Reset()         { *m = MsgDeleteOutgoingApprovalResponse{} }
func (m *MsgDeleteOutgoingApprovalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteOutgoingApprovalResponse) ProtoMessage()    {}
func (*MsgDeleteOutgoingApprovalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{27}
}
func (m *MsgDeleteOutgoingApprovalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteOutgoingApprovalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteOutgoingApprovalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteOutgoingApprovalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteOutgoingApprovalResponse.Merge(m, src)
}
func (m *MsgDeleteOutgoingApprovalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteOutgoingApprovalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteOutgoingApprovalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteOutgoingApprovalResponse proto.InternalMessageInfo

// MsgPurgeApprovals is a helper message to purge expired approvals.
type MsgPurgeApprovals struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// Whether to purge expired approvals (approvals with no future valid transfer times).
	PurgeExpired bool `protobuf:"varint,3,opt,name=purgeExpired,proto3" json:"purgeExpired,omitempty"`
	// Address of the user whose approvals to purge. If empty, defaults to creator.
	ApproverAddress string `protobuf:"bytes,4,opt,name=approverAddress,proto3" json:"approverAddress,omitempty"`
	// Whether to purge counterparty approvals (approvals where the creator is the only initiator).
	PurgeCounterpartyApprovals bool `protobuf:"varint,5,opt,name=purgeCounterpartyApprovals,proto3" json:"purgeCounterpartyApprovals,omitempty"`
	// Specific approvals to purge. If empty, purges all applicable approvals based on other flags.
	ApprovalsToPurge []*ApprovalIdentifierDetails `protobuf:"bytes,6,rep,name=approvalsToPurge,proto3" json:"approvalsToPurge,omitempty"`
}

func (m *MsgPurgeApprovals) Reset()         { *m = MsgPurgeApprovals{} }
func (m *MsgPurgeApprovals) String() string { return proto.CompactTextString(m) }
func (*MsgPurgeApprovals) ProtoMessage()    {}
func (*MsgPurgeApprovals) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{28}
}
func (m *MsgPurgeApprovals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPurgeApprovals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPurgeApprovals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPurgeApprovals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPurgeApprovals.Merge(m, src)
}
func (m *MsgPurgeApprovals) XXX_Size() int {
	return m.Size()
}
func (m *MsgPurgeApprovals) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPurgeApprovals.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPurgeApprovals proto.InternalMessageInfo

func (m *MsgPurgeApprovals) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgPurgeApprovals) GetPurgeExpired() bool {
	if m != nil {
		return m.PurgeExpired
	}
	return false
}

func (m *MsgPurgeApprovals) GetApproverAddress() string {
	if m != nil {
		return m.ApproverAddress
	}
	return ""
}

func (m *MsgPurgeApprovals) GetPurgeCounterpartyApprovals() bool {
	if m != nil {
		return m.PurgeCounterpartyApprovals
	}
	return false
}

func (m *MsgPurgeApprovals) GetApprovalsToPurge() []*ApprovalIdentifierDetails {
	if m != nil {
		return m.ApprovalsToPurge
	}
	return nil
}

// MsgPurgeApprovalsResponse is the response to MsgPurgeApprovals.
type MsgPurgeApprovalsResponse struct {
	// Number of approvals purged.
	NumPurged Uint `protobuf:"bytes,1,opt,name=numPurged,proto3,customtype=Uint" json:"numPurged"`
}

func (m *MsgPurgeApprovalsResponse) Reset()         { *m = MsgPurgeApprovalsResponse{} }
func (m *MsgPurgeApprovalsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPurgeApprovalsResponse) ProtoMessage()    {}
func (*MsgPurgeApprovalsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{29}
}
func (m *MsgPurgeApprovalsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPurgeApprovalsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPurgeApprovalsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPurgeApprovalsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPurgeApprovalsResponse.Merge(m, src)
}
func (m *MsgPurgeApprovalsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPurgeApprovalsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPurgeApprovalsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPurgeApprovalsResponse proto.InternalMessageInfo

// MsgCreateDynamicStore is used to create a new dynamic store.
type MsgCreateDynamicStore struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// The default value for uninitialized addresses (true/false).
	DefaultValue bool `protobuf:"varint,2,opt,name=defaultValue,proto3" json:"defaultValue,omitempty"`
}

func (m *MsgCreateDynamicStore) Reset()         { *m = MsgCreateDynamicStore{} }
func (m *MsgCreateDynamicStore) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDynamicStore) ProtoMessage()    {}
func (*MsgCreateDynamicStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{30}
}
func (m *MsgCreateDynamicStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDynamicStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDynamicStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDynamicStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDynamicStore.Merge(m, src)
}
func (m *MsgCreateDynamicStore) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDynamicStore) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDynamicStore.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDynamicStore proto.InternalMessageInfo

func (m *MsgCreateDynamicStore) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateDynamicStore) GetDefaultValue() bool {
	if m != nil {
		return m.DefaultValue
	}
	return false
}

// MsgCreateDynamicStoreResponse is the response to MsgCreateDynamicStore.
type MsgCreateDynamicStoreResponse struct {
	// ID of the dynamic store.
	StoreId Uint `protobuf:"bytes,1,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
}

func (m *MsgCreateDynamicStoreResponse) Reset()         { *m = MsgCreateDynamicStoreResponse{} }
func (m *MsgCreateDynamicStoreResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDynamicStoreResponse) ProtoMessage()    {}
func (*MsgCreateDynamicStoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{31}
}
func (m *MsgCreateDynamicStoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDynamicStoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDynamicStoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDynamicStoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDynamicStoreResponse.Merge(m, src)
}
func (m *MsgCreateDynamicStoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDynamicStoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDynamicStoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDynamicStoreResponse proto.InternalMessageInfo

// MsgUpdateDynamicStore is used to update an existing dynamic store.
type MsgUpdateDynamicStore struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the dynamic store to update.
	StoreId Uint `protobuf:"bytes,2,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
	// The new default value for uninitialized addresses (true/false).
	DefaultValue bool `protobuf:"varint,3,opt,name=defaultValue,proto3" json:"defaultValue,omitempty"`
}

func (m *MsgUpdateDynamicStore) Reset()         { *m = MsgUpdateDynamicStore{} }
func (m *MsgUpdateDynamicStore) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDynamicStore) ProtoMessage()    {}
func (*MsgUpdateDynamicStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{32}
}
func (m *MsgUpdateDynamicStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDynamicStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDynamicStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDynamicStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDynamicStore.Merge(m, src)
}
func (m *MsgUpdateDynamicStore) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDynamicStore) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDynamicStore.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDynamicStore proto.InternalMessageInfo

func (m *MsgUpdateDynamicStore) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUpdateDynamicStore) GetDefaultValue() bool {
	if m != nil {
		return m.DefaultValue
	}
	return false
}

// MsgUpdateDynamicStoreResponse is the response to MsgUpdateDynamicStore.
type MsgUpdateDynamicStoreResponse struct {
}

func (m *MsgUpdateDynamicStoreResponse) Reset()         { *m = MsgUpdateDynamicStoreResponse{} }
func (m *MsgUpdateDynamicStoreResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDynamicStoreResponse) ProtoMessage()    {}
func (*MsgUpdateDynamicStoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{33}
}
func (m *MsgUpdateDynamicStoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDynamicStoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDynamicStoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDynamicStoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDynamicStoreResponse.Merge(m, src)
}
func (m *MsgUpdateDynamicStoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDynamicStoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDynamicStoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDynamicStoreResponse proto.InternalMessageInfo

// MsgDeleteDynamicStore is used to delete a dynamic store.
type MsgDeleteDynamicStore struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the dynamic store to delete.
	StoreId Uint `protobuf:"bytes,2,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
}

func (m *MsgDeleteDynamicStore) Reset()         { *m = MsgDeleteDynamicStore{} }
func (m *MsgDeleteDynamicStore) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteDynamicStore) ProtoMessage()    {}
func (*MsgDeleteDynamicStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{34}
}
func (m *MsgDeleteDynamicStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteDynamicStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteDynamicStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteDynamicStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteDynamicStore.Merge(m, src)
}
func (m *MsgDeleteDynamicStore) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteDynamicStore) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteDynamicStore.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteDynamicStore proto.InternalMessageInfo

func (m *MsgDeleteDynamicStore) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

// MsgDeleteDynamicStoreResponse is the response to MsgDeleteDynamicStore.
type MsgDeleteDynamicStoreResponse struct {
}

func (m *MsgDeleteDynamicStoreResponse) Reset()         { *m = MsgDeleteDynamicStoreResponse{} }
func (m *MsgDeleteDynamicStoreResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteDynamicStoreResponse) ProtoMessage()    {}
func (*MsgDeleteDynamicStoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{35}
}
func (m *MsgDeleteDynamicStoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteDynamicStoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteDynamicStoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteDynamicStoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteDynamicStoreResponse.Merge(m, src)
}
func (m *MsgDeleteDynamicStoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteDynamicStoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteDynamicStoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteDynamicStoreResponse proto.InternalMessageInfo

// MsgSetDynamicStoreValue is used to set a boolean value for a specific address in a dynamic store.
type MsgSetDynamicStoreValue struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the dynamic store.
	StoreId Uint `protobuf:"bytes,2,opt,name=storeId,proto3,customtype=Uint" json:"storeId"`
	// The address for which to set the value.
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	// The boolean value to set (true/false).
	Value bool `protobuf:"varint,4,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MsgSetDynamicStoreValue) Reset()         { *m = MsgSetDynamicStoreValue{} }
func (m *MsgSetDynamicStoreValue) String() string { return proto.CompactTextString(m) }
func (*MsgSetDynamicStoreValue) ProtoMessage()    {}
func (*MsgSetDynamicStoreValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{36}
}
func (m *MsgSetDynamicStoreValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetDynamicStoreValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetDynamicStoreValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetDynamicStoreValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetDynamicStoreValue.Merge(m, src)
}
func (m *MsgSetDynamicStoreValue) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetDynamicStoreValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetDynamicStoreValue.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetDynamicStoreValue proto.InternalMessageInfo

func (m *MsgSetDynamicStoreValue) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetDynamicStoreValue) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *MsgSetDynamicStoreValue) GetValue() bool {
	if m != nil {
		return m.Value
	}
	return false
}

// MsgSetDynamicStoreValueResponse is the response to MsgSetDynamicStoreValue.
type MsgSetDynamicStoreValueResponse struct {
}

func (m *MsgSetDynamicStoreValueResponse) Reset()         { *m = MsgSetDynamicStoreValueResponse{} }
func (m *MsgSetDynamicStoreValueResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetDynamicStoreValueResponse) ProtoMessage()    {}
func (*MsgSetDynamicStoreValueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{37}
}
func (m *MsgSetDynamicStoreValueResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetDynamicStoreValueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetDynamicStoreValueResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetDynamicStoreValueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetDynamicStoreValueResponse.Merge(m, src)
}
func (m *MsgSetDynamicStoreValueResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetDynamicStoreValueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetDynamicStoreValueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetDynamicStoreValueResponse proto.InternalMessageInfo

// MsgSetValidTokenIds sets the validTokenIds and canUpdateValidTokenIds permission
type MsgSetValidTokenIds struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New token IDs to add to this collection
	ValidTokenIds []*UintRange `protobuf:"bytes,3,rep,name=validTokenIds,proto3" json:"validTokenIds,omitempty"`
	// Permission to update valid token IDs
	CanUpdateValidTokenIds []*TokenIdsActionPermission `protobuf:"bytes,4,rep,name=canUpdateValidTokenIds,proto3" json:"canUpdateValidTokenIds,omitempty"`
}

func (m *MsgSetValidTokenIds) Reset()         { *m = MsgSetValidTokenIds{} }
func (m *MsgSetValidTokenIds) String() string { return proto.CompactTextString(m) }
func (*MsgSetValidTokenIds) ProtoMessage()    {}
func (*MsgSetValidTokenIds) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{38}
}
func (m *MsgSetValidTokenIds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetValidTokenIds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetValidTokenIds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetValidTokenIds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetValidTokenIds.Merge(m, src)
}
func (m *MsgSetValidTokenIds) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetValidTokenIds) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetValidTokenIds.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetValidTokenIds proto.InternalMessageInfo

func (m *MsgSetValidTokenIds) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetValidTokenIds) GetValidTokenIds() []*UintRange {
	if m != nil {
		return m.ValidTokenIds
	}
	return nil
}

func (m *MsgSetValidTokenIds) GetCanUpdateValidTokenIds() []*TokenIdsActionPermission {
	if m != nil {
		return m.CanUpdateValidTokenIds
	}
	return nil
}

// MsgSetValidTokenIdsResponse is the response to MsgSetValidTokenIds.
type MsgSetValidTokenIdsResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetValidTokenIdsResponse) Reset()         { *m = MsgSetValidTokenIdsResponse{} }
func (m *MsgSetValidTokenIdsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetValidTokenIdsResponse) ProtoMessage()    {}
func (*MsgSetValidTokenIdsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{39}
}
func (m *MsgSetValidTokenIdsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetValidTokenIdsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetValidTokenIdsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetValidTokenIdsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetValidTokenIdsResponse.Merge(m, src)
}
func (m *MsgSetValidTokenIdsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetValidTokenIdsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetValidTokenIdsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetValidTokenIdsResponse proto.InternalMessageInfo

// MsgSetManager sets the manager timeline and canUpdateManager permission
type MsgSetManager struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New manager timeline to set.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,3,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Permission to update manager timeline
	CanUpdateManager []*TimedUpdatePermission `protobuf:"bytes,4,rep,name=canUpdateManager,proto3" json:"canUpdateManager,omitempty"`
}

func (m *MsgSetManager) Reset()         { *m = MsgSetManager{} }
func (m *MsgSetManager) String() string { return proto.CompactTextString(m) }
func (*MsgSetManager) ProtoMessage()    {}
func (*MsgSetManager) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{40}
}
func (m *MsgSetManager) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetManager) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetManager.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetManager) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetManager.Merge(m, src)
}
func (m *MsgSetManager) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetManager) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetManager.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetManager proto.InternalMessageInfo

func (m *MsgSetManager) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetManager) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *MsgSetManager) GetCanUpdateManager() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateManager
	}
	return nil
}

// MsgSetManagerResponse is the response to MsgSetManager.
type MsgSetManagerResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetManagerResponse) Reset()         { *m = MsgSetManagerResponse{} }
func (m *MsgSetManagerResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetManagerResponse) ProtoMessage()    {}
func (*MsgSetManagerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{41}
}
func (m *MsgSetManagerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetManagerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetManagerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetManagerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetManagerResponse.Merge(m, src)
}
func (m *MsgSetManagerResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetManagerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetManagerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetManagerResponse proto.InternalMessageInfo

// MsgSetCollectionMetadata sets the collection metadata timeline and canUpdateCollectionMetadata permission
type MsgSetCollectionMetadata struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New collection metadata timeline to set.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,3,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// Permission to update collection metadata timeline
	CanUpdateCollectionMetadata []*TimedUpdatePermission `protobuf:"bytes,4,rep,name=canUpdateCollectionMetadata,proto3" json:"canUpdateCollectionMetadata,omitempty"`
}

func (m *MsgSetCollectionMetadata) Reset()         { *m = MsgSetCollectionMetadata{} }
func (m *MsgSetCollectionMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgSetCollectionMetadata) ProtoMessage()    {}
func (*MsgSetCollectionMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{42}
}
func (m *MsgSetCollectionMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCollectionMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCollectionMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCollectionMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCollectionMetadata.Merge(m, src)
}
func (m *MsgSetCollectionMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCollectionMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCollectionMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCollectionMetadata proto.InternalMessageInfo

func (m *MsgSetCollectionMetadata) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetCollectionMetadata) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *MsgSetCollectionMetadata) GetCanUpdateCollectionMetadata() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCollectionMetadata
	}
	return nil
}

// MsgSetCollectionMetadataResponse is the response to MsgSetCollectionMetadata.
type MsgSetCollectionMetadataResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetCollectionMetadataResponse) Reset()         { *m = MsgSetCollectionMetadataResponse{} }
func (m *MsgSetCollectionMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetCollectionMetadataResponse) ProtoMessage()    {}
func (*MsgSetCollectionMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{43}
}
func (m *MsgSetCollectionMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCollectionMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCollectionMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCollectionMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCollectionMetadataResponse.Merge(m, src)
}
func (m *MsgSetCollectionMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCollectionMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCollectionMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCollectionMetadataResponse proto.InternalMessageInfo

// MsgSetTokenMetadata sets the token metadata timeline and canUpdateTokenMetadata permission
type MsgSetTokenMetadata struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New token metadata timeline to set.
	TokenMetadataTimeline []*TokenMetadataTimeline `protobuf:"bytes,3,rep,name=tokenMetadataTimeline,proto3" json:"tokenMetadataTimeline,omitempty"`
	// Permission to update token metadata timeline
	CanUpdateTokenMetadata []*TimedUpdateWithTokenIdsPermission `protobuf:"bytes,4,rep,name=canUpdateTokenMetadata,proto3" json:"canUpdateTokenMetadata,omitempty"`
}

func (m *MsgSetTokenMetadata) Reset()         { *m = MsgSetTokenMetadata{} }
func (m *MsgSetTokenMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgSetTokenMetadata) ProtoMessage()    {}
func (*MsgSetTokenMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{44}
}
func (m *MsgSetTokenMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetTokenMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetTokenMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetTokenMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetTokenMetadata.Merge(m, src)
}
func (m *MsgSetTokenMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetTokenMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetTokenMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetTokenMetadata proto.InternalMessageInfo

func (m *MsgSetTokenMetadata) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetTokenMetadata) GetTokenMetadataTimeline() []*TokenMetadataTimeline {
	if m != nil {
		return m.TokenMetadataTimeline
	}
	return nil
}

func (m *MsgSetTokenMetadata) GetCanUpdateTokenMetadata() []*TimedUpdateWithTokenIdsPermission {
	if m != nil {
		return m.CanUpdateTokenMetadata
	}
	return nil
}

// MsgSetTokenMetadataResponse is the response to MsgSetTokenMetadata.
type MsgSetTokenMetadataResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetTokenMetadataResponse) Reset()         { *m = MsgSetTokenMetadataResponse{} }
func (m *MsgSetTokenMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetTokenMetadataResponse) ProtoMessage()    {}
func (*MsgSetTokenMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{45}
}
func (m *MsgSetTokenMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetTokenMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetTokenMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetTokenMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetTokenMetadataResponse.Merge(m, src)
}
func (m *MsgSetTokenMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetTokenMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetTokenMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetTokenMetadataResponse proto.InternalMessageInfo

// MsgSetCustomData sets the custom data timeline and canUpdateCustomData permission
type MsgSetCustomData struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New custom data timeline to set.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,3,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// Permission to update custom data timeline
	CanUpdateCustomData []*TimedUpdatePermission `protobuf:"bytes,4,rep,name=canUpdateCustomData,proto3" json:"canUpdateCustomData,omitempty"`
}

func (m *MsgSetCustomData) Reset()         { *m = MsgSetCustomData{} }
func (m *MsgSetCustomData) String() string { return proto.CompactTextString(m) }
func (*MsgSetCustomData) ProtoMessage()    {}
func (*MsgSetCustomData) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{46}
}
func (m *MsgSetCustomData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCustomData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCustomData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCustomData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCustomData.Merge(m, src)
}
func (m *MsgSetCustomData) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCustomData) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCustomData.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCustomData proto.InternalMessageInfo

func (m *MsgSetCustomData) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetCustomData) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *MsgSetCustomData) GetCanUpdateCustomData() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateCustomData
	}
	return nil
}

// MsgSetCustomDataResponse is the response to MsgSetCustomData.
type MsgSetCustomDataResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetCustomDataResponse) Reset()         { *m = MsgSetCustomDataResponse{} }
func (m *MsgSetCustomDataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetCustomDataResponse) ProtoMessage()    {}
func (*MsgSetCustomDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{47}
}
func (m *MsgSetCustomDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCustomDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCustomDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCustomDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCustomDataResponse.Merge(m, src)
}
func (m *MsgSetCustomDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCustomDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCustomDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCustomDataResponse proto.InternalMessageInfo

// MsgSetStandards sets the standards timeline and canUpdateStandards permission
type MsgSetStandards struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New standards timeline to set.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,3,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// Permission to update standards timeline
	CanUpdateStandards []*TimedUpdatePermission `protobuf:"bytes,4,rep,name=canUpdateStandards,proto3" json:"canUpdateStandards,omitempty"`
}

func (m *MsgSetStandards) Reset()         { *m = MsgSetStandards{} }
func (m *MsgSetStandards) String() string { return proto.CompactTextString(m) }
func (*MsgSetStandards) ProtoMessage()    {}
func (*MsgSetStandards) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{48}
}
func (m *MsgSetStandards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetStandards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetStandards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetStandards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetStandards.Merge(m, src)
}
func (m *MsgSetStandards) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetStandards) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetStandards.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetStandards proto.InternalMessageInfo

func (m *MsgSetStandards) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetStandards) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *MsgSetStandards) GetCanUpdateStandards() []*TimedUpdatePermission {
	if m != nil {
		return m.CanUpdateStandards
	}
	return nil
}

// MsgSetStandardsResponse is the response to MsgSetStandards.
type MsgSetStandardsResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetStandardsResponse) Reset()         { *m = MsgSetStandardsResponse{} }
func (m *MsgSetStandardsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetStandardsResponse) ProtoMessage()    {}
func (*MsgSetStandardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{49}
}
func (m *MsgSetStandardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetStandardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetStandardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetStandardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetStandardsResponse.Merge(m, src)
}
func (m *MsgSetStandardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetStandardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetStandardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetStandardsResponse proto.InternalMessageInfo

// MsgSetCollectionApprovals sets the collection approvals and canUpdateCollectionApprovals permission
type MsgSetCollectionApprovals struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New collection approvals to set.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,3,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Permission to update collection approvals
	CanUpdateCollectionApprovals []*CollectionApprovalPermission `protobuf:"bytes,4,rep,name=canUpdateCollectionApprovals,proto3" json:"canUpdateCollectionApprovals,omitempty"`
}

func (m *MsgSetCollectionApprovals) Reset()         { *m = MsgSetCollectionApprovals{} }
func (m *MsgSetCollectionApprovals) String() string { return proto.CompactTextString(m) }
func (*MsgSetCollectionApprovals) ProtoMessage()    {}
func (*MsgSetCollectionApprovals) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{50}
}
func (m *MsgSetCollectionApprovals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCollectionApprovals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCollectionApprovals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCollectionApprovals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCollectionApprovals.Merge(m, src)
}
func (m *MsgSetCollectionApprovals) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCollectionApprovals) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCollectionApprovals.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCollectionApprovals proto.InternalMessageInfo

func (m *MsgSetCollectionApprovals) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetCollectionApprovals) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *MsgSetCollectionApprovals) GetCanUpdateCollectionApprovals() []*CollectionApprovalPermission {
	if m != nil {
		return m.CanUpdateCollectionApprovals
	}
	return nil
}

// MsgSetCollectionApprovalsResponse is the response to MsgSetCollectionApprovals.
type MsgSetCollectionApprovalsResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetCollectionApprovalsResponse) Reset()         { *m = MsgSetCollectionApprovalsResponse{} }
func (m *MsgSetCollectionApprovalsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetCollectionApprovalsResponse) ProtoMessage()    {}
func (*MsgSetCollectionApprovalsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{51}
}
func (m *MsgSetCollectionApprovalsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetCollectionApprovalsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetCollectionApprovalsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetCollectionApprovalsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetCollectionApprovalsResponse.Merge(m, src)
}
func (m *MsgSetCollectionApprovalsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetCollectionApprovalsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetCollectionApprovalsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetCollectionApprovalsResponse proto.InternalMessageInfo

// MsgSetIsArchived sets the isArchived timeline and canArchiveCollection permission
type MsgSetIsArchived struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New isArchived timeline to set.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,3,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
	// Permission to archive collection
	CanArchiveCollection []*TimedUpdatePermission `protobuf:"bytes,4,rep,name=canArchiveCollection,proto3" json:"canArchiveCollection,omitempty"`
}

func (m *MsgSetIsArchived) Reset()         { *m = MsgSetIsArchived{} }
func (m *MsgSetIsArchived) String() string { return proto.CompactTextString(m) }
func (*MsgSetIsArchived) ProtoMessage()    {}
func (*MsgSetIsArchived) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{52}
}
func (m *MsgSetIsArchived) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetIsArchived) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetIsArchived.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetIsArchived) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetIsArchived.Merge(m, src)
}
func (m *MsgSetIsArchived) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetIsArchived) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetIsArchived.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetIsArchived proto.InternalMessageInfo

func (m *MsgSetIsArchived) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetIsArchived) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

func (m *MsgSetIsArchived) GetCanArchiveCollection() []*TimedUpdatePermission {
	if m != nil {
		return m.CanArchiveCollection
	}
	return nil
}

// MsgSetIsArchivedResponse is the response to MsgSetIsArchived.
type MsgSetIsArchivedResponse struct {
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgSetIsArchivedResponse) Reset()         { *m = MsgSetIsArchivedResponse{} }
func (m *MsgSetIsArchivedResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetIsArchivedResponse) ProtoMessage()    {}
func (*MsgSetIsArchivedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{53}
}
func (m *MsgSetIsArchivedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetIsArchivedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetIsArchivedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetIsArchivedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetIsArchivedResponse.Merge(m, src)
}
func (m *MsgSetIsArchivedResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetIsArchivedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetIsArchivedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetIsArchivedResponse proto.InternalMessageInfo

// MsgSetReservedProtocolAddress sets or unsets a reserved protocol address (governance-only).
type MsgSetReservedProtocolAddress struct {
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Address to set or unset as reserved protocol address.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// Whether the address should be a reserved protocol address (true) or not (false).
	IsReservedProtocol bool `protobuf:"varint,3,opt,name=isReservedProtocol,proto3" json:"isReservedProtocol,omitempty"`
}

func (m *MsgSetReservedProtocolAddress) Reset()         { *m = MsgSetReservedProtocolAddress{} }
func (m *MsgSetReservedProtocolAddress) String() string { return proto.CompactTextString(m) }
func (*MsgSetReservedProtocolAddress) ProtoMessage()    {}
func (*MsgSetReservedProtocolAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{54}
}
func (m *MsgSetReservedProtocolAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetReservedProtocolAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetReservedProtocolAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetReservedProtocolAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetReservedProtocolAddress.Merge(m, src)
}
func (m *MsgSetReservedProtocolAddress) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetReservedProtocolAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetReservedProtocolAddress.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetReservedProtocolAddress proto.InternalMessageInfo

func (m *MsgSetReservedProtocolAddress) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgSetReservedProtocolAddress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *MsgSetReservedProtocolAddress) GetIsReservedProtocol() bool {
	if m != nil {
		return m.IsReservedProtocol
	}
	return false
}

// MsgSetReservedProtocolAddressResponse is the response to MsgSetReservedProtocolAddress.
type MsgSetReservedProtocolAddressResponse struct {
}

func (m *MsgSetReservedProtocolAddressResponse) Reset()         { *m = MsgSetReservedProtocolAddressResponse{} }
func (m *MsgSetReservedProtocolAddressResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetReservedProtocolAddressResponse) ProtoMessage()    {}
func (*MsgSetReservedProtocolAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_89ea078015f9c7f5, []int{55}
}
func (m *MsgSetReservedProtocolAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetReservedProtocolAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetReservedProtocolAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetReservedProtocolAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetReservedProtocolAddressResponse.Merge(m, src)
}
func (m *MsgSetReservedProtocolAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetReservedProtocolAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetReservedProtocolAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetReservedProtocolAddressResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*BadgeCustomMsgType)(nil), "badges.v20.BadgeCustomMsgType")
	proto.RegisterType((*MsgUpdateParams)(nil), "badges.v20.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "badges.v20.MsgUpdateParamsResponse")
	proto.RegisterType((*CosmosCoinWrapperPathAddObject)(nil), "badges.v20.CosmosCoinWrapperPathAddObject")
	proto.RegisterType((*CosmosCoinBackedPathAddObject)(nil), "badges.v20.CosmosCoinBackedPathAddObject")
	proto.RegisterType((*InvariantsAddObject)(nil), "badges.v20.InvariantsAddObject")
	proto.RegisterType((*MsgUniversalUpdateCollection)(nil), "badges.v20.MsgUniversalUpdateCollection")
	proto.RegisterType((*MsgUniversalUpdateCollectionResponse)(nil), "badges.v20.MsgUniversalUpdateCollectionResponse")
	proto.RegisterType((*MsgUpdateCollection)(nil), "badges.v20.MsgUpdateCollection")
	proto.RegisterType((*MsgUpdateCollectionResponse)(nil), "badges.v20.MsgUpdateCollectionResponse")
	proto.RegisterType((*MsgCreateCollection)(nil), "badges.v20.MsgCreateCollection")
	proto.RegisterType((*MsgCreateCollectionResponse)(nil), "badges.v20.MsgCreateCollectionResponse")
	proto.RegisterType((*MsgCreateAddressLists)(nil), "badges.v20.MsgCreateAddressLists")
	proto.RegisterType((*MsgCreateAddressListsResponse)(nil), "badges.v20.MsgCreateAddressListsResponse")
	proto.RegisterType((*MsgTransferTokens)(nil), "badges.v20.MsgTransferTokens")
	proto.RegisterType((*MsgTransferTokensResponse)(nil), "badges.v20.MsgTransferTokensResponse")
	proto.RegisterType((*MsgDeleteCollection)(nil), "badges.v20.MsgDeleteCollection")
	proto.RegisterType((*MsgDeleteCollectionResponse)(nil), "badges.v20.MsgDeleteCollectionResponse")
	proto.RegisterType((*MsgUpdateUserApprovals)(nil), "badges.v20.MsgUpdateUserApprovals")
	proto.RegisterType((*MsgUpdateUserApprovalsResponse)(nil), "badges.v20.MsgUpdateUserApprovalsResponse")
	proto.RegisterType((*MsgSetIncomingApproval)(nil), "badges.v20.MsgSetIncomingApproval")
	proto.RegisterType((*MsgSetIncomingApprovalResponse)(nil), "badges.v20.MsgSetIncomingApprovalResponse")
	proto.RegisterType((*MsgDeleteIncomingApproval)(nil), "badges.v20.MsgDeleteIncomingApproval")
	proto.RegisterType((*MsgDeleteIncomingApprovalResponse)(nil), "badges.v20.MsgDeleteIncomingApprovalResponse")
	proto.RegisterType((*MsgSetOutgoingApproval)(nil), "badges.v20.MsgSetOutgoingApproval")
	proto.RegisterType((*MsgSetOutgoingApprovalResponse)(nil), "badges.v20.MsgSetOutgoingApprovalResponse")
	proto.RegisterType((*MsgDeleteOutgoingApproval)(nil), "badges.v20.MsgDeleteOutgoingApproval")
	proto.RegisterType((*MsgDeleteOutgoingApprovalResponse)(nil), "badges.v20.MsgDeleteOutgoingApprovalResponse")
	proto.RegisterType((*MsgPurgeApprovals)(nil), "badges.v20.MsgPurgeApprovals")
	proto.RegisterType((*MsgPurgeApprovalsResponse)(nil), "badges.v20.MsgPurgeApprovalsResponse")
	proto.RegisterType((*MsgCreateDynamicStore)(nil), "badges.v20.MsgCreateDynamicStore")
	proto.RegisterType((*MsgCreateDynamicStoreResponse)(nil), "badges.v20.MsgCreateDynamicStoreResponse")
	proto.RegisterType((*MsgUpdateDynamicStore)(nil), "badges.v20.MsgUpdateDynamicStore")
	proto.RegisterType((*MsgUpdateDynamicStoreResponse)(nil), "badges.v20.MsgUpdateDynamicStoreResponse")
	proto.RegisterType((*MsgDeleteDynamicStore)(nil), "badges.v20.MsgDeleteDynamicStore")
	proto.RegisterType((*MsgDeleteDynamicStoreResponse)(nil), "badges.v20.MsgDeleteDynamicStoreResponse")
	proto.RegisterType((*MsgSetDynamicStoreValue)(nil), "badges.v20.MsgSetDynamicStoreValue")
	proto.RegisterType((*MsgSetDynamicStoreValueResponse)(nil), "badges.v20.MsgSetDynamicStoreValueResponse")
	proto.RegisterType((*MsgSetValidTokenIds)(nil), "badges.v20.MsgSetValidTokenIds")
	proto.RegisterType((*MsgSetValidTokenIdsResponse)(nil), "badges.v20.MsgSetValidTokenIdsResponse")
	proto.RegisterType((*MsgSetManager)(nil), "badges.v20.MsgSetManager")
	proto.RegisterType((*MsgSetManagerResponse)(nil), "badges.v20.MsgSetManagerResponse")
	proto.RegisterType((*MsgSetCollectionMetadata)(nil), "badges.v20.MsgSetCollectionMetadata")
	proto.RegisterType((*MsgSetCollectionMetadataResponse)(nil), "badges.v20.MsgSetCollectionMetadataResponse")
	proto.RegisterType((*MsgSetTokenMetadata)(nil), "badges.v20.MsgSetTokenMetadata")
	proto.RegisterType((*MsgSetTokenMetadataResponse)(nil), "badges.v20.MsgSetTokenMetadataResponse")
	proto.RegisterType((*MsgSetCustomData)(nil), "badges.v20.MsgSetCustomData")
	proto.RegisterType((*MsgSetCustomDataResponse)(nil), "badges.v20.MsgSetCustomDataResponse")
	proto.RegisterType((*MsgSetStandards)(nil), "badges.v20.MsgSetStandards")
	proto.RegisterType((*MsgSetStandardsResponse)(nil), "badges.v20.MsgSetStandardsResponse")
	proto.RegisterType((*MsgSetCollectionApprovals)(nil), "badges.v20.MsgSetCollectionApprovals")
	proto.RegisterType((*MsgSetCollectionApprovalsResponse)(nil), "badges.v20.MsgSetCollectionApprovalsResponse")
	proto.RegisterType((*MsgSetIsArchived)(nil), "badges.v20.MsgSetIsArchived")
	proto.RegisterType((*MsgSetIsArchivedResponse)(nil), "badges.v20.MsgSetIsArchivedResponse")
	proto.RegisterType((*MsgSetReservedProtocolAddress)(nil), "badges.v20.MsgSetReservedProtocolAddress")
	proto.RegisterType((*MsgSetReservedProtocolAddressResponse)(nil), "badges.v20.MsgSetReservedProtocolAddressResponse")
}

func init() { proto.RegisterFile("badges/v20/tx.proto", fileDescriptor_89ea078015f9c7f5) }

var fileDescriptor_89ea078015f9c7f5 = []byte{
	// 3423 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x5c, 0x4d, 0x6c, 0x1b, 0xc7,
	0x15, 0x36, 0x49, 0x5b, 0x22, 0x9f, 0xf5, 0x3b, 0xfa, 0xa7, 0x6c, 0x4a, 0x5e, 0xdb, 0x89, 0xad,
	0xc6, 0xa2, 0xad, 0x26, 0x41, 0xa0, 0x04, 0x4d, 0xf5, 0x93, 0x1f, 0x25, 0x51, 0xac, 0x8c, 0x24,
	0xbb, 0x08, 0x1c, 0xa4, 0x4b, 0x72, 0x4c, 0x6d, 0x43, 0xee, 0x12, 0xbb, 0x4b, 0xc5, 0xea, 0xa9,
	0x28, 0xd0, 0x43, 0x03, 0x14, 0xed, 0xb1, 0x05, 0x8a, 0x5e, 0x5b, 0x14, 0x68, 0xab, 0x43, 0x6f,
	0x45, 0xd1, 0x6b, 0x6e, 0x0d, 0x5a, 0x20, 0x28, 0x5a, 0x20, 0x28, 0x12, 0xa0, 0xbe, 0xf4, 0xdc,
	0x73, 0xb1, 0xb3, 0xb3, 0x7f, 0xf3, 0xb3, 0xa4, 0x28, 0x32, 0x97, 0x44, 0xdc, 0x79, 0xef, 0x9b,
	0x79, 0x6f, 0x76, 0xdf, 0x7b, 0xf3, 0xe6, 0x3d, 0xc3, 0x54, 0x45, 0xaf, 0xd5, 0x89, 0x53, 0x3e,
	0x5e, 0xbb, 0x5b, 0x76, 0x9f, 0xac, 0xb6, 0x6c, 0xcb, 0xb5, 0x10, 0xf8, 0x0f, 0x57, 0x8f, 0xd7,
	0xee, 0x16, 0x27, 0xf5, 0xa6, 0x61, 0x5a, 0x65, 0xfa, 0x5f, 0x7f, 0xb8, 0x38, 0x57, 0xb5, 0x9c,
	0xa6, 0xe5, 0x94, 0x9b, 0x4e, 0xbd, 0x7c, 0x7c, 0xcf, 0xfb, 0x1f, 0x1b, 0x58, 0xf0, 0x07, 0x3e,
	0xa4, 0xbf, 0xca, 0xfe, 0x0f, 0x36, 0x34, 0x5d, 0xb7, 0xea, 0x96, 0xff, 0xdc, 0xfb, 0x2b, 0x40,
	0x8a, 0xcd, 0xde, 0xd2, 0x6d, 0xbd, 0x19, 0x90, 0x17, 0xe3, 0xcb, 0xb2, 0x75, 0xd3, 0x79, 0x4c,
	0xec, 0x60, 0x6c, 0x21, 0x36, 0x56, 0xd1, 0x1b, 0xba, 0x59, 0x25, 0xc1, 0xd0, 0x95, 0x38, 0x1e,
	0xb1, 0x9b, 0x86, 0xe3, 0x18, 0x96, 0x29, 0x63, 0x6c, 0x12, 0x57, 0xaf, 0xe9, 0xae, 0x2e, 0x61,
	0xac, 0x5a, 0x8d, 0x06, 0xa9, 0xba, 0x31, 0xc6, 0x52, 0x6c, 0x54, 0xaf, 0xd5, 0x6c, 0xe2, 0x38,
	0x1f, 0x36, 0x0c, 0xc7, 0x95, 0xae, 0xd6, 0x68, 0x92, 0x86, 0x61, 0x86, 0x4b, 0x5a, 0x8a, 0x8d,
	0xd5, 0x4e, 0x4c, 0xbd, 0x69, 0x54, 0x3f, 0x74, 0x5c, 0xcb, 0x0e, 0x09, 0x4a, 0x4c, 0x9b, 0x15,
	0xdd, 0x21, 0xe5, 0xe3, 0x7b, 0x15, 0xe2, 0xea, 0xf7, 0xca, 0x55, 0xcb, 0x30, 0xfd, 0x71, 0xed,
	0x74, 0x12, 0xd0, 0xa6, 0x87, 0xb1, 0xd5, 0x76, 0x5c, 0xab, 0xb9, 0xeb, 0xd4, 0x0f, 0x4e, 0x5a,
	0x04, 0x3d, 0x84, 0x99, 0xaa, 0x4d, 0x74, 0x97, 0x6c, 0xf8, 0x0b, 0x7a, 0xc7, 0x5b, 0xcf, 0xae,
	0x53, 0x9f, 0xcf, 0x2c, 0x67, 0x6e, 0x5d, 0x5e, 0xbb, 0xb6, 0x1a, 0xed, 0xe1, 0xea, 0xae, 0x53,
	0xdf, 0x12, 0x68, 0xb1, 0x9c, 0x1f, 0x35, 0xe0, 0x4a, 0xdb, 0x34, 0x8e, 0x89, 0xed, 0xe8, 0x8d,
	0xc3, 0x56, 0x4d, 0x77, 0xc9, 0x56, 0xa8, 0x10, 0x0f, 0x3f, 0x4b, 0xf1, 0x6f, 0x71, 0xf8, 0x87,
	0x2a, 0x16, 0x9c, 0x8a, 0x86, 0xde, 0x83, 0xa9, 0x1a, 0x69, 0x10, 0x7e, 0x92, 0x1c, 0x9d, 0x64,
	0x89, 0x9b, 0x64, 0x9b, 0xa3, 0xc4, 0x32, 0x5e, 0xf4, 0x36, 0x4c, 0x06, 0xaf, 0xcc, 0x81, 0xf5,
	0x11, 0x31, 0xa9, 0x56, 0x2e, 0x52, 0xc0, 0xab, 0x1c, 0xe0, 0x41, 0x82, 0x0e, 0x8b, 0x7c, 0xe8,
	0x7d, 0x98, 0x6d, 0xd3, 0x65, 0x1f, 0x3a, 0xc4, 0xde, 0x68, 0xb5, 0x6c, 0xeb, 0x58, 0x6f, 0x50,
	0xc4, 0x4b, 0x14, 0x51, 0xe3, 0xf5, 0x20, 0x12, 0x63, 0x05, 0x82, 0x27, 0x7b, 0x5b, 0xa2, 0xe0,
	0x21, 0xa9, 0xec, 0x82, 0x5e, 0x65, 0xbc, 0x1e, 0xa4, 0xbf, 0xab, 0x49, 0xc8, 0x61, 0x29, 0xe4,
	0x16, 0x47, 0x89, 0x65, 0xbc, 0xd1, 0x8b, 0xb6, 0xed, 0xbf, 0xbd, 0xfb, 0xde, 0xcb, 0xeb, 0x81,
	0xe6, 0x53, 0x5e, 0xb4, 0x38, 0x2d, 0x96, 0xf3, 0x7b, 0xc0, 0xbe, 0x08, 0x3c, 0x70, 0x41, 0x0a,
	0x7c, 0x28, 0xd0, 0x62, 0x39, 0xbf, 0x07, 0xec, 0xbf, 0x17, 0x3c, 0x30, 0x48, 0x81, 0xb7, 0x05,
	0x5a, 0x2c, 0xe7, 0x47, 0x1f, 0xc0, 0x9c, 0x43, 0xdc, 0xf8, 0xd3, 0x07, 0x7a, 0xa3, 0x4d, 0xa1,
	0x2f, 0x53, 0xe8, 0xeb, 0x1c, 0xf4, 0xbe, 0x84, 0x1a, 0xab, 0x30, 0xbc, 0x77, 0xcd, 0x21, 0xee,
	0x8e, 0x59, 0xb5, 0x9a, 0x86, 0x59, 0x0f, 0x5e, 0x15, 0x0f, 0x7d, 0x4c, 0xfa, 0xae, 0xed, 0x8b,
	0xc4, 0x58, 0x81, 0x80, 0xaa, 0xb0, 0xe0, 0xcb, 0x24, 0x83, 0x1f, 0xa7, 0xf0, 0x37, 0xa5, 0x7a,
	0x11, 0x66, 0x50, 0xe3, 0x30, 0x01, 0xee, 0xb7, 0xdd, 0xba, 0xc5, 0xcd, 0x30, 0xa1, 0x12, 0x80,
	0x27, 0xc6, 0x0a, 0x84, 0x48, 0x00, 0x19, 0xfc, 0x64, 0x8a, 0x00, 0xc2, 0x0c, 0x6a, 0x1c, 0xcf,
	0x74, 0xb4, 0xda, 0x76, 0x9d, 0x24, 0x3e, 0x74, 0x24, 0x35, 0x1d, 0x7b, 0x09, 0x3a, 0x2c, 0xf2,
	0x79, 0xdf, 0xa2, 0x43, 0xdc, 0x07, 0x7a, 0xc3, 0xa8, 0x51, 0x7b, 0xb2, 0x53, 0xa3, 0x70, 0x53,
	0xd2, 0x6f, 0x71, 0x9f, 0xa3, 0xc4, 0x32, 0x5e, 0xf4, 0x2a, 0x8c, 0x3a, 0xc4, 0xdd, 0xd5, 0x4d,
	0xbd, 0x4e, 0x6c, 0x0f, 0x6c, 0x9a, 0x82, 0x2d, 0x88, 0x60, 0x8c, 0x06, 0x27, 0xe9, 0xd1, 0x77,
	0x61, 0xde, 0x21, 0x6e, 0xec, 0x03, 0x67, 0x6e, 0xd0, 0xc3, 0x9a, 0xa1, 0x58, 0x37, 0x44, 0x2c,
	0x91, 0x1c, 0x2b, 0x51, 0x98, 0xd4, 0x74, 0xd1, 0x71, 0xf0, 0x59, 0x95, 0xd4, 0x09, 0x4a, 0x2c,
	0xe3, 0x45, 0x6f, 0xc2, 0x84, 0x37, 0x1d, 0x75, 0x7f, 0xdb, 0x0c, 0x6f, 0x8e, 0xe2, 0x5d, 0x91,
	0x2c, 0x36, 0x24, 0xc3, 0x02, 0x17, 0x7a, 0x0d, 0xc6, 0x1d, 0xe2, 0xee, 0xbb, 0xba, 0x59, 0xd3,
	0x6d, 0x7f, 0x3b, 0xe6, 0x29, 0xd0, 0xa2, 0x08, 0x14, 0x52, 0x61, 0x9e, 0xc7, 0x7b, 0x17, 0x13,
	0xf2, 0x27, 0x5e, 0x97, 0x05, 0xe9, 0xbb, 0xb8, 0x2f, 0xa5, 0xc7, 0x6a, 0x1c, 0x26, 0xf5, 0x8e,
	0xb3, 0x61, 0x57, 0x8f, 0x8c, 0x63, 0x52, 0xf3, 0xb0, 0x8b, 0x2a, 0xa9, 0x23, 0x32, 0x2c, 0x70,
	0x21, 0x0b, 0xae, 0x3a, 0xc4, 0xc5, 0xc4, 0x21, 0xf6, 0x31, 0xa9, 0xed, 0x79, 0x51, 0x45, 0xd5,
	0x6a, 0x30, 0xbf, 0xef, 0xc1, 0x2e, 0x52, 0xd8, 0xdb, 0x22, 0xac, 0x82, 0x07, 0xa7, 0xe3, 0x69,
	0x7f, 0xc8, 0xc0, 0x78, 0x68, 0xb1, 0xf7, 0x68, 0x5c, 0x87, 0x5e, 0x84, 0x82, 0xde, 0x76, 0x8f,
	0x2c, 0xdb, 0x70, 0x4f, 0x68, 0x8c, 0x52, 0xd8, 0x9c, 0xff, 0xdb, 0x1f, 0xef, 0x4c, 0xb3, 0x28,
	0x91, 0x71, 0xef, 0xbb, 0xb6, 0x61, 0xd6, 0x71, 0x44, 0x8a, 0x5e, 0x80, 0x21, 0x3f, 0x32, 0x64,
	0x81, 0x07, 0x8a, 0xaf, 0xd2, 0xc7, 0xde, 0x2c, 0x7c, 0xfa, 0xc5, 0xd2, 0x85, 0xdf, 0x3c, 0x3d,
	0x5d, 0xc9, 0x60, 0x46, 0xbc, 0x7e, 0xe7, 0x87, 0x4f, 0x4f, 0x57, 0x22, 0x98, 0x4f, 0x9e, 0x9e,
	0xae, 0xc4, 0xa3, 0x34, 0x6e, 0x75, 0xda, 0x02, 0xcc, 0x71, 0x8f, 0x30, 0x71, 0x5a, 0x96, 0xe9,
	0x10, 0xed, 0x34, 0x0b, 0xa5, 0x2d, 0xba, 0xc8, 0x2d, 0xcb, 0x30, 0x1f, 0xda, 0x7a, 0xab, 0x45,
	0xec, 0x3d, 0xdd, 0x3d, 0xda, 0xa8, 0xd5, 0xee, 0x57, 0xbe, 0x47, 0xaa, 0x2e, 0x9a, 0x86, 0x4b,
	0x35, 0x62, 0x5a, 0x4d, 0x5f, 0x2e, 0xec, 0xff, 0x40, 0x65, 0xc8, 0x07, 0xe1, 0xe9, 0x7c, 0x76,
	0x39, 0x77, 0xeb, 0xf2, 0xda, 0x54, 0x7c, 0xed, 0x9b, 0xfe, 0x18, 0x0e, 0x89, 0xd0, 0x2c, 0x0c,
	0x39, 0x27, 0xcd, 0x8a, 0xd5, 0xa0, 0xe1, 0x4f, 0x01, 0xb3, 0x5f, 0xe8, 0x05, 0x00, 0x8a, 0x78,
	0x68, 0x1a, 0xae, 0x33, 0x7f, 0x91, 0x42, 0xcd, 0xc4, 0xa1, 0xb6, 0x83, 0x51, 0x1c, 0x23, 0x44,
	0xaf, 0x43, 0x49, 0x6f, 0x34, 0xac, 0x8f, 0xef, 0x1f, 0x13, 0xdb, 0x36, 0x6a, 0xe4, 0xa1, 0xe1,
	0x1e, 0x6d, 0x98, 0x27, 0x91, 0x51, 0xa1, 0x21, 0x4c, 0x1e, 0x77, 0xa0, 0x42, 0x77, 0x61, 0x8a,
	0x52, 0xf8, 0x4a, 0xa0, 0x0a, 0x30, 0x4c, 0x3f, 0x4c, 0xc9, 0x63, 0xd9, 0x90, 0xf6, 0xf3, 0x0c,
	0x5c, 0x8d, 0x54, 0xb6, 0xa9, 0x57, 0x3f, 0x22, 0xb5, 0xa4, 0xc6, 0x8a, 0x90, 0x37, 0x2a, 0xd5,
	0xed, 0x98, 0xd2, 0xc2, 0xdf, 0x67, 0xd7, 0xdb, 0x0a, 0x14, 0x8c, 0x4a, 0x75, 0xa3, 0x69, 0xb5,
	0x4d, 0xd7, 0x57, 0xdd, 0xe6, 0x88, 0xf7, 0x46, 0xfc, 0xf3, 0x8b, 0xa5, 0x8b, 0x87, 0x86, 0xe9,
	0xe2, 0x68, 0x58, 0xfb, 0x3c, 0x0b, 0x53, 0x3b, 0xe6, 0xb1, 0x6e, 0x1b, 0xba, 0xe9, 0x3a, 0xd1,
	0x82, 0x5e, 0x84, 0x59, 0xd3, 0xf2, 0x8d, 0xc5, 0xfd, 0x8f, 0x4d, 0x62, 0x3b, 0x47, 0x46, 0xeb,
	0xc0, 0x68, 0x12, 0x87, 0x2e, 0x2f, 0x8f, 0x15, 0xa3, 0xe8, 0x79, 0x18, 0x6b, 0xea, 0x4f, 0xf6,
	0xdb, 0xad, 0x56, 0xe3, 0x64, 0x8f, 0xd8, 0x3b, 0x35, 0xfa, 0x9a, 0xf2, 0x0b, 0xe0, 0x68, 0xd0,
	0x07, 0xc0, 0xde, 0xfb, 0xa4, 0x7e, 0x58, 0xd8, 0x9b, 0xf8, 0x10, 0x53, 0xf5, 0x88, 0xa5, 0x30,
	0xe8, 0xdb, 0xb0, 0x68, 0x5a, 0xaf, 0x5b, 0x76, 0x95, 0x3c, 0x6e, 0x37, 0xf6, 0x2c, 0xc7, 0xdd,
	0x35, 0x4c, 0x37, 0x88, 0x75, 0x1d, 0x1a, 0x0b, 0xe7, 0x71, 0x1a, 0x89, 0xb7, 0xe7, 0x35, 0xc3,
	0xd1, 0x2b, 0x0d, 0xb2, 0x67, 0x59, 0x0d, 0x1a, 0xd3, 0x19, 0x56, 0xf0, 0xc2, 0xc8, 0x86, 0xb4,
	0xff, 0x8d, 0xc2, 0x95, 0xb4, 0x73, 0x00, 0x9a, 0x87, 0x61, 0x1a, 0x07, 0x5a, 0x36, 0xdb, 0xf1,
	0xe0, 0x27, 0xba, 0x0b, 0x23, 0xd1, 0x99, 0x4b, 0xa1, 0xc1, 0x04, 0x05, 0x7a, 0x1d, 0xc6, 0x6b,
	0xe4, 0xb1, 0xde, 0x6e, 0xb8, 0x9b, 0xc1, 0x9b, 0x92, 0x13, 0x4d, 0xa3, 0x17, 0x70, 0xb3, 0x71,
	0x3f, 0xac, 0xe3, 0x99, 0x3c, 0x31, 0xfd, 0x10, 0x32, 0xe1, 0x69, 0x99, 0x82, 0x64, 0x43, 0xe8,
	0x65, 0x18, 0x3d, 0x4e, 0xd0, 0x5e, 0x12, 0x3f, 0x47, 0xba, 0x60, 0xdd, 0xac, 0x13, 0x9c, 0xa4,
	0xf5, 0xf6, 0x85, 0x0f, 0xda, 0xf7, 0xa2, 0x53, 0x2a, 0xfb, 0xa2, 0xd2, 0x48, 0x68, 0x30, 0x2e,
	0xe5, 0x1d, 0x16, 0x43, 0x5b, 0x29, 0x02, 0x96, 0xf3, 0xa3, 0xe7, 0x83, 0x60, 0x9c, 0x05, 0x0b,
	0x07, 0xec, 0x18, 0x4b, 0xa3, 0xfc, 0x3c, 0x96, 0x0f, 0x7a, 0xfe, 0xb4, 0xc9, 0xd1, 0x17, 0xa8,
	0x3e, 0x92, 0xfe, 0x34, 0x49, 0x82, 0x79, 0x1e, 0xf4, 0x16, 0x2c, 0x0b, 0x87, 0x19, 0xe6, 0xff,
	0x43, 0x5c, 0xa0, 0xeb, 0xe8, 0x48, 0x87, 0x1e, 0x43, 0xb1, 0xaa, 0x46, 0xb9, 0x4c, 0x57, 0xf7,
	0x8c, 0x5c, 0x4d, 0x3c, 0x35, 0x4e, 0x41, 0x8a, 0xf6, 0x32, 0x11, 0xae, 0x84, 0x13, 0x8d, 0xc4,
	0xf7, 0x52, 0x4a, 0xe2, 0xed, 0xa5, 0x2b, 0xe5, 0x1d, 0xa5, 0x8b, 0x4c, 0xec, 0xa5, 0x14, 0x01,
	0xcb, 0xf9, 0xd1, 0x3a, 0xcc, 0x33, 0x35, 0x85, 0xc1, 0x4f, 0x88, 0x3d, 0x46, 0xd7, 0xa5, 0x1c,
	0x47, 0xef, 0x02, 0xaa, 0x8a, 0x5c, 0xe3, 0x74, 0x45, 0xa5, 0x84, 0xda, 0x04, 0x2a, 0x2c, 0xe1,
	0x44, 0xaf, 0xc0, 0x02, 0xbf, 0x65, 0x61, 0x94, 0x43, 0x4f, 0x05, 0x79, 0xac, 0x26, 0x40, 0x7b,
	0x30, 0x55, 0x95, 0xf0, 0x4d, 0x4a, 0x96, 0x23, 0x90, 0x61, 0x19, 0x2b, 0x7a, 0x09, 0xe6, 0xfc,
	0xe9, 0xc2, 0x80, 0x2e, 0x14, 0x12, 0xd1, 0xd5, 0xa8, 0x86, 0xbd, 0xb3, 0x81, 0x23, 0xf0, 0x4c,
	0xd1, 0x95, 0x24, 0xce, 0x06, 0x02, 0x27, 0x16, 0xf9, 0xa2, 0x2d, 0x8a, 0x22, 0xb5, 0x10, 0x73,
	0x3a, 0xbe, 0x45, 0xe2, 0xb8, 0xb7, 0x45, 0x86, 0xc8, 0x35, 0x23, 0xea, 0x44, 0xe4, 0xc5, 0x12,
	0x4e, 0xf4, 0x10, 0x16, 0x9a, 0x86, 0xe9, 0xbe, 0xe6, 0x54, 0x6d, 0xcf, 0x93, 0x1b, 0xa6, 0x73,
	0x60, 0x05, 0x9e, 0x60, 0x7e, 0x96, 0xc2, 0x2e, 0xac, 0xb2, 0x30, 0xad, 0xa2, 0x3b, 0x64, 0x95,
	0x25, 0xa9, 0x56, 0x3d, 0x5a, 0xac, 0xe6, 0x45, 0x0d, 0x58, 0xac, 0xca, 0x02, 0x27, 0xe7, 0xc0,
	0xda, 0xa8, 0xd5, 0xe6, 0xe7, 0x28, 0xf4, 0x8a, 0xdc, 0xd9, 0xc9, 0xe2, 0x2c, 0x9c, 0x06, 0x87,
	0x5e, 0x05, 0x30, 0x42, 0xc7, 0xce, 0xc2, 0xfa, 0xc4, 0x79, 0x43, 0xe2, 0xf6, 0x71, 0x8c, 0x65,
	0xfd, 0x05, 0x2f, 0x64, 0x0c, 0x9c, 0x92, 0x17, 0x30, 0xde, 0x88, 0x05, 0x8c, 0x4a, 0xbf, 0xa6,
	0x7d, 0x07, 0x6e, 0xa4, 0xe6, 0xbf, 0x58, 0x1c, 0x29, 0x78, 0xb9, 0x4c, 0x27, 0x2f, 0xa7, 0xfd,
	0x72, 0x14, 0xa6, 0x24, 0x99, 0x9f, 0xbe, 0x7a, 0x52, 0x85, 0x07, 0xcc, 0x9d, 0xc1, 0x03, 0x5e,
	0xec, 0x9f, 0x07, 0xbc, 0x74, 0x0e, 0x0f, 0x38, 0x34, 0x28, 0x0f, 0x38, 0x7c, 0x46, 0x0f, 0x98,
	0x1f, 0x90, 0x07, 0x2c, 0xf4, 0xc5, 0x03, 0xc2, 0xd7, 0xe5, 0x01, 0x2f, 0x9f, 0xc3, 0x03, 0x8e,
	0x0c, 0xd0, 0x03, 0x8e, 0xf6, 0xe4, 0x01, 0xc7, 0x06, 0xe3, 0x01, 0xc7, 0x7b, 0xf4, 0x80, 0x13,
	0x03, 0xf1, 0x80, 0x93, 0x3d, 0x78, 0x40, 0x34, 0x00, 0x0f, 0x38, 0xd5, 0x93, 0x07, 0x9c, 0x1e,
	0x8c, 0x07, 0x9c, 0x19, 0x9c, 0x07, 0x9c, 0x1d, 0xa4, 0x07, 0x9c, 0x3b, 0xbb, 0x07, 0x7c, 0x8e,
	0xf7, 0x80, 0x8b, 0x71, 0x0f, 0xc8, 0x3b, 0xbe, 0xfb, 0xb0, 0x28, 0xbb, 0x97, 0xe8, 0xdd, 0xdf,
	0x7d, 0x52, 0xa0, 0xfe, 0x8e, 0xbf, 0x96, 0x48, 0xf1, 0x77, 0x92, 0x73, 0x60, 0xb6, 0x97, 0x73,
	0xa0, 0xe0, 0xd3, 0x72, 0x67, 0xf0, 0x69, 0x4a, 0x8f, 0x74, 0xf1, 0x9c, 0x1e, 0x49, 0xe2, 0x5b,
	0x2e, 0xf5, 0xe0, 0x5b, 0xd2, 0xfd, 0xc1, 0x50, 0xdf, 0xfc, 0x81, 0xd2, 0x9a, 0x0f, 0x9f, 0xd3,
	0x9a, 0xcb, 0x2d, 0x72, 0xbe, 0x67, 0x8b, 0xac, 0xb0, 0xa9, 0x85, 0xde, 0x6d, 0xaa, 0xd4, 0x32,
	0x42, 0x8f, 0x96, 0x51, 0x6e, 0xdd, 0x2e, 0x0f, 0xc6, 0xba, 0x8d, 0x0c, 0xce, 0xba, 0x8d, 0x0e,
	0xd2, 0xba, 0x8d, 0xf5, 0xd9, 0xba, 0xf1, 0x46, 0x87, 0x59, 0x37, 0xe1, 0x8a, 0xb4, 0x77, 0xeb,
	0xf6, 0xab, 0x0c, 0xcc, 0x48, 0x2f, 0xe2, 0x53, 0xec, 0xdb, 0xcb, 0x30, 0xa2, 0xc7, 0x28, 0x59,
	0x3a, 0x74, 0x2e, 0x2e, 0x75, 0x0c, 0x09, 0x27, 0x88, 0xd7, 0x57, 0x79, 0x79, 0xaf, 0x0a, 0xf2,
	0xc6, 0x97, 0xa1, 0x2d, 0xc1, 0x55, 0x79, 0xa1, 0x40, 0x90, 0x09, 0xff, 0x4b, 0x06, 0x26, 0x85,
	0x4b, 0xf3, 0xbe, 0x9e, 0x46, 0xd6, 0xa0, 0x10, 0x56, 0x7b, 0x30, 0x1b, 0x3c, 0x9d, 0x30, 0x1b,
	0x6c, 0x10, 0x47, 0x64, 0xeb, 0x2b, 0xbc, 0x98, 0xf1, 0x32, 0x8f, 0xe4, 0x5a, 0xb5, 0x45, 0x58,
	0x10, 0x6f, 0xfd, 0x03, 0xf1, 0x7e, 0x9a, 0xa1, 0xee, 0x87, 0x2f, 0x32, 0xe8, 0xa7, 0x80, 0xe9,
	0xef, 0x20, 0x3f, 0xb3, 0x76, 0x95, 0xbe, 0x83, 0x42, 0xd5, 0x43, 0xb0, 0xe0, 0xcf, 0xf3, 0x30,
	0x2b, 0x2f, 0x39, 0xe8, 0xeb, 0xa6, 0x84, 0x01, 0x23, 0x7f, 0x63, 0x1a, 0x1c, 0x13, 0x55, 0xc3,
	0xe8, 0x5d, 0x98, 0xb4, 0x04, 0x1e, 0xff, 0xb8, 0xb8, 0xcc, 0x3b, 0x68, 0xe1, 0x9a, 0x56, 0x64,
	0x8d, 0x56, 0xc2, 0x5f, 0x3e, 0x07, 0x27, 0x47, 0xd5, 0xb0, 0xb7, 0x12, 0x43, 0xe0, 0x19, 0x92,
	0xaf, 0x44, 0xb8, 0xf1, 0x16, 0x59, 0xd1, 0x11, 0x94, 0xfd, 0xa9, 0x36, 0xda, 0xae, 0xe5, 0x3f,
	0x26, 0xfb, 0xa4, 0xf1, 0x78, 0xc7, 0x34, 0x5c, 0x43, 0x77, 0x49, 0x2d, 0x10, 0x27, 0xca, 0xba,
	0xfb, 0xc7, 0xc8, 0xb3, 0xb2, 0xa1, 0x47, 0x70, 0x5b, 0xef, 0x7a, 0x0e, 0x3f, 0x59, 0xdb, 0x3d,
	0x43, 0x67, 0x39, 0x02, 0x65, 0x44, 0x73, 0x14, 0xba, 0x91, 0x43, 0x60, 0x4b, 0x93, 0x43, 0x9c,
	0x03, 0xd2, 0xe5, 0x10, 0xd1, 0x0f, 0xe0, 0xa6, 0xb0, 0xa0, 0x8d, 0x46, 0x43, 0x44, 0xf6, 0x4f,
	0xa5, 0xdd, 0x11, 0xa3, 0x37, 0x61, 0x49, 0xef, 0x80, 0xe7, 0xe7, 0x79, 0x3b, 0x91, 0x45, 0xc9,
	0x05, 0xef, 0x05, 0x8b, 0xc7, 0x88, 0xa3, 0xf1, 0xe4, 0x02, 0x37, 0xe8, 0x05, 0x80, 0x6d, 0x8e,
	0x7e, 0x4c, 0xbc, 0xae, 0xe6, 0xb8, 0x30, 0xcf, 0xb3, 0x5e, 0xe6, 0x8d, 0x4e, 0x49, 0x08, 0xeb,
	0x13, 0xd6, 0x43, 0x5b, 0x86, 0x92, 0xa2, 0x94, 0x29, 0x30, 0x3d, 0x7f, 0xcf, 0x50, 0xd3, 0x23,
	0xa9, 0x40, 0xe9, 0xab, 0xe9, 0x79, 0x05, 0xf2, 0x3a, 0xc3, 0x65, 0x17, 0x3c, 0x9d, 0xbf, 0xd6,
	0x90, 0x23, 0x5d, 0x6e, 0xc9, 0xd2, 0x99, 0xdc, 0xb2, 0xb2, 0x9a, 0x40, 0xee, 0x3f, 0x65, 0xa8,
	0x07, 0x91, 0x97, 0xc6, 0xf4, 0x55, 0xf4, 0x12, 0x40, 0x20, 0xc8, 0x4e, 0x8d, 0x5d, 0x08, 0xc7,
	0x9e, 0xac, 0xaf, 0xf1, 0xc2, 0x5d, 0x13, 0x3c, 0x89, 0x20, 0xdf, 0x75, 0xb8, 0xa6, 0xae, 0xeb,
	0x11, 0xb7, 0x96, 0x37, 0xc9, 0x5f, 0xf7, 0xd6, 0x0a, 0x2e, 0xa1, 0xfb, 0xad, 0xe5, 0x59, 0xa3,
	0xad, 0x15, 0x40, 0xa5, 0x5b, 0x3b, 0x50, 0xd1, 0xfb, 0xb0, 0xb5, 0x82, 0x7c, 0xf1, 0xad, 0x55,
	0x8a, 0xf8, 0xdf, 0x2c, 0x0d, 0xe0, 0x92, 0xa5, 0x4b, 0x7d, 0x15, 0x4d, 0x83, 0x11, 0x5a, 0x08,
	0xf5, 0xda, 0x93, 0x96, 0x61, 0x93, 0x1a, 0x0b, 0x10, 0x12, 0xcf, 0xd0, 0x2d, 0x18, 0xf7, 0x85,
	0x25, 0x36, 0x0b, 0x33, 0xe9, 0x49, 0xb9, 0x80, 0xf9, 0xc7, 0xe8, 0x5b, 0x50, 0xa4, 0x9c, 0x5b,
	0x56, 0xdb, 0x74, 0x89, 0xdd, 0xd2, 0x6d, 0xf7, 0x84, 0x77, 0xf9, 0x29, 0x14, 0xe8, 0x3d, 0x98,
	0x08, 0xd4, 0xea, 0x1c, 0x58, 0x54, 0x6c, 0xe6, 0xf4, 0x13, 0xe5, 0x39, 0x1b, 0xa1, 0xea, 0x89,
	0xe9, 0x1a, 0x8f, 0x0d, 0x62, 0x6f, 0x13, 0x57, 0x37, 0x1a, 0x0e, 0x16, 0xd8, 0xd3, 0xa3, 0xcd,
	0xa4, 0x62, 0xb5, 0x37, 0xe8, 0x0b, 0xc5, 0x15, 0x8a, 0x05, 0x07, 0x88, 0x15, 0x28, 0x98, 0xed,
	0x26, 0x1d, 0x94, 0x9f, 0x1e, 0xa2, 0x61, 0xed, 0x47, 0xf1, 0xa3, 0x43, 0xbc, 0x74, 0x30, 0x65,
	0xef, 0x34, 0x18, 0x61, 0x59, 0x0e, 0x5a, 0x5f, 0x48, 0xf7, 0x2e, 0x8f, 0x13, 0xcf, 0xba, 0x39,
	0x21, 0xc4, 0x67, 0xd3, 0xde, 0x88, 0x9d, 0x10, 0x12, 0xf5, 0x92, 0x81, 0x50, 0xcf, 0xc0, 0x30,
	0xad, 0x6d, 0x56, 0x1c, 0x88, 0x82, 0x41, 0xed, 0x77, 0xbe, 0x40, 0x62, 0x49, 0x67, 0x8a, 0x40,
	0x31, 0xec, 0x6c, 0x0a, 0xb6, 0x20, 0x78, 0xee, 0xac, 0x82, 0x8b, 0xab, 0x62, 0x47, 0x23, 0x49,
	0x05, 0x6a, 0xf0, 0x65, 0xfd, 0xd8, 0x17, 0x48, 0x2c, 0x25, 0x3d, 0xbf, 0x40, 0xe9, 0x8b, 0x15,
	0x67, 0x64, 0x8b, 0x95, 0x54, 0xb5, 0x06, 0x8b, 0xfd, 0x73, 0x86, 0x56, 0x3b, 0xc9, 0x8a, 0x53,
	0xfb, 0xa0, 0xff, 0x79, 0x18, 0x66, 0xc7, 0x50, 0x66, 0xda, 0x82, 0x9f, 0x68, 0x1a, 0x2e, 0x1d,
	0xd3, 0x2d, 0xf1, 0xeb, 0x2b, 0xfc, 0x1f, 0xeb, 0x77, 0x79, 0xf1, 0x96, 0x92, 0xa6, 0x5c, 0x58,
	0xa3, 0x76, 0x0d, 0x96, 0x54, 0xb5, 0xb5, 0x81, 0x88, 0xbf, 0xcd, 0xd2, 0xb3, 0x1c, 0x5f, 0x55,
	0xd9, 0x57, 0x5b, 0x77, 0xae, 0xa4, 0xe1, 0x23, 0x98, 0xad, 0xea, 0xe6, 0xa1, 0xb4, 0xf8, 0x24,
	0xc7, 0x97, 0x61, 0x06, 0x63, 0x1b, 0x5c, 0x8a, 0x10, 0x2b, 0x30, 0xd2, 0x8f, 0x99, 0xbc, 0x52,
	0x58, 0xaa, 0x43, 0xa8, 0x40, 0xed, 0x3d, 0xd5, 0xf1, 0x8b, 0x2c, 0x8c, 0x26, 0xca, 0x50, 0xfb,
	0xaa, 0x77, 0x49, 0x5a, 0x34, 0xd7, 0x43, 0x5a, 0x74, 0x17, 0x26, 0x42, 0xed, 0x31, 0x62, 0xa6,
	0xfb, 0x64, 0xa6, 0xd2, 0x68, 0x92, 0x1a, 0x2b, 0x0c, 0x8c, 0x14, 0x2f, 0xb0, 0xae, 0x3f, 0xc3,
	0xab, 0x7c, 0x26, 0xa9, 0x72, 0x46, 0xa7, 0xed, 0x50, 0x43, 0x11, 0xab, 0xd0, 0xed, 0x5d, 0xcd,
	0xff, 0xc9, 0xc2, 0xbc, 0xaa, 0x42, 0xb7, 0xaf, 0x1a, 0x4f, 0xcf, 0x20, 0xe7, 0xfa, 0x96, 0x41,
	0xae, 0xc2, 0x62, 0xa8, 0x57, 0x11, 0xa2, 0xfb, 0xdd, 0x49, 0x43, 0x59, 0xbf, 0xc7, 0x6f, 0xd4,
	0x72, 0x72, 0xa3, 0x44, 0x16, 0xed, 0x00, 0x96, 0x95, 0x95, 0xd0, 0xbd, 0x6f, 0xdf, 0x5f, 0x43,
	0x1b, 0x95, 0xc8, 0x86, 0xf7, 0x75, 0xe7, 0x94, 0x39, 0xf9, 0xdc, 0x39, 0x73, 0xf2, 0x24, 0x66,
	0xbf, 0x12, 0x8c, 0x6c, 0x97, 0xee, 0x28, 0x76, 0xe9, 0xa1, 0xe1, 0x1e, 0x05, 0x16, 0x46, 0x6a,
	0xc8, 0x12, 0x60, 0x1d, 0x0d, 0x59, 0x82, 0x3a, 0x32, 0x64, 0xc9, 0xa2, 0xf2, 0xde, 0xb7, 0xe8,
	0xf7, 0x59, 0x98, 0xe0, 0xcb, 0xca, 0xfb, 0xba, 0x3f, 0xf2, 0xab, 0x8d, 0x5c, 0xcf, 0x57, 0x1b,
	0xfb, 0x30, 0x15, 0xbd, 0xfb, 0xe1, 0x70, 0xf7, 0x5f, 0x8e, 0x8c, 0x7b, 0xfd, 0x36, 0xbf, 0x09,
	0xf3, 0xdc, 0x17, 0x13, 0x92, 0x6a, 0xef, 0x84, 0x16, 0x29, 0x2a, 0xc3, 0xef, 0x5d, 0xfd, 0xbf,
	0xce, 0xd2, 0x3a, 0xf2, 0x78, 0x31, 0x7e, 0x5f, 0xb5, 0x2f, 0xbd, 0xb6, 0xc9, 0xf5, 0x78, 0x6d,
	0xf3, 0x1e, 0xa0, 0x50, 0x79, 0x21, 0x43, 0xf7, 0x9a, 0x97, 0x30, 0xaf, 0xdf, 0xe2, 0x15, 0x3f,
	0x97, 0x54, 0x7c, 0x48, 0xa9, 0xbd, 0x1d, 0x44, 0x74, 0x51, 0xd7, 0x42, 0xef, 0x6a, 0xff, 0x57,
	0x96, 0x1e, 0x5c, 0xe4, 0x2d, 0x0b, 0x7d, 0xdd, 0x00, 0xc5, 0x4d, 0x5c, 0xae, 0xf7, 0x9b, 0xb8,
	0x06, 0x5c, 0x91, 0x18, 0x7f, 0x3e, 0xfb, 0x7c, 0x2b, 0x1d, 0x3a, 0xb6, 0x2d, 0xa9, 0x68, 0xe9,
	0x27, 0x75, 0xb9, 0xfe, 0xb4, 0x43, 0x7a, 0x52, 0x57, 0xf4, 0x83, 0xf4, 0xbe, 0x69, 0xa7, 0xa1,
	0xa9, 0x8a, 0xae, 0x05, 0xfb, 0x6d, 0xaa, 0x24, 0xd7, 0x92, 0xb9, 0x9e, 0xaf, 0x25, 0x0f, 0x61,
	0xba, 0xaa, 0x9b, 0xec, 0x71, 0xa4, 0x8b, 0xee, 0xbf, 0x18, 0x29, 0x7b, 0x47, 0x63, 0x15, 0xad,
	0x2e, 0x32, 0x56, 0xb1, 0xee, 0x99, 0x73, 0x7c, 0x35, 0x19, 0x7a, 0xee, 0x52, 0x77, 0xcd, 0xf4,
	0xdc, 0x02, 0x13, 0x3b, 0x51, 0x65, 0x93, 0x27, 0xaa, 0x55, 0x6f, 0x4f, 0xf8, 0xe9, 0xd8, 0x89,
	0x57, 0x32, 0xb2, 0xfe, 0x92, 0xd8, 0x15, 0x73, 0x33, 0xa9, 0x1e, 0xc5, 0xda, 0xb5, 0x67, 0xe1,
	0x66, 0x7a, 0x4b, 0x10, 0x53, 0xdc, 0xda, 0x4f, 0xa6, 0x21, 0xb7, 0xeb, 0xd4, 0xd1, 0x1e, 0x8c,
	0x24, 0xfa, 0x7f, 0x16, 0xa5, 0xed, 0x9c, 0xfe, 0x60, 0xf1, 0x7a, 0xca, 0x60, 0xb8, 0x25, 0x1f,
	0xc3, 0x82, 0xba, 0xbb, 0xa0, 0xeb, 0x7e, 0xe4, 0xe2, 0xdd, 0xae, 0x3b, 0x97, 0x83, 0x89, 0x2b,
	0x80, 0x24, 0xb7, 0xb6, 0x9d, 0x3b, 0xac, 0x8b, 0xb7, 0x3b, 0x37, 0x61, 0x07, 0x73, 0x3c, 0x80,
	0x31, 0xee, 0x5e, 0x35, 0xbd, 0x57, 0xb9, 0x78, 0x33, 0xbd, 0x95, 0x39, 0xc0, 0x25, 0x30, 0x25,
	0xbb, 0x1f, 0xec, 0xa2, 0x6d, 0xb9, 0xb8, 0xd2, 0x45, 0x6b, 0x73, 0x6c, 0x1a, 0xd9, 0x5d, 0x40,
	0x17, 0x1d, 0xab, 0xc2, 0x34, 0x29, 0xe9, 0x77, 0x64, 0xc2, 0xac, 0x22, 0xf5, 0xde, 0x5d, 0xf3,
	0x6a, 0xf1, 0x4e, 0x77, 0x3d, 0xae, 0x49, 0xb1, 0x84, 0x64, 0x70, 0x17, 0x7d, 0xac, 0x32, 0xb1,
	0x54, 0x79, 0xd9, 0x48, 0x2c, 0x61, 0xa6, 0xee, 0x5a, 0x5a, 0x15, 0x62, 0x29, 0xe7, 0x7b, 0x00,
	0x63, 0x5c, 0x0e, 0x38, 0xbd, 0xbb, 0x55, 0x78, 0xd9, 0x14, 0x39, 0xcd, 0x47, 0x30, 0x21, 0xdc,
	0x9e, 0x77, 0xea, 0xe1, 0x2f, 0x3e, 0xdb, 0xa9, 0xc9, 0x3f, 0x86, 0x2e, 0x7c, 0xf6, 0x9d, 0xba,
	0xe4, 0x05, 0x74, 0xe5, 0x47, 0xfe, 0x08, 0x26, 0x84, 0xc2, 0xb3, 0x4e, 0x0d, 0xf3, 0x02, 0xba,
	0xb2, 0x5c, 0x24, 0x34, 0x21, 0x89, 0xdc, 0x60, 0xe7, 0xde, 0x79, 0x85, 0x09, 0x91, 0x26, 0x5f,
	0x2b, 0x80, 0x24, 0x09, 0xd5, 0xce, 0x6d, 0xf4, 0xc2, 0x1c, 0xea, 0x3c, 0xa7, 0x37, 0x87, 0x24,
	0xc7, 0xd9, 0xb9, 0xa3, 0x5e, 0x98, 0x43, 0x9d, 0x9e, 0x44, 0x47, 0x30, 0x2d, 0x4d, 0x4d, 0x76,
	0xd3, 0x5c, 0x5f, 0xfc, 0x46, 0x37, 0x1d, 0xf8, 0xb1, 0x3d, 0x17, 0x32, 0x84, 0x9d, 0x1a, 0xb3,
	0x85, 0x3d, 0x57, 0xe6, 0xcd, 0xde, 0x02, 0x88, 0x65, 0xc0, 0xd4, 0x3d, 0xda, 0xc5, 0x6b, 0xea,
	0xf6, 0xed, 0x00, 0xeb, 0x23, 0x98, 0x91, 0xa7, 0x79, 0xba, 0x6a, 0xd7, 0x2e, 0x3e, 0xd7, 0x55,
	0x53, 0x77, 0x52, 0x2d, 0xc9, 0xa4, 0x44, 0xa7, 0xce, 0x6d, 0x99, 0x5a, 0xe4, 0xa7, 0xf0, 0x7d,
	0x18, 0x4d, 0x9e, 0xa7, 0x53, 0x9b, 0xb8, 0x8b, 0x37, 0x52, 0x5b, 0xbc, 0x03, 0xd0, 0x3d, 0x18,
	0x49, 0x9c, 0x12, 0xd3, 0xfa, 0xb9, 0x8b, 0xd7, 0xd3, 0x9a, 0xbd, 0x63, 0x36, 0x59, 0x71, 0x00,
	0xea, 0xae, 0xb5, 0x5b, 0xb0, 0xc9, 0x1d, 0x22, 0x7e, 0x5f, 0x2d, 0xb1, 0xd8, 0x3d, 0xb5, 0xcb,
	0x5b, 0xa6, 0x16, 0x49, 0x14, 0xfb, 0x7d, 0x28, 0xa6, 0xc4, 0xa3, 0xdd, 0x37, 0x7c, 0x17, 0xef,
	0x75, 0xdf, 0x1b, 0xce, 0xe6, 0x2e, 0x5e, 0xfa, 0xc1, 0xd3, 0xd3, 0x95, 0xcc, 0xe6, 0xde, 0xa7,
	0x5f, 0x96, 0x32, 0x9f, 0x7d, 0x59, 0xca, 0xfc, 0xfb, 0xcb, 0x52, 0xe6, 0x67, 0x5f, 0x95, 0x2e,
	0x7c, 0xf6, 0x55, 0xe9, 0xc2, 0x3f, 0xbe, 0x2a, 0x5d, 0x78, 0xff, 0xc5, 0xba, 0xe1, 0x1e, 0xb5,
	0x2b, 0xab, 0x55, 0xab, 0x59, 0xae, 0x18, 0x2e, 0x8b, 0x43, 0xc3, 0xbf, 0xaa, 0x47, 0xba, 0x61,
	0x96, 0x9f, 0x94, 0xd9, 0x73, 0xf7, 0xa4, 0xe5, 0x47, 0xa9, 0x95, 0x21, 0xfa, 0xef, 0xe2, 0x7c,
	0xf3, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x47, 0xf9, 0x70, 0x2d, 0xbb, 0x48, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	UniversalUpdateCollection(ctx context.Context, in *MsgUniversalUpdateCollection, opts ...grpc.CallOption) (*MsgUniversalUpdateCollectionResponse, error)
	CreateAddressLists(ctx context.Context, in *MsgCreateAddressLists, opts ...grpc.CallOption) (*MsgCreateAddressListsResponse, error)
	TransferTokens(ctx context.Context, in *MsgTransferTokens, opts ...grpc.CallOption) (*MsgTransferTokensResponse, error)
	UpdateUserApprovals(ctx context.Context, in *MsgUpdateUserApprovals, opts ...grpc.CallOption) (*MsgUpdateUserApprovalsResponse, error)
	SetIncomingApproval(ctx context.Context, in *MsgSetIncomingApproval, opts ...grpc.CallOption) (*MsgSetIncomingApprovalResponse, error)
	DeleteIncomingApproval(ctx context.Context, in *MsgDeleteIncomingApproval, opts ...grpc.CallOption) (*MsgDeleteIncomingApprovalResponse, error)
	SetOutgoingApproval(ctx context.Context, in *MsgSetOutgoingApproval, opts ...grpc.CallOption) (*MsgSetOutgoingApprovalResponse, error)
	DeleteOutgoingApproval(ctx context.Context, in *MsgDeleteOutgoingApproval, opts ...grpc.CallOption) (*MsgDeleteOutgoingApprovalResponse, error)
	PurgeApprovals(ctx context.Context, in *MsgPurgeApprovals, opts ...grpc.CallOption) (*MsgPurgeApprovalsResponse, error)
	DeleteCollection(ctx context.Context, in *MsgDeleteCollection, opts ...grpc.CallOption) (*MsgDeleteCollectionResponse, error)
	UpdateCollection(ctx context.Context, in *MsgUpdateCollection, opts ...grpc.CallOption) (*MsgUpdateCollectionResponse, error)
	CreateCollection(ctx context.Context, in *MsgCreateCollection, opts ...grpc.CallOption) (*MsgCreateCollectionResponse, error)
	CreateDynamicStore(ctx context.Context, in *MsgCreateDynamicStore, opts ...grpc.CallOption) (*MsgCreateDynamicStoreResponse, error)
	UpdateDynamicStore(ctx context.Context, in *MsgUpdateDynamicStore, opts ...grpc.CallOption) (*MsgUpdateDynamicStoreResponse, error)
	DeleteDynamicStore(ctx context.Context, in *MsgDeleteDynamicStore, opts ...grpc.CallOption) (*MsgDeleteDynamicStoreResponse, error)
	SetDynamicStoreValue(ctx context.Context, in *MsgSetDynamicStoreValue, opts ...grpc.CallOption) (*MsgSetDynamicStoreValueResponse, error)
	// Helper message types for UniversalUpdateCollection subsets
	SetValidTokenIds(ctx context.Context, in *MsgSetValidTokenIds, opts ...grpc.CallOption) (*MsgSetValidTokenIdsResponse, error)
	SetManager(ctx context.Context, in *MsgSetManager, opts ...grpc.CallOption) (*MsgSetManagerResponse, error)
	SetCollectionMetadata(ctx context.Context, in *MsgSetCollectionMetadata, opts ...grpc.CallOption) (*MsgSetCollectionMetadataResponse, error)
	SetTokenMetadata(ctx context.Context, in *MsgSetTokenMetadata, opts ...grpc.CallOption) (*MsgSetTokenMetadataResponse, error)
	SetCustomData(ctx context.Context, in *MsgSetCustomData, opts ...grpc.CallOption) (*MsgSetCustomDataResponse, error)
	SetStandards(ctx context.Context, in *MsgSetStandards, opts ...grpc.CallOption) (*MsgSetStandardsResponse, error)
	SetCollectionApprovals(ctx context.Context, in *MsgSetCollectionApprovals, opts ...grpc.CallOption) (*MsgSetCollectionApprovalsResponse, error)
	SetIsArchived(ctx context.Context, in *MsgSetIsArchived, opts ...grpc.CallOption) (*MsgSetIsArchivedResponse, error)
	SetReservedProtocolAddress(ctx context.Context, in *MsgSetReservedProtocolAddress, opts ...grpc.CallOption) (*MsgSetReservedProtocolAddressResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UniversalUpdateCollection(ctx context.Context, in *MsgUniversalUpdateCollection, opts ...grpc.CallOption) (*MsgUniversalUpdateCollectionResponse, error) {
	out := new(MsgUniversalUpdateCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/UniversalUpdateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateAddressLists(ctx context.Context, in *MsgCreateAddressLists, opts ...grpc.CallOption) (*MsgCreateAddressListsResponse, error) {
	out := new(MsgCreateAddressListsResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/CreateAddressLists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TransferTokens(ctx context.Context, in *MsgTransferTokens, opts ...grpc.CallOption) (*MsgTransferTokensResponse, error) {
	out := new(MsgTransferTokensResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/TransferTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateUserApprovals(ctx context.Context, in *MsgUpdateUserApprovals, opts ...grpc.CallOption) (*MsgUpdateUserApprovalsResponse, error) {
	out := new(MsgUpdateUserApprovalsResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/UpdateUserApprovals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetIncomingApproval(ctx context.Context, in *MsgSetIncomingApproval, opts ...grpc.CallOption) (*MsgSetIncomingApprovalResponse, error) {
	out := new(MsgSetIncomingApprovalResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetIncomingApproval", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeleteIncomingApproval(ctx context.Context, in *MsgDeleteIncomingApproval, opts ...grpc.CallOption) (*MsgDeleteIncomingApprovalResponse, error) {
	out := new(MsgDeleteIncomingApprovalResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/DeleteIncomingApproval", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetOutgoingApproval(ctx context.Context, in *MsgSetOutgoingApproval, opts ...grpc.CallOption) (*MsgSetOutgoingApprovalResponse, error) {
	out := new(MsgSetOutgoingApprovalResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetOutgoingApproval", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeleteOutgoingApproval(ctx context.Context, in *MsgDeleteOutgoingApproval, opts ...grpc.CallOption) (*MsgDeleteOutgoingApprovalResponse, error) {
	out := new(MsgDeleteOutgoingApprovalResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/DeleteOutgoingApproval", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PurgeApprovals(ctx context.Context, in *MsgPurgeApprovals, opts ...grpc.CallOption) (*MsgPurgeApprovalsResponse, error) {
	out := new(MsgPurgeApprovalsResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/PurgeApprovals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeleteCollection(ctx context.Context, in *MsgDeleteCollection, opts ...grpc.CallOption) (*MsgDeleteCollectionResponse, error) {
	out := new(MsgDeleteCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/DeleteCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateCollection(ctx context.Context, in *MsgUpdateCollection, opts ...grpc.CallOption) (*MsgUpdateCollectionResponse, error) {
	out := new(MsgUpdateCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/UpdateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateCollection(ctx context.Context, in *MsgCreateCollection, opts ...grpc.CallOption) (*MsgCreateCollectionResponse, error) {
	out := new(MsgCreateCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/CreateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateDynamicStore(ctx context.Context, in *MsgCreateDynamicStore, opts ...grpc.CallOption) (*MsgCreateDynamicStoreResponse, error) {
	out := new(MsgCreateDynamicStoreResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/CreateDynamicStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDynamicStore(ctx context.Context, in *MsgUpdateDynamicStore, opts ...grpc.CallOption) (*MsgUpdateDynamicStoreResponse, error) {
	out := new(MsgUpdateDynamicStoreResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/UpdateDynamicStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeleteDynamicStore(ctx context.Context, in *MsgDeleteDynamicStore, opts ...grpc.CallOption) (*MsgDeleteDynamicStoreResponse, error) {
	out := new(MsgDeleteDynamicStoreResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/DeleteDynamicStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetDynamicStoreValue(ctx context.Context, in *MsgSetDynamicStoreValue, opts ...grpc.CallOption) (*MsgSetDynamicStoreValueResponse, error) {
	out := new(MsgSetDynamicStoreValueResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetDynamicStoreValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetValidTokenIds(ctx context.Context, in *MsgSetValidTokenIds, opts ...grpc.CallOption) (*MsgSetValidTokenIdsResponse, error) {
	out := new(MsgSetValidTokenIdsResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetValidTokenIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetManager(ctx context.Context, in *MsgSetManager, opts ...grpc.CallOption) (*MsgSetManagerResponse, error) {
	out := new(MsgSetManagerResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetManager", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetCollectionMetadata(ctx context.Context, in *MsgSetCollectionMetadata, opts ...grpc.CallOption) (*MsgSetCollectionMetadataResponse, error) {
	out := new(MsgSetCollectionMetadataResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetCollectionMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetTokenMetadata(ctx context.Context, in *MsgSetTokenMetadata, opts ...grpc.CallOption) (*MsgSetTokenMetadataResponse, error) {
	out := new(MsgSetTokenMetadataResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetTokenMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetCustomData(ctx context.Context, in *MsgSetCustomData, opts ...grpc.CallOption) (*MsgSetCustomDataResponse, error) {
	out := new(MsgSetCustomDataResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetCustomData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetStandards(ctx context.Context, in *MsgSetStandards, opts ...grpc.CallOption) (*MsgSetStandardsResponse, error) {
	out := new(MsgSetStandardsResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetStandards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetCollectionApprovals(ctx context.Context, in *MsgSetCollectionApprovals, opts ...grpc.CallOption) (*MsgSetCollectionApprovalsResponse, error) {
	out := new(MsgSetCollectionApprovalsResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetCollectionApprovals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetIsArchived(ctx context.Context, in *MsgSetIsArchived, opts ...grpc.CallOption) (*MsgSetIsArchivedResponse, error) {
	out := new(MsgSetIsArchivedResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetIsArchived", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetReservedProtocolAddress(ctx context.Context, in *MsgSetReservedProtocolAddress, opts ...grpc.CallOption) (*MsgSetReservedProtocolAddressResponse, error) {
	out := new(MsgSetReservedProtocolAddressResponse)
	err := c.cc.Invoke(ctx, "/badges.v20.Msg/SetReservedProtocolAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	UniversalUpdateCollection(context.Context, *MsgUniversalUpdateCollection) (*MsgUniversalUpdateCollectionResponse, error)
	CreateAddressLists(context.Context, *MsgCreateAddressLists) (*MsgCreateAddressListsResponse, error)
	TransferTokens(context.Context, *MsgTransferTokens) (*MsgTransferTokensResponse, error)
	UpdateUserApprovals(context.Context, *MsgUpdateUserApprovals) (*MsgUpdateUserApprovalsResponse, error)
	SetIncomingApproval(context.Context, *MsgSetIncomingApproval) (*MsgSetIncomingApprovalResponse, error)
	DeleteIncomingApproval(context.Context, *MsgDeleteIncomingApproval) (*MsgDeleteIncomingApprovalResponse, error)
	SetOutgoingApproval(context.Context, *MsgSetOutgoingApproval) (*MsgSetOutgoingApprovalResponse, error)
	DeleteOutgoingApproval(context.Context, *MsgDeleteOutgoingApproval) (*MsgDeleteOutgoingApprovalResponse, error)
	PurgeApprovals(context.Context, *MsgPurgeApprovals) (*MsgPurgeApprovalsResponse, error)
	DeleteCollection(context.Context, *MsgDeleteCollection) (*MsgDeleteCollectionResponse, error)
	UpdateCollection(context.Context, *MsgUpdateCollection) (*MsgUpdateCollectionResponse, error)
	CreateCollection(context.Context, *MsgCreateCollection) (*MsgCreateCollectionResponse, error)
	CreateDynamicStore(context.Context, *MsgCreateDynamicStore) (*MsgCreateDynamicStoreResponse, error)
	UpdateDynamicStore(context.Context, *MsgUpdateDynamicStore) (*MsgUpdateDynamicStoreResponse, error)
	DeleteDynamicStore(context.Context, *MsgDeleteDynamicStore) (*MsgDeleteDynamicStoreResponse, error)
	SetDynamicStoreValue(context.Context, *MsgSetDynamicStoreValue) (*MsgSetDynamicStoreValueResponse, error)
	// Helper message types for UniversalUpdateCollection subsets
	SetValidTokenIds(context.Context, *MsgSetValidTokenIds) (*MsgSetValidTokenIdsResponse, error)
	SetManager(context.Context, *MsgSetManager) (*MsgSetManagerResponse, error)
	SetCollectionMetadata(context.Context, *MsgSetCollectionMetadata) (*MsgSetCollectionMetadataResponse, error)
	SetTokenMetadata(context.Context, *MsgSetTokenMetadata) (*MsgSetTokenMetadataResponse, error)
	SetCustomData(context.Context, *MsgSetCustomData) (*MsgSetCustomDataResponse, error)
	SetStandards(context.Context, *MsgSetStandards) (*MsgSetStandardsResponse, error)
	SetCollectionApprovals(context.Context, *MsgSetCollectionApprovals) (*MsgSetCollectionApprovalsResponse, error)
	SetIsArchived(context.Context, *MsgSetIsArchived) (*MsgSetIsArchivedResponse, error)
	SetReservedProtocolAddress(context.Context, *MsgSetReservedProtocolAddress) (*MsgSetReservedProtocolAddressResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) UniversalUpdateCollection(ctx context.Context, req *MsgUniversalUpdateCollection) (*MsgUniversalUpdateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UniversalUpdateCollection not implemented")
}
func (*UnimplementedMsgServer) CreateAddressLists(ctx context.Context, req *MsgCreateAddressLists) (*MsgCreateAddressListsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAddressLists not implemented")
}
func (*UnimplementedMsgServer) TransferTokens(ctx context.Context, req *MsgTransferTokens) (*MsgTransferTokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferTokens not implemented")
}
func (*UnimplementedMsgServer) UpdateUserApprovals(ctx context.Context, req *MsgUpdateUserApprovals) (*MsgUpdateUserApprovalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserApprovals not implemented")
}
func (*UnimplementedMsgServer) SetIncomingApproval(ctx context.Context, req *MsgSetIncomingApproval) (*MsgSetIncomingApprovalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIncomingApproval not implemented")
}
func (*UnimplementedMsgServer) DeleteIncomingApproval(ctx context.Context, req *MsgDeleteIncomingApproval) (*MsgDeleteIncomingApprovalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIncomingApproval not implemented")
}
func (*UnimplementedMsgServer) SetOutgoingApproval(ctx context.Context, req *MsgSetOutgoingApproval) (*MsgSetOutgoingApprovalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOutgoingApproval not implemented")
}
func (*UnimplementedMsgServer) DeleteOutgoingApproval(ctx context.Context, req *MsgDeleteOutgoingApproval) (*MsgDeleteOutgoingApprovalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOutgoingApproval not implemented")
}
func (*UnimplementedMsgServer) PurgeApprovals(ctx context.Context, req *MsgPurgeApprovals) (*MsgPurgeApprovalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PurgeApprovals not implemented")
}
func (*UnimplementedMsgServer) DeleteCollection(ctx context.Context, req *MsgDeleteCollection) (*MsgDeleteCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCollection not implemented")
}
func (*UnimplementedMsgServer) UpdateCollection(ctx context.Context, req *MsgUpdateCollection) (*MsgUpdateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCollection not implemented")
}
func (*UnimplementedMsgServer) CreateCollection(ctx context.Context, req *MsgCreateCollection) (*MsgCreateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCollection not implemented")
}
func (*UnimplementedMsgServer) CreateDynamicStore(ctx context.Context, req *MsgCreateDynamicStore) (*MsgCreateDynamicStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDynamicStore not implemented")
}
func (*UnimplementedMsgServer) UpdateDynamicStore(ctx context.Context, req *MsgUpdateDynamicStore) (*MsgUpdateDynamicStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDynamicStore not implemented")
}
func (*UnimplementedMsgServer) DeleteDynamicStore(ctx context.Context, req *MsgDeleteDynamicStore) (*MsgDeleteDynamicStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDynamicStore not implemented")
}
func (*UnimplementedMsgServer) SetDynamicStoreValue(ctx context.Context, req *MsgSetDynamicStoreValue) (*MsgSetDynamicStoreValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDynamicStoreValue not implemented")
}
func (*UnimplementedMsgServer) SetValidTokenIds(ctx context.Context, req *MsgSetValidTokenIds) (*MsgSetValidTokenIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetValidTokenIds not implemented")
}
func (*UnimplementedMsgServer) SetManager(ctx context.Context, req *MsgSetManager) (*MsgSetManagerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetManager not implemented")
}
func (*UnimplementedMsgServer) SetCollectionMetadata(ctx context.Context, req *MsgSetCollectionMetadata) (*MsgSetCollectionMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCollectionMetadata not implemented")
}
func (*UnimplementedMsgServer) SetTokenMetadata(ctx context.Context, req *MsgSetTokenMetadata) (*MsgSetTokenMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTokenMetadata not implemented")
}
func (*UnimplementedMsgServer) SetCustomData(ctx context.Context, req *MsgSetCustomData) (*MsgSetCustomDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCustomData not implemented")
}
func (*UnimplementedMsgServer) SetStandards(ctx context.Context, req *MsgSetStandards) (*MsgSetStandardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetStandards not implemented")
}
func (*UnimplementedMsgServer) SetCollectionApprovals(ctx context.Context, req *MsgSetCollectionApprovals) (*MsgSetCollectionApprovalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCollectionApprovals not implemented")
}
func (*UnimplementedMsgServer) SetIsArchived(ctx context.Context, req *MsgSetIsArchived) (*MsgSetIsArchivedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIsArchived not implemented")
}
func (*UnimplementedMsgServer) SetReservedProtocolAddress(ctx context.Context, req *MsgSetReservedProtocolAddress) (*MsgSetReservedProtocolAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetReservedProtocolAddress not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UniversalUpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUniversalUpdateCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UniversalUpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/UniversalUpdateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UniversalUpdateCollection(ctx, req.(*MsgUniversalUpdateCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateAddressLists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateAddressLists)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateAddressLists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/CreateAddressLists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateAddressLists(ctx, req.(*MsgCreateAddressLists))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TransferTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransferTokens)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TransferTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/TransferTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TransferTokens(ctx, req.(*MsgTransferTokens))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateUserApprovals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateUserApprovals)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateUserApprovals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/UpdateUserApprovals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateUserApprovals(ctx, req.(*MsgUpdateUserApprovals))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetIncomingApproval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetIncomingApproval)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetIncomingApproval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetIncomingApproval",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetIncomingApproval(ctx, req.(*MsgSetIncomingApproval))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeleteIncomingApproval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteIncomingApproval)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeleteIncomingApproval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/DeleteIncomingApproval",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeleteIncomingApproval(ctx, req.(*MsgDeleteIncomingApproval))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetOutgoingApproval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetOutgoingApproval)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetOutgoingApproval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetOutgoingApproval",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetOutgoingApproval(ctx, req.(*MsgSetOutgoingApproval))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeleteOutgoingApproval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteOutgoingApproval)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeleteOutgoingApproval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/DeleteOutgoingApproval",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeleteOutgoingApproval(ctx, req.(*MsgDeleteOutgoingApproval))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PurgeApprovals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPurgeApprovals)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PurgeApprovals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/PurgeApprovals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PurgeApprovals(ctx, req.(*MsgPurgeApprovals))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeleteCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeleteCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/DeleteCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeleteCollection(ctx, req.(*MsgDeleteCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/UpdateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateCollection(ctx, req.(*MsgUpdateCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/CreateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateCollection(ctx, req.(*MsgCreateCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateDynamicStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateDynamicStore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateDynamicStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/CreateDynamicStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateDynamicStore(ctx, req.(*MsgCreateDynamicStore))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDynamicStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDynamicStore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDynamicStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/UpdateDynamicStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDynamicStore(ctx, req.(*MsgUpdateDynamicStore))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeleteDynamicStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteDynamicStore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeleteDynamicStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/DeleteDynamicStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeleteDynamicStore(ctx, req.(*MsgDeleteDynamicStore))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetDynamicStoreValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetDynamicStoreValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetDynamicStoreValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetDynamicStoreValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetDynamicStoreValue(ctx, req.(*MsgSetDynamicStoreValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetValidTokenIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetValidTokenIds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetValidTokenIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetValidTokenIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetValidTokenIds(ctx, req.(*MsgSetValidTokenIds))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetManager_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetManager)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetManager(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetManager",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetManager(ctx, req.(*MsgSetManager))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetCollectionMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetCollectionMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetCollectionMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetCollectionMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetCollectionMetadata(ctx, req.(*MsgSetCollectionMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetTokenMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetTokenMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetTokenMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetTokenMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetTokenMetadata(ctx, req.(*MsgSetTokenMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetCustomData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetCustomData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetCustomData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetCustomData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetCustomData(ctx, req.(*MsgSetCustomData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetStandards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetStandards)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetStandards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetStandards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetStandards(ctx, req.(*MsgSetStandards))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetCollectionApprovals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetCollectionApprovals)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetCollectionApprovals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetCollectionApprovals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetCollectionApprovals(ctx, req.(*MsgSetCollectionApprovals))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetIsArchived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetIsArchived)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetIsArchived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetIsArchived",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetIsArchived(ctx, req.(*MsgSetIsArchived))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetReservedProtocolAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetReservedProtocolAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetReservedProtocolAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.v20.Msg/SetReservedProtocolAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetReservedProtocolAddress(ctx, req.(*MsgSetReservedProtocolAddress))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "badges.v20.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "UniversalUpdateCollection",
			Handler:    _Msg_UniversalUpdateCollection_Handler,
		},
		{
			MethodName: "CreateAddressLists",
			Handler:    _Msg_CreateAddressLists_Handler,
		},
		{
			MethodName: "TransferTokens",
			Handler:    _Msg_TransferTokens_Handler,
		},
		{
			MethodName: "UpdateUserApprovals",
			Handler:    _Msg_UpdateUserApprovals_Handler,
		},
		{
			MethodName: "SetIncomingApproval",
			Handler:    _Msg_SetIncomingApproval_Handler,
		},
		{
			MethodName: "DeleteIncomingApproval",
			Handler:    _Msg_DeleteIncomingApproval_Handler,
		},
		{
			MethodName: "SetOutgoingApproval",
			Handler:    _Msg_SetOutgoingApproval_Handler,
		},
		{
			MethodName: "DeleteOutgoingApproval",
			Handler:    _Msg_DeleteOutgoingApproval_Handler,
		},
		{
			MethodName: "PurgeApprovals",
			Handler:    _Msg_PurgeApprovals_Handler,
		},
		{
			MethodName: "DeleteCollection",
			Handler:    _Msg_DeleteCollection_Handler,
		},
		{
			MethodName: "UpdateCollection",
			Handler:    _Msg_UpdateCollection_Handler,
		},
		{
			MethodName: "CreateCollection",
			Handler:    _Msg_CreateCollection_Handler,
		},
		{
			MethodName: "CreateDynamicStore",
			Handler:    _Msg_CreateDynamicStore_Handler,
		},
		{
			MethodName: "UpdateDynamicStore",
			Handler:    _Msg_UpdateDynamicStore_Handler,
		},
		{
			MethodName: "DeleteDynamicStore",
			Handler:    _Msg_DeleteDynamicStore_Handler,
		},
		{
			MethodName: "SetDynamicStoreValue",
			Handler:    _Msg_SetDynamicStoreValue_Handler,
		},
		{
			MethodName: "SetValidTokenIds",
			Handler:    _Msg_SetValidTokenIds_Handler,
		},
		{
			MethodName: "SetManager",
			Handler:    _Msg_SetManager_Handler,
		},
		{
			MethodName: "SetCollectionMetadata",
			Handler:    _Msg_SetCollectionMetadata_Handler,
		},
		{
			MethodName: "SetTokenMetadata",
			Handler:    _Msg_SetTokenMetadata_Handler,
		},
		{
			MethodName: "SetCustomData",
			Handler:    _Msg_SetCustomData_Handler,
		},
		{
			MethodName: "SetStandards",
			Handler:    _Msg_SetStandards_Handler,
		},
		{
			MethodName: "SetCollectionApprovals",
			Handler:    _Msg_SetCollectionApprovals_Handler,
		},
		{
			MethodName: "SetIsArchived",
			Handler:    _Msg_SetIsArchived_Handler,
		},
		{
			MethodName: "SetReservedProtocolAddress",
			Handler:    _Msg_SetReservedProtocolAddress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "badges/v20/tx.proto",
}

func (m *BadgeCustomMsgType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadgeCustomMsgType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadgeCustomMsgType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetReservedProtocolAddressMsg != nil {
		{
			size, err := m.SetReservedProtocolAddressMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.SetIsArchivedMsg != nil {
		{
			size, err := m.SetIsArchivedMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.SetCollectionApprovalsMsg != nil {
		{
			size, err := m.SetCollectionApprovalsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.SetStandardsMsg != nil {
		{
			size, err := m.SetStandardsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.SetCustomDataMsg != nil {
		{
			size, err := m.SetCustomDataMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.SetTokenMetadataMsg != nil {
		{
			size, err := m.SetTokenMetadataMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.SetCollectionMetadataMsg != nil {
		{
			size, err := m.SetCollectionMetadataMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.SetManagerMsg != nil {
		{
			size, err := m.SetManagerMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.SetValidTokenIdsMsg != nil {
		{
			size, err := m.SetValidTokenIdsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.PurgeApprovalsMsg != nil {
		{
			size, err := m.PurgeApprovalsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.DeleteOutgoingApprovalMsg != nil {
		{
			size, err := m.DeleteOutgoingApprovalMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.SetOutgoingApprovalMsg != nil {
		{
			size, err := m.SetOutgoingApprovalMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.DeleteIncomingApprovalMsg != nil {
		{
			size, err := m.DeleteIncomingApprovalMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.SetIncomingApprovalMsg != nil {
		{
			size, err := m.SetIncomingApprovalMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.SetDynamicStoreValueMsg != nil {
		{
			size, err := m.SetDynamicStoreValueMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.DeleteDynamicStoreMsg != nil {
		{
			size, err := m.DeleteDynamicStoreMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.UpdateDynamicStoreMsg != nil {
		{
			size, err := m.UpdateDynamicStoreMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CreateDynamicStoreMsg != nil {
		{
			size, err := m.CreateDynamicStoreMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CreateCollectionMsg != nil {
		{
			size, err := m.CreateCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.UpdateCollectionMsg != nil {
		{
			size, err := m.UpdateCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UpdateUserApprovalsMsg != nil {
		{
			size, err := m.UpdateUserApprovalsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TransferTokensMsg != nil {
		{
			size, err := m.TransferTokensMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DeleteCollectionMsg != nil {
		{
			size, err := m.DeleteCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.UniversalUpdateCollectionMsg != nil {
		{
			size, err := m.UniversalUpdateCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CreateAddressListsMsg != nil {
		{
			size, err := m.CreateAddressListsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CosmosCoinWrapperPathAddObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosCoinWrapperPathAddObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosCoinWrapperPathAddObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowCosmosWrapping {
		i--
		if m.AllowCosmosWrapping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.AllowOverrideWithAnyValidToken {
		i--
		if m.AllowOverrideWithAnyValidToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.DenomUnits) > 0 {
		for iNdEx := len(m.DenomUnits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DenomUnits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CosmosCoinBackedPathAddObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CosmosCoinBackedPathAddObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CosmosCoinBackedPathAddObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.IbcAmount.Size()
		i -= size
		if _, err := m.IbcAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Balances) > 0 {
		for iNdEx := len(m.Balances) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balances[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.IbcDenom) > 0 {
		i -= len(m.IbcDenom)
		copy(dAtA[i:], m.IbcDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.IbcDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InvariantsAddObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvariantsAddObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvariantsAddObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisablePoolCreation {
		i--
		if m.DisablePoolCreation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.NoForcefulPostMintTransfers {
		i--
		if m.NoForcefulPostMintTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CosmosCoinBackedPath != nil {
		{
			size, err := m.CosmosCoinBackedPath.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.MaxSupplyPerId.Size()
		i -= size
		if _, err := m.MaxSupplyPerId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.NoCustomOwnershipTimes {
		i--
		if m.NoCustomOwnershipTimes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUniversalUpdateCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUniversalUpdateCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUniversalUpdateCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Invariants != nil {
		{
			size, err := m.Invariants.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for iNdEx := len(m.CosmosCoinWrapperPathsToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CosmosCoinWrapperPathsToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for iNdEx := len(m.MintEscrowCoinsToTransfer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MintEscrowCoinsToTransfer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.UpdateIsArchivedTimeline {
		i--
		if m.UpdateIsArchivedTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.UpdateStandardsTimeline {
		i--
		if m.UpdateStandardsTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.UpdateCollectionApprovals {
		i--
		if m.UpdateCollectionApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.UpdateCustomDataTimeline {
		i--
		if m.UpdateCustomDataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.TokenMetadataTimeline) > 0 {
		for iNdEx := len(m.TokenMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.UpdateTokenMetadataTimeline {
		i--
		if m.UpdateTokenMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		i--
		if m.UpdateCollectionMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.UpdateManagerTimeline {
		i--
		if m.UpdateManagerTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.UpdateCollectionPermissions {
		i--
		if m.UpdateCollectionPermissions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.ValidTokenIds) > 0 {
		for iNdEx := len(m.ValidTokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidTokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.UpdateValidTokenIds {
		i--
		if m.UpdateValidTokenIds {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DefaultBalances != nil {
		{
			size, err := m.DefaultBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUniversalUpdateCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUniversalUpdateCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUniversalUpdateCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Invariants != nil {
		{
			size, err := m.Invariants.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for iNdEx := len(m.CosmosCoinWrapperPathsToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CosmosCoinWrapperPathsToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for iNdEx := len(m.MintEscrowCoinsToTransfer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MintEscrowCoinsToTransfer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.UpdateIsArchivedTimeline {
		i--
		if m.UpdateIsArchivedTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.UpdateStandardsTimeline {
		i--
		if m.UpdateStandardsTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.UpdateCollectionApprovals {
		i--
		if m.UpdateCollectionApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.UpdateCustomDataTimeline {
		i--
		if m.UpdateCustomDataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.TokenMetadataTimeline) > 0 {
		for iNdEx := len(m.TokenMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.UpdateTokenMetadataTimeline {
		i--
		if m.UpdateTokenMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		i--
		if m.UpdateCollectionMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.UpdateManagerTimeline {
		i--
		if m.UpdateManagerTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UpdateCollectionPermissions {
		i--
		if m.UpdateCollectionPermissions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ValidTokenIds) > 0 {
		for iNdEx := len(m.ValidTokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidTokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.UpdateValidTokenIds {
		i--
		if m.UpdateValidTokenIds {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Invariants != nil {
		{
			size, err := m.Invariants.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for iNdEx := len(m.CosmosCoinWrapperPathsToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CosmosCoinWrapperPathsToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for iNdEx := len(m.MintEscrowCoinsToTransfer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MintEscrowCoinsToTransfer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.TokenMetadataTimeline) > 0 {
		for iNdEx := len(m.TokenMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ValidTokenIds) > 0 {
		for iNdEx := len(m.ValidTokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidTokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DefaultBalances != nil {
		{
			size, err := m.DefaultBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateAddressLists) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAddressLists) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAddressLists) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddressLists) > 0 {
		for iNdEx := len(m.AddressLists) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddressLists[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateAddressListsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAddressListsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAddressListsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgTransferTokens) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferTokens) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferTokens) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Transfers) > 0 {
		for iNdEx := len(m.Transfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransferTokensResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferTokensResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferTokensResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeleteCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeleteCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateUserApprovals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateUserApprovals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateUserApprovals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserPermissions != nil {
		{
			size, err := m.UserPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.UpdateUserPermissions {
		i--
		if m.UpdateUserPermissions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.AutoApproveAllIncomingTransfers {
		i--
		if m.AutoApproveAllIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.UpdateAutoApproveAllIncomingTransfers {
		i--
		if m.UpdateAutoApproveAllIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		i--
		if m.AutoApproveSelfInitiatedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.UpdateAutoApproveSelfInitiatedIncomingTransfers {
		i--
		if m.UpdateAutoApproveSelfInitiatedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		i--
		if m.AutoApproveSelfInitiatedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.UpdateAutoApproveSelfInitiatedOutgoingTransfers {
		i--
		if m.UpdateAutoApproveSelfInitiatedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.IncomingApprovals) > 0 {
		for iNdEx := len(m.IncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IncomingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.UpdateIncomingApprovals {
		i--
		if m.UpdateIncomingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.OutgoingApprovals) > 0 {
		for iNdEx := len(m.OutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutgoingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.UpdateOutgoingApprovals {
		i--
		if m.UpdateOutgoingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateUserApprovalsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateUserApprovalsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateUserApprovalsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetIncomingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetIncomingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetIncomingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Approval != nil {
		{
			size, err := m.Approval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetIncomingApprovalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetIncomingApprovalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetIncomingApprovalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeleteIncomingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteIncomingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteIncomingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeleteIncomingApprovalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteIncomingApprovalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteIncomingApprovalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetOutgoingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetOutgoingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetOutgoingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Approval != nil {
		{
			size, err := m.Approval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetOutgoingApprovalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetOutgoingApprovalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetOutgoingApprovalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeleteOutgoingApproval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteOutgoingApproval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteOutgoingApproval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalId) > 0 {
		i -= len(m.ApprovalId)
		copy(dAtA[i:], m.ApprovalId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ApprovalId)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeleteOutgoingApprovalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteOutgoingApprovalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteOutgoingApprovalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPurgeApprovals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPurgeApprovals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPurgeApprovals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalsToPurge) > 0 {
		for iNdEx := len(m.ApprovalsToPurge) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ApprovalsToPurge[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.PurgeCounterpartyApprovals {
		i--
		if m.PurgeCounterpartyApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ApproverAddress) > 0 {
		i -= len(m.ApproverAddress)
		copy(dAtA[i:], m.ApproverAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ApproverAddress)))
		i--
		dAtA[i] = 0x22
	}
	if m.PurgeExpired {
		i--
		if m.PurgeExpired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPurgeApprovalsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPurgeApprovalsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPurgeApprovalsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NumPurged.Size()
		i -= size
		if _, err := m.NumPurged.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateDynamicStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDynamicStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDynamicStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultValue {
		i--
		if m.DefaultValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDynamicStoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDynamicStoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDynamicStoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDynamicStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDynamicStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDynamicStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultValue {
		i--
		if m.DefaultValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDynamicStoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDynamicStoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDynamicStoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeleteDynamicStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteDynamicStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteDynamicStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeleteDynamicStoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteDynamicStoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteDynamicStoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetDynamicStoreValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetDynamicStoreValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetDynamicStoreValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value {
		i--
		if m.Value {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.StoreId.Size()
		i -= size
		if _, err := m.StoreId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetDynamicStoreValueResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetDynamicStoreValueResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetDynamicStoreValueResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetValidTokenIds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetValidTokenIds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetValidTokenIds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateValidTokenIds) > 0 {
		for iNdEx := len(m.CanUpdateValidTokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateValidTokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ValidTokenIds) > 0 {
		for iNdEx := len(m.ValidTokenIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidTokenIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetValidTokenIdsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetValidTokenIdsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetValidTokenIdsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetManager) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetManager) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetManager) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateManager) > 0 {
		for iNdEx := len(m.CanUpdateManager) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateManager[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetManagerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetManagerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetManagerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetCollectionMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCollectionMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCollectionMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for iNdEx := len(m.CanUpdateCollectionMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetCollectionMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCollectionMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCollectionMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetTokenMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetTokenMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetTokenMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateTokenMetadata) > 0 {
		for iNdEx := len(m.CanUpdateTokenMetadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateTokenMetadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TokenMetadataTimeline) > 0 {
		for iNdEx := len(m.TokenMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokenMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetTokenMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetTokenMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetTokenMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetCustomData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCustomData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCustomData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateCustomData) > 0 {
		for iNdEx := len(m.CanUpdateCustomData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCustomData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetCustomDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCustomDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCustomDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetStandards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetStandards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetStandards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateStandards) > 0 {
		for iNdEx := len(m.CanUpdateStandards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateStandards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetStandardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetStandardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetStandardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetCollectionApprovals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCollectionApprovals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCollectionApprovals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanUpdateCollectionApprovals) > 0 {
		for iNdEx := len(m.CanUpdateCollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanUpdateCollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetCollectionApprovalsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetCollectionApprovalsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetCollectionApprovalsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetIsArchived) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetIsArchived) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetIsArchived) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CanArchiveCollection) > 0 {
		for iNdEx := len(m.CanArchiveCollection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CanArchiveCollection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetIsArchivedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetIsArchivedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetIsArchivedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSetReservedProtocolAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetReservedProtocolAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetReservedProtocolAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsReservedProtocol {
		i--
		if m.IsReservedProtocol {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetReservedProtocolAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetReservedProtocolAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetReservedProtocolAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BadgeCustomMsgType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateAddressListsMsg != nil {
		l = m.CreateAddressListsMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UniversalUpdateCollectionMsg != nil {
		l = m.UniversalUpdateCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DeleteCollectionMsg != nil {
		l = m.DeleteCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TransferTokensMsg != nil {
		l = m.TransferTokensMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateUserApprovalsMsg != nil {
		l = m.UpdateUserApprovalsMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateCollectionMsg != nil {
		l = m.UpdateCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CreateCollectionMsg != nil {
		l = m.CreateCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CreateDynamicStoreMsg != nil {
		l = m.CreateDynamicStoreMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateDynamicStoreMsg != nil {
		l = m.UpdateDynamicStoreMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DeleteDynamicStoreMsg != nil {
		l = m.DeleteDynamicStoreMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SetDynamicStoreValueMsg != nil {
		l = m.SetDynamicStoreValueMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SetIncomingApprovalMsg != nil {
		l = m.SetIncomingApprovalMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DeleteIncomingApprovalMsg != nil {
		l = m.DeleteIncomingApprovalMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SetOutgoingApprovalMsg != nil {
		l = m.SetOutgoingApprovalMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.DeleteOutgoingApprovalMsg != nil {
		l = m.DeleteOutgoingApprovalMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.PurgeApprovalsMsg != nil {
		l = m.PurgeApprovalsMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetValidTokenIdsMsg != nil {
		l = m.SetValidTokenIdsMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetManagerMsg != nil {
		l = m.SetManagerMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetCollectionMetadataMsg != nil {
		l = m.SetCollectionMetadataMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetTokenMetadataMsg != nil {
		l = m.SetTokenMetadataMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetCustomDataMsg != nil {
		l = m.SetCustomDataMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetStandardsMsg != nil {
		l = m.SetStandardsMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetCollectionApprovalsMsg != nil {
		l = m.SetCollectionApprovalsMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetIsArchivedMsg != nil {
		l = m.SetIsArchivedMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	if m.SetReservedProtocolAddressMsg != nil {
		l = m.SetReservedProtocolAddressMsg.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CosmosCoinWrapperPathAddObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.DenomUnits) > 0 {
		for _, e := range m.DenomUnits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.AllowOverrideWithAnyValidToken {
		n += 2
	}
	if m.AllowCosmosWrapping {
		n += 2
	}
	return n
}

func (m *CosmosCoinBackedPathAddObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IbcDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = m.IbcAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *InvariantsAddObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoCustomOwnershipTimes {
		n += 2
	}
	l = m.MaxSupplyPerId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.CosmosCoinBackedPath != nil {
		l = m.CosmosCoinBackedPath.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NoForcefulPostMintTransfers {
		n += 2
	}
	if m.DisablePoolCreation {
		n += 2
	}
	return n
}

func (m *MsgUniversalUpdateCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.DefaultBalances != nil {
		l = m.DefaultBalances.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateValidTokenIds {
		n += 2
	}
	if len(m.ValidTokenIds) > 0 {
		for _, e := range m.ValidTokenIds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionPermissions {
		n += 2
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateManagerTimeline {
		n += 2
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		n += 2
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateTokenMetadataTimeline {
		n += 2
	}
	if len(m.TokenMetadataTimeline) > 0 {
		for _, e := range m.TokenMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCustomDataTimeline {
		n += 2
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionApprovals {
		n += 3
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateStandardsTimeline {
		n += 3
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateIsArchivedTimeline {
		n += 3
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for _, e := range m.MintEscrowCoinsToTransfer {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for _, e := range m.CosmosCoinWrapperPathsToAdd {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.Invariants != nil {
		l = m.Invariants.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUniversalUpdateCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.UpdateValidTokenIds {
		n += 2
	}
	if len(m.ValidTokenIds) > 0 {
		for _, e := range m.ValidTokenIds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionPermissions {
		n += 2
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateManagerTimeline {
		n += 2
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		n += 2
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateTokenMetadataTimeline {
		n += 2
	}
	if len(m.TokenMetadataTimeline) > 0 {
		for _, e := range m.TokenMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCustomDataTimeline {
		n += 2
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionApprovals {
		n += 2
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateStandardsTimeline {
		n += 3
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateIsArchivedTimeline {
		n += 3
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for _, e := range m.MintEscrowCoinsToTransfer {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for _, e := range m.CosmosCoinWrapperPathsToAdd {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.Invariants != nil {
		l = m.Invariants.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DefaultBalances != nil {
		l = m.DefaultBalances.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.ValidTokenIds) > 0 {
		for _, e := range m.ValidTokenIds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.TokenMetadataTimeline) > 0 {
		for _, e := range m.TokenMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.MintEscrowCoinsToTransfer) > 0 {
		for _, e := range m.MintEscrowCoinsToTransfer {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CosmosCoinWrapperPathsToAdd) > 0 {
		for _, e := range m.CosmosCoinWrapperPathsToAdd {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Invariants != nil {
		l = m.Invariants.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateAddressLists) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.AddressLists) > 0 {
		for _, e := range m.AddressLists {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateAddressListsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgTransferTokens) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.Transfers) > 0 {
		for _, e := range m.Transfers {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgTransferTokensResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeleteCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDeleteCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateUserApprovals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.UpdateOutgoingApprovals {
		n += 2
	}
	if len(m.OutgoingApprovals) > 0 {
		for _, e := range m.OutgoingApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateIncomingApprovals {
		n += 2
	}
	if len(m.IncomingApprovals) > 0 {
		for _, e := range m.IncomingApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateAutoApproveSelfInitiatedOutgoingTransfers {
		n += 2
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		n += 2
	}
	if m.UpdateAutoApproveSelfInitiatedIncomingTransfers {
		n += 2
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		n += 2
	}
	if m.UpdateAutoApproveAllIncomingTransfers {
		n += 2
	}
	if m.AutoApproveAllIncomingTransfers {
		n += 2
	}
	if m.UpdateUserPermissions {
		n += 2
	}
	if m.UserPermissions != nil {
		l = m.UserPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateUserApprovalsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetIncomingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.Approval != nil {
		l = m.Approval.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetIncomingApprovalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeleteIncomingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDeleteIncomingApprovalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetOutgoingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.Approval != nil {
		l = m.Approval.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetOutgoingApprovalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeleteOutgoingApproval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.ApprovalId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDeleteOutgoingApprovalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPurgeApprovals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.PurgeExpired {
		n += 2
	}
	l = len(m.ApproverAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PurgeCounterpartyApprovals {
		n += 2
	}
	if len(m.ApprovalsToPurge) > 0 {
		for _, e := range m.ApprovalsToPurge {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgPurgeApprovalsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.NumPurged.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateDynamicStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DefaultValue {
		n += 2
	}
	return n
}

func (m *MsgCreateDynamicStoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StoreId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateDynamicStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.StoreId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.DefaultValue {
		n += 2
	}
	return n
}

func (m *MsgUpdateDynamicStoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeleteDynamicStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.StoreId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDeleteDynamicStoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetDynamicStoreValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.StoreId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Value {
		n += 2
	}
	return n
}

func (m *MsgSetDynamicStoreValueResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetValidTokenIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.ValidTokenIds) > 0 {
		for _, e := range m.ValidTokenIds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateValidTokenIds) > 0 {
		for _, e := range m.CanUpdateValidTokenIds {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetValidTokenIdsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetManager) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateManager) > 0 {
		for _, e := range m.CanUpdateManager {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetManagerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetCollectionMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionMetadata) > 0 {
		for _, e := range m.CanUpdateCollectionMetadata {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetCollectionMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetTokenMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.TokenMetadataTimeline) > 0 {
		for _, e := range m.TokenMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateTokenMetadata) > 0 {
		for _, e := range m.CanUpdateTokenMetadata {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetTokenMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetCustomData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateCustomData) > 0 {
		for _, e := range m.CanUpdateCustomData {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetCustomDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetStandards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateStandards) > 0 {
		for _, e := range m.CanUpdateStandards {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetStandardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetCollectionApprovals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanUpdateCollectionApprovals) > 0 {
		for _, e := range m.CanUpdateCollectionApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetCollectionApprovalsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetIsArchived) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CanArchiveCollection) > 0 {
		for _, e := range m.CanArchiveCollection {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSetIsArchivedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSetReservedProtocolAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.IsReservedProtocol {
		n += 2
	}
	return n
}

func (m *MsgSetReservedProtocolAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BadgeCustomMsgType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadgeCustomMsgType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadgeCustomMsgType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAddressListsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateAddressListsMsg == nil {
				m.CreateAddressListsMsg = &MsgCreateAddressLists{}
			}
			if err := m.CreateAddressListsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniversalUpdateCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UniversalUpdateCollectionMsg == nil {
				m.UniversalUpdateCollectionMsg = &MsgUniversalUpdateCollection{}
			}
			if err := m.UniversalUpdateCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteCollectionMsg == nil {
				m.DeleteCollectionMsg = &MsgDeleteCollection{}
			}
			if err := m.DeleteCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferTokensMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferTokensMsg == nil {
				m.TransferTokensMsg = &MsgTransferTokens{}
			}
			if err := m.TransferTokensMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateUserApprovalsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateUserApprovalsMsg == nil {
				m.UpdateUserApprovalsMsg = &MsgUpdateUserApprovals{}
			}
			if err := m.UpdateUserApprovalsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateCollectionMsg == nil {
				m.UpdateCollectionMsg = &MsgUpdateCollection{}
			}
			if err := m.UpdateCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateCollectionMsg == nil {
				m.CreateCollectionMsg = &MsgCreateCollection{}
			}
			if err := m.CreateCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDynamicStoreMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateDynamicStoreMsg == nil {
				m.CreateDynamicStoreMsg = &MsgCreateDynamicStore{}
			}
			if err := m.CreateDynamicStoreMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDynamicStoreMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateDynamicStoreMsg == nil {
				m.UpdateDynamicStoreMsg = &MsgUpdateDynamicStore{}
			}
			if err := m.UpdateDynamicStoreMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteDynamicStoreMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteDynamicStoreMsg == nil {
				m.DeleteDynamicStoreMsg = &MsgDeleteDynamicStore{}
			}
			if err := m.DeleteDynamicStoreMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetDynamicStoreValueMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetDynamicStoreValueMsg == nil {
				m.SetDynamicStoreValueMsg = &MsgSetDynamicStoreValue{}
			}
			if err := m.SetDynamicStoreValueMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetIncomingApprovalMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetIncomingApprovalMsg == nil {
				m.SetIncomingApprovalMsg = &MsgSetIncomingApproval{}
			}
			if err := m.SetIncomingApprovalMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteIncomingApprovalMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteIncomingApprovalMsg == nil {
				m.DeleteIncomingApprovalMsg = &MsgDeleteIncomingApproval{}
			}
			if err := m.DeleteIncomingApprovalMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetOutgoingApprovalMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetOutgoingApprovalMsg == nil {
				m.SetOutgoingApprovalMsg = &MsgSetOutgoingApproval{}
			}
			if err := m.SetOutgoingApprovalMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteOutgoingApprovalMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteOutgoingApprovalMsg == nil {
				m.DeleteOutgoingApprovalMsg = &MsgDeleteOutgoingApproval{}
			}
			if err := m.DeleteOutgoingApprovalMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeApprovalsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PurgeApprovalsMsg == nil {
				m.PurgeApprovalsMsg = &MsgPurgeApprovals{}
			}
			if err := m.PurgeApprovalsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetValidTokenIdsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetValidTokenIdsMsg == nil {
				m.SetValidTokenIdsMsg = &MsgSetValidTokenIds{}
			}
			if err := m.SetValidTokenIdsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetManagerMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetManagerMsg == nil {
				m.SetManagerMsg = &MsgSetManager{}
			}
			if err := m.SetManagerMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetCollectionMetadataMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetCollectionMetadataMsg == nil {
				m.SetCollectionMetadataMsg = &MsgSetCollectionMetadata{}
			}
			if err := m.SetCollectionMetadataMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetTokenMetadataMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetTokenMetadataMsg == nil {
				m.SetTokenMetadataMsg = &MsgSetTokenMetadata{}
			}
			if err := m.SetTokenMetadataMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetCustomDataMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetCustomDataMsg == nil {
				m.SetCustomDataMsg = &MsgSetCustomData{}
			}
			if err := m.SetCustomDataMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetStandardsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetStandardsMsg == nil {
				m.SetStandardsMsg = &MsgSetStandards{}
			}
			if err := m.SetStandardsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetCollectionApprovalsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetCollectionApprovalsMsg == nil {
				m.SetCollectionApprovalsMsg = &MsgSetCollectionApprovals{}
			}
			if err := m.SetCollectionApprovalsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetIsArchivedMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetIsArchivedMsg == nil {
				m.SetIsArchivedMsg = &MsgSetIsArchived{}
			}
			if err := m.SetIsArchivedMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetReservedProtocolAddressMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetReservedProtocolAddressMsg == nil {
				m.SetReservedProtocolAddressMsg = &MsgSetReservedProtocolAddress{}
			}
			if err := m.SetReservedProtocolAddressMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosCoinWrapperPathAddObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosCoinWrapperPathAddObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosCoinWrapperPathAddObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenomUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenomUnits = append(m.DenomUnits, &DenomUnit{})
			if err := m.DenomUnits[len(m.DenomUnits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOverrideWithAnyValidToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowOverrideWithAnyValidToken = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCosmosWrapping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowCosmosWrapping = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CosmosCoinBackedPathAddObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CosmosCoinBackedPathAddObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CosmosCoinBackedPathAddObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IbcDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IbcAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IbcAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvariantsAddObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvariantsAddObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvariantsAddObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCustomOwnershipTimes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoCustomOwnershipTimes = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSupplyPerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxSupplyPerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinBackedPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CosmosCoinBackedPath == nil {
				m.CosmosCoinBackedPath = &CosmosCoinBackedPathAddObject{}
			}
			if err := m.CosmosCoinBackedPath.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoForcefulPostMintTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoForcefulPostMintTransfers = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePoolCreation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePoolCreation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUniversalUpdateCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBalances == nil {
				m.DefaultBalances = &UserBalanceStore{}
			}
			if err := m.DefaultBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateValidTokenIds", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateValidTokenIds = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidTokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidTokenIds = append(m.ValidTokenIds, &UintRange{})
			if err := m.ValidTokenIds[len(m.ValidTokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionPermissions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionPermissions = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateManagerTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateManagerTimeline = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionMetadataTimeline = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTokenMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateTokenMetadataTimeline = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenMetadataTimeline = append(m.TokenMetadataTimeline, &TokenMetadataTimeline{})
			if err := m.TokenMetadataTimeline[len(m.TokenMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCustomDataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCustomDataTimeline = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionApprovals = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateStandardsTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateStandardsTimeline = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIsArchivedTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateIsArchivedTimeline = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintEscrowCoinsToTransfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintEscrowCoinsToTransfer = append(m.MintEscrowCoinsToTransfer, &types.Coin{})
			if err := m.MintEscrowCoinsToTransfer[len(m.MintEscrowCoinsToTransfer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinWrapperPathsToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosCoinWrapperPathsToAdd = append(m.CosmosCoinWrapperPathsToAdd, &CosmosCoinWrapperPathAddObject{})
			if err := m.CosmosCoinWrapperPathsToAdd[len(m.CosmosCoinWrapperPathsToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invariants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invariants == nil {
				m.Invariants = &InvariantsAddObject{}
			}
			if err := m.Invariants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUniversalUpdateCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateValidTokenIds", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateValidTokenIds = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidTokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidTokenIds = append(m.ValidTokenIds, &UintRange{})
			if err := m.ValidTokenIds[len(m.ValidTokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionPermissions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionPermissions = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateManagerTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateManagerTimeline = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionMetadataTimeline = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTokenMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateTokenMetadataTimeline = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenMetadataTimeline = append(m.TokenMetadataTimeline, &TokenMetadataTimeline{})
			if err := m.TokenMetadataTimeline[len(m.TokenMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCustomDataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCustomDataTimeline = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionApprovals = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateStandardsTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateStandardsTimeline = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIsArchivedTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateIsArchivedTimeline = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintEscrowCoinsToTransfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintEscrowCoinsToTransfer = append(m.MintEscrowCoinsToTransfer, &types.Coin{})
			if err := m.MintEscrowCoinsToTransfer[len(m.MintEscrowCoinsToTransfer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinWrapperPathsToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosCoinWrapperPathsToAdd = append(m.CosmosCoinWrapperPathsToAdd, &CosmosCoinWrapperPathAddObject{})
			if err := m.CosmosCoinWrapperPathsToAdd[len(m.CosmosCoinWrapperPathsToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invariants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invariants == nil {
				m.Invariants = &InvariantsAddObject{}
			}
			if err := m.Invariants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBalances == nil {
				m.DefaultBalances = &UserBalanceStore{}
			}
			if err := m.DefaultBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidTokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidTokenIds = append(m.ValidTokenIds, &UintRange{})
			if err := m.ValidTokenIds[len(m.ValidTokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenMetadataTimeline = append(m.TokenMetadataTimeline, &TokenMetadataTimeline{})
			if err := m.TokenMetadataTimeline[len(m.TokenMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintEscrowCoinsToTransfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintEscrowCoinsToTransfer = append(m.MintEscrowCoinsToTransfer, &types.Coin{})
			if err := m.MintEscrowCoinsToTransfer[len(m.MintEscrowCoinsToTransfer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CosmosCoinWrapperPathsToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CosmosCoinWrapperPathsToAdd = append(m.CosmosCoinWrapperPathsToAdd, &CosmosCoinWrapperPathAddObject{})
			if err := m.CosmosCoinWrapperPathsToAdd[len(m.CosmosCoinWrapperPathsToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invariants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invariants == nil {
				m.Invariants = &InvariantsAddObject{}
			}
			if err := m.Invariants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAddressLists) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAddressLists: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAddressLists: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressLists", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressLists = append(m.AddressLists, &AddressList{})
			if err := m.AddressLists[len(m.AddressLists)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAddressListsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAddressListsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAddressListsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferTokens) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferTokens: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferTokens: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transfers = append(m.Transfers, &Transfer{})
			if err := m.Transfers[len(m.Transfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferTokensResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferTokensResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferTokensResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateUserApprovals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateUserApprovals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateUserApprovals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateOutgoingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateOutgoingApprovals = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutgoingApprovals = append(m.OutgoingApprovals, &UserOutgoingApproval{})
			if err := m.OutgoingApprovals[len(m.OutgoingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIncomingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateIncomingApprovals = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncomingApprovals = append(m.IncomingApprovals, &UserIncomingApproval{})
			if err := m.IncomingApprovals[len(m.IncomingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateAutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateAutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAutoApproveAllIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateAutoApproveAllIncomingTransfers = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveAllIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveAllIncomingTransfers = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateUserPermissions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateUserPermissions = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPermissions == nil {
				m.UserPermissions = &UserPermissions{}
			}
			if err := m.UserPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateUserApprovalsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateUserApprovalsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateUserApprovalsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetIncomingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetIncomingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetIncomingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Approval == nil {
				m.Approval = &UserIncomingApproval{}
			}
			if err := m.Approval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetIncomingApprovalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetIncomingApprovalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetIncomingApprovalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteIncomingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteIncomingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteIncomingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteIncomingApprovalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteIncomingApprovalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteIncomingApprovalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetOutgoingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetOutgoingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetOutgoingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Approval == nil {
				m.Approval = &UserOutgoingApproval{}
			}
			if err := m.Approval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetOutgoingApprovalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetOutgoingApprovalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetOutgoingApprovalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteOutgoingApproval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteOutgoingApproval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteOutgoingApproval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteOutgoingApprovalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteOutgoingApprovalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteOutgoingApprovalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPurgeApprovals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPurgeApprovals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPurgeApprovals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeExpired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PurgeExpired = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproverAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApproverAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurgeCounterpartyApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PurgeCounterpartyApprovals = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalsToPurge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalsToPurge = append(m.ApprovalsToPurge, &ApprovalIdentifierDetails{})
			if err := m.ApprovalsToPurge[len(m.ApprovalsToPurge)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPurgeApprovalsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPurgeApprovalsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPurgeApprovalsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPurged", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NumPurged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDynamicStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDynamicStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDynamicStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultValue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDynamicStoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDynamicStoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDynamicStoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDynamicStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDynamicStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDynamicStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultValue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDynamicStoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDynamicStoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDynamicStoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteDynamicStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteDynamicStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteDynamicStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteDynamicStoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteDynamicStoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteDynamicStoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetDynamicStoreValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetDynamicStoreValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetDynamicStoreValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetDynamicStoreValueResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetDynamicStoreValueResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetDynamicStoreValueResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetValidTokenIds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetValidTokenIds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetValidTokenIds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidTokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidTokenIds = append(m.ValidTokenIds, &UintRange{})
			if err := m.ValidTokenIds[len(m.ValidTokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateValidTokenIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateValidTokenIds = append(m.CanUpdateValidTokenIds, &TokenIdsActionPermission{})
			if err := m.CanUpdateValidTokenIds[len(m.CanUpdateValidTokenIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetValidTokenIdsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetValidTokenIdsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetValidTokenIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetManager) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetManager: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetManager: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateManager", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateManager = append(m.CanUpdateManager, &TimedUpdatePermission{})
			if err := m.CanUpdateManager[len(m.CanUpdateManager)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetManagerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetManagerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetManagerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCollectionMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCollectionMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCollectionMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionMetadata = append(m.CanUpdateCollectionMetadata, &TimedUpdatePermission{})
			if err := m.CanUpdateCollectionMetadata[len(m.CanUpdateCollectionMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCollectionMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCollectionMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCollectionMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetTokenMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetTokenMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetTokenMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenMetadataTimeline = append(m.TokenMetadataTimeline, &TokenMetadataTimeline{})
			if err := m.TokenMetadataTimeline[len(m.TokenMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateTokenMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateTokenMetadata = append(m.CanUpdateTokenMetadata, &TimedUpdateWithTokenIdsPermission{})
			if err := m.CanUpdateTokenMetadata[len(m.CanUpdateTokenMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetTokenMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetTokenMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetTokenMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCustomData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCustomData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCustomData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCustomData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCustomData = append(m.CanUpdateCustomData, &TimedUpdatePermission{})
			if err := m.CanUpdateCustomData[len(m.CanUpdateCustomData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCustomDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCustomDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCustomDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetStandards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetStandards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetStandards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateStandards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateStandards = append(m.CanUpdateStandards, &TimedUpdatePermission{})
			if err := m.CanUpdateStandards[len(m.CanUpdateStandards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetStandardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetStandardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetStandardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCollectionApprovals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCollectionApprovals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCollectionApprovals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpdateCollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanUpdateCollectionApprovals = append(m.CanUpdateCollectionApprovals, &CollectionApprovalPermission{})
			if err := m.CanUpdateCollectionApprovals[len(m.CanUpdateCollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetCollectionApprovalsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetCollectionApprovalsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetCollectionApprovalsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetIsArchived) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetIsArchived: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetIsArchived: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanArchiveCollection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanArchiveCollection = append(m.CanArchiveCollection, &TimedUpdatePermission{})
			if err := m.CanArchiveCollection[len(m.CanArchiveCollection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetIsArchivedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetIsArchivedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetIsArchivedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetReservedProtocolAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetReservedProtocolAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetReservedProtocolAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReservedProtocol", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReservedProtocol = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetReservedProtocolAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetReservedProtocolAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetReservedProtocolAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
