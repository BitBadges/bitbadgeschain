// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the module parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{0}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{1}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// Used for WASM bindings and JSON parsing
type BadgeCustomMsgType struct {
	CreateAddressListsMsg        *MsgCreateAddressLists        `protobuf:"bytes,1,opt,name=createAddressListsMsg,proto3" json:"createAddressListsMsg,omitempty"`
	UniversalUpdateCollectionMsg *MsgUniversalUpdateCollection `protobuf:"bytes,2,opt,name=universalUpdateCollectionMsg,proto3" json:"universalUpdateCollectionMsg,omitempty"`
	DeleteCollectionMsg          *MsgDeleteCollection          `protobuf:"bytes,3,opt,name=deleteCollectionMsg,proto3" json:"deleteCollectionMsg,omitempty"`
	TransferBadgesMsg            *MsgTransferBadges            `protobuf:"bytes,4,opt,name=transferBadgesMsg,proto3" json:"transferBadgesMsg,omitempty"`
	UpdateUserApprovalsMsg       *MsgUpdateUserApprovals       `protobuf:"bytes,5,opt,name=updateUserApprovalsMsg,proto3" json:"updateUserApprovalsMsg,omitempty"`
	UpdateCollectionMsg          *MsgUpdateCollection          `protobuf:"bytes,6,opt,name=updateCollectionMsg,proto3" json:"updateCollectionMsg,omitempty"`
	CreateCollectionMsg          *MsgCreateCollection          `protobuf:"bytes,7,opt,name=createCollectionMsg,proto3" json:"createCollectionMsg,omitempty"`
}

func (m *BadgeCustomMsgType) Reset()         { *m = BadgeCustomMsgType{} }
func (m *BadgeCustomMsgType) String() string { return proto.CompactTextString(m) }
func (*BadgeCustomMsgType) ProtoMessage()    {}
func (*BadgeCustomMsgType) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{2}
}
func (m *BadgeCustomMsgType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadgeCustomMsgType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BadgeCustomMsgType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BadgeCustomMsgType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadgeCustomMsgType.Merge(m, src)
}
func (m *BadgeCustomMsgType) XXX_Size() int {
	return m.Size()
}
func (m *BadgeCustomMsgType) XXX_DiscardUnknown() {
	xxx_messageInfo_BadgeCustomMsgType.DiscardUnknown(m)
}

var xxx_messageInfo_BadgeCustomMsgType proto.InternalMessageInfo

func (m *BadgeCustomMsgType) GetCreateAddressListsMsg() *MsgCreateAddressLists {
	if m != nil {
		return m.CreateAddressListsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetUniversalUpdateCollectionMsg() *MsgUniversalUpdateCollection {
	if m != nil {
		return m.UniversalUpdateCollectionMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetDeleteCollectionMsg() *MsgDeleteCollection {
	if m != nil {
		return m.DeleteCollectionMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetTransferBadgesMsg() *MsgTransferBadges {
	if m != nil {
		return m.TransferBadgesMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetUpdateUserApprovalsMsg() *MsgUpdateUserApprovals {
	if m != nil {
		return m.UpdateUserApprovalsMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetUpdateCollectionMsg() *MsgUpdateCollection {
	if m != nil {
		return m.UpdateCollectionMsg
	}
	return nil
}

func (m *BadgeCustomMsgType) GetCreateCollectionMsg() *MsgCreateCollection {
	if m != nil {
		return m.CreateCollectionMsg
	}
	return nil
}

// MsgUniversalUpdateCollection is used to define MsgServer types for all requests and responses for Msgs of the badges module.
// It is a universal interface that can be used for both creating and updating collections.
// We have it defined for legacy purposes, but it is recommended to use MsgCreateCollection and MsgUpdateCollection instead.
type MsgUniversalUpdateCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection (0 for new collection).
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// Type of balances "Standard" or "Off-Chain - Indexed" or "Off-Chain - Non-Indexed" or "Non-Public".
	BalancesType string `protobuf:"bytes,3,opt,name=balancesType,proto3" json:"balancesType,omitempty"`
	//The default balances for the user
	DefaultBalances *UserBalanceStore `protobuf:"bytes,4,opt,name=defaultBalances,proto3" json:"defaultBalances,omitempty"`
	// New badge IDs to add to this collection
	BadgeIdsToAdd []*UintRange `protobuf:"bytes,6,rep,name=badgeIdsToAdd,proto3" json:"badgeIdsToAdd,omitempty"`
	// Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionPermissions bool `protobuf:"varint,7,opt,name=updateCollectionPermissions,proto3" json:"updateCollectionPermissions,omitempty"`
	// New collection permissions to set.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,8,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateManagerTimeline bool `protobuf:"varint,9,opt,name=updateManagerTimeline,proto3" json:"updateManagerTimeline,omitempty"`
	// New manager timeline to set.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,10,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionMetadataTimeline bool `protobuf:"varint,11,opt,name=updateCollectionMetadataTimeline,proto3" json:"updateCollectionMetadataTimeline,omitempty"`
	// New collection metadata timeline to set.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,12,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateBadgeMetadataTimeline bool `protobuf:"varint,13,opt,name=updateBadgeMetadataTimeline,proto3" json:"updateBadgeMetadataTimeline,omitempty"`
	// New badge metadata timeline to set.
	BadgeMetadataTimeline []*BadgeMetadataTimeline `protobuf:"bytes,14,rep,name=badgeMetadataTimeline,proto3" json:"badgeMetadataTimeline,omitempty"`
	// Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateOffChainBalancesMetadataTimeline bool `protobuf:"varint,15,opt,name=updateOffChainBalancesMetadataTimeline,proto3" json:"updateOffChainBalancesMetadataTimeline,omitempty"`
	// New off-chain balances metadata timeline to set.
	OffChainBalancesMetadataTimeline []*OffChainBalancesMetadataTimeline `protobuf:"bytes,16,rep,name=offChainBalancesMetadataTimeline,proto3" json:"offChainBalancesMetadataTimeline,omitempty"`
	// Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCustomDataTimeline bool `protobuf:"varint,17,opt,name=updateCustomDataTimeline,proto3" json:"updateCustomDataTimeline,omitempty"`
	// New custom data timeline to set.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,18,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionApprovals bool `protobuf:"varint,21,opt,name=updateCollectionApprovals,proto3" json:"updateCollectionApprovals,omitempty"`
	// New collection approvals to set.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,22,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateStandardsTimeline bool `protobuf:"varint,23,opt,name=updateStandardsTimeline,proto3" json:"updateStandardsTimeline,omitempty"`
	// New standards timeline to set.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,24,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateIsArchivedTimeline bool `protobuf:"varint,25,opt,name=updateIsArchivedTimeline,proto3" json:"updateIsArchivedTimeline,omitempty"`
	// New isArchived timeline to set.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,26,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
}

func (m *MsgUniversalUpdateCollection) Reset()         { *m = MsgUniversalUpdateCollection{} }
func (m *MsgUniversalUpdateCollection) String() string { return proto.CompactTextString(m) }
func (*MsgUniversalUpdateCollection) ProtoMessage()    {}
func (*MsgUniversalUpdateCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{3}
}
func (m *MsgUniversalUpdateCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUniversalUpdateCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUniversalUpdateCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUniversalUpdateCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUniversalUpdateCollection.Merge(m, src)
}
func (m *MsgUniversalUpdateCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgUniversalUpdateCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUniversalUpdateCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUniversalUpdateCollection proto.InternalMessageInfo

func (m *MsgUniversalUpdateCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUniversalUpdateCollection) GetBalancesType() string {
	if m != nil {
		return m.BalancesType
	}
	return ""
}

func (m *MsgUniversalUpdateCollection) GetDefaultBalances() *UserBalanceStore {
	if m != nil {
		return m.DefaultBalances
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetBadgeIdsToAdd() []*UintRange {
	if m != nil {
		return m.BadgeIdsToAdd
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCollectionPermissions() bool {
	if m != nil {
		return m.UpdateCollectionPermissions
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateManagerTimeline() bool {
	if m != nil {
		return m.UpdateManagerTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCollectionMetadataTimeline() bool {
	if m != nil {
		return m.UpdateCollectionMetadataTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateBadgeMetadataTimeline() bool {
	if m != nil {
		return m.UpdateBadgeMetadataTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetBadgeMetadataTimeline() []*BadgeMetadataTimeline {
	if m != nil {
		return m.BadgeMetadataTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateOffChainBalancesMetadataTimeline() bool {
	if m != nil {
		return m.UpdateOffChainBalancesMetadataTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetOffChainBalancesMetadataTimeline() []*OffChainBalancesMetadataTimeline {
	if m != nil {
		return m.OffChainBalancesMetadataTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCustomDataTimeline() bool {
	if m != nil {
		return m.UpdateCustomDataTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateCollectionApprovals() bool {
	if m != nil {
		return m.UpdateCollectionApprovals
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateStandardsTimeline() bool {
	if m != nil {
		return m.UpdateStandardsTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *MsgUniversalUpdateCollection) GetUpdateIsArchivedTimeline() bool {
	if m != nil {
		return m.UpdateIsArchivedTimeline
	}
	return false
}

func (m *MsgUniversalUpdateCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

// MsgUniversalUpdateCollectionResponse is the response to MsgUniversalUpdateCollection.
type MsgUniversalUpdateCollectionResponse struct {
	// ID of the badge collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgUniversalUpdateCollectionResponse) Reset()         { *m = MsgUniversalUpdateCollectionResponse{} }
func (m *MsgUniversalUpdateCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUniversalUpdateCollectionResponse) ProtoMessage()    {}
func (*MsgUniversalUpdateCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{4}
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUniversalUpdateCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUniversalUpdateCollectionResponse.Merge(m, src)
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUniversalUpdateCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUniversalUpdateCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUniversalUpdateCollectionResponse proto.InternalMessageInfo

// MsgUpdateCollection is used to update a collection.
type MsgUpdateCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection (0 for new collection).
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// New badge IDs to add to this collection
	BadgeIdsToAdd []*UintRange `protobuf:"bytes,6,rep,name=badgeIdsToAdd,proto3" json:"badgeIdsToAdd,omitempty"`
	// Indicates if collection permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionPermissions bool `protobuf:"varint,7,opt,name=updateCollectionPermissions,proto3" json:"updateCollectionPermissions,omitempty"`
	// New collection permissions to set.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,8,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Indicates if the manager timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateManagerTimeline bool `protobuf:"varint,9,opt,name=updateManagerTimeline,proto3" json:"updateManagerTimeline,omitempty"`
	// New manager timeline to set.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,10,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Indicates if the collection metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionMetadataTimeline bool `protobuf:"varint,11,opt,name=updateCollectionMetadataTimeline,proto3" json:"updateCollectionMetadataTimeline,omitempty"`
	// New collection metadata timeline to set.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,12,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// Indicates if the badge metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateBadgeMetadataTimeline bool `protobuf:"varint,13,opt,name=updateBadgeMetadataTimeline,proto3" json:"updateBadgeMetadataTimeline,omitempty"`
	// New badge metadata timeline to set.
	BadgeMetadataTimeline []*BadgeMetadataTimeline `protobuf:"bytes,14,rep,name=badgeMetadataTimeline,proto3" json:"badgeMetadataTimeline,omitempty"`
	// Indicates if the off-chain balances metadata timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateOffChainBalancesMetadataTimeline bool `protobuf:"varint,15,opt,name=updateOffChainBalancesMetadataTimeline,proto3" json:"updateOffChainBalancesMetadataTimeline,omitempty"`
	// New off-chain balances metadata timeline to set.
	OffChainBalancesMetadataTimeline []*OffChainBalancesMetadataTimeline `protobuf:"bytes,16,rep,name=offChainBalancesMetadataTimeline,proto3" json:"offChainBalancesMetadataTimeline,omitempty"`
	// Indicates if the custom data timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCustomDataTimeline bool `protobuf:"varint,17,opt,name=updateCustomDataTimeline,proto3" json:"updateCustomDataTimeline,omitempty"`
	// New custom data timeline to set.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,18,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// Indicates if collection approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateCollectionApprovals bool `protobuf:"varint,21,opt,name=updateCollectionApprovals,proto3" json:"updateCollectionApprovals,omitempty"`
	// New collection approvals to set.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,22,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Indicates if the standards timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateStandardsTimeline bool `protobuf:"varint,23,opt,name=updateStandardsTimeline,proto3" json:"updateStandardsTimeline,omitempty"`
	// New standards timeline to set.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,24,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// Indicates if the isArchived timeline should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateIsArchivedTimeline bool `protobuf:"varint,27,opt,name=updateIsArchivedTimeline,proto3" json:"updateIsArchivedTimeline,omitempty"`
	// New isArchived timeline to set.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,28,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
}

func (m *MsgUpdateCollection) Reset()         { *m = MsgUpdateCollection{} }
func (m *MsgUpdateCollection) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCollection) ProtoMessage()    {}
func (*MsgUpdateCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{5}
}
func (m *MsgUpdateCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCollection.Merge(m, src)
}
func (m *MsgUpdateCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCollection proto.InternalMessageInfo

func (m *MsgUpdateCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUpdateCollection) GetBadgeIdsToAdd() []*UintRange {
	if m != nil {
		return m.BadgeIdsToAdd
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCollectionPermissions() bool {
	if m != nil {
		return m.UpdateCollectionPermissions
	}
	return false
}

func (m *MsgUpdateCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateManagerTimeline() bool {
	if m != nil {
		return m.UpdateManagerTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCollectionMetadataTimeline() bool {
	if m != nil {
		return m.UpdateCollectionMetadataTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateBadgeMetadataTimeline() bool {
	if m != nil {
		return m.UpdateBadgeMetadataTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetBadgeMetadataTimeline() []*BadgeMetadataTimeline {
	if m != nil {
		return m.BadgeMetadataTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateOffChainBalancesMetadataTimeline() bool {
	if m != nil {
		return m.UpdateOffChainBalancesMetadataTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetOffChainBalancesMetadataTimeline() []*OffChainBalancesMetadataTimeline {
	if m != nil {
		return m.OffChainBalancesMetadataTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCustomDataTimeline() bool {
	if m != nil {
		return m.UpdateCustomDataTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateCollectionApprovals() bool {
	if m != nil {
		return m.UpdateCollectionApprovals
	}
	return false
}

func (m *MsgUpdateCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateStandardsTimeline() bool {
	if m != nil {
		return m.UpdateStandardsTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *MsgUpdateCollection) GetUpdateIsArchivedTimeline() bool {
	if m != nil {
		return m.UpdateIsArchivedTimeline
	}
	return false
}

func (m *MsgUpdateCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

// MsgUpdateCollectionResponse is the response to MsgUpdateCollection.
type MsgUpdateCollectionResponse struct {
	// ID of the badge collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgUpdateCollectionResponse) Reset()         { *m = MsgUpdateCollectionResponse{} }
func (m *MsgUpdateCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCollectionResponse) ProtoMessage()    {}
func (*MsgUpdateCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{6}
}
func (m *MsgUpdateCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCollectionResponse.Merge(m, src)
}
func (m *MsgUpdateCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCollectionResponse proto.InternalMessageInfo

// MsgCreateCollection is used to create a new collection.
type MsgCreateCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// Type of balances "Standard" or "Off-Chain - Indexed" or "Off-Chain - Non-Indexed" or "Non-Public".
	BalancesType string `protobuf:"bytes,2,opt,name=balancesType,proto3" json:"balancesType,omitempty"`
	//The default balances for the user
	DefaultBalances *UserBalanceStore `protobuf:"bytes,4,opt,name=defaultBalances,proto3" json:"defaultBalances,omitempty"`
	// New badge IDs to add to this collection
	BadgeIdsToAdd []*UintRange `protobuf:"bytes,5,rep,name=badgeIdsToAdd,proto3" json:"badgeIdsToAdd,omitempty"`
	// Collection permissions.
	CollectionPermissions *CollectionPermissions `protobuf:"bytes,6,opt,name=collectionPermissions,proto3" json:"collectionPermissions,omitempty"`
	// Manager timeline entries.
	ManagerTimeline []*ManagerTimeline `protobuf:"bytes,7,rep,name=managerTimeline,proto3" json:"managerTimeline,omitempty"`
	// Collection metadata timeline entries.
	CollectionMetadataTimeline []*CollectionMetadataTimeline `protobuf:"bytes,8,rep,name=collectionMetadataTimeline,proto3" json:"collectionMetadataTimeline,omitempty"`
	// Badge metadata timeline entries.
	BadgeMetadataTimeline []*BadgeMetadataTimeline `protobuf:"bytes,9,rep,name=badgeMetadataTimeline,proto3" json:"badgeMetadataTimeline,omitempty"`
	// Off-chain balances metadata timeline entries.
	OffChainBalancesMetadataTimeline []*OffChainBalancesMetadataTimeline `protobuf:"bytes,10,rep,name=offChainBalancesMetadataTimeline,proto3" json:"offChainBalancesMetadataTimeline,omitempty"`
	// Custom data timeline entries.
	CustomDataTimeline []*CustomDataTimeline `protobuf:"bytes,11,rep,name=customDataTimeline,proto3" json:"customDataTimeline,omitempty"`
	// Collection approvals.
	CollectionApprovals []*CollectionApproval `protobuf:"bytes,12,rep,name=collectionApprovals,proto3" json:"collectionApprovals,omitempty"`
	// Standards timeline entries.
	StandardsTimeline []*StandardsTimeline `protobuf:"bytes,13,rep,name=standardsTimeline,proto3" json:"standardsTimeline,omitempty"`
	// isArchived timeline entries.
	IsArchivedTimeline []*IsArchivedTimeline `protobuf:"bytes,14,rep,name=isArchivedTimeline,proto3" json:"isArchivedTimeline,omitempty"`
}

func (m *MsgCreateCollection) Reset()         { *m = MsgCreateCollection{} }
func (m *MsgCreateCollection) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCollection) ProtoMessage()    {}
func (*MsgCreateCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{7}
}
func (m *MsgCreateCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCollection.Merge(m, src)
}
func (m *MsgCreateCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCollection proto.InternalMessageInfo

func (m *MsgCreateCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateCollection) GetBalancesType() string {
	if m != nil {
		return m.BalancesType
	}
	return ""
}

func (m *MsgCreateCollection) GetDefaultBalances() *UserBalanceStore {
	if m != nil {
		return m.DefaultBalances
	}
	return nil
}

func (m *MsgCreateCollection) GetBadgeIdsToAdd() []*UintRange {
	if m != nil {
		return m.BadgeIdsToAdd
	}
	return nil
}

func (m *MsgCreateCollection) GetCollectionPermissions() *CollectionPermissions {
	if m != nil {
		return m.CollectionPermissions
	}
	return nil
}

func (m *MsgCreateCollection) GetManagerTimeline() []*ManagerTimeline {
	if m != nil {
		return m.ManagerTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetCollectionMetadataTimeline() []*CollectionMetadataTimeline {
	if m != nil {
		return m.CollectionMetadataTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetBadgeMetadataTimeline() []*BadgeMetadataTimeline {
	if m != nil {
		return m.BadgeMetadataTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetOffChainBalancesMetadataTimeline() []*OffChainBalancesMetadataTimeline {
	if m != nil {
		return m.OffChainBalancesMetadataTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetCustomDataTimeline() []*CustomDataTimeline {
	if m != nil {
		return m.CustomDataTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetCollectionApprovals() []*CollectionApproval {
	if m != nil {
		return m.CollectionApprovals
	}
	return nil
}

func (m *MsgCreateCollection) GetStandardsTimeline() []*StandardsTimeline {
	if m != nil {
		return m.StandardsTimeline
	}
	return nil
}

func (m *MsgCreateCollection) GetIsArchivedTimeline() []*IsArchivedTimeline {
	if m != nil {
		return m.IsArchivedTimeline
	}
	return nil
}

// MsgCreateCollectionResponse is the response to MsgCreateCollection.
type MsgCreateCollectionResponse struct {
	// ID of the badge collection.
	CollectionId Uint `protobuf:"bytes,1,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgCreateCollectionResponse) Reset()         { *m = MsgCreateCollectionResponse{} }
func (m *MsgCreateCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateCollectionResponse) ProtoMessage()    {}
func (*MsgCreateCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{8}
}
func (m *MsgCreateCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateCollectionResponse.Merge(m, src)
}
func (m *MsgCreateCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateCollectionResponse proto.InternalMessageInfo

// MsgCreateAddressLists is used to create address lists.
type MsgCreateAddressLists struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// Address lists to create.
	AddressLists []*AddressList `protobuf:"bytes,2,rep,name=addressLists,proto3" json:"addressLists,omitempty"`
}

func (m *MsgCreateAddressLists) Reset()         { *m = MsgCreateAddressLists{} }
func (m *MsgCreateAddressLists) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAddressLists) ProtoMessage()    {}
func (*MsgCreateAddressLists) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{9}
}
func (m *MsgCreateAddressLists) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAddressLists) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAddressLists.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAddressLists) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAddressLists.Merge(m, src)
}
func (m *MsgCreateAddressLists) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAddressLists) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAddressLists.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAddressLists proto.InternalMessageInfo

func (m *MsgCreateAddressLists) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateAddressLists) GetAddressLists() []*AddressList {
	if m != nil {
		return m.AddressLists
	}
	return nil
}

// MsgCreateAddressListsResponse is the response to MsgCreateAddressLists.
type MsgCreateAddressListsResponse struct {
}

func (m *MsgCreateAddressListsResponse) Reset()         { *m = MsgCreateAddressListsResponse{} }
func (m *MsgCreateAddressListsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateAddressListsResponse) ProtoMessage()    {}
func (*MsgCreateAddressListsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{10}
}
func (m *MsgCreateAddressListsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateAddressListsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateAddressListsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateAddressListsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateAddressListsResponse.Merge(m, src)
}
func (m *MsgCreateAddressListsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateAddressListsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateAddressListsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateAddressListsResponse proto.InternalMessageInfo

// MsgTransferBadges is used to transfer badges.
type MsgTransferBadges struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// Transfers to execute.
	Transfers []*Transfer `protobuf:"bytes,3,rep,name=transfers,proto3" json:"transfers,omitempty"`
}

func (m *MsgTransferBadges) Reset()         { *m = MsgTransferBadges{} }
func (m *MsgTransferBadges) String() string { return proto.CompactTextString(m) }
func (*MsgTransferBadges) ProtoMessage()    {}
func (*MsgTransferBadges) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{11}
}
func (m *MsgTransferBadges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferBadges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferBadges.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferBadges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferBadges.Merge(m, src)
}
func (m *MsgTransferBadges) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferBadges) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferBadges.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferBadges proto.InternalMessageInfo

func (m *MsgTransferBadges) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgTransferBadges) GetTransfers() []*Transfer {
	if m != nil {
		return m.Transfers
	}
	return nil
}

// MsgTransferBadgesResponse is the response to MsgTransferBadges.
type MsgTransferBadgesResponse struct {
}

func (m *MsgTransferBadgesResponse) Reset()         { *m = MsgTransferBadgesResponse{} }
func (m *MsgTransferBadgesResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTransferBadgesResponse) ProtoMessage()    {}
func (*MsgTransferBadgesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{12}
}
func (m *MsgTransferBadgesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferBadgesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferBadgesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferBadgesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferBadgesResponse.Merge(m, src)
}
func (m *MsgTransferBadgesResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferBadgesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferBadgesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferBadgesResponse proto.InternalMessageInfo

// MsgDeleteCollection is used to delete a collection.
type MsgDeleteCollection struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
}

func (m *MsgDeleteCollection) Reset()         { *m = MsgDeleteCollection{} }
func (m *MsgDeleteCollection) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteCollection) ProtoMessage()    {}
func (*MsgDeleteCollection) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{13}
}
func (m *MsgDeleteCollection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteCollection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteCollection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteCollection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteCollection.Merge(m, src)
}
func (m *MsgDeleteCollection) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteCollection) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteCollection.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteCollection proto.InternalMessageInfo

func (m *MsgDeleteCollection) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

// MsgDeleteCollectionResponse is the response to MsgDeleteCollection.
type MsgDeleteCollectionResponse struct {
}

func (m *MsgDeleteCollectionResponse) Reset()         { *m = MsgDeleteCollectionResponse{} }
func (m *MsgDeleteCollectionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteCollectionResponse) ProtoMessage()    {}
func (*MsgDeleteCollectionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{14}
}
func (m *MsgDeleteCollectionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteCollectionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteCollectionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteCollectionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteCollectionResponse.Merge(m, src)
}
func (m *MsgDeleteCollectionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteCollectionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteCollectionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteCollectionResponse proto.InternalMessageInfo

// MsgUpdateUserApprovals is used to update user approvals.
type MsgUpdateUserApprovals struct {
	// Address of the creator.
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	// ID of the collection.
	CollectionId Uint `protobuf:"bytes,2,opt,name=collectionId,proto3,customtype=Uint" json:"collectionId"`
	// Indicates if outgoing approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateOutgoingApprovals bool `protobuf:"varint,3,opt,name=updateOutgoingApprovals,proto3" json:"updateOutgoingApprovals,omitempty"`
	// New outgoing approvals to set.
	OutgoingApprovals []*UserOutgoingApproval `protobuf:"bytes,4,rep,name=outgoingApprovals,proto3" json:"outgoingApprovals,omitempty"`
	// Indicates if incoming approvals should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateIncomingApprovals bool `protobuf:"varint,5,opt,name=updateIncomingApprovals,proto3" json:"updateIncomingApprovals,omitempty"`
	// New incoming approvals to set.
	IncomingApprovals []*UserIncomingApproval `protobuf:"bytes,6,rep,name=incomingApprovals,proto3" json:"incomingApprovals,omitempty"`
	// Indicates if auto-approve settings for self-initiated outgoing transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateAutoApproveSelfInitiatedOutgoingTransfers bool `protobuf:"varint,7,opt,name=updateAutoApproveSelfInitiatedOutgoingTransfers,proto3" json:"updateAutoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Auto-approve setting for self-initiated outgoing transfers.
	AutoApproveSelfInitiatedOutgoingTransfers bool `protobuf:"varint,8,opt,name=autoApproveSelfInitiatedOutgoingTransfers,proto3" json:"autoApproveSelfInitiatedOutgoingTransfers,omitempty"`
	// Indicates if auto-approve settings for self-initiated incoming transfers should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateAutoApproveSelfInitiatedIncomingTransfers bool `protobuf:"varint,9,opt,name=updateAutoApproveSelfInitiatedIncomingTransfers,proto3" json:"updateAutoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// Auto-approve setting for self-initiated incoming transfers.
	AutoApproveSelfInitiatedIncomingTransfers bool `protobuf:"varint,10,opt,name=autoApproveSelfInitiatedIncomingTransfers,proto3" json:"autoApproveSelfInitiatedIncomingTransfers,omitempty"`
	// Indicates if user permissions should be updated. If true, we set to value in this Msg. If false, we keep existing value.
	UpdateUserPermissions bool `protobuf:"varint,11,opt,name=updateUserPermissions,proto3" json:"updateUserPermissions,omitempty"`
	// New user permissions to set.
	UserPermissions *UserPermissions `protobuf:"bytes,12,opt,name=userPermissions,proto3" json:"userPermissions,omitempty"`
}

func (m *MsgUpdateUserApprovals) Reset()         { *m = MsgUpdateUserApprovals{} }
func (m *MsgUpdateUserApprovals) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateUserApprovals) ProtoMessage()    {}
func (*MsgUpdateUserApprovals) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{15}
}
func (m *MsgUpdateUserApprovals) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateUserApprovals) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateUserApprovals.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateUserApprovals) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateUserApprovals.Merge(m, src)
}
func (m *MsgUpdateUserApprovals) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateUserApprovals) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateUserApprovals.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateUserApprovals proto.InternalMessageInfo

func (m *MsgUpdateUserApprovals) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUpdateUserApprovals) GetUpdateOutgoingApprovals() bool {
	if m != nil {
		return m.UpdateOutgoingApprovals
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetOutgoingApprovals() []*UserOutgoingApproval {
	if m != nil {
		return m.OutgoingApprovals
	}
	return nil
}

func (m *MsgUpdateUserApprovals) GetUpdateIncomingApprovals() bool {
	if m != nil {
		return m.UpdateIncomingApprovals
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetIncomingApprovals() []*UserIncomingApproval {
	if m != nil {
		return m.IncomingApprovals
	}
	return nil
}

func (m *MsgUpdateUserApprovals) GetUpdateAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if m != nil {
		return m.UpdateAutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetAutoApproveSelfInitiatedOutgoingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedOutgoingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetUpdateAutoApproveSelfInitiatedIncomingTransfers() bool {
	if m != nil {
		return m.UpdateAutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetAutoApproveSelfInitiatedIncomingTransfers() bool {
	if m != nil {
		return m.AutoApproveSelfInitiatedIncomingTransfers
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetUpdateUserPermissions() bool {
	if m != nil {
		return m.UpdateUserPermissions
	}
	return false
}

func (m *MsgUpdateUserApprovals) GetUserPermissions() *UserPermissions {
	if m != nil {
		return m.UserPermissions
	}
	return nil
}

// MsgUpdateUserApprovalsResponse is the response to MsgUpdateUserApprovals.
type MsgUpdateUserApprovalsResponse struct {
}

func (m *MsgUpdateUserApprovalsResponse) Reset()         { *m = MsgUpdateUserApprovalsResponse{} }
func (m *MsgUpdateUserApprovalsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateUserApprovalsResponse) ProtoMessage()    {}
func (*MsgUpdateUserApprovalsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc897b33479788c9, []int{16}
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateUserApprovalsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateUserApprovalsResponse.Merge(m, src)
}
func (m *MsgUpdateUserApprovalsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateUserApprovalsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateUserApprovalsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateUserApprovalsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgUpdateParams)(nil), "badges.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "badges.MsgUpdateParamsResponse")
	proto.RegisterType((*BadgeCustomMsgType)(nil), "badges.BadgeCustomMsgType")
	proto.RegisterType((*MsgUniversalUpdateCollection)(nil), "badges.MsgUniversalUpdateCollection")
	proto.RegisterType((*MsgUniversalUpdateCollectionResponse)(nil), "badges.MsgUniversalUpdateCollectionResponse")
	proto.RegisterType((*MsgUpdateCollection)(nil), "badges.MsgUpdateCollection")
	proto.RegisterType((*MsgUpdateCollectionResponse)(nil), "badges.MsgUpdateCollectionResponse")
	proto.RegisterType((*MsgCreateCollection)(nil), "badges.MsgCreateCollection")
	proto.RegisterType((*MsgCreateCollectionResponse)(nil), "badges.MsgCreateCollectionResponse")
	proto.RegisterType((*MsgCreateAddressLists)(nil), "badges.MsgCreateAddressLists")
	proto.RegisterType((*MsgCreateAddressListsResponse)(nil), "badges.MsgCreateAddressListsResponse")
	proto.RegisterType((*MsgTransferBadges)(nil), "badges.MsgTransferBadges")
	proto.RegisterType((*MsgTransferBadgesResponse)(nil), "badges.MsgTransferBadgesResponse")
	proto.RegisterType((*MsgDeleteCollection)(nil), "badges.MsgDeleteCollection")
	proto.RegisterType((*MsgDeleteCollectionResponse)(nil), "badges.MsgDeleteCollectionResponse")
	proto.RegisterType((*MsgUpdateUserApprovals)(nil), "badges.MsgUpdateUserApprovals")
	proto.RegisterType((*MsgUpdateUserApprovalsResponse)(nil), "badges.MsgUpdateUserApprovalsResponse")
}

func init() { proto.RegisterFile("badges/tx.proto", fileDescriptor_bc897b33479788c9) }

var fileDescriptor_bc897b33479788c9 = []byte{
	// 1576 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0x8f, 0x9b, 0xbf, 0x7e, 0x71, 0xfe, 0x4d, 0x9a, 0xd8, 0xde, 0xa4, 0x4e, 0x30, 0xa5, 0x4a,
	0x03, 0xc4, 0x34, 0x45, 0x14, 0x45, 0x1c, 0x88, 0x53, 0x09, 0x52, 0xd5, 0xb4, 0x9a, 0x38, 0x15,
	0xaa, 0x40, 0xd5, 0xc6, 0x3b, 0xd9, 0xac, 0x64, 0xef, 0x5a, 0xbb, 0xeb, 0xa8, 0xbd, 0xa1, 0x9e,
	0x10, 0x5c, 0x38, 0xf1, 0x11, 0x80, 0x63, 0x0e, 0x48, 0x7c, 0x85, 0x1e, 0x2b, 0xc4, 0x01, 0x71,
	0xa8, 0xa0, 0x3d, 0xe4, 0xca, 0x47, 0x40, 0x3b, 0xbb, 0xb3, 0xde, 0x9d, 0x99, 0x5d, 0xbb, 0xae,
	0xc5, 0x29, 0x97, 0x36, 0x9e, 0x79, 0xbf, 0xf7, 0x67, 0xde, 0xcc, 0xfb, 0xcd, 0xce, 0x83, 0xb9,
	0x23, 0x55, 0xd3, 0x89, 0x53, 0x71, 0x1f, 0x6f, 0xb5, 0x6d, 0xcb, 0xb5, 0xd0, 0x84, 0x3f, 0xa0,
	0x2c, 0xa8, 0x2d, 0xc3, 0xb4, 0x2a, 0xf4, 0x5f, 0x7f, 0x4a, 0xc9, 0x37, 0x2c, 0xa7, 0x65, 0x39,
	0x95, 0x96, 0xa3, 0x57, 0x4e, 0x6f, 0x78, 0xff, 0x05, 0x13, 0x45, 0x7f, 0xe2, 0x11, 0xfd, 0x55,
	0xf1, 0x7f, 0x04, 0x53, 0x97, 0x75, 0x4b, 0xb7, 0xfc, 0x71, 0xef, 0xaf, 0x60, 0x74, 0x31, 0xb0,
	0xda, 0x56, 0x6d, 0xb5, 0xc5, 0x44, 0x97, 0x99, 0x2b, 0xb6, 0x6a, 0x3a, 0xc7, 0xc4, 0x66, 0xe3,
	0x4b, 0xc1, 0xf8, 0x91, 0xda, 0x54, 0xcd, 0x06, 0x61, 0xc3, 0x05, 0xa6, 0x83, 0xd8, 0x2d, 0xc3,
	0x71, 0x0c, 0xcb, 0xe4, 0x01, 0x2d, 0xe2, 0xaa, 0x9a, 0xea, 0xaa, 0x1c, 0xa0, 0x61, 0x35, 0x9b,
	0xa4, 0xe1, 0x46, 0x00, 0x4a, 0x30, 0xa3, 0x6a, 0x9a, 0x4d, 0x1c, 0xe7, 0x51, 0xd3, 0x70, 0x5c,
	0xc1, 0x2b, 0xa3, 0x45, 0x9a, 0x86, 0xc9, 0xcc, 0x97, 0x7f, 0xce, 0xc0, 0x5c, 0xcd, 0xd1, 0x0f,
	0xdb, 0x9a, 0xea, 0x92, 0xfb, 0x34, 0x0e, 0xf4, 0x11, 0x64, 0xd5, 0x8e, 0x7b, 0x62, 0xd9, 0x86,
	0xfb, 0xa4, 0x90, 0x59, 0xcf, 0x6c, 0x64, 0xab, 0x85, 0xdf, 0x7f, 0x7d, 0xff, 0x72, 0xb0, 0x22,
	0xbb, 0xbe, 0xfa, 0x03, 0xd7, 0x36, 0x4c, 0x1d, 0x77, 0x45, 0xd1, 0x0d, 0x98, 0xf0, 0x57, 0xa2,
	0x70, 0x69, 0x3d, 0xb3, 0x31, 0xbd, 0x3d, 0xbb, 0xe5, 0x1b, 0xdd, 0xf2, 0xf5, 0x56, 0xb3, 0xcf,
	0x5e, 0xac, 0x8d, 0xfc, 0x72, 0x7e, 0xb6, 0x99, 0xc1, 0x81, 0xe0, 0xce, 0xf5, 0xa7, 0xe7, 0x67,
	0x9b, 0x5d, 0x15, 0xdf, 0x9d, 0x9f, 0x6d, 0x32, 0x4f, 0x39, 0xaf, 0xca, 0x45, 0xc8, 0x73, 0x43,
	0x98, 0x38, 0x6d, 0xcb, 0x74, 0x48, 0xf9, 0x9f, 0x31, 0x40, 0x55, 0x0f, 0xb5, 0xd7, 0x71, 0x5c,
	0xab, 0x55, 0x73, 0xf4, 0xfa, 0x93, 0x36, 0x41, 0x07, 0xb0, 0xd4, 0xb0, 0x89, 0xea, 0x92, 0xc0,
	0xe3, 0xbb, 0xde, 0x7a, 0xd4, 0x1c, 0x9d, 0xc6, 0x34, 0xbd, 0x7d, 0x85, 0xb9, 0x57, 0x73, 0xf4,
	0x3d, 0x41, 0x0e, 0xcb, 0xb1, 0xe8, 0x04, 0x56, 0x3b, 0xa6, 0x71, 0x4a, 0x6c, 0x47, 0x6d, 0xfa,
	0xce, 0xec, 0x85, 0x89, 0xf0, 0x74, 0xfb, 0xa1, 0x5f, 0x8d, 0xe8, 0x3e, 0x4c, 0x12, 0xc7, 0xa9,
	0x9a, 0x50, 0x0d, 0x16, 0x35, 0xd2, 0x24, 0xbc, 0x81, 0x51, 0x6a, 0x60, 0x25, 0x62, 0xe0, 0x36,
	0x27, 0x85, 0x65, 0x38, 0xf4, 0x19, 0x2c, 0xb0, 0x2d, 0x49, 0xd7, 0x8a, 0xae, 0xc4, 0x18, 0x55,
	0x56, 0x8c, 0x28, 0xab, 0xc7, 0x64, 0xb0, 0x88, 0x41, 0x0f, 0x60, 0xb9, 0x43, 0xdd, 0x3d, 0x74,
	0x88, 0xbd, 0xdb, 0x6e, 0xdb, 0xd6, 0xa9, 0xda, 0xa4, 0xda, 0xc6, 0xa9, 0xb6, 0x52, 0x34, 0x76,
	0x51, 0x10, 0x27, 0xa0, 0xbd, 0x78, 0x3b, 0x92, 0x05, 0x9d, 0x10, 0xe2, 0x15, 0xd6, 0x51, 0x86,
	0xf3, 0xd4, 0xf9, 0x19, 0x8c, 0xab, 0x9b, 0x14, 0xd4, 0xed, 0x71, 0x52, 0x58, 0x86, 0x2b, 0x3f,
	0x9d, 0x81, 0xd5, 0xb4, 0x64, 0xa2, 0x02, 0x4c, 0x52, 0x9c, 0x65, 0xfb, 0x67, 0x06, 0xb3, 0x9f,
	0xe8, 0x03, 0xc8, 0x75, 0x0f, 0xeb, 0xbe, 0x46, 0xb7, 0x48, 0xb6, 0x9a, 0xf3, 0x4e, 0xc3, 0x5f,
	0x2f, 0xd6, 0xc6, 0x0e, 0x0d, 0xd3, 0xc5, 0x31, 0x09, 0x54, 0x86, 0x1c, 0x2b, 0x13, 0xde, 0x4e,
	0xa6, 0x39, 0xcf, 0xe2, 0xd8, 0x18, 0xaa, 0xc2, 0x9c, 0x46, 0x8e, 0xd5, 0x4e, 0xd3, 0xad, 0x06,
	0xc3, 0x41, 0x36, 0x0b, 0x2c, 0x36, 0x6f, 0x85, 0x83, 0xb9, 0x03, 0xd7, 0xb2, 0x09, 0xe6, 0x01,
	0xe8, 0x16, 0xcc, 0x50, 0xd9, 0x7d, 0xcd, 0xa9, 0x5b, 0xbb, 0x9a, 0x56, 0x98, 0x58, 0x1f, 0xdd,
	0x98, 0xde, 0x5e, 0x08, 0x35, 0x78, 0xae, 0xa9, 0xa6, 0x4e, 0x70, 0x5c, 0x0e, 0x7d, 0x0a, 0x2b,
	0xfc, 0x9a, 0xdf, 0xef, 0x16, 0x30, 0xba, 0xc8, 0x53, 0x38, 0x4d, 0x84, 0x1e, 0x4e, 0x29, 0x76,
	0x2a, 0x7e, 0x38, 0xa5, 0x68, 0x2c, 0xc7, 0xa2, 0x0f, 0x61, 0xc9, 0xb7, 0x59, 0x53, 0x4d, 0x55,
	0x27, 0x76, 0x3d, 0xa8, 0x76, 0x85, 0x2c, 0x75, 0x48, 0x3e, 0x89, 0x76, 0x61, 0xae, 0xc5, 0xc9,
	0x03, 0x5d, 0x87, 0x7c, 0xb8, 0x4b, 0xe2, 0xd3, 0x98, 0x97, 0x47, 0x77, 0x60, 0x5d, 0xd8, 0x83,
	0x41, 0xd9, 0x0e, 0x75, 0x4e, 0x53, 0x1f, 0x7a, 0xca, 0xa1, 0x23, 0x50, 0x1a, 0xc9, 0x5a, 0x72,
	0xd4, 0xb3, 0xb2, 0xb8, 0x3c, 0xbc, 0x24, 0x4e, 0xd1, 0xd2, 0xcd, 0x1f, 0x3d, 0xd6, 0x82, 0x91,
	0x99, 0x68, 0xfe, 0xa4, 0x22, 0x5e, 0xfe, 0x8e, 0xa4, 0xd8, 0x59, 0xea, 0x60, 0x98, 0x3f, 0x29,
	0x1a, 0xcb, 0xb1, 0xe8, 0x01, 0x5c, 0xf3, 0x6d, 0xde, 0x3b, 0x3e, 0xde, 0x3b, 0x51, 0x0d, 0x93,
	0xed, 0x54, 0xc1, 0xca, 0x1c, 0xf5, 0xb0, 0x4f, 0x69, 0xe4, 0xc2, 0xba, 0xd5, 0x4b, 0xe3, 0x3c,
	0xf5, 0x7b, 0x83, 0xf9, 0xdd, 0x4b, 0x27, 0xee, 0xa9, 0x11, 0xed, 0x40, 0x21, 0x48, 0x36, 0xa5,
	0xa5, 0xdb, 0x51, 0x6b, 0x0b, 0xd4, 0xff, 0xc4, 0x79, 0x74, 0x07, 0x50, 0x43, 0x44, 0x21, 0xea,
	0xa3, 0x12, 0x26, 0x5f, 0x90, 0xc0, 0x12, 0x14, 0xfa, 0x04, 0x8a, 0xfc, 0xa6, 0x0b, 0x0b, 0x6f,
	0x61, 0x89, 0x3a, 0x92, 0x2c, 0x80, 0xee, 0xc2, 0x62, 0x43, 0x82, 0x5b, 0xe6, 0x5c, 0x11, 0x44,
	0xb0, 0x0c, 0x86, 0x3e, 0x86, 0xbc, 0x6f, 0xea, 0xc0, 0x55, 0x4d, 0x4d, 0xb5, 0x35, 0x27, 0x0c,
	0x2e, 0x4f, 0x3d, 0x49, 0x9a, 0xf6, 0xf8, 0xcb, 0x11, 0x30, 0x05, 0xea, 0x45, 0xc8, 0x5f, 0x02,
	0x0a, 0x8b, 0x98, 0x6e, 0x5a, 0xf6, 0x9d, 0x5d, 0xbb, 0x71, 0x62, 0x9c, 0x12, 0x2d, 0xd4, 0x57,
	0x8c, 0xa6, 0x45, 0x9c, 0xf7, 0xd2, 0x62, 0x88, 0x28, 0x25, 0xbe, 0x16, 0x22, 0x0e, 0x4b, 0x50,
	0x3b, 0x37, 0xbc, 0xbb, 0x0f, 0x23, 0x09, 0xef, 0xe6, 0xb3, 0x1e, 0xdc, 0x7c, 0x12, 0x39, 0xa6,
	0xfc, 0x25, 0x5c, 0x4d, 0xbd, 0x50, 0x04, 0x17, 0x22, 0x81, 0x71, 0x32, 0xbd, 0x18, 0xa7, 0xfc,
	0x6d, 0x0e, 0x16, 0x25, 0xd4, 0x3a, 0x54, 0x56, 0xbb, 0x60, 0x9b, 0x0b, 0xb6, 0xb9, 0x60, 0x9b,
	0x0b, 0xb6, 0xb9, 0x60, 0x9b, 0x40, 0xdf, 0xca, 0x40, 0x6c, 0xb3, 0x3a, 0x10, 0xdb, 0x6c, 0xf0,
	0x6c, 0x93, 0x67, 0x6c, 0xc3, 0x93, 0xcc, 0x3d, 0x58, 0x91, 0x7d, 0x64, 0x0d, 0xce, 0x2d, 0xff,
	0x4e, 0x52, 0x6e, 0xe1, 0xbf, 0xb3, 0x52, 0xb8, 0x85, 0xff, 0xfe, 0xb9, 0xf4, 0x7f, 0x7d, 0xff,
	0x8c, 0xf7, 0xc9, 0x48, 0x89, 0x7c, 0x32, 0xf1, 0x06, 0x7c, 0x22, 0x61, 0x86, 0xc9, 0xd7, 0x64,
	0x86, 0xf4, 0x6a, 0x3e, 0x35, 0x94, 0x6a, 0x9e, 0x58, 0x8b, 0xb3, 0x6f, 0x50, 0x8b, 0xfb, 0xa9,
	0x99, 0x30, 0xf4, 0x9a, 0x29, 0xaf, 0x7b, 0xd3, 0x03, 0xd5, 0xbd, 0x84, 0xca, 0x95, 0x1b, 0xac,
	0x72, 0x49, 0xeb, 0xcf, 0xcc, 0x00, 0xf5, 0x47, 0x5e, 0x43, 0x66, 0x87, 0x5b, 0x43, 0xf8, 0xa3,
	0x1d, 0xd4, 0x10, 0xe1, 0x65, 0x65, 0xf0, 0x1a, 0xf2, 0x63, 0x06, 0x96, 0xa4, 0xef, 0x74, 0x29,
	0x55, 0xe4, 0x16, 0xe4, 0xd4, 0x88, 0x64, 0xe1, 0x12, 0x0d, 0x7a, 0x91, 0x05, 0x1d, 0xd1, 0x82,
	0x63, 0x82, 0x3b, 0x9b, 0x7c, 0x9c, 0xc5, 0x58, 0x9c, 0x51, 0xf3, 0xe5, 0x35, 0xb8, 0x22, 0x7f,
	0x3f, 0x64, 0x8f, 0x93, 0xbf, 0x65, 0x60, 0x41, 0x78, 0x57, 0x1b, 0xea, 0xbd, 0x7a, 0x0b, 0xb2,
	0xe1, 0x63, 0x73, 0x61, 0x94, 0x06, 0x39, 0xcf, 0x82, 0x64, 0x66, 0x71, 0x57, 0x64, 0xe7, 0x1a,
	0x1f, 0x1e, 0x7b, 0x69, 0x8e, 0xfb, 0x58, 0x5e, 0x81, 0xa2, 0xf8, 0x20, 0xc8, 0xc2, 0xfa, 0x3e,
	0x43, 0x8b, 0x3a, 0xff, 0xf6, 0x38, 0xcc, 0xc0, 0x92, 0xf7, 0x1b, 0x6f, 0xb5, 0x7c, 0x85, 0xee,
	0x37, 0xe1, 0x21, 0x94, 0x39, 0xfb, 0xd3, 0x24, 0x2c, 0xcb, 0x5f, 0x23, 0x87, 0x9a, 0x88, 0xf0,
	0xba, 0x71, 0xaf, 0xe3, 0xea, 0x96, 0x61, 0xea, 0xdd, 0x32, 0x30, 0x1a, 0xbd, 0x6e, 0x08, 0xd3,
	0xe8, 0x0e, 0x2c, 0x58, 0x02, 0x66, 0x8c, 0xa6, 0x72, 0x35, 0x4a, 0x67, 0x3c, 0x12, 0x8b, 0xb0,
	0xae, 0x17, 0xfb, 0x66, 0xc3, 0x6a, 0xc5, 0x34, 0x8e, 0x47, 0xbd, 0x10, 0xa6, 0x3d, 0x2f, 0x0c,
	0x01, 0x33, 0x21, 0x7a, 0xc1, 0x23, 0xb1, 0x08, 0x43, 0x27, 0x50, 0xf1, 0xcd, 0xec, 0x76, 0x5c,
	0xcb, 0x1f, 0x26, 0x07, 0xa4, 0x79, 0xbc, 0x6f, 0x1a, 0xae, 0xa1, 0xba, 0x44, 0x63, 0xa1, 0xd4,
	0xc3, 0xad, 0xeb, 0x7f, 0xc7, 0xbd, 0x2e, 0x0c, 0x7d, 0x05, 0xd7, 0xd5, 0xbe, 0x6d, 0x4c, 0x51,
	0x1b, 0xfd, 0x03, 0x7a, 0xc7, 0xc1, 0x16, 0xa3, 0x6b, 0x23, 0xdb, 0x4f, 0x1c, 0x02, 0x2c, 0x2d,
	0x0e, 0xd1, 0x06, 0xa4, 0xc7, 0x21, 0x6a, 0x0f, 0x3f, 0x56, 0xbd, 0x04, 0x46, 0x6f, 0x2c, 0xd3,
	0xd1, 0x8f, 0x55, 0x6e, 0xd2, 0xbb, 0x92, 0x74, 0x38, 0xf9, 0x1c, 0xbd, 0xe1, 0xe4, 0xa3, 0xfb,
	0x21, 0x7a, 0xb7, 0xe1, 0xe5, 0x77, 0xde, 0xe5, 0x0f, 0xb1, 0x12, 0xbb, 0x78, 0xc6, 0x4e, 0x63,
	0x79, 0x1d, 0x4a, 0x09, 0x5d, 0x83, 0xe0, 0x28, 0x6f, 0xff, 0x31, 0x0e, 0xa3, 0x35, 0x47, 0x47,
	0x9f, 0x43, 0x2e, 0xd6, 0xb4, 0xca, 0x0b, 0x0d, 0x02, 0x7f, 0x42, 0x59, 0x4b, 0x98, 0x08, 0xc9,
	0xc8, 0x82, 0x62, 0xf2, 0xab, 0x7e, 0x5f, 0x8d, 0x1c, 0xe5, 0xbd, 0xbe, 0xda, 0x3d, 0xcc, 0xe0,
	0x43, 0x40, 0x12, 0x1e, 0x4b, 0x6f, 0x47, 0x29, 0xef, 0xa4, 0x77, 0xab, 0x98, 0xee, 0x2f, 0x60,
	0x96, 0x63, 0x9a, 0xe4, 0xe6, 0x8e, 0xf2, 0x56, 0x72, 0xdf, 0x87, 0xe9, 0xfb, 0x1a, 0x16, 0x65,
	0x55, 0xb3, 0x47, 0x8f, 0x47, 0xb9, 0xd6, 0xa3, 0x07, 0xc4, 0xd4, 0xd7, 0x61, 0x5e, 0x60, 0x90,
	0xb4, 0xd6, 0x96, 0xf2, 0x76, 0x5a, 0xdf, 0x2b, 0xa2, 0x55, 0x48, 0x64, 0x5a, 0x03, 0x29, 0xa6,
	0x35, 0x31, 0x6d, 0x75, 0x98, 0x17, 0x3e, 0x61, 0xd2, 0xfa, 0x48, 0x31, 0xad, 0x49, 0x57, 0x21,
	0x65, 0xfc, 0x9b, 0xf3, 0xb3, 0xcd, 0x4c, 0x75, 0xff, 0xd9, 0xcb, 0x52, 0xe6, 0xf9, 0xcb, 0x52,
	0xe6, 0xef, 0x97, 0xa5, 0xcc, 0x0f, 0xaf, 0x4a, 0x23, 0xcf, 0x5f, 0x95, 0x46, 0xfe, 0x7c, 0x55,
	0x1a, 0x79, 0x58, 0xd1, 0x0d, 0xb7, 0xa9, 0x1e, 0x6d, 0x35, 0xac, 0x56, 0xc5, 0x3d, 0xb1, 0xec,
	0x86, 0x77, 0xa3, 0xa5, 0x7f, 0x99, 0x96, 0x46, 0x2a, 0xa7, 0x37, 0x2b, 0x8f, 0x2b, 0xac, 0xb9,
	0xfb, 0xa4, 0x4d, 0x9c, 0xa3, 0x09, 0xda, 0xd9, 0xbd, 0xf9, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xcd, 0x81, 0x74, 0xe3, 0x14, 0x1f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	UniversalUpdateCollection(ctx context.Context, in *MsgUniversalUpdateCollection, opts ...grpc.CallOption) (*MsgUniversalUpdateCollectionResponse, error)
	CreateAddressLists(ctx context.Context, in *MsgCreateAddressLists, opts ...grpc.CallOption) (*MsgCreateAddressListsResponse, error)
	TransferBadges(ctx context.Context, in *MsgTransferBadges, opts ...grpc.CallOption) (*MsgTransferBadgesResponse, error)
	UpdateUserApprovals(ctx context.Context, in *MsgUpdateUserApprovals, opts ...grpc.CallOption) (*MsgUpdateUserApprovalsResponse, error)
	DeleteCollection(ctx context.Context, in *MsgDeleteCollection, opts ...grpc.CallOption) (*MsgDeleteCollectionResponse, error)
	UpdateCollection(ctx context.Context, in *MsgUpdateCollection, opts ...grpc.CallOption) (*MsgUpdateCollectionResponse, error)
	CreateCollection(ctx context.Context, in *MsgCreateCollection, opts ...grpc.CallOption) (*MsgCreateCollectionResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/badges.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UniversalUpdateCollection(ctx context.Context, in *MsgUniversalUpdateCollection, opts ...grpc.CallOption) (*MsgUniversalUpdateCollectionResponse, error) {
	out := new(MsgUniversalUpdateCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.Msg/UniversalUpdateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateAddressLists(ctx context.Context, in *MsgCreateAddressLists, opts ...grpc.CallOption) (*MsgCreateAddressListsResponse, error) {
	out := new(MsgCreateAddressListsResponse)
	err := c.cc.Invoke(ctx, "/badges.Msg/CreateAddressLists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TransferBadges(ctx context.Context, in *MsgTransferBadges, opts ...grpc.CallOption) (*MsgTransferBadgesResponse, error) {
	out := new(MsgTransferBadgesResponse)
	err := c.cc.Invoke(ctx, "/badges.Msg/TransferBadges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateUserApprovals(ctx context.Context, in *MsgUpdateUserApprovals, opts ...grpc.CallOption) (*MsgUpdateUserApprovalsResponse, error) {
	out := new(MsgUpdateUserApprovalsResponse)
	err := c.cc.Invoke(ctx, "/badges.Msg/UpdateUserApprovals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeleteCollection(ctx context.Context, in *MsgDeleteCollection, opts ...grpc.CallOption) (*MsgDeleteCollectionResponse, error) {
	out := new(MsgDeleteCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.Msg/DeleteCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateCollection(ctx context.Context, in *MsgUpdateCollection, opts ...grpc.CallOption) (*MsgUpdateCollectionResponse, error) {
	out := new(MsgUpdateCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.Msg/UpdateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateCollection(ctx context.Context, in *MsgCreateCollection, opts ...grpc.CallOption) (*MsgCreateCollectionResponse, error) {
	out := new(MsgCreateCollectionResponse)
	err := c.cc.Invoke(ctx, "/badges.Msg/CreateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	UniversalUpdateCollection(context.Context, *MsgUniversalUpdateCollection) (*MsgUniversalUpdateCollectionResponse, error)
	CreateAddressLists(context.Context, *MsgCreateAddressLists) (*MsgCreateAddressListsResponse, error)
	TransferBadges(context.Context, *MsgTransferBadges) (*MsgTransferBadgesResponse, error)
	UpdateUserApprovals(context.Context, *MsgUpdateUserApprovals) (*MsgUpdateUserApprovalsResponse, error)
	DeleteCollection(context.Context, *MsgDeleteCollection) (*MsgDeleteCollectionResponse, error)
	UpdateCollection(context.Context, *MsgUpdateCollection) (*MsgUpdateCollectionResponse, error)
	CreateCollection(context.Context, *MsgCreateCollection) (*MsgCreateCollectionResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) UniversalUpdateCollection(ctx context.Context, req *MsgUniversalUpdateCollection) (*MsgUniversalUpdateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UniversalUpdateCollection not implemented")
}
func (*UnimplementedMsgServer) CreateAddressLists(ctx context.Context, req *MsgCreateAddressLists) (*MsgCreateAddressListsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAddressLists not implemented")
}
func (*UnimplementedMsgServer) TransferBadges(ctx context.Context, req *MsgTransferBadges) (*MsgTransferBadgesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferBadges not implemented")
}
func (*UnimplementedMsgServer) UpdateUserApprovals(ctx context.Context, req *MsgUpdateUserApprovals) (*MsgUpdateUserApprovalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserApprovals not implemented")
}
func (*UnimplementedMsgServer) DeleteCollection(ctx context.Context, req *MsgDeleteCollection) (*MsgDeleteCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCollection not implemented")
}
func (*UnimplementedMsgServer) UpdateCollection(ctx context.Context, req *MsgUpdateCollection) (*MsgUpdateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCollection not implemented")
}
func (*UnimplementedMsgServer) CreateCollection(ctx context.Context, req *MsgCreateCollection) (*MsgCreateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCollection not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UniversalUpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUniversalUpdateCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UniversalUpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.Msg/UniversalUpdateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UniversalUpdateCollection(ctx, req.(*MsgUniversalUpdateCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateAddressLists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateAddressLists)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateAddressLists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.Msg/CreateAddressLists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateAddressLists(ctx, req.(*MsgCreateAddressLists))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TransferBadges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransferBadges)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TransferBadges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.Msg/TransferBadges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TransferBadges(ctx, req.(*MsgTransferBadges))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateUserApprovals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateUserApprovals)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateUserApprovals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.Msg/UpdateUserApprovals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateUserApprovals(ctx, req.(*MsgUpdateUserApprovals))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeleteCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeleteCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.Msg/DeleteCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeleteCollection(ctx, req.(*MsgDeleteCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.Msg/UpdateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateCollection(ctx, req.(*MsgUpdateCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/badges.Msg/CreateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateCollection(ctx, req.(*MsgCreateCollection))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "badges.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "UniversalUpdateCollection",
			Handler:    _Msg_UniversalUpdateCollection_Handler,
		},
		{
			MethodName: "CreateAddressLists",
			Handler:    _Msg_CreateAddressLists_Handler,
		},
		{
			MethodName: "TransferBadges",
			Handler:    _Msg_TransferBadges_Handler,
		},
		{
			MethodName: "UpdateUserApprovals",
			Handler:    _Msg_UpdateUserApprovals_Handler,
		},
		{
			MethodName: "DeleteCollection",
			Handler:    _Msg_DeleteCollection_Handler,
		},
		{
			MethodName: "UpdateCollection",
			Handler:    _Msg_UpdateCollection_Handler,
		},
		{
			MethodName: "CreateCollection",
			Handler:    _Msg_CreateCollection_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "badges/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BadgeCustomMsgType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadgeCustomMsgType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadgeCustomMsgType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreateCollectionMsg != nil {
		{
			size, err := m.CreateCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.UpdateCollectionMsg != nil {
		{
			size, err := m.UpdateCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UpdateUserApprovalsMsg != nil {
		{
			size, err := m.UpdateUserApprovalsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TransferBadgesMsg != nil {
		{
			size, err := m.TransferBadgesMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DeleteCollectionMsg != nil {
		{
			size, err := m.DeleteCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.UniversalUpdateCollectionMsg != nil {
		{
			size, err := m.UniversalUpdateCollectionMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CreateAddressListsMsg != nil {
		{
			size, err := m.CreateAddressListsMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUniversalUpdateCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUniversalUpdateCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUniversalUpdateCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.UpdateIsArchivedTimeline {
		i--
		if m.UpdateIsArchivedTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.UpdateStandardsTimeline {
		i--
		if m.UpdateStandardsTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.UpdateCollectionApprovals {
		i--
		if m.UpdateCollectionApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.UpdateCustomDataTimeline {
		i--
		if m.UpdateCustomDataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for iNdEx := len(m.OffChainBalancesMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OffChainBalancesMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.UpdateOffChainBalancesMetadataTimeline {
		i--
		if m.UpdateOffChainBalancesMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for iNdEx := len(m.BadgeMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.UpdateBadgeMetadataTimeline {
		i--
		if m.UpdateBadgeMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		i--
		if m.UpdateCollectionMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.UpdateManagerTimeline {
		i--
		if m.UpdateManagerTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.UpdateCollectionPermissions {
		i--
		if m.UpdateCollectionPermissions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.BadgeIdsToAdd) > 0 {
		for iNdEx := len(m.BadgeIdsToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIdsToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.DefaultBalances != nil {
		{
			size, err := m.DefaultBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.BalancesType) > 0 {
		i -= len(m.BalancesType)
		copy(dAtA[i:], m.BalancesType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BalancesType)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUniversalUpdateCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUniversalUpdateCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUniversalUpdateCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	if m.UpdateIsArchivedTimeline {
		i--
		if m.UpdateIsArchivedTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.UpdateStandardsTimeline {
		i--
		if m.UpdateStandardsTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.UpdateCollectionApprovals {
		i--
		if m.UpdateCollectionApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.UpdateCustomDataTimeline {
		i--
		if m.UpdateCustomDataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for iNdEx := len(m.OffChainBalancesMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OffChainBalancesMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.UpdateOffChainBalancesMetadataTimeline {
		i--
		if m.UpdateOffChainBalancesMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for iNdEx := len(m.BadgeMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.UpdateBadgeMetadataTimeline {
		i--
		if m.UpdateBadgeMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		i--
		if m.UpdateCollectionMetadataTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.UpdateManagerTimeline {
		i--
		if m.UpdateManagerTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.UpdateCollectionPermissions {
		i--
		if m.UpdateCollectionPermissions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.BadgeIdsToAdd) > 0 {
		for iNdEx := len(m.BadgeIdsToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIdsToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IsArchivedTimeline) > 0 {
		for iNdEx := len(m.IsArchivedTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IsArchivedTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for iNdEx := len(m.StandardsTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StandardsTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for iNdEx := len(m.CollectionApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for iNdEx := len(m.CustomDataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomDataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for iNdEx := len(m.OffChainBalancesMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OffChainBalancesMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for iNdEx := len(m.BadgeMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for iNdEx := len(m.CollectionMetadataTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectionMetadataTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ManagerTimeline) > 0 {
		for iNdEx := len(m.ManagerTimeline) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ManagerTimeline[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.CollectionPermissions != nil {
		{
			size, err := m.CollectionPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.BadgeIdsToAdd) > 0 {
		for iNdEx := len(m.BadgeIdsToAdd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BadgeIdsToAdd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DefaultBalances != nil {
		{
			size, err := m.DefaultBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.BalancesType) > 0 {
		i -= len(m.BalancesType)
		copy(dAtA[i:], m.BalancesType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BalancesType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCreateAddressLists) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAddressLists) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAddressLists) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddressLists) > 0 {
		for iNdEx := len(m.AddressLists) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddressLists[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateAddressListsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateAddressListsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateAddressListsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgTransferBadges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferBadges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferBadges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Transfers) > 0 {
		for iNdEx := len(m.Transfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransferBadgesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferBadgesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferBadgesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeleteCollection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteCollection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteCollection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeleteCollectionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteCollectionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteCollectionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateUserApprovals) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateUserApprovals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateUserApprovals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserPermissions != nil {
		{
			size, err := m.UserPermissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.UpdateUserPermissions {
		i--
		if m.UpdateUserPermissions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		i--
		if m.AutoApproveSelfInitiatedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.UpdateAutoApproveSelfInitiatedIncomingTransfers {
		i--
		if m.UpdateAutoApproveSelfInitiatedIncomingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		i--
		if m.AutoApproveSelfInitiatedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.UpdateAutoApproveSelfInitiatedOutgoingTransfers {
		i--
		if m.UpdateAutoApproveSelfInitiatedOutgoingTransfers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.IncomingApprovals) > 0 {
		for iNdEx := len(m.IncomingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IncomingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.UpdateIncomingApprovals {
		i--
		if m.UpdateIncomingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.OutgoingApprovals) > 0 {
		for iNdEx := len(m.OutgoingApprovals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutgoingApprovals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.UpdateOutgoingApprovals {
		i--
		if m.UpdateOutgoingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.CollectionId.Size()
		i -= size
		if _, err := m.CollectionId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateUserApprovalsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateUserApprovalsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateUserApprovalsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BadgeCustomMsgType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateAddressListsMsg != nil {
		l = m.CreateAddressListsMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UniversalUpdateCollectionMsg != nil {
		l = m.UniversalUpdateCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DeleteCollectionMsg != nil {
		l = m.DeleteCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TransferBadgesMsg != nil {
		l = m.TransferBadgesMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateUserApprovalsMsg != nil {
		l = m.UpdateUserApprovalsMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateCollectionMsg != nil {
		l = m.UpdateCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CreateCollectionMsg != nil {
		l = m.CreateCollectionMsg.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUniversalUpdateCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.BalancesType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DefaultBalances != nil {
		l = m.DefaultBalances.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.BadgeIdsToAdd) > 0 {
		for _, e := range m.BadgeIdsToAdd {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionPermissions {
		n += 2
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateManagerTimeline {
		n += 2
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		n += 2
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateBadgeMetadataTimeline {
		n += 2
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for _, e := range m.BadgeMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateOffChainBalancesMetadataTimeline {
		n += 2
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for _, e := range m.OffChainBalancesMetadataTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCustomDataTimeline {
		n += 3
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionApprovals {
		n += 3
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateStandardsTimeline {
		n += 3
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateIsArchivedTimeline {
		n += 3
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUniversalUpdateCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.BadgeIdsToAdd) > 0 {
		for _, e := range m.BadgeIdsToAdd {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionPermissions {
		n += 2
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UpdateManagerTimeline {
		n += 2
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionMetadataTimeline {
		n += 2
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateBadgeMetadataTimeline {
		n += 2
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for _, e := range m.BadgeMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateOffChainBalancesMetadataTimeline {
		n += 2
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for _, e := range m.OffChainBalancesMetadataTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCustomDataTimeline {
		n += 3
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateCollectionApprovals {
		n += 3
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateStandardsTimeline {
		n += 3
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateIsArchivedTimeline {
		n += 3
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 2 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BalancesType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DefaultBalances != nil {
		l = m.DefaultBalances.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.BadgeIdsToAdd) > 0 {
		for _, e := range m.BadgeIdsToAdd {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.CollectionPermissions != nil {
		l = m.CollectionPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.ManagerTimeline) > 0 {
		for _, e := range m.ManagerTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CollectionMetadataTimeline) > 0 {
		for _, e := range m.CollectionMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.BadgeMetadataTimeline) > 0 {
		for _, e := range m.BadgeMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.OffChainBalancesMetadataTimeline) > 0 {
		for _, e := range m.OffChainBalancesMetadataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CustomDataTimeline) > 0 {
		for _, e := range m.CustomDataTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.CollectionApprovals) > 0 {
		for _, e := range m.CollectionApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.StandardsTimeline) > 0 {
		for _, e := range m.StandardsTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.IsArchivedTimeline) > 0 {
		for _, e := range m.IsArchivedTimeline {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateAddressLists) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.AddressLists) > 0 {
		for _, e := range m.AddressLists {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateAddressListsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgTransferBadges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.Transfers) > 0 {
		for _, e := range m.Transfers {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgTransferBadgesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeleteCollection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgDeleteCollectionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateUserApprovals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.CollectionId.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.UpdateOutgoingApprovals {
		n += 2
	}
	if len(m.OutgoingApprovals) > 0 {
		for _, e := range m.OutgoingApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateIncomingApprovals {
		n += 2
	}
	if len(m.IncomingApprovals) > 0 {
		for _, e := range m.IncomingApprovals {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UpdateAutoApproveSelfInitiatedOutgoingTransfers {
		n += 2
	}
	if m.AutoApproveSelfInitiatedOutgoingTransfers {
		n += 2
	}
	if m.UpdateAutoApproveSelfInitiatedIncomingTransfers {
		n += 2
	}
	if m.AutoApproveSelfInitiatedIncomingTransfers {
		n += 2
	}
	if m.UpdateUserPermissions {
		n += 2
	}
	if m.UserPermissions != nil {
		l = m.UserPermissions.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateUserApprovalsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BadgeCustomMsgType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadgeCustomMsgType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadgeCustomMsgType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAddressListsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateAddressListsMsg == nil {
				m.CreateAddressListsMsg = &MsgCreateAddressLists{}
			}
			if err := m.CreateAddressListsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniversalUpdateCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UniversalUpdateCollectionMsg == nil {
				m.UniversalUpdateCollectionMsg = &MsgUniversalUpdateCollection{}
			}
			if err := m.UniversalUpdateCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteCollectionMsg == nil {
				m.DeleteCollectionMsg = &MsgDeleteCollection{}
			}
			if err := m.DeleteCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferBadgesMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferBadgesMsg == nil {
				m.TransferBadgesMsg = &MsgTransferBadges{}
			}
			if err := m.TransferBadgesMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateUserApprovalsMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateUserApprovalsMsg == nil {
				m.UpdateUserApprovalsMsg = &MsgUpdateUserApprovals{}
			}
			if err := m.UpdateUserApprovalsMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateCollectionMsg == nil {
				m.UpdateCollectionMsg = &MsgUpdateCollection{}
			}
			if err := m.UpdateCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateCollectionMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateCollectionMsg == nil {
				m.CreateCollectionMsg = &MsgCreateCollection{}
			}
			if err := m.CreateCollectionMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUniversalUpdateCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalancesType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalancesType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBalances == nil {
				m.DefaultBalances = &UserBalanceStore{}
			}
			if err := m.DefaultBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIdsToAdd = append(m.BadgeIdsToAdd, &UintRange{})
			if err := m.BadgeIdsToAdd[len(m.BadgeIdsToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionPermissions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionPermissions = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateManagerTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateManagerTimeline = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionMetadataTimeline = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateBadgeMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateBadgeMetadataTimeline = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeMetadataTimeline = append(m.BadgeMetadataTimeline, &BadgeMetadataTimeline{})
			if err := m.BadgeMetadataTimeline[len(m.BadgeMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateOffChainBalancesMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateOffChainBalancesMetadataTimeline = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffChainBalancesMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffChainBalancesMetadataTimeline = append(m.OffChainBalancesMetadataTimeline, &OffChainBalancesMetadataTimeline{})
			if err := m.OffChainBalancesMetadataTimeline[len(m.OffChainBalancesMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCustomDataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCustomDataTimeline = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionApprovals = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateStandardsTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateStandardsTimeline = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIsArchivedTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateIsArchivedTimeline = bool(v != 0)
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUniversalUpdateCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUniversalUpdateCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIdsToAdd = append(m.BadgeIdsToAdd, &UintRange{})
			if err := m.BadgeIdsToAdd[len(m.BadgeIdsToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionPermissions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionPermissions = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateManagerTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateManagerTimeline = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionMetadataTimeline = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateBadgeMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateBadgeMetadataTimeline = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeMetadataTimeline = append(m.BadgeMetadataTimeline, &BadgeMetadataTimeline{})
			if err := m.BadgeMetadataTimeline[len(m.BadgeMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateOffChainBalancesMetadataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateOffChainBalancesMetadataTimeline = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffChainBalancesMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffChainBalancesMetadataTimeline = append(m.OffChainBalancesMetadataTimeline, &OffChainBalancesMetadataTimeline{})
			if err := m.OffChainBalancesMetadataTimeline[len(m.OffChainBalancesMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCustomDataTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCustomDataTimeline = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCollectionApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateCollectionApprovals = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateStandardsTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateStandardsTimeline = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIsArchivedTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateIsArchivedTimeline = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalancesType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalancesType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBalances == nil {
				m.DefaultBalances = &UserBalanceStore{}
			}
			if err := m.DefaultBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeIdsToAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeIdsToAdd = append(m.BadgeIdsToAdd, &UintRange{})
			if err := m.BadgeIdsToAdd[len(m.BadgeIdsToAdd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CollectionPermissions == nil {
				m.CollectionPermissions = &CollectionPermissions{}
			}
			if err := m.CollectionPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagerTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagerTimeline = append(m.ManagerTimeline, &ManagerTimeline{})
			if err := m.ManagerTimeline[len(m.ManagerTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionMetadataTimeline = append(m.CollectionMetadataTimeline, &CollectionMetadataTimeline{})
			if err := m.CollectionMetadataTimeline[len(m.CollectionMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadgeMetadataTimeline = append(m.BadgeMetadataTimeline, &BadgeMetadataTimeline{})
			if err := m.BadgeMetadataTimeline[len(m.BadgeMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffChainBalancesMetadataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffChainBalancesMetadataTimeline = append(m.OffChainBalancesMetadataTimeline, &OffChainBalancesMetadataTimeline{})
			if err := m.OffChainBalancesMetadataTimeline[len(m.OffChainBalancesMetadataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDataTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomDataTimeline = append(m.CustomDataTimeline, &CustomDataTimeline{})
			if err := m.CustomDataTimeline[len(m.CustomDataTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectionApprovals = append(m.CollectionApprovals, &CollectionApproval{})
			if err := m.CollectionApprovals[len(m.CollectionApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardsTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandardsTimeline = append(m.StandardsTimeline, &StandardsTimeline{})
			if err := m.StandardsTimeline[len(m.StandardsTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchivedTimeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsArchivedTimeline = append(m.IsArchivedTimeline, &IsArchivedTimeline{})
			if err := m.IsArchivedTimeline[len(m.IsArchivedTimeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAddressLists) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAddressLists: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAddressLists: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressLists", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressLists = append(m.AddressLists, &AddressList{})
			if err := m.AddressLists[len(m.AddressLists)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateAddressListsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateAddressListsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateAddressListsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferBadges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferBadges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferBadges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transfers = append(m.Transfers, &Transfer{})
			if err := m.Transfers[len(m.Transfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferBadgesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferBadgesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferBadgesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteCollection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteCollection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteCollection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteCollectionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteCollectionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateUserApprovals) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateUserApprovals: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateUserApprovals: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollectionId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateOutgoingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateOutgoingApprovals = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutgoingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutgoingApprovals = append(m.OutgoingApprovals, &UserOutgoingApproval{})
			if err := m.OutgoingApprovals[len(m.OutgoingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIncomingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateIncomingApprovals = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingApprovals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncomingApprovals = append(m.IncomingApprovals, &UserIncomingApproval{})
			if err := m.IncomingApprovals[len(m.IncomingApprovals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateAutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedOutgoingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedOutgoingTransfers = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateAutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApproveSelfInitiatedIncomingTransfers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApproveSelfInitiatedIncomingTransfers = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateUserPermissions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateUserPermissions = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPermissions == nil {
				m.UserPermissions = &UserPermissions{}
			}
			if err := m.UserPermissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateUserApprovalsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateUserApprovalsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateUserApprovalsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
