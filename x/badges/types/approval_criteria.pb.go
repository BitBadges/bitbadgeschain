// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/approval_criteria.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ApprovalCriteria defines the criteria for approving transfers.
// All criteria must be satisfied for the approval to be considered valid.
type ApprovalCriteria struct {
	// Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs
	// that satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs
	// that can be transferred when using this approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts
	// transferred and enforces maximum limits per approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval. Tracks the count of transfers
	// and enforces the limit to prevent exceeding the allowed number of uses.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,
	// royalties) that must be executed alongside the badge transfer for the approval to be valid.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	// If true, only transfers where the recipient matches the initiator are allowed.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	// If true, only transfers where the sender matches the initiator are allowed.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,7,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	// If true, transfers where the recipient equals the initiator are forbidden.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,8,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	// If true, transfers where the sender equals the initiator are forbidden.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,9,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
	// Overrides the user's outgoing approvals for approval. If true, this collection-level approval
	// takes precedence over any outgoing approvals defined by the sender, allowing the collection to
	// control outgoing transfer behavior.
	OverridesFromOutgoingApprovals bool `protobuf:"varint,10,opt,name=overridesFromOutgoingApprovals,proto3" json:"overridesFromOutgoingApprovals,omitempty"`
	// Overrides the user's incoming approvals for approval. If true, this collection-level approval
	// takes precedence over any incoming approvals defined by the recipient, allowing the collection to
	// control incoming transfer behavior.
	OverridesToIncomingApprovals bool `protobuf:"varint,11,opt,name=overridesToIncomingApprovals,proto3" json:"overridesToIncomingApprovals,omitempty"`
	// Auto-deletion options for this approval. Defines conditions under which this approval should be
	// automatically deleted (e.g., after a certain number of uses or time period).
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,12,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// User level royalties to apply to the transfer. Defines the percentage and payout address for
	// royalties that should be collected when this approval is used for a transfer.
	UserRoyalties *UserRoyalties `protobuf:"bytes,13,opt,name=userRoyalties,proto3" json:"userRoyalties,omitempty"`
	// Must own tokens for approval. Defines token ownership requirements that must be satisfied for
	// the approval to be valid. The initiator must own the specified tokens at the specified ownership times.
	MustOwnTokens []*MustOwnTokens `protobuf:"bytes,14,rep,name=mustOwnTokens,proto3" json:"mustOwnTokens,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval. The initiator must provide
	// valid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,15,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
	// ETH signature challenges that the initiator must pass for approval. The initiator must provide
	// valid Ethereum signatures for all specified challenges. Each signature can only be used once.
	EthSignatureChallenges []*ETHSignatureChallenge `protobuf:"bytes,16,rep,name=ethSignatureChallenges,proto3" json:"ethSignatureChallenges,omitempty"`
	// Address checks for the sender of the transfer. Validates that the sender address meets the
	// specified criteria (e.g., whitelist, blacklist, protocol address requirements).
	SenderChecks *AddressChecks `protobuf:"bytes,17,opt,name=senderChecks,proto3" json:"senderChecks,omitempty"`
	// Address checks for the recipient of the transfer. Validates that the recipient address meets the
	// specified criteria (e.g., whitelist, blacklist, protocol address requirements).
	RecipientChecks *AddressChecks `protobuf:"bytes,18,opt,name=recipientChecks,proto3" json:"recipientChecks,omitempty"`
	// Address checks for the initiator of the transfer. Validates that the initiator address meets the
	// specified criteria (e.g., whitelist, blacklist, protocol address requirements).
	InitiatorChecks *AddressChecks `protobuf:"bytes,19,opt,name=initiatorChecks,proto3" json:"initiatorChecks,omitempty"`
	// Alternative time-based checks for approval denial (offline hours/days). Defines time periods
	// during which this approval should be denied, such as specific hours of the day or days of the week.
	AltTimeChecks *AltTimeChecks `protobuf:"bytes,20,opt,name=altTimeChecks,proto3" json:"altTimeChecks,omitempty"`
	// If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
	// This allows fine-grained control over which approvals are applied when multiple approvals could match.
	MustPrioritize bool `protobuf:"varint,21,opt,name=mustPrioritize,proto3" json:"mustPrioritize,omitempty"`
	// Voting challenges that must be satisfied for approval. The initiator must provide
	// valid votes that meet the quorum threshold for all specified challenges.
	VotingChallenges []*VotingChallenge `protobuf:"bytes,22,rep,name=votingChallenges,proto3" json:"votingChallenges,omitempty"`
}

func (m *ApprovalCriteria) Reset()         { *m = ApprovalCriteria{} }
func (m *ApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*ApprovalCriteria) ProtoMessage()    {}
func (*ApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae3667979cfbe476, []int{0}
}
func (m *ApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalCriteria.Merge(m, src)
}
func (m *ApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalCriteria proto.InternalMessageInfo

func (m *ApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *ApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *ApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *ApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *ApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetOverridesFromOutgoingApprovals() bool {
	if m != nil {
		return m.OverridesFromOutgoingApprovals
	}
	return false
}

func (m *ApprovalCriteria) GetOverridesToIncomingApprovals() bool {
	if m != nil {
		return m.OverridesToIncomingApprovals
	}
	return false
}

func (m *ApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *ApprovalCriteria) GetUserRoyalties() *UserRoyalties {
	if m != nil {
		return m.UserRoyalties
	}
	return nil
}

func (m *ApprovalCriteria) GetMustOwnTokens() []*MustOwnTokens {
	if m != nil {
		return m.MustOwnTokens
	}
	return nil
}

func (m *ApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetEthSignatureChallenges() []*ETHSignatureChallenge {
	if m != nil {
		return m.EthSignatureChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetSenderChecks() *AddressChecks {
	if m != nil {
		return m.SenderChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetRecipientChecks() *AddressChecks {
	if m != nil {
		return m.RecipientChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetInitiatorChecks() *AddressChecks {
	if m != nil {
		return m.InitiatorChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetAltTimeChecks() *AltTimeChecks {
	if m != nil {
		return m.AltTimeChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetMustPrioritize() bool {
	if m != nil {
		return m.MustPrioritize
	}
	return false
}

func (m *ApprovalCriteria) GetVotingChallenges() []*VotingChallenge {
	if m != nil {
		return m.VotingChallenges
	}
	return nil
}

// OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.
// This is used for user-level outgoing approvals and only includes fields relevant to outgoing transfers.
// All criteria must be satisfied for the approval to be considered valid.
type OutgoingApprovalCriteria struct {
	// Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs
	// that satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs
	// that can be transferred when using this approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts
	// transferred and enforces maximum limits per approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval. Tracks the count of transfers
	// and enforces the limit to prevent exceeding the allowed number of uses.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,
	// royalties) that must be executed alongside the badge transfer for the approval to be valid.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	// If true, only transfers where the recipient matches the initiator are allowed.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	// If true, transfers where the recipient equals the initiator are forbidden.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,7,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
	// Auto-deletion options for this approval. Defines conditions under which this approval should be
	// automatically deleted (e.g., after a certain number of uses or time period).
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,8,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// Must own tokens for approval. Defines token ownership requirements that must be satisfied for
	// the approval to be valid. The initiator must own the specified tokens at the specified ownership times.
	MustOwnTokens []*MustOwnTokens `protobuf:"bytes,9,rep,name=mustOwnTokens,proto3" json:"mustOwnTokens,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval. The initiator must provide
	// valid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,10,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
	// ETH signature challenges that the initiator must pass for approval. The initiator must provide
	// valid Ethereum signatures for all specified challenges. Each signature can only be used once.
	EthSignatureChallenges []*ETHSignatureChallenge `protobuf:"bytes,11,rep,name=ethSignatureChallenges,proto3" json:"ethSignatureChallenges,omitempty"`
	// Address checks for the recipient of the transfer. Validates that the recipient address meets the
	// specified criteria (e.g., whitelist, blacklist, protocol address requirements).
	// Note: No sender checks are included for outgoing approvals since the sender is the user themselves.
	RecipientChecks *AddressChecks `protobuf:"bytes,12,opt,name=recipientChecks,proto3" json:"recipientChecks,omitempty"`
	// Address checks for the initiator of the transfer. Validates that the initiator address meets the
	// specified criteria (e.g., whitelist, blacklist, protocol address requirements).
	InitiatorChecks *AddressChecks `protobuf:"bytes,13,opt,name=initiatorChecks,proto3" json:"initiatorChecks,omitempty"`
	// Alternative time-based checks for approval denial (offline hours/days). Defines time periods
	// during which this approval should be denied, such as specific hours of the day or days of the week.
	AltTimeChecks *AltTimeChecks `protobuf:"bytes,14,opt,name=altTimeChecks,proto3" json:"altTimeChecks,omitempty"`
	// If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
	// This allows fine-grained control over which approvals are applied when multiple approvals could match.
	MustPrioritize bool `protobuf:"varint,15,opt,name=mustPrioritize,proto3" json:"mustPrioritize,omitempty"`
	// Voting challenges that must be satisfied for approval. The initiator must provide
	// valid votes that meet the quorum threshold for all specified challenges.
	VotingChallenges []*VotingChallenge `protobuf:"bytes,16,rep,name=votingChallenges,proto3" json:"votingChallenges,omitempty"`
}

func (m *OutgoingApprovalCriteria) Reset()         { *m = OutgoingApprovalCriteria{} }
func (m *OutgoingApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*OutgoingApprovalCriteria) ProtoMessage()    {}
func (*OutgoingApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae3667979cfbe476, []int{1}
}
func (m *OutgoingApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutgoingApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutgoingApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutgoingApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutgoingApprovalCriteria.Merge(m, src)
}
func (m *OutgoingApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *OutgoingApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_OutgoingApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_OutgoingApprovalCriteria proto.InternalMessageInfo

func (m *OutgoingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *OutgoingApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

func (m *OutgoingApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMustOwnTokens() []*MustOwnTokens {
	if m != nil {
		return m.MustOwnTokens
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetEthSignatureChallenges() []*ETHSignatureChallenge {
	if m != nil {
		return m.EthSignatureChallenges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetRecipientChecks() *AddressChecks {
	if m != nil {
		return m.RecipientChecks
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetInitiatorChecks() *AddressChecks {
	if m != nil {
		return m.InitiatorChecks
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetAltTimeChecks() *AltTimeChecks {
	if m != nil {
		return m.AltTimeChecks
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMustPrioritize() bool {
	if m != nil {
		return m.MustPrioritize
	}
	return false
}

func (m *OutgoingApprovalCriteria) GetVotingChallenges() []*VotingChallenge {
	if m != nil {
		return m.VotingChallenges
	}
	return nil
}

// IncomingApprovalCriteria defines the criteria for approving incoming transfers.
// This is used for user-level incoming approvals and only includes fields relevant to incoming transfers.
// All criteria must be satisfied for the approval to be considered valid.
type IncomingApprovalCriteria struct {
	// Merkle challenges that must be satisfied for approval. The initiator must provide valid Merkle proofs
	// that satisfy all specified challenges. Each challenge requires a proof that leads to a specific root hash.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances that must be used for each approval. Defines the exact token amounts and IDs
	// that can be transferred when using this approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval. Tracks cumulative amounts
	// transferred and enforces maximum limits per approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval. Tracks the count of transfers
	// and enforces the limit to prevent exceeding the allowed number of uses.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval. Defines required coin transfers (e.g., fees,
	// royalties) that must be executed alongside the badge transfer for the approval to be valid.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	// If true, only transfers where the sender matches the initiator are allowed.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	// If true, transfers where the sender equals the initiator are forbidden.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,7,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
	// Auto-deletion options for this approval. Defines conditions under which this approval should be
	// automatically deleted (e.g., after a certain number of uses or time period).
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,8,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// Must own tokens for approval. Defines token ownership requirements that must be satisfied for
	// the approval to be valid. The initiator must own the specified tokens at the specified ownership times.
	MustOwnTokens []*MustOwnTokens `protobuf:"bytes,9,rep,name=mustOwnTokens,proto3" json:"mustOwnTokens,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval. The initiator must provide
	// valid proofs that satisfy all specified dynamic store challenges (e.g., key-value store lookups).
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,10,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
	// ETH signature challenges that the initiator must pass for approval. The initiator must provide
	// valid Ethereum signatures for all specified challenges. Each signature can only be used once.
	EthSignatureChallenges []*ETHSignatureChallenge `protobuf:"bytes,11,rep,name=ethSignatureChallenges,proto3" json:"ethSignatureChallenges,omitempty"`
	// Address checks for the sender of the transfer. Validates that the sender address meets the
	// specified criteria (e.g., whitelist, blacklist, protocol address requirements).
	// Note: No recipient checks are included for incoming approvals since the recipient is the user themselves.
	SenderChecks *AddressChecks `protobuf:"bytes,12,opt,name=senderChecks,proto3" json:"senderChecks,omitempty"`
	// Address checks for the initiator of the transfer. Validates that the initiator address meets the
	// specified criteria (e.g., whitelist, blacklist, protocol address requirements).
	InitiatorChecks *AddressChecks `protobuf:"bytes,13,opt,name=initiatorChecks,proto3" json:"initiatorChecks,omitempty"`
	// Alternative time-based checks for approval denial (offline hours/days). Defines time periods
	// during which this approval should be denied, such as specific hours of the day or days of the week.
	AltTimeChecks *AltTimeChecks `protobuf:"bytes,14,opt,name=altTimeChecks,proto3" json:"altTimeChecks,omitempty"`
	// If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
	// This allows fine-grained control over which approvals are applied when multiple approvals could match.
	MustPrioritize bool `protobuf:"varint,15,opt,name=mustPrioritize,proto3" json:"mustPrioritize,omitempty"`
	// Voting challenges that must be satisfied for approval. The initiator must provide
	// valid votes that meet the quorum threshold for all specified challenges.
	VotingChallenges []*VotingChallenge `protobuf:"bytes,16,rep,name=votingChallenges,proto3" json:"votingChallenges,omitempty"`
}

func (m *IncomingApprovalCriteria) Reset()         { *m = IncomingApprovalCriteria{} }
func (m *IncomingApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*IncomingApprovalCriteria) ProtoMessage()    {}
func (*IncomingApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae3667979cfbe476, []int{2}
}
func (m *IncomingApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncomingApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncomingApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncomingApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncomingApprovalCriteria.Merge(m, src)
}
func (m *IncomingApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *IncomingApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_IncomingApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_IncomingApprovalCriteria proto.InternalMessageInfo

func (m *IncomingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *IncomingApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

func (m *IncomingApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMustOwnTokens() []*MustOwnTokens {
	if m != nil {
		return m.MustOwnTokens
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetEthSignatureChallenges() []*ETHSignatureChallenge {
	if m != nil {
		return m.EthSignatureChallenges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetSenderChecks() *AddressChecks {
	if m != nil {
		return m.SenderChecks
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetInitiatorChecks() *AddressChecks {
	if m != nil {
		return m.InitiatorChecks
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetAltTimeChecks() *AltTimeChecks {
	if m != nil {
		return m.AltTimeChecks
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMustPrioritize() bool {
	if m != nil {
		return m.MustPrioritize
	}
	return false
}

func (m *IncomingApprovalCriteria) GetVotingChallenges() []*VotingChallenge {
	if m != nil {
		return m.VotingChallenges
	}
	return nil
}

func init() {
	proto.RegisterType((*ApprovalCriteria)(nil), "badges.ApprovalCriteria")
	proto.RegisterType((*OutgoingApprovalCriteria)(nil), "badges.OutgoingApprovalCriteria")
	proto.RegisterType((*IncomingApprovalCriteria)(nil), "badges.IncomingApprovalCriteria")
}

func init() { proto.RegisterFile("badges/approval_criteria.proto", fileDescriptor_ae3667979cfbe476) }

var fileDescriptor_ae3667979cfbe476 = []byte{
	// 812 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xcb, 0x6e, 0xeb, 0x44,
	0x18, 0x6e, 0x38, 0x90, 0xe6, 0x4c, 0x92, 0x26, 0xcc, 0xe9, 0xc5, 0x2a, 0x60, 0x45, 0x45, 0x42,
	0x5d, 0x25, 0x52, 0x59, 0x01, 0x12, 0x28, 0x49, 0x5b, 0x51, 0x44, 0xda, 0xca, 0x4d, 0x59, 0xb0,
	0xa9, 0x26, 0xf6, 0x8f, 0x33, 0x8a, 0x3d, 0x93, 0xce, 0x8c, 0x4b, 0xc3, 0x53, 0xf0, 0x58, 0x2c,
	0xbb, 0x64, 0x89, 0xda, 0x0d, 0xe2, 0x09, 0x58, 0x22, 0x3b, 0x8e, 0xf1, 0x38, 0x97, 0xa6, 0xa4,
	0x20, 0xa1, 0xd3, 0x5d, 0x34, 0xdf, 0x65, 0xfe, 0xcc, 0xe5, 0x9b, 0xdf, 0xc8, 0xec, 0x11, 0xc7,
	0x05, 0xd9, 0x20, 0xc3, 0xa1, 0xe0, 0x37, 0xc4, 0xbb, 0xb2, 0x05, 0x55, 0x20, 0x28, 0xa9, 0x0f,
	0x05, 0x57, 0x1c, 0xe7, 0xc7, 0xf8, 0xee, 0xa6, 0xcb, 0x5d, 0x1e, 0x0d, 0x35, 0xc2, 0x5f, 0x63,
	0x74, 0x77, 0x27, 0x56, 0xdb, 0x7d, 0xe2, 0x79, 0xc0, 0x5c, 0x90, 0x31, 0xf0, 0x71, 0x0c, 0x0c,
	0x05, 0x38, 0xa0, 0x40, 0xf8, 0x94, 0x81, 0x73, 0xd5, 0x23, 0x1e, 0x61, 0x76, 0x42, 0x9a, 0x9a,
	0x5b, 0x09, 0x62, 0x0f, 0x28, 0x73, 0x63, 0xbc, 0x36, 0x55, 0x1b, 0x67, 0x0e, 0x55, 0x94, 0xb3,
	0xd8, 0x61, 0xef, 0xcf, 0x22, 0xaa, 0x36, 0x63, 0xb4, 0x1d, 0x17, 0x8e, 0xdb, 0xa8, 0xea, 0x83,
	0x18, 0x78, 0xd0, 0x4e, 0xaa, 0x32, 0x72, 0xb5, 0x57, 0xfb, 0xc5, 0x83, 0x9d, 0xfa, 0xd8, 0xb1,
	0xde, 0xd1, 0x71, 0x6b, 0x4a, 0x80, 0x2f, 0xd0, 0x96, 0x56, 0x7b, 0x2b, 0x2e, 0xdd, 0x78, 0xa7,
	0x96, 0xdb, 0x2f, 0x1e, 0x7c, 0x34, 0x71, 0x3a, 0x9f, 0x45, 0xb2, 0x66, 0x6b, 0x71, 0x13, 0x55,
	0x26, 0xff, 0xa5, 0xe9, 0xf3, 0x80, 0x29, 0x69, 0xbc, 0x8a, 0xec, 0x92, 0xc2, 0x9a, 0x3a, 0x6c,
	0x65, 0xf9, 0xa1, 0x85, 0x4f, 0x6e, 0x4f, 0x03, 0xbf, 0x2b, 0x08, 0x93, 0x3f, 0x80, 0x90, 0xc6,
	0xbb, 0xba, 0x45, 0x47, 0x87, 0xad, 0x2c, 0x1f, 0x7f, 0x8e, 0xca, 0x36, 0xa7, 0xec, 0x6f, 0x83,
	0xf7, 0xa2, 0xc5, 0xd9, 0x9c, 0x18, 0xb4, 0x53, 0xa0, 0xa5, 0x53, 0xf1, 0x97, 0x68, 0x57, 0xc0,
	0x75, 0x40, 0x05, 0x74, 0xf9, 0xd1, 0x75, 0x40, 0x3c, 0x79, 0xc2, 0xa8, 0xa2, 0x44, 0x81, 0xd3,
	0x1a, 0x19, 0xf9, 0x5a, 0x6e, 0xbf, 0x60, 0x2d, 0x60, 0xe0, 0x16, 0xfa, 0x30, 0x46, 0x8f, 0x05,
	0xf7, 0xa7, 0x1d, 0xd6, 0x23, 0x87, 0x85, 0x1c, 0xfc, 0x0d, 0xaa, 0x25, 0x33, 0x1c, 0x72, 0x90,
	0xa7, 0x5c, 0x45, 0xa4, 0xb4, 0x4f, 0x21, 0xf2, 0x79, 0x94, 0x87, 0x4f, 0xd1, 0x5e, 0x6a, 0xae,
	0x79, 0x6e, 0xaf, 0x23, 0xb7, 0x25, 0x98, 0xf8, 0x18, 0x99, 0xfc, 0x06, 0x84, 0xa0, 0x0e, 0xc8,
	0x90, 0x77, 0x16, 0x28, 0x97, 0x53, 0xe6, 0x4e, 0xf6, 0x55, 0x1a, 0x28, 0xf2, 0x7a, 0x84, 0x15,
	0xae, 0x53, 0xc2, 0xe8, 0xf2, 0x13, 0x66, 0x73, 0x5f, 0x73, 0x29, 0x8e, 0xd7, 0x69, 0x11, 0x07,
	0x77, 0xd0, 0x1b, 0x12, 0x28, 0x7e, 0x08, 0x1e, 0x84, 0x77, 0xe6, 0x6c, 0x18, 0xdd, 0x1c, 0xa3,
	0x14, 0x1d, 0x97, 0x0f, 0x92, 0x13, 0x37, 0x4d, 0xb1, 0x66, 0xe9, 0xf0, 0x17, 0xa8, 0x1c, 0x48,
	0x10, 0x16, 0x1f, 0x11, 0x4f, 0x51, 0x90, 0x46, 0x39, 0x32, 0xda, 0x9a, 0x18, 0x5d, 0xa6, 0x41,
	0x4b, 0xe7, 0x86, 0x62, 0x3f, 0x90, 0xea, 0xec, 0x47, 0xd6, 0xe5, 0x03, 0x60, 0xd2, 0xd8, 0x88,
	0xce, 0x5c, 0x22, 0xee, 0xa4, 0x41, 0x4b, 0xe7, 0xe2, 0x4b, 0xb4, 0xed, 0x8c, 0x18, 0xf1, 0xa9,
	0x7d, 0xa1, 0xb8, 0x48, 0x5f, 0xeb, 0x4a, 0xe4, 0x92, 0x5c, 0xc6, 0xc3, 0x59, 0x2c, 0x6b, 0x8e,
	0x38, 0xb4, 0x05, 0xd5, 0xbf, 0xa0, 0x2e, 0x23, 0x2a, 0xd0, 0x6c, 0xab, 0xba, 0xed, 0x51, 0xf7,
	0xeb, 0x69, 0x96, 0x35, 0x47, 0x8c, 0x3f, 0x43, 0x25, 0x09, 0xcc, 0x01, 0xd1, 0xee, 0x83, 0x3d,
	0x90, 0xc6, 0xfb, 0xfa, 0x32, 0x35, 0x1d, 0x47, 0x80, 0x94, 0x63, 0xd0, 0xd2, 0xa8, 0xf8, 0x2b,
	0x54, 0x11, 0x60, 0xd3, 0x21, 0x05, 0xa6, 0x62, 0x35, 0x5e, 0xa4, 0xce, 0xb2, 0x43, 0x03, 0x3a,
	0x3e, 0x8d, 0x7c, 0x32, 0xfd, 0x9b, 0x85, 0x06, 0x19, 0x76, 0xb8, 0x4f, 0xc4, 0x53, 0x5d, 0xea,
	0x43, 0x2c, 0xdf, 0xcc, 0xc8, 0xd3, 0xa0, 0xa5, 0x73, 0xf1, 0x27, 0x68, 0x23, 0xdc, 0xb8, 0x73,
	0x41, 0xb9, 0xa0, 0x8a, 0xfe, 0x04, 0xc6, 0x56, 0x74, 0x4c, 0x33, 0xa3, 0x61, 0x40, 0xdf, 0x70,
	0x45, 0x99, 0x9b, 0x5a, 0xf2, 0x6d, 0x3d, 0xa0, 0xbf, 0xd3, 0x71, 0x6b, 0x4a, 0xb0, 0xf7, 0x7b,
	0x01, 0x19, 0xd9, 0x7b, 0xf3, 0xf2, 0x04, 0xfc, 0x0f, 0x9e, 0x80, 0x65, 0xe2, 0x7b, 0x7d, 0xc9,
	0xf8, 0x9e, 0x13, 0x71, 0x85, 0x7f, 0x1e, 0x71, 0x7a, 0x4a, 0xbd, 0x7e, 0x96, 0x94, 0x42, 0xff,
	0x4e, 0x4a, 0x15, 0x57, 0x49, 0xa9, 0x19, 0x51, 0x53, 0x5a, 0x35, 0x6a, 0xca, 0xab, 0x45, 0xcd,
	0xc6, 0x4a, 0x51, 0x53, 0x59, 0x3a, 0x6a, 0xaa, 0x4f, 0x8d, 0x9a, 0x3f, 0x0a, 0xc8, 0xc8, 0x3e,
	0xaf, 0x2f, 0x51, 0xf3, 0x1f, 0x44, 0xcd, 0x63, 0xdd, 0x62, 0x7e, 0x89, 0x6e, 0x71, 0xb9, 0x0e,
	0x6f, 0x7d, 0xe9, 0x0e, 0xef, 0x25, 0x72, 0x9e, 0xab, 0x31, 0x2a, 0x3d, 0xa9, 0x31, 0x7a, 0x4b,
	0xc2, 0xa6, 0xf5, 0xed, 0x2f, 0xf7, 0x66, 0xee, 0xee, 0xde, 0xcc, 0xfd, 0x76, 0x6f, 0xe6, 0x7e,
	0x7e, 0x30, 0xd7, 0xee, 0x1e, 0xcc, 0xb5, 0x5f, 0x1f, 0xcc, 0xb5, 0xef, 0x0f, 0x5c, 0xaa, 0xfa,
	0x41, 0xaf, 0x6e, 0x73, 0xbf, 0xd1, 0xa3, 0x2a, 0xfe, 0x38, 0x4e, 0x7e, 0xd9, 0x7d, 0x42, 0x59,
	0xe3, 0xb6, 0x11, 0x8f, 0xab, 0xd1, 0x10, 0x64, 0x2f, 0x1f, 0x7d, 0x27, 0x7f, 0xfa, 0x57, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x6d, 0xdb, 0xf8, 0x78, 0xe7, 0x0f, 0x00, 0x00,
}

func (m *ApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VotingChallenges) > 0 {
		for iNdEx := len(m.VotingChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VotingChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.MustPrioritize {
		i--
		if m.MustPrioritize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.AltTimeChecks != nil {
		{
			size, err := m.AltTimeChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.InitiatorChecks != nil {
		{
			size, err := m.InitiatorChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.RecipientChecks != nil {
		{
			size, err := m.RecipientChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.SenderChecks != nil {
		{
			size, err := m.SenderChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.EthSignatureChallenges) > 0 {
		for iNdEx := len(m.EthSignatureChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EthSignatureChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.MustOwnTokens) > 0 {
		for iNdEx := len(m.MustOwnTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.UserRoyalties != nil {
		{
			size, err := m.UserRoyalties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.OverridesToIncomingApprovals {
		i--
		if m.OverridesToIncomingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.OverridesFromOutgoingApprovals {
		i--
		if m.OverridesFromOutgoingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OutgoingApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutgoingApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutgoingApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VotingChallenges) > 0 {
		for iNdEx := len(m.VotingChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VotingChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.MustPrioritize {
		i--
		if m.MustPrioritize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.AltTimeChecks != nil {
		{
			size, err := m.AltTimeChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.InitiatorChecks != nil {
		{
			size, err := m.InitiatorChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.RecipientChecks != nil {
		{
			size, err := m.RecipientChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.EthSignatureChallenges) > 0 {
		for iNdEx := len(m.EthSignatureChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EthSignatureChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.MustOwnTokens) > 0 {
		for iNdEx := len(m.MustOwnTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IncomingApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomingApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncomingApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VotingChallenges) > 0 {
		for iNdEx := len(m.VotingChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VotingChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.MustPrioritize {
		i--
		if m.MustPrioritize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.AltTimeChecks != nil {
		{
			size, err := m.AltTimeChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.InitiatorChecks != nil {
		{
			size, err := m.InitiatorChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.SenderChecks != nil {
		{
			size, err := m.SenderChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.EthSignatureChallenges) > 0 {
		for iNdEx := len(m.EthSignatureChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EthSignatureChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.MustOwnTokens) > 0 {
		for iNdEx := len(m.MustOwnTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintApprovalCriteria(dAtA []byte, offset int, v uint64) int {
	offset -= sovApprovalCriteria(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.OverridesFromOutgoingApprovals {
		n += 2
	}
	if m.OverridesToIncomingApprovals {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.UserRoyalties != nil {
		l = m.UserRoyalties.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.MustOwnTokens) > 0 {
		for _, e := range m.MustOwnTokens {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.EthSignatureChallenges) > 0 {
		for _, e := range m.EthSignatureChallenges {
			l = e.Size()
			n += 2 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.SenderChecks != nil {
		l = m.SenderChecks.Size()
		n += 2 + l + sovApprovalCriteria(uint64(l))
	}
	if m.RecipientChecks != nil {
		l = m.RecipientChecks.Size()
		n += 2 + l + sovApprovalCriteria(uint64(l))
	}
	if m.InitiatorChecks != nil {
		l = m.InitiatorChecks.Size()
		n += 2 + l + sovApprovalCriteria(uint64(l))
	}
	if m.AltTimeChecks != nil {
		l = m.AltTimeChecks.Size()
		n += 2 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MustPrioritize {
		n += 3
	}
	if len(m.VotingChallenges) > 0 {
		for _, e := range m.VotingChallenges {
			l = e.Size()
			n += 2 + l + sovApprovalCriteria(uint64(l))
		}
	}
	return n
}

func (m *OutgoingApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.MustOwnTokens) > 0 {
		for _, e := range m.MustOwnTokens {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.EthSignatureChallenges) > 0 {
		for _, e := range m.EthSignatureChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.RecipientChecks != nil {
		l = m.RecipientChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.InitiatorChecks != nil {
		l = m.InitiatorChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.AltTimeChecks != nil {
		l = m.AltTimeChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MustPrioritize {
		n += 2
	}
	if len(m.VotingChallenges) > 0 {
		for _, e := range m.VotingChallenges {
			l = e.Size()
			n += 2 + l + sovApprovalCriteria(uint64(l))
		}
	}
	return n
}

func (m *IncomingApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.MustOwnTokens) > 0 {
		for _, e := range m.MustOwnTokens {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.EthSignatureChallenges) > 0 {
		for _, e := range m.EthSignatureChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.SenderChecks != nil {
		l = m.SenderChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.InitiatorChecks != nil {
		l = m.InitiatorChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.AltTimeChecks != nil {
		l = m.AltTimeChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MustPrioritize {
		n += 2
	}
	if len(m.VotingChallenges) > 0 {
		for _, e := range m.VotingChallenges {
			l = e.Size()
			n += 2 + l + sovApprovalCriteria(uint64(l))
		}
	}
	return n
}

func sovApprovalCriteria(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApprovalCriteria(x uint64) (n int) {
	return sovApprovalCriteria(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalCriteria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesFromOutgoingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesFromOutgoingApprovals = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesToIncomingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesToIncomingApprovals = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRoyalties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserRoyalties == nil {
				m.UserRoyalties = &UserRoyalties{}
			}
			if err := m.UserRoyalties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnTokens = append(m.MustOwnTokens, &MustOwnTokens{})
			if err := m.MustOwnTokens[len(m.MustOwnTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSignatureChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthSignatureChallenges = append(m.EthSignatureChallenges, &ETHSignatureChallenge{})
			if err := m.EthSignatureChallenges[len(m.EthSignatureChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SenderChecks == nil {
				m.SenderChecks = &AddressChecks{}
			}
			if err := m.SenderChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecipientChecks == nil {
				m.RecipientChecks = &AddressChecks{}
			}
			if err := m.RecipientChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatorChecks == nil {
				m.InitiatorChecks = &AddressChecks{}
			}
			if err := m.InitiatorChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltTimeChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AltTimeChecks == nil {
				m.AltTimeChecks = &AltTimeChecks{}
			}
			if err := m.AltTimeChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustPrioritize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustPrioritize = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VotingChallenges = append(m.VotingChallenges, &VotingChallenge{})
			if err := m.VotingChallenges[len(m.VotingChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalCriteria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutgoingApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalCriteria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutgoingApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutgoingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnTokens = append(m.MustOwnTokens, &MustOwnTokens{})
			if err := m.MustOwnTokens[len(m.MustOwnTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSignatureChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthSignatureChallenges = append(m.EthSignatureChallenges, &ETHSignatureChallenge{})
			if err := m.EthSignatureChallenges[len(m.EthSignatureChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecipientChecks == nil {
				m.RecipientChecks = &AddressChecks{}
			}
			if err := m.RecipientChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatorChecks == nil {
				m.InitiatorChecks = &AddressChecks{}
			}
			if err := m.InitiatorChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltTimeChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AltTimeChecks == nil {
				m.AltTimeChecks = &AltTimeChecks{}
			}
			if err := m.AltTimeChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustPrioritize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustPrioritize = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VotingChallenges = append(m.VotingChallenges, &VotingChallenge{})
			if err := m.VotingChallenges[len(m.VotingChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalCriteria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomingApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalCriteria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomingApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnTokens = append(m.MustOwnTokens, &MustOwnTokens{})
			if err := m.MustOwnTokens[len(m.MustOwnTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSignatureChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthSignatureChallenges = append(m.EthSignatureChallenges, &ETHSignatureChallenge{})
			if err := m.EthSignatureChallenges[len(m.EthSignatureChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SenderChecks == nil {
				m.SenderChecks = &AddressChecks{}
			}
			if err := m.SenderChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatorChecks == nil {
				m.InitiatorChecks = &AddressChecks{}
			}
			if err := m.InitiatorChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltTimeChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AltTimeChecks == nil {
				m.AltTimeChecks = &AltTimeChecks{}
			}
			if err := m.AltTimeChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustPrioritize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustPrioritize = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VotingChallenges = append(m.VotingChallenges, &VotingChallenge{})
			if err := m.VotingChallenges[len(m.VotingChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalCriteria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApprovalCriteria(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApprovalCriteria
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApprovalCriteria
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApprovalCriteria
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApprovalCriteria
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApprovalCriteria        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApprovalCriteria          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApprovalCriteria = fmt.Errorf("proto: unexpected end of group")
)
