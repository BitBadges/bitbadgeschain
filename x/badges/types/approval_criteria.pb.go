// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: badges/approval_criteria.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ApprovalCriteria defines the criteria for approving transfers.
type ApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,7,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,8,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,9,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
	// Overrides the user's outgoing approvals for approval.
	OverridesFromOutgoingApprovals bool `protobuf:"varint,10,opt,name=overridesFromOutgoingApprovals,proto3" json:"overridesFromOutgoingApprovals,omitempty"`
	// Overrides the user's incoming approvals for approval.
	OverridesToIncomingApprovals bool `protobuf:"varint,11,opt,name=overridesToIncomingApprovals,proto3" json:"overridesToIncomingApprovals,omitempty"`
	// Auto-deletion options.
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,12,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// User level royalties to apply to the transfer.
	UserRoyalties *UserRoyalties `protobuf:"bytes,13,opt,name=userRoyalties,proto3" json:"userRoyalties,omitempty"`
	// Must own tokens for approval.
	MustOwnTokens []*MustOwnTokens `protobuf:"bytes,14,rep,name=mustOwnTokens,proto3" json:"mustOwnTokens,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval.
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,15,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
	// ETH signature challenges that the initiator must pass for approval.
	EthSignatureChallenges []*ETHSignatureChallenge `protobuf:"bytes,16,rep,name=ethSignatureChallenges,proto3" json:"ethSignatureChallenges,omitempty"`
	// Address checks for sender, recipient, and initiator.
	SenderChecks    *AddressChecks `protobuf:"bytes,17,opt,name=senderChecks,proto3" json:"senderChecks,omitempty"`
	RecipientChecks *AddressChecks `protobuf:"bytes,18,opt,name=recipientChecks,proto3" json:"recipientChecks,omitempty"`
	InitiatorChecks *AddressChecks `protobuf:"bytes,19,opt,name=initiatorChecks,proto3" json:"initiatorChecks,omitempty"`
	// Alternative time-based checks for approval denial (offline hours/days).
	AltTimeChecks *AltTimeChecks `protobuf:"bytes,20,opt,name=altTimeChecks,proto3" json:"altTimeChecks,omitempty"`
	// If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
	MustPrioritize bool `protobuf:"varint,21,opt,name=mustPrioritize,proto3" json:"mustPrioritize,omitempty"`
}

func (m *ApprovalCriteria) Reset()         { *m = ApprovalCriteria{} }
func (m *ApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*ApprovalCriteria) ProtoMessage()    {}
func (*ApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae3667979cfbe476, []int{0}
}
func (m *ApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovalCriteria.Merge(m, src)
}
func (m *ApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *ApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovalCriteria proto.InternalMessageInfo

func (m *ApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *ApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *ApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *ApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *ApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

func (m *ApprovalCriteria) GetOverridesFromOutgoingApprovals() bool {
	if m != nil {
		return m.OverridesFromOutgoingApprovals
	}
	return false
}

func (m *ApprovalCriteria) GetOverridesToIncomingApprovals() bool {
	if m != nil {
		return m.OverridesToIncomingApprovals
	}
	return false
}

func (m *ApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *ApprovalCriteria) GetUserRoyalties() *UserRoyalties {
	if m != nil {
		return m.UserRoyalties
	}
	return nil
}

func (m *ApprovalCriteria) GetMustOwnTokens() []*MustOwnTokens {
	if m != nil {
		return m.MustOwnTokens
	}
	return nil
}

func (m *ApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetEthSignatureChallenges() []*ETHSignatureChallenge {
	if m != nil {
		return m.EthSignatureChallenges
	}
	return nil
}

func (m *ApprovalCriteria) GetSenderChecks() *AddressChecks {
	if m != nil {
		return m.SenderChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetRecipientChecks() *AddressChecks {
	if m != nil {
		return m.RecipientChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetInitiatorChecks() *AddressChecks {
	if m != nil {
		return m.InitiatorChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetAltTimeChecks() *AltTimeChecks {
	if m != nil {
		return m.AltTimeChecks
	}
	return nil
}

func (m *ApprovalCriteria) GetMustPrioritize() bool {
	if m != nil {
		return m.MustPrioritize
	}
	return false
}

// OutgoingApprovalCriteria defines the criteria for approving outgoing transfers.
type OutgoingApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "to" address to be equal to the "initiated by" address for approval.
	RequireToEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireToEqualsInitiatedBy,proto3" json:"requireToEqualsInitiatedBy,omitempty"`
	// Require the "to" address to not be equal to the "initiated by" address for approval.
	RequireToDoesNotEqualInitiatedBy bool `protobuf:"varint,7,opt,name=requireToDoesNotEqualInitiatedBy,proto3" json:"requireToDoesNotEqualInitiatedBy,omitempty"`
	// Auto-deletion options.
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,8,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// Must own tokens for approval.
	MustOwnTokens []*MustOwnTokens `protobuf:"bytes,9,rep,name=mustOwnTokens,proto3" json:"mustOwnTokens,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval.
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,10,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
	// ETH signature challenges that the initiator must pass for approval.
	EthSignatureChallenges []*ETHSignatureChallenge `protobuf:"bytes,11,rep,name=ethSignatureChallenges,proto3" json:"ethSignatureChallenges,omitempty"`
	// Address checks for recipient and initiator (no sender checks for outgoing approvals).
	RecipientChecks *AddressChecks `protobuf:"bytes,12,opt,name=recipientChecks,proto3" json:"recipientChecks,omitempty"`
	InitiatorChecks *AddressChecks `protobuf:"bytes,13,opt,name=initiatorChecks,proto3" json:"initiatorChecks,omitempty"`
	// Alternative time-based checks for approval denial (offline hours/days).
	AltTimeChecks *AltTimeChecks `protobuf:"bytes,14,opt,name=altTimeChecks,proto3" json:"altTimeChecks,omitempty"`
	// If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
	MustPrioritize bool `protobuf:"varint,15,opt,name=mustPrioritize,proto3" json:"mustPrioritize,omitempty"`
}

func (m *OutgoingApprovalCriteria) Reset()         { *m = OutgoingApprovalCriteria{} }
func (m *OutgoingApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*OutgoingApprovalCriteria) ProtoMessage()    {}
func (*OutgoingApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae3667979cfbe476, []int{1}
}
func (m *OutgoingApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OutgoingApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OutgoingApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OutgoingApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutgoingApprovalCriteria.Merge(m, src)
}
func (m *OutgoingApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *OutgoingApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_OutgoingApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_OutgoingApprovalCriteria proto.InternalMessageInfo

func (m *OutgoingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetRequireToEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireToEqualsInitiatedBy
	}
	return false
}

func (m *OutgoingApprovalCriteria) GetRequireToDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireToDoesNotEqualInitiatedBy
	}
	return false
}

func (m *OutgoingApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMustOwnTokens() []*MustOwnTokens {
	if m != nil {
		return m.MustOwnTokens
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetEthSignatureChallenges() []*ETHSignatureChallenge {
	if m != nil {
		return m.EthSignatureChallenges
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetRecipientChecks() *AddressChecks {
	if m != nil {
		return m.RecipientChecks
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetInitiatorChecks() *AddressChecks {
	if m != nil {
		return m.InitiatorChecks
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetAltTimeChecks() *AltTimeChecks {
	if m != nil {
		return m.AltTimeChecks
	}
	return nil
}

func (m *OutgoingApprovalCriteria) GetMustPrioritize() bool {
	if m != nil {
		return m.MustPrioritize
	}
	return false
}

// IncomingApprovalCriteria defines the criteria for approving incoming transfers.
type IncomingApprovalCriteria struct {
	// Merkle challenge that must be satisfied for approval.
	MerkleChallenges []*MerkleChallenge `protobuf:"bytes,1,rep,name=merkleChallenges,proto3" json:"merkleChallenges,omitempty"`
	// Predetermined balances for eeach approval.
	PredeterminedBalances *PredeterminedBalances `protobuf:"bytes,2,opt,name=predeterminedBalances,proto3" json:"predeterminedBalances,omitempty"`
	// Threshold limit of amounts that can be transferred using this approval.
	ApprovalAmounts *ApprovalAmounts `protobuf:"bytes,3,opt,name=approvalAmounts,proto3" json:"approvalAmounts,omitempty"`
	// Maximum number of transfers that can be processed using this approval.
	MaxNumTransfers *MaxNumTransfers `protobuf:"bytes,4,opt,name=maxNumTransfers,proto3" json:"maxNumTransfers,omitempty"`
	// The sdk.Coins that need to be transferred for approval.
	CoinTransfers []*CoinTransfer `protobuf:"bytes,5,rep,name=coinTransfers,proto3" json:"coinTransfers,omitempty"`
	// Require the "from" address to be equal to the "initiated by" address for approval.
	RequireFromEqualsInitiatedBy bool `protobuf:"varint,6,opt,name=requireFromEqualsInitiatedBy,proto3" json:"requireFromEqualsInitiatedBy,omitempty"`
	// Require the "from" address to not be equal to the "initiated by" address for approval.
	RequireFromDoesNotEqualInitiatedBy bool `protobuf:"varint,7,opt,name=requireFromDoesNotEqualInitiatedBy,proto3" json:"requireFromDoesNotEqualInitiatedBy,omitempty"`
	// Auto-deletion options.
	AutoDeletionOptions *AutoDeletionOptions `protobuf:"bytes,8,opt,name=autoDeletionOptions,proto3" json:"autoDeletionOptions,omitempty"`
	// Must own tokens for approval.
	MustOwnTokens []*MustOwnTokens `protobuf:"bytes,9,rep,name=mustOwnTokens,proto3" json:"mustOwnTokens,omitempty"`
	// Dynamic store challenges that the initiator must pass for approval.
	DynamicStoreChallenges []*DynamicStoreChallenge `protobuf:"bytes,10,rep,name=dynamicStoreChallenges,proto3" json:"dynamicStoreChallenges,omitempty"`
	// ETH signature challenges that the initiator must pass for approval.
	EthSignatureChallenges []*ETHSignatureChallenge `protobuf:"bytes,11,rep,name=ethSignatureChallenges,proto3" json:"ethSignatureChallenges,omitempty"`
	// Address checks for sender and initiator (no recipient checks for incoming approvals).
	SenderChecks    *AddressChecks `protobuf:"bytes,12,opt,name=senderChecks,proto3" json:"senderChecks,omitempty"`
	InitiatorChecks *AddressChecks `protobuf:"bytes,13,opt,name=initiatorChecks,proto3" json:"initiatorChecks,omitempty"`
	// Alternative time-based checks for approval denial (offline hours/days).
	AltTimeChecks *AltTimeChecks `protobuf:"bytes,14,opt,name=altTimeChecks,proto3" json:"altTimeChecks,omitempty"`
	// If true, this approval must be explicitly prioritized in PrioritizedApprovals to be used.
	MustPrioritize bool `protobuf:"varint,15,opt,name=mustPrioritize,proto3" json:"mustPrioritize,omitempty"`
}

func (m *IncomingApprovalCriteria) Reset()         { *m = IncomingApprovalCriteria{} }
func (m *IncomingApprovalCriteria) String() string { return proto.CompactTextString(m) }
func (*IncomingApprovalCriteria) ProtoMessage()    {}
func (*IncomingApprovalCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_ae3667979cfbe476, []int{2}
}
func (m *IncomingApprovalCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncomingApprovalCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncomingApprovalCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncomingApprovalCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncomingApprovalCriteria.Merge(m, src)
}
func (m *IncomingApprovalCriteria) XXX_Size() int {
	return m.Size()
}
func (m *IncomingApprovalCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_IncomingApprovalCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_IncomingApprovalCriteria proto.InternalMessageInfo

func (m *IncomingApprovalCriteria) GetMerkleChallenges() []*MerkleChallenge {
	if m != nil {
		return m.MerkleChallenges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetPredeterminedBalances() *PredeterminedBalances {
	if m != nil {
		return m.PredeterminedBalances
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetApprovalAmounts() *ApprovalAmounts {
	if m != nil {
		return m.ApprovalAmounts
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMaxNumTransfers() *MaxNumTransfers {
	if m != nil {
		return m.MaxNumTransfers
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetCoinTransfers() []*CoinTransfer {
	if m != nil {
		return m.CoinTransfers
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetRequireFromEqualsInitiatedBy() bool {
	if m != nil {
		return m.RequireFromEqualsInitiatedBy
	}
	return false
}

func (m *IncomingApprovalCriteria) GetRequireFromDoesNotEqualInitiatedBy() bool {
	if m != nil {
		return m.RequireFromDoesNotEqualInitiatedBy
	}
	return false
}

func (m *IncomingApprovalCriteria) GetAutoDeletionOptions() *AutoDeletionOptions {
	if m != nil {
		return m.AutoDeletionOptions
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMustOwnTokens() []*MustOwnTokens {
	if m != nil {
		return m.MustOwnTokens
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetDynamicStoreChallenges() []*DynamicStoreChallenge {
	if m != nil {
		return m.DynamicStoreChallenges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetEthSignatureChallenges() []*ETHSignatureChallenge {
	if m != nil {
		return m.EthSignatureChallenges
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetSenderChecks() *AddressChecks {
	if m != nil {
		return m.SenderChecks
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetInitiatorChecks() *AddressChecks {
	if m != nil {
		return m.InitiatorChecks
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetAltTimeChecks() *AltTimeChecks {
	if m != nil {
		return m.AltTimeChecks
	}
	return nil
}

func (m *IncomingApprovalCriteria) GetMustPrioritize() bool {
	if m != nil {
		return m.MustPrioritize
	}
	return false
}

func init() {
	proto.RegisterType((*ApprovalCriteria)(nil), "badges.ApprovalCriteria")
	proto.RegisterType((*OutgoingApprovalCriteria)(nil), "badges.OutgoingApprovalCriteria")
	proto.RegisterType((*IncomingApprovalCriteria)(nil), "badges.IncomingApprovalCriteria")
}

func init() { proto.RegisterFile("badges/approval_criteria.proto", fileDescriptor_ae3667979cfbe476) }

var fileDescriptor_ae3667979cfbe476 = []byte{
	// 793 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x97, 0x4f, 0x4f, 0xdb, 0x48,
	0x18, 0xc6, 0xc9, 0xb2, 0x1b, 0xc2, 0x24, 0x21, 0xec, 0x00, 0x8b, 0xc5, 0xee, 0x5a, 0x11, 0x95,
	0x2a, 0x4e, 0x89, 0x44, 0x4f, 0x6d, 0xa5, 0x56, 0x49, 0x00, 0x95, 0xaa, 0x01, 0x64, 0xc2, 0xa5,
	0x17, 0x34, 0xb1, 0xdf, 0x3a, 0xa3, 0xd8, 0x33, 0x61, 0x66, 0x4c, 0x49, 0x3f, 0x45, 0xbf, 0x43,
	0xd5, 0x4f, 0xd0, 0x2f, 0xd1, 0x23, 0xc7, 0x1e, 0x2b, 0xf8, 0x22, 0x95, 0x1d, 0xc7, 0x8d, 0x9d,
	0x3f, 0xa4, 0x0d, 0xad, 0x5a, 0x89, 0x9b, 0xe5, 0xe7, 0x79, 0x7f, 0x33, 0x99, 0x3f, 0x4f, 0x5e,
	0x23, 0xbd, 0x49, 0x2c, 0x1b, 0x64, 0x99, 0x74, 0x3a, 0x82, 0x9f, 0x13, 0xe7, 0xd4, 0x14, 0x54,
	0x81, 0xa0, 0xa4, 0xd4, 0x11, 0x5c, 0x71, 0x9c, 0xee, 0xe9, 0x1b, 0xab, 0x36, 0xb7, 0x79, 0xf0,
	0xaa, 0xec, 0x3f, 0xf5, 0xd4, 0x8d, 0xf5, 0xb0, 0xda, 0x6c, 0x11, 0xc7, 0x01, 0x66, 0x83, 0x0c,
	0x85, 0x7b, 0xa1, 0xd0, 0x11, 0x60, 0x81, 0x02, 0xe1, 0x52, 0x06, 0xd6, 0x69, 0x93, 0x38, 0x84,
	0x99, 0x91, 0x69, 0x68, 0x6c, 0x25, 0x88, 0xd9, 0xa6, 0xcc, 0x0e, 0xf5, 0xe2, 0xd0, 0xdc, 0x38,
	0xb3, 0xa8, 0xa2, 0x9c, 0x85, 0x84, 0xcd, 0x0f, 0x59, 0xb4, 0x5c, 0x09, 0xd5, 0x5a, 0x38, 0x71,
	0x5c, 0x43, 0xcb, 0x2e, 0x88, 0xb6, 0x03, 0xb5, 0x68, 0x56, 0x5a, 0xaa, 0x38, 0xbf, 0x95, 0xdd,
	0x5e, 0x2f, 0xf5, 0x88, 0xa5, 0x7a, 0x5c, 0x37, 0x86, 0x0a, 0xf0, 0x31, 0x5a, 0x8b, 0xcd, 0xbd,
	0x1a, 0x4e, 0x5d, 0xfb, 0xa3, 0x98, 0xda, 0xca, 0x6e, 0xff, 0xdf, 0x27, 0x1d, 0x8d, 0x32, 0x19,
	0xa3, 0x6b, 0x71, 0x05, 0x15, 0xfa, 0xbf, 0xa5, 0xe2, 0x72, 0x8f, 0x29, 0xa9, 0xcd, 0x07, 0xb8,
	0x68, 0x62, 0x95, 0xb8, 0x6c, 0x24, 0xfd, 0x3e, 0xc2, 0x25, 0x17, 0x07, 0x9e, 0xdb, 0x10, 0x84,
	0xc9, 0x57, 0x20, 0xa4, 0xf6, 0x67, 0x1c, 0x51, 0x8f, 0xcb, 0x46, 0xd2, 0x8f, 0x1f, 0xa1, 0xbc,
	0xc9, 0x29, 0xfb, 0x0a, 0xf8, 0x2b, 0x58, 0x9c, 0xd5, 0x3e, 0xa0, 0x36, 0x20, 0x1a, 0x71, 0x2b,
	0x7e, 0x82, 0x36, 0x04, 0x9c, 0x79, 0x54, 0x40, 0x83, 0xef, 0x9e, 0x79, 0xc4, 0x91, 0xfb, 0x8c,
	0x2a, 0x4a, 0x14, 0x58, 0xd5, 0xae, 0x96, 0x2e, 0xa6, 0xb6, 0x32, 0xc6, 0x04, 0x07, 0xae, 0xa2,
	0xff, 0x42, 0x75, 0x4f, 0x70, 0x77, 0x98, 0xb0, 0x10, 0x10, 0x26, 0x7a, 0xf0, 0x73, 0x54, 0x8c,
	0x46, 0xd8, 0xe1, 0x20, 0x0f, 0xb8, 0x0a, 0x4c, 0x83, 0x9c, 0x4c, 0xc0, 0xb9, 0xd1, 0x87, 0x0f,
	0xd0, 0xe6, 0xc0, 0x58, 0xe3, 0x68, 0x8b, 0x01, 0x6d, 0x0a, 0x27, 0xde, 0x43, 0x3a, 0x3f, 0x07,
	0x21, 0xa8, 0x05, 0xd2, 0xf7, 0x1d, 0x7a, 0xca, 0xe6, 0x94, 0xd9, 0xfd, 0x7d, 0x95, 0x1a, 0x0a,
	0x58, 0x37, 0xb8, 0xfc, 0x75, 0x8a, 0x1c, 0x0d, 0xbe, 0xcf, 0x4c, 0xee, 0xc6, 0x28, 0xd9, 0xde,
	0x3a, 0x4d, 0xf2, 0xe0, 0x3a, 0x5a, 0x21, 0x9e, 0xe2, 0x3b, 0xe0, 0x80, 0x7f, 0x67, 0x0e, 0x3b,
	0xc1, 0xcd, 0xd1, 0x72, 0xc1, 0x71, 0xf9, 0x37, 0x3a, 0x71, 0xc3, 0x16, 0x63, 0x54, 0x1d, 0x7e,
	0x8c, 0xf2, 0x9e, 0x04, 0x61, 0xf0, 0x2e, 0x71, 0x14, 0x05, 0xa9, 0xe5, 0x03, 0xd0, 0x5a, 0x1f,
	0x74, 0x32, 0x28, 0x1a, 0x71, 0xaf, 0x5f, 0xec, 0x7a, 0x52, 0x1d, 0xbe, 0x66, 0x0d, 0xde, 0x06,
	0x26, 0xb5, 0xa5, 0xe0, 0xcc, 0x45, 0xc5, 0xf5, 0x41, 0xd1, 0x88, 0x7b, 0xf1, 0x09, 0xfa, 0xc7,
	0xea, 0x32, 0xe2, 0x52, 0xf3, 0x58, 0x71, 0x31, 0x78, 0xad, 0x0b, 0x01, 0x25, 0xba, 0x8c, 0x3b,
	0xa3, 0x5c, 0xc6, 0x98, 0x62, 0x1f, 0x0b, 0xaa, 0x75, 0x4c, 0x6d, 0x46, 0x94, 0x17, 0xc3, 0x2e,
	0xc7, 0xb1, 0xbb, 0x8d, 0x67, 0xc3, 0x2e, 0x63, 0x4c, 0x31, 0x7e, 0x88, 0x72, 0x12, 0x98, 0x05,
	0xa2, 0xd6, 0x02, 0xb3, 0x2d, 0xb5, 0xbf, 0xe3, 0xcb, 0x54, 0xb1, 0x2c, 0x01, 0x52, 0xf6, 0x44,
	0x23, 0x66, 0xc5, 0x4f, 0x51, 0x41, 0x80, 0x49, 0x3b, 0x14, 0x98, 0x0a, 0xab, 0xf1, 0xa4, 0xea,
	0xa4, 0xdb, 0x07, 0xd0, 0xde, 0x69, 0xe4, 0xfd, 0xe1, 0x57, 0x26, 0x02, 0x12, 0x6e, 0x7f, 0x9f,
	0x88, 0xa3, 0x1a, 0xd4, 0x85, 0xb0, 0x7c, 0x35, 0x51, 0x3e, 0x28, 0x1a, 0x71, 0x2f, 0xbe, 0x8f,
	0x96, 0xfc, 0x8d, 0x3b, 0x12, 0x94, 0x0b, 0xaa, 0xe8, 0x1b, 0xd0, 0xd6, 0x82, 0x63, 0x9a, 0x78,
	0xbb, 0xf9, 0x2e, 0x83, 0xb4, 0xe4, 0x91, 0xbf, 0x4b, 0xef, 0xdf, 0x20, 0xbd, 0xa7, 0x49, 0xde,
	0x85, 0x29, 0x93, 0x77, 0x4c, 0x3a, 0x65, 0xbe, 0x3f, 0x9d, 0xe2, 0x01, 0xb3, 0x78, 0x2b, 0x01,
	0x83, 0x7e, 0x4c, 0xc0, 0x64, 0x67, 0x09, 0x98, 0x11, 0x29, 0x91, 0x9b, 0x35, 0x25, 0xf2, 0xb3,
	0xa5, 0xc4, 0xd2, 0x4c, 0x29, 0x51, 0x18, 0x99, 0x12, 0xef, 0x33, 0x48, 0x4b, 0xfe, 0xa9, 0xdd,
	0xa5, 0xc4, 0x4f, 0x48, 0x89, 0x9b, 0x7a, 0xb4, 0xf4, 0x14, 0x3d, 0xda, 0x74, 0x7d, 0xd5, 0xc2,
	0xd4, 0x7d, 0xd5, 0x5d, 0x5a, 0xdc, 0x56, 0x3b, 0x92, 0xfb, 0xa6, 0x76, 0xe4, 0xd7, 0xcf, 0x89,
	0xea, 0x8b, 0x8f, 0x57, 0x7a, 0xea, 0xf2, 0x4a, 0x4f, 0x7d, 0xbe, 0xd2, 0x53, 0x6f, 0xaf, 0xf5,
	0xb9, 0xcb, 0x6b, 0x7d, 0xee, 0xd3, 0xb5, 0x3e, 0xf7, 0x72, 0xdb, 0xa6, 0xaa, 0xe5, 0x35, 0x4b,
	0x26, 0x77, 0xcb, 0x4d, 0xaa, 0xc2, 0xaf, 0xc9, 0xe8, 0xc9, 0x6c, 0x11, 0xca, 0xca, 0x17, 0xe5,
	0xf0, 0xbd, 0xea, 0x76, 0x40, 0x36, 0xd3, 0xc1, 0x87, 0xe5, 0x83, 0x2f, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x9e, 0xb3, 0xa5, 0xa5, 0x18, 0x0f, 0x00, 0x00,
}

func (m *ApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MustPrioritize {
		i--
		if m.MustPrioritize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.AltTimeChecks != nil {
		{
			size, err := m.AltTimeChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.InitiatorChecks != nil {
		{
			size, err := m.InitiatorChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.RecipientChecks != nil {
		{
			size, err := m.RecipientChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.SenderChecks != nil {
		{
			size, err := m.SenderChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.EthSignatureChallenges) > 0 {
		for iNdEx := len(m.EthSignatureChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EthSignatureChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.MustOwnTokens) > 0 {
		for iNdEx := len(m.MustOwnTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.UserRoyalties != nil {
		{
			size, err := m.UserRoyalties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.OverridesToIncomingApprovals {
		i--
		if m.OverridesToIncomingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.OverridesFromOutgoingApprovals {
		i--
		if m.OverridesFromOutgoingApprovals {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OutgoingApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutgoingApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OutgoingApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MustPrioritize {
		i--
		if m.MustPrioritize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.AltTimeChecks != nil {
		{
			size, err := m.AltTimeChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.InitiatorChecks != nil {
		{
			size, err := m.InitiatorChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.RecipientChecks != nil {
		{
			size, err := m.RecipientChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.EthSignatureChallenges) > 0 {
		for iNdEx := len(m.EthSignatureChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EthSignatureChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.MustOwnTokens) > 0 {
		for iNdEx := len(m.MustOwnTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		i--
		if m.RequireToDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireToEqualsInitiatedBy {
		i--
		if m.RequireToEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IncomingApprovalCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomingApprovalCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncomingApprovalCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MustPrioritize {
		i--
		if m.MustPrioritize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.AltTimeChecks != nil {
		{
			size, err := m.AltTimeChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.InitiatorChecks != nil {
		{
			size, err := m.InitiatorChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.SenderChecks != nil {
		{
			size, err := m.SenderChecks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.EthSignatureChallenges) > 0 {
		for iNdEx := len(m.EthSignatureChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EthSignatureChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for iNdEx := len(m.DynamicStoreChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DynamicStoreChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.MustOwnTokens) > 0 {
		for iNdEx := len(m.MustOwnTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MustOwnTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.AutoDeletionOptions != nil {
		{
			size, err := m.AutoDeletionOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		i--
		if m.RequireFromDoesNotEqualInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequireFromEqualsInitiatedBy {
		i--
		if m.RequireFromEqualsInitiatedBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CoinTransfers) > 0 {
		for iNdEx := len(m.CoinTransfers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CoinTransfers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxNumTransfers != nil {
		{
			size, err := m.MaxNumTransfers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ApprovalAmounts != nil {
		{
			size, err := m.ApprovalAmounts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PredeterminedBalances != nil {
		{
			size, err := m.PredeterminedBalances.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MerkleChallenges) > 0 {
		for iNdEx := len(m.MerkleChallenges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerkleChallenges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApprovalCriteria(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintApprovalCriteria(dAtA []byte, offset int, v uint64) int {
	offset -= sovApprovalCriteria(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.OverridesFromOutgoingApprovals {
		n += 2
	}
	if m.OverridesToIncomingApprovals {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.UserRoyalties != nil {
		l = m.UserRoyalties.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.MustOwnTokens) > 0 {
		for _, e := range m.MustOwnTokens {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.EthSignatureChallenges) > 0 {
		for _, e := range m.EthSignatureChallenges {
			l = e.Size()
			n += 2 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.SenderChecks != nil {
		l = m.SenderChecks.Size()
		n += 2 + l + sovApprovalCriteria(uint64(l))
	}
	if m.RecipientChecks != nil {
		l = m.RecipientChecks.Size()
		n += 2 + l + sovApprovalCriteria(uint64(l))
	}
	if m.InitiatorChecks != nil {
		l = m.InitiatorChecks.Size()
		n += 2 + l + sovApprovalCriteria(uint64(l))
	}
	if m.AltTimeChecks != nil {
		l = m.AltTimeChecks.Size()
		n += 2 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MustPrioritize {
		n += 3
	}
	return n
}

func (m *OutgoingApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.RequireToEqualsInitiatedBy {
		n += 2
	}
	if m.RequireToDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.MustOwnTokens) > 0 {
		for _, e := range m.MustOwnTokens {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.EthSignatureChallenges) > 0 {
		for _, e := range m.EthSignatureChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.RecipientChecks != nil {
		l = m.RecipientChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.InitiatorChecks != nil {
		l = m.InitiatorChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.AltTimeChecks != nil {
		l = m.AltTimeChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MustPrioritize {
		n += 2
	}
	return n
}

func (m *IncomingApprovalCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MerkleChallenges) > 0 {
		for _, e := range m.MerkleChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.PredeterminedBalances != nil {
		l = m.PredeterminedBalances.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.ApprovalAmounts != nil {
		l = m.ApprovalAmounts.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MaxNumTransfers != nil {
		l = m.MaxNumTransfers.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.CoinTransfers) > 0 {
		for _, e := range m.CoinTransfers {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.RequireFromEqualsInitiatedBy {
		n += 2
	}
	if m.RequireFromDoesNotEqualInitiatedBy {
		n += 2
	}
	if m.AutoDeletionOptions != nil {
		l = m.AutoDeletionOptions.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if len(m.MustOwnTokens) > 0 {
		for _, e := range m.MustOwnTokens {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.DynamicStoreChallenges) > 0 {
		for _, e := range m.DynamicStoreChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if len(m.EthSignatureChallenges) > 0 {
		for _, e := range m.EthSignatureChallenges {
			l = e.Size()
			n += 1 + l + sovApprovalCriteria(uint64(l))
		}
	}
	if m.SenderChecks != nil {
		l = m.SenderChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.InitiatorChecks != nil {
		l = m.InitiatorChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.AltTimeChecks != nil {
		l = m.AltTimeChecks.Size()
		n += 1 + l + sovApprovalCriteria(uint64(l))
	}
	if m.MustPrioritize {
		n += 2
	}
	return n
}

func sovApprovalCriteria(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApprovalCriteria(x uint64) (n int) {
	return sovApprovalCriteria(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalCriteria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesFromOutgoingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesFromOutgoingApprovals = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridesToIncomingApprovals", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverridesToIncomingApprovals = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRoyalties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserRoyalties == nil {
				m.UserRoyalties = &UserRoyalties{}
			}
			if err := m.UserRoyalties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnTokens = append(m.MustOwnTokens, &MustOwnTokens{})
			if err := m.MustOwnTokens[len(m.MustOwnTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSignatureChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthSignatureChallenges = append(m.EthSignatureChallenges, &ETHSignatureChallenge{})
			if err := m.EthSignatureChallenges[len(m.EthSignatureChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SenderChecks == nil {
				m.SenderChecks = &AddressChecks{}
			}
			if err := m.SenderChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecipientChecks == nil {
				m.RecipientChecks = &AddressChecks{}
			}
			if err := m.RecipientChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatorChecks == nil {
				m.InitiatorChecks = &AddressChecks{}
			}
			if err := m.InitiatorChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltTimeChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AltTimeChecks == nil {
				m.AltTimeChecks = &AltTimeChecks{}
			}
			if err := m.AltTimeChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustPrioritize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustPrioritize = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalCriteria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutgoingApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalCriteria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutgoingApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutgoingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireToDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireToDoesNotEqualInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnTokens = append(m.MustOwnTokens, &MustOwnTokens{})
			if err := m.MustOwnTokens[len(m.MustOwnTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSignatureChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthSignatureChallenges = append(m.EthSignatureChallenges, &ETHSignatureChallenge{})
			if err := m.EthSignatureChallenges[len(m.EthSignatureChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecipientChecks == nil {
				m.RecipientChecks = &AddressChecks{}
			}
			if err := m.RecipientChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatorChecks == nil {
				m.InitiatorChecks = &AddressChecks{}
			}
			if err := m.InitiatorChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltTimeChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AltTimeChecks == nil {
				m.AltTimeChecks = &AltTimeChecks{}
			}
			if err := m.AltTimeChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustPrioritize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustPrioritize = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalCriteria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomingApprovalCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApprovalCriteria
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomingApprovalCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomingApprovalCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleChallenges = append(m.MerkleChallenges, &MerkleChallenge{})
			if err := m.MerkleChallenges[len(m.MerkleChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredeterminedBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredeterminedBalances == nil {
				m.PredeterminedBalances = &PredeterminedBalances{}
			}
			if err := m.PredeterminedBalances.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApprovalAmounts == nil {
				m.ApprovalAmounts = &ApprovalAmounts{}
			}
			if err := m.ApprovalAmounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxNumTransfers == nil {
				m.MaxNumTransfers = &MaxNumTransfers{}
			}
			if err := m.MaxNumTransfers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinTransfers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinTransfers = append(m.CoinTransfers, &CoinTransfer{})
			if err := m.CoinTransfers[len(m.CoinTransfers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromEqualsInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromEqualsInitiatedBy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireFromDoesNotEqualInitiatedBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireFromDoesNotEqualInitiatedBy = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDeletionOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoDeletionOptions == nil {
				m.AutoDeletionOptions = &AutoDeletionOptions{}
			}
			if err := m.AutoDeletionOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustOwnTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MustOwnTokens = append(m.MustOwnTokens, &MustOwnTokens{})
			if err := m.MustOwnTokens[len(m.MustOwnTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicStoreChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DynamicStoreChallenges = append(m.DynamicStoreChallenges, &DynamicStoreChallenge{})
			if err := m.DynamicStoreChallenges[len(m.DynamicStoreChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthSignatureChallenges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthSignatureChallenges = append(m.EthSignatureChallenges, &ETHSignatureChallenge{})
			if err := m.EthSignatureChallenges[len(m.EthSignatureChallenges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SenderChecks == nil {
				m.SenderChecks = &AddressChecks{}
			}
			if err := m.SenderChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitiatorChecks == nil {
				m.InitiatorChecks = &AddressChecks{}
			}
			if err := m.InitiatorChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltTimeChecks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AltTimeChecks == nil {
				m.AltTimeChecks = &AltTimeChecks{}
			}
			if err := m.AltTimeChecks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustPrioritize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustPrioritize = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApprovalCriteria(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApprovalCriteria
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApprovalCriteria(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApprovalCriteria
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApprovalCriteria
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApprovalCriteria
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApprovalCriteria
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApprovalCriteria
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApprovalCriteria        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApprovalCriteria          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApprovalCriteria = fmt.Errorf("proto: unexpected end of group")
)
